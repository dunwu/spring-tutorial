(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],p=e[2],d=0,g=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&g.push(a[o][0]),a[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(c&&c(e);g.length;)g.shift()();return i.push.apply(i,p||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},a={1:0},i=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"c83e292c",3:"73be09f2",4:"a5cae8aa",5:"8dc0a646",6:"aaa74b22",7:"6df75efc",8:"e65c95d4",9:"d144d69e",10:"b7601455",11:"03948980",12:"ecf38bf0",13:"e75cd6c0",14:"5998fd7f",15:"bed79774",16:"82055b07",17:"f6042cab",18:"d08028c1",19:"ab5a7a0c",20:"21031ee6",21:"f301cc59",22:"e81d3a52",23:"ac570f2d",24:"2a9ff969",25:"dce5186a",26:"30d77b82",27:"bc02dd9d",28:"57c0657d",29:"759b5117",30:"a58bf8be",31:"b0bbb91f",32:"af4a0d23",33:"cda8ce76",34:"d8c61183",35:"07911c10",36:"fea80826",37:"26d11b84",38:"cf23f3c8",39:"6b871216",40:"bdcf602f",41:"92ddddfd",42:"afb2f83f",43:"87c61e7a",44:"6ebbb44c",45:"3c340e17",46:"74cf9cd1",47:"6b88e592",48:"3f4c8dde",49:"7a8efab0",50:"c9e00468",51:"f749b4b1",52:"211e3e93",53:"fa74dd36",54:"712ed5d2",55:"e5907eba",56:"fb6c932f",57:"6d1f0260",58:"e1a3dfc7",59:"b3267c14",60:"9bf75b52",61:"4ac19364",62:"41f2ac41",63:"e6a603db",64:"cf0d866f",65:"7b49e268",66:"6cc7cfa1",67:"a41f2515",68:"27ed265a",69:"47dbdb01",70:"5f3ecd44",71:"58845d95",72:"3a6afab8"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(p);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+i+")",l.name="ChunkLoadError",l.type=r,l.request=i,t[1](l)}a[n]=void 0}};var p=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/spring-tutorial/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var p=0;p<s.length;p++)e(s[p]);var c=l;i.push([106,0]),t()}([function(n,e,t){"use strict";var r=function(n){return n&&n.Math===Math&&n};n.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||r("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";var r="object"==typeof document&&document.all;n.exports=void 0===r&&void 0!==r?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var r=t(27),a=Function.prototype,i=a.call,o=r&&a.bind.bind(i,i);n.exports=r?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";function r(n,e,t,r,a,i,o,s){var l,p="function"==typeof n?n.options:n;if(e&&(p.render=e,p.staticRenderFns=t,p._compiled=!0),r&&(p.functional=!0),i&&(p._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},p._ssrRegister=l):a&&(l=s?function(){a.call(this,(p.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(p.functional){p._injectStyles=l;var c=p.render;p.render=function(n,e){return l.call(e),c(n,e)}}else{var d=p.beforeCreate;p.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:p}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(3);n.exports=!r((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var r=t(1);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(69),a="object"==typeof self&&self&&self.Object===Object&&self,i=r||a||Function("return this")();n.exports=i},function(n,e,t){"use strict";var r=t(2),a=t(32),i=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(a(n),e)}},function(n,e,t){var r=t(165),a=t(168);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return p})),t.d(e,"i",(function(){return c})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return g})),t.d(e,"l",(function(){return u})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return h})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return x}));t(16);const r=/#.*$/,a=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return o.test(n)}function p(n){return/^mailto:/.test(n)}function c(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",a=s(n);return i.test(a)?n:a+".html"+t}function g(n,e){const t=n.hash,a=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(a&&t!==a)return!1;return s(n.path)===s(e)}function u(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const a=e.split("/");t&&a[a.length-1]||a.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?a.pop():"."!==e&&a.push(e)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function m(n,e,t,r){const{pages:a,themeConfig:i}=t,o=r&&i.locales&&i.locales[r]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return b(n);const s=o.sidebar||i.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?b(n):r?r.map(n=>function n(e,t,r,a=1){if("string"==typeof e)return u(t,e,r);if(Array.isArray(e))return Object.assign(u(t,e[0],r),{title:e[1]});{a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(u(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,r,a+1)),collapsable:!1!==e.collapsable}}}(n,a,t)):[]}return[]}function b(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function h(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(15),a=t(150),i=t(151),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?a(n):i(n)}},function(n,e,t){"use strict";var r=t(5),a=t(17),i=t(35);n.exports=r?function(n,e,t){return a.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(8).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(26),a=t(32),i=t(33),o=t(144),s=t(146);r({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=a(this),t=i(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){"use strict";var r=t(5),a=t(64),i=t(101),o=t(48),s=t(55),l=TypeError,p=Object.defineProperty,c=Object.getOwnPropertyDescriptor;e.f=r?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=c(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return p(n,e,t)}:p:function(n,e,t){if(o(n),e=s(e),o(t),a)try{return p(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){"use strict";var r=t(2),a=r({}.toString),i=r("".slice);n.exports=function(n){return i(a(n),8,-1)}},function(n,e,t){var r=t(155),a=t(156),i=t(157),o=t(158),s=t(159);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(177);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(46);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),p=l.querySelector(r.barSelector),c=r.speed,d=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(p,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,a}(n,c,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),c)}),c)):setTimeout(e,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");p(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,o=e.querySelector(r.barSelector),l=n?"-100":i(t.status||0),c=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&g(a),c!=document.body&&p(c,"nprogress-custom-parent"),c.appendChild(e),e},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&g(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+i)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,i=arguments;if(2==i.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function p(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function c(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function g(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){"use strict";var r=t(0),a=t(53).f,i=t(14),o=t(97),s=t(38),l=t(65),p=t(125);n.exports=function(n,e){var t,c,d,g,u,m=n.target,b=n.global,f=n.stat;if(t=b?r:f?r[m]||s(m,{}):r[m]&&r[m].prototype)for(c in e){if(g=e[c],d=n.dontCallGetSet?(u=a(t,c))&&u.value:t[c],!p(b?c:m+(f?".":"#")+c,n.forced)&&void 0!==d){if(typeof g==typeof d)continue;l(g,d)}(n.sham||d&&d.sham)&&i(g,"sham",!0),o(t,c,g,n)}}},function(n,e,t){"use strict";var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";var r=t(49),a=t(36);n.exports=function(n){return r(a(n))}},function(n,e,t){"use strict";var r=t(0),a=t(1),i=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";var r=t(1),a=t(112),i=TypeError;n.exports=function(n){if(r(n))return n;throw new i(a(n)+" is not a function")}},function(n,e,t){"use strict";var r=t(0),a=t(61),i=t(9),o=t(63),s=t(59),l=t(58),p=r.Symbol,c=a("wks"),d=l?p.for||p:p&&p.withoutSetter||o;n.exports=function(n){return i(c,n)||(c[n]=s&&i(p,n)?p[n]:d("Symbol."+n)),c[n]}},function(n,e,t){"use strict";var r=t(36),a=Object;n.exports=function(n){return a(r(n))}},function(n,e,t){"use strict";var r=t(123);n.exports=function(n){return r(n.length)}},function(n,e,t){"use strict";var r=t(27),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var r=t(54),a=TypeError;n.exports=function(n){if(r(n))throw new a("Can't call method on "+n);return n}},function(n,e,t){"use strict";var r=t(62),a=t(0),i=t(38),o=n.exports=a["__core-js_shared__"]||i("__core-js_shared__",{});(o.versions||(o.versions=[])).push({version:"3.37.0",mode:r?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.37.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var r=t(0),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(149),a=t(12),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(8),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(169),a=t(176),i=t(178),o=t(179),s=t(180);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(6),a=t(46),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(13),a=t(12);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var r=t(7),a=String,i=TypeError;n.exports=function(n){if(r(n))return n;throw new i(a(n)+" is not an object")}},function(n,e,t){"use strict";var r=t(2),a=t(3),i=t(18),o=Object,s=r("".split);n.exports=a((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"===i(n)?s(n,""):o(n)}:o},function(n,e,t){"use strict";n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,p=s||l||Function("return this")(),c=Object.prototype.toString,d=Math.max,g=Math.min,u=function(){return p.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function b(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==c.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,i,o,s,l,p=0,c=!1,f=!1,h=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=r,i=a;return r=a=void 0,p=e,o=n.apply(i,t)}function y(n){return p=n,s=setTimeout(w,e),c?v(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-p>=i}function w(){var n=u();if(x(n))return S(n);s=setTimeout(w,function(n){var t=e-(n-l);return f?g(t,i-(n-p)):t}(n))}function S(n){return s=void 0,h&&r?v(n):(r=a=void 0,o)}function k(){var n=u(),t=x(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return y(l);if(f)return s=setTimeout(w,e),v(l)}return void 0===s&&(s=setTimeout(w,e)),o}return e=b(e)||0,m(t)&&(c=!!t.leading,i=(f="maxWait"in t)?d(b(t.maxWait)||0,e):i,h="trailing"in t?!!t.trailing:h),k.cancel=function(){void 0!==s&&clearTimeout(s),p=0,r=l=a=s=void 0},k.flush=function(){return void 0===s?o:S(u())},k}},function(n,e,t){"use strict";var r=t(5),a=t(34),i=t(108),o=t(35),s=t(28),l=t(55),p=t(9),c=t(64),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),c)try{return d(n,e)}catch(n){}if(p(n,e))return o(!a(i.f,n,e),n[e])}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var r=t(109),a=t(56);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e,t){"use strict";var r=t(29),a=t(1),i=t(57),o=t(58),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&i(e.prototype,s(n))}},function(n,e,t){"use strict";var r=t(2);n.exports=r({}.isPrototypeOf)},function(n,e,t){"use strict";var r=t(59);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var r=t(60),a=t(3),i=t(0).String;n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol("symbol detection");return!i(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){"use strict";var r,a,i=t(0),o=t(110),s=i.process,l=i.Deno,p=s&&s.versions||l&&l.version,c=p&&p.v8;c&&(a=(r=c.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){"use strict";var r=t(37);n.exports=function(n,e){return r[n]||(r[n]=e||{})}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var r=t(2),a=0,i=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++a+i,36)}},function(n,e,t){"use strict";var r=t(5),a=t(3),i=t(100);n.exports=!r&&!a((function(){return 7!==Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var r=t(9),a=t(118),i=t(53),o=t(17);n.exports=function(n,e,t){for(var s=a(e),l=o.f,p=i.f,c=0;c<s.length;c++){var d=s[c];r(n,d)||t&&r(t,d)||l(n,d,p(e,d))}}},function(n,e,t){"use strict";var r=t(122);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){"use strict";var r=t(132),a=t(7),i=t(36),o=t(133);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return i(t),o(r),a(t)?(e?n(t,r):t.__proto__=r,t):t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(19),a=t(160),i=t(161),o=t(162),s=t(163),l=t(164);function p(n){var e=this.__data__=new r(n);this.size=e.size}p.prototype.clear=a,p.prototype.delete=i,p.prototype.get=o,p.prototype.has=s,p.prototype.set=l,n.exports=p},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(13),a=t(41);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(181),a=t(12);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,i,o,n,s))}},function(n,e,t){var r=t(76),a=t(184),i=t(77);n.exports=function(n,e,t,o,s,l){var p=1&t,c=n.length,d=e.length;if(c!=d&&!(p&&d>c))return!1;var g=l.get(n),u=l.get(e);if(g&&u)return g==e&&u==n;var m=-1,b=!0,f=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++m<c;){var h=n[m],v=e[m];if(o)var y=p?o(v,h,m,e,n,l):o(h,v,m,n,e,l);if(void 0!==y){if(y)continue;b=!1;break}if(f){if(!a(e,(function(n,e){if(!i(f,e)&&(h===n||s(h,n,t,o,l)))return f.push(e)}))){b=!1;break}}else if(h!==v&&!s(h,v,t,o,l)){b=!1;break}}return l.delete(n),l.delete(e),b}},function(n,e,t){var r=t(42),a=t(182),i=t(183);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=a,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(194),a=t(200),i=t(82);n.exports=function(n){return i(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(8),a=t(196),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(51)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(197),a=t(198),i=t(199),o=i&&i.isTypedArray,s=o?a(o):r;n.exports=s},function(n,e,t){var r=t(72),a=t(44);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(8),"Set");n.exports=r},function(n,e,t){var r=t(41);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(87),a=t(23);n.exports=function(n,e){for(var t=0,i=(e=r(e,n)).length;null!=n&&t<i;)n=n[a(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var r=t(6),a=t(45),i=t(211),o=t(214);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(147),a=t(152),i=t(223),o=t(231),s=t(240),l=t(105),p=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),a(e,2))}));n.exports=p},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var i="",o=0,s=0;for(o=a.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(247),a=t(248),i=t(249),o=!1,s=t(250).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],p=l.concat("cache"),c=/^\uFEFF/;function d(n,t){var a,i,o=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)a=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(i=e.resolveInclude(n,t.filename),r.existsSync(i)&&(a=i)),a||Array.isArray(o)&&o.some((function(t){return i=e.resolveInclude(n,t,!0),r.existsSync(i)}))&&(a=i),!a)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return a}function g(n,t){var r,a=n.filename,i=arguments.length>1;if(n.cache){if(!a)throw new Error("cache option requires a filename");if(r=e.cache.get(a))return r;i||(t=m(a).toString().replace(c,""))}else if(!i){if(!a)throw new Error("Internal EJS error: no file name or template provided");t=m(a).toString().replace(c,"")}return r=e.compile(t,n),n.cache&&e.cache.set(a,r),r}function u(n,t,r){var a;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(a=g(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{a=g(n)(t)}catch(n){return r(n)}r(null,a)}function m(n){return e.fileLoader(n)}function b(n,e,t,r,a){var i=e.split("\n"),o=Math.max(r-3,0),s=Math.min(i.length,r+3),l=a(t),p=i.slice(o,s).map((function(n,e){var t=e+o+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+p+"\n\n"+n.message,n}function f(n){return n.replace(/;(\s*$)/,"$1")}function h(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||i.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=i.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=a.dirname,i=a.extname,o=(0,a.resolve)(t?e:r(e),n);return i(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new h(n,e).compile()},e.render=function(n,e,t){var r=e||{},a=t||{};return 2==arguments.length&&i.shallowCopyFromList(a,r,l),g(a,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),a=r.shift(),o={filename:a};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?i.shallowCopy(o,r.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&i.shallowCopy(o,t)),i.shallowCopyFromList(o,e,p)),o.filename=a):e={},u(o,e,n)},e.Template=h,e.clearCache=function(){e.cache.reset()},h.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},h.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=i.escapeRegExpChars(this.opts.delimiter),t=i.escapeRegExpChars(this.opts.openDelimiter),r=i.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,o="",s="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(o+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var p="  var __locals = ("+r.localsName+" || {}),\n",c=0;c<r.destructuredLocals.length;c++){var u=r.destructuredLocals[c];c>0&&(p+=",\n  "),p+=u+" = __locals."+u}o+=p+";\n"}!1!==r._with&&(o+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=o+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+b.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var m=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var a=i.shallowCopy({},n);return t&&(a=i.shallowCopy(a,t)),function(n,e){var t=i.shallowCopy({},e);return t.filename=d(n,t),g(t)}(e,r)(a)},b])};if(m.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var f=r.filename,h=a.basename(f,a.extname(f));try{Object.defineProperty(m,"name",{value:h,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return m},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),a=this.opts.delimiter,o=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,p){var g,u,b,f,v,y;if(0===l.indexOf(o+a)&&0!==l.indexOf(o+a+a)&&(u=r[p+2])!=a+s&&u!="-"+a+s&&u!="_"+a+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(b=l.match(/^\s*include\s+(\S+)/))&&(g=r[p-1])&&(g==o+a||g==o+a+"-"||g==o+a+"_"))return f=i.shallowCopy({},t.opts),v=function(n,e){var t,r,a=i.shallowCopy({},e);r=m(t=d(n,a)).toString().replace(c,""),a.filename=t;var o=new h(r,a);return o.generateSource(),{source:o.source,filename:t,template:r}}(b[1],f),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(v.template)+"\n      , __filename = "+JSON.stringify(v.filename)+";\n      try {\n"+v.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+v.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(b[1],f.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),a=[];r;)0!==(n=r.index)&&(a.push(e.substring(0,n)),e=e.slice(n)),a.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&a.push(e),a},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,a=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=h.modes.EVAL;break;case r+t+"=":this.mode=h.modes.ESCAPED;break;case r+t+"-":this.mode=h.modes.RAW;break;case r+t+"#":this.mode=h.modes.COMMENT;break;case r+t+t:this.mode=h.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+a:this.mode=h.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+a,t+a)+'")\n';break;case t+a:case"-"+t+a:case"_"+t+a:this.mode==h.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case h.modes.EVAL:case h.modes.ESCAPED:case h.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case h.modes.EVAL:this.source+="    ; "+n+"\n";break;case h.modes.ESCAPED:this.source+="    ; __append(escapeFn("+f(n)+"))\n";break;case h.modes.RAW:this.source+="    ; __append("+f(n)+")\n";break;case h.modes.COMMENT:break;case h.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=i.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(243),t(4)),i=Object(a.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},a=(t(244),t(4)),i=Object(a.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e,t){"use strict";var r=t(1),a=t(17),i=t(102),o=t(38);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,p=void 0!==s.name?s.name:e;if(r(t)&&i(t,p,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r=t(138),a=String;n.exports=function(n){if("Symbol"===r(n))throw new TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){"use strict";var r=t(0),a=t(7),i=r.document,o=a(i)&&a(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){"use strict";var r=t(5),a=t(3);n.exports=r&&a((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var r=t(2),a=t(3),i=t(1),o=t(9),s=t(5),l=t(114).CONFIGURABLE,p=t(115),c=t(116),d=c.enforce,g=c.get,u=String,m=Object.defineProperty,b=r("".slice),f=r("".replace),h=r([].join),v=s&&!a((function(){return 8!==m((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===b(u(e),0,7)&&(e="["+f(u(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?m(n,"name",{value:e,configurable:!0}):n.name=e),v&&t&&o(t,"arity")&&n.length!==t.arity&&m(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&m(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=d(n);return o(r,"source")||(r.source=h(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return i(this)&&g(this).source||p(this)}),"toString")},function(n,e,t){"use strict";var r=t(61),a=t(63),i=r("keys");n.exports=function(n){return i[n]||(i[n]=a(n))}},function(n,e,t){"use strict";var r=t(2),a=t(9),i=t(28),o=t(120).indexOf,s=t(50),l=r([].push);n.exports=function(n,e){var t,r=i(n),p=0,c=[];for(t in r)!a(s,t)&&a(r,t)&&l(c,t);for(;e.length>p;)a(r,t=e[p++])&&(~o(c,t)||l(c,t));return c}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(253)},function(n,e,t){"use strict";var r=t(26),a=t(126).left,i=t(127),o=t(60);r({target:"Array",proto:!0,forced:!t(128)&&o>79&&o<83||!i("reduce")},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,i=a&&!r.call({1:2},1);e.f=i?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){"use strict";var r=t(34),a=t(7),i=t(56),o=t(111),s=t(113),l=t(31),p=TypeError,c=l("toPrimitive");n.exports=function(n,e){if(!a(n)||i(n))return n;var t,l=o(n,c);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!a(t)||i(t))return t;throw new p("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){"use strict";var r=t(30),a=t(54);n.exports=function(n,e){var t=n[e];return a(t)?void 0:r(t)}},function(n,e,t){"use strict";var r=String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var r=t(34),a=t(1),i=t(7),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!i(s=r(t,n)))return s;if(a(t=n.valueOf)&&!i(s=r(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!i(s=r(t,n)))return s;throw new o("Can't convert object to primitive value")}},function(n,e,t){"use strict";var r=t(5),a=t(9),i=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=a(i,"name"),l=s&&"something"===function(){}.name,p=s&&(!r||r&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:p}},function(n,e,t){"use strict";var r=t(2),a=t(1),i=t(37),o=r(Function.toString);a(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){"use strict";var r,a,i,o=t(117),s=t(0),l=t(7),p=t(14),c=t(9),d=t(37),g=t(103),u=t(50),m=s.TypeError,b=s.WeakMap;if(o||d.state){var f=d.state||(d.state=new b);f.get=f.get,f.has=f.has,f.set=f.set,r=function(n,e){if(f.has(n))throw new m("Object already initialized");return e.facade=n,f.set(n,e),e},a=function(n){return f.get(n)||{}},i=function(n){return f.has(n)}}else{var h=g("state");u[h]=!0,r=function(n,e){if(c(n,h))throw new m("Object already initialized");return e.facade=n,p(n,h,e),e},a=function(n){return c(n,h)?n[h]:{}},i=function(n){return c(n,h)}}n.exports={set:r,get:a,has:i,enforce:function(n){return i(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw new m("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(0),a=t(1),i=r.WeakMap;n.exports=a(i)&&/native code/.test(String(i))},function(n,e,t){"use strict";var r=t(29),a=t(2),i=t(119),o=t(124),s=t(48),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r=t(104),a=t(98).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){"use strict";var r=t(28),a=t(121),i=t(33),o=function(n){return function(e,t,o){var s=r(e),l=i(s);if(0===l)return!n&&-1;var p,c=a(o,l);if(n&&t!=t){for(;l>c;)if((p=s[c++])!=p)return!0}else for(;l>c;c++)if((n||c in s)&&s[c]===t)return n||c||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){"use strict";var r=t(66),a=Math.max,i=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):i(t,e)}},function(n,e,t){"use strict";var r=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:r)(e)}},function(n,e,t){"use strict";var r=t(66),a=Math.min;n.exports=function(n){var e=r(n);return e>0?a(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var r=t(3),a=t(1),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t===c||t!==p&&(a(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},p=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){"use strict";var r=t(30),a=t(32),i=t(49),o=t(33),s=TypeError,l="Reduce of empty array with no initial value",p=function(n){return function(e,t,p,c){var d=a(e),g=i(d),u=o(d);if(r(t),0===u&&p<2)throw new s(l);var m=n?u-1:0,b=n?-1:1;if(p<2)for(;;){if(m in g){c=g[m],m+=b;break}if(m+=b,n?m<0:u<=m)throw new s(l)}for(;n?m>=0:u>m;m+=b)m in g&&(c=t(c,g[m],m,d));return c}};n.exports={left:p(!1),right:p(!0)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var r=t(0),a=t(18);n.exports="process"===a(r.process)},function(n,e,t){"use strict";var r=t(26),a=t(0),i=t(130),o=t(131),s=a.WebAssembly,l=7!==new Error("e",{cause:7}).cause,p=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},c=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};p("Error",(function(n){return function(e){return i(n,this,arguments)}})),p("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),p("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),p("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),p("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),p("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),p("URIError",(function(n){return function(e){return i(n,this,arguments)}})),c("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),c("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),c("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){"use strict";var r=t(27),a=Function.prototype,i=a.apply,o=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var r=t(29),a=t(9),i=t(14),o=t(57),s=t(67),l=t(65),p=t(135),c=t(136),d=t(137),g=t(140),u=t(141),m=t(5),b=t(62);n.exports=function(n,e,t,f){var h=f?2:1,v=n.split("."),y=v[v.length-1],x=r.apply(null,v);if(x){var w=x.prototype;if(!b&&a(w,"cause")&&delete w.cause,!t)return x;var S=r("Error"),k=e((function(n,e){var t=d(f?e:n,void 0),r=f?new x(n):new x;return void 0!==t&&i(r,"message",t),u(r,k,r.stack,2),this&&o(w,this)&&c(r,this,k),arguments.length>h&&g(r,arguments[h]),r}));if(k.prototype=w,"Error"!==y?s?s(k,S):l(k,S,{name:!0}):m&&"stackTraceLimit"in x&&(p(k,x,"stackTraceLimit"),p(k,x,"prepareStackTrace")),l(k,x),!b)try{w.name!==y&&i(w,"name",y),w.constructor=k}catch(n){}return k}}},function(n,e,t){"use strict";var r=t(2),a=t(30);n.exports=function(n,e,t){try{return r(a(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var r=t(134),a=String,i=TypeError;n.exports=function(n){if(r(n))return n;throw new i("Can't set "+a(n)+" as a prototype")}},function(n,e,t){"use strict";var r=t(7);n.exports=function(n){return r(n)||null===n}},function(n,e,t){"use strict";var r=t(17).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),a=t(7),i=t(67);n.exports=function(n,e,t){var o,s;return i&&r(o=e.constructor)&&o!==t&&a(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){"use strict";var r=t(99);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){"use strict";var r=t(139),a=t(1),i=t(18),o=t(31)("toStringTag"),s=Object,l="Arguments"===i(function(){return arguments}());n.exports=r?i:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"===(r=i(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){"use strict";var r={};r[t(31)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){"use strict";var r=t(7),a=t(14);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){"use strict";var r=t(14),a=t(142),i=t(143),o=Error.captureStackTrace;n.exports=function(n,e,t,s){i&&(o?o(n,e):r(n,"stack",a(t,s)))}},function(n,e,t){"use strict";var r=t(2),a=Error,i=r("".replace),o=String(new a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){"use strict";var r=t(3),a=t(35);n.exports=!r((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(5),a=t(145),i=TypeError,o=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(a(n)&&!o(n,"length").writable)throw new i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var r=t(18);n.exports=Array.isArray||function(n){return"Array"===r(n)}},function(n,e,t){"use strict";var r=TypeError;n.exports=function(n){if(n>9007199254740991)throw r("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(68),a=t(148);n.exports=function n(e,t,i,o,s){var l=-1,p=e.length;for(i||(i=a),s||(s=[]);++l<p;){var c=e[l];t>0&&i(c)?t>1?n(c,t-1,i,o,s):r(s,c):o||(s[s.length]=c)}return s}},function(n,e,t){var r=t(15),a=t(39),i=t(6),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||a(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(13),a=t(12);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(15),a=Object.prototype,i=a.hasOwnProperty,o=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=o.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(153),a=t(209),i=t(47),o=t(6),s=t(220);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(154),a=t(208),i=t(85);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(70),a=t(74);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var p=t[o];if(l&&p[2]?p[1]!==n[p[0]]:!(p[0]in n))return!1}for(;++o<s;){var c=(p=t[o])[0],d=n[c],g=p[1];if(l&&p[2]){if(void 0===d&&!(c in n))return!1}else{var u=new r;if(i)var m=i(d,g,c,n,e,u);if(!(void 0===m?a(g,d,3,i,u):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(20),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(20);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(20);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(19);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(19),a=t(40),i=t(42);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!a||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(72),a=t(166),i=t(41),o=t(73),s=/^\[object .+?Constructor\]$/,l=Function.prototype,p=Object.prototype,c=l.toString,d=p.hasOwnProperty,g=RegExp("^"+c.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||a(n))&&(r(n)?g:s).test(o(n))}},function(n,e,t){var r,a=t(167),i=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var r=t(8)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(170),a=t(19),i=t(40);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(i||a),string:new r}}},function(n,e,t){var r=t(171),a=t(172),i=t(173),o=t(174),s=t(175);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(21);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(22);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(70),a=t(75),i=t(185),o=t(188),s=t(204),l=t(6),p=t(79),c=t(81),d="[object Object]",g=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,u,m,b){var f=l(n),h=l(e),v=f?"[object Array]":s(n),y=h?"[object Array]":s(e),x=(v="[object Arguments]"==v?d:v)==d,w=(y="[object Arguments]"==y?d:y)==d,S=v==y;if(S&&p(n)){if(!p(e))return!1;f=!0,x=!1}if(S&&!x)return b||(b=new r),f||c(n)?a(n,e,t,u,m,b):i(n,e,v,t,u,m,b);if(!(1&t)){var k=x&&g.call(n,"__wrapped__"),j=w&&g.call(e,"__wrapped__");if(k||j){var C=k?n.value():n,T=j?e.value():e;return b||(b=new r),m(C,T,t,u,b)}}return!!S&&(b||(b=new r),o(n,e,t,u,m,b))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(15),a=t(186),i=t(71),o=t(75),s=t(187),l=t(43),p=r?r.prototype:void 0,c=p?p.valueOf:void 0;n.exports=function(n,e,t,r,p,d,g){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var u=s;case"[object Set]":var m=1&r;if(u||(u=l),n.size!=e.size&&!m)return!1;var b=g.get(n);if(b)return b==e;r|=2,g.set(n,e);var f=o(u(n),u(e),r,p,d,g);return g.delete(n),f;case"[object Symbol]":if(c)return c.call(n)==c.call(e)}return!1}},function(n,e,t){var r=t(8).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(189),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,p=r(n),c=p.length;if(c!=r(e).length&&!l)return!1;for(var d=c;d--;){var g=p[d];if(!(l?g in e:a.call(e,g)))return!1}var u=s.get(n),m=s.get(e);if(u&&m)return u==e&&m==n;var b=!0;s.set(n,e),s.set(e,n);for(var f=l;++d<c;){var h=n[g=p[d]],v=e[g];if(i)var y=l?i(v,h,g,e,n,s):i(h,v,g,n,e,s);if(!(void 0===y?h===v||o(h,v,t,i,s):y)){b=!1;break}f||(f="constructor"==g)}if(b&&!f){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(b=!1)}return s.delete(n),s.delete(e),b}},function(n,e,t){var r=t(190),a=t(191),i=t(78);n.exports=function(n){return r(n,i,a)}},function(n,e,t){var r=t(68),a=t(6);n.exports=function(n,e,t){var i=e(n);return a(n)?i:r(i,t(n))}},function(n,e,t){var r=t(192),a=t(193),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return i.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,i=[];++t<r;){var o=n[t];e(o,t,n)&&(i[a++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(195),a=t(39),i=t(6),o=t(79),s=t(80),l=t(81),p=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),c=!t&&a(n),d=!t&&!c&&o(n),g=!t&&!c&&!d&&l(n),u=t||c||d||g,m=u?r(n.length,String):[],b=m.length;for(var f in n)!e&&!p.call(n,f)||u&&("length"==f||d&&("offset"==f||"parent"==f)||g&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,b))||m.push(f);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(13),a=t(44),i=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&a(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(69),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===a&&r.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(51)(n))},function(n,e,t){var r=t(201),a=t(202),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(203)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(205),a=t(40),i=t(206),o=t(83),s=t(207),l=t(13),p=t(73),c=p(r),d=p(a),g=p(i),u=p(o),m=p(s),b=l;(r&&"[object DataView]"!=b(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=b(new a)||i&&"[object Promise]"!=b(i.resolve())||o&&"[object Set]"!=b(new o)||s&&"[object WeakMap]"!=b(new s))&&(b=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?p(t):"";if(r)switch(r){case c:return"[object DataView]";case d:return"[object Map]";case g:return"[object Promise]";case u:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=b},function(n,e,t){var r=t(10)(t(8),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(8),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(8),"WeakMap");n.exports=r},function(n,e,t){var r=t(84),a=t(78);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,r(o)]}return e}},function(n,e,t){var r=t(74),a=t(210),i=t(217),o=t(45),s=t(84),l=t(85),p=t(23);n.exports=function(n,e){return o(n)&&s(e)?l(p(n),e):function(t){var o=a(t,n);return void 0===o&&o===e?i(t,n):r(e,o,3)}}},function(n,e,t){var r=t(86);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(212),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(213);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(42);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],i=t.cache;if(i.has(a))return i.get(a);var o=n.apply(this,r);return t.cache=i.set(a,o)||i,o};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(215);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(15),a=t(216),i=t(6),o=t(46),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return a(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(218),a=t(219);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(87),a=t(39),i=t(6),o=t(80),s=t(44),l=t(23);n.exports=function(n,e,t){for(var p=-1,c=(e=r(e,n)).length,d=!1;++p<c;){var g=l(e[p]);if(!(d=null!=n&&t(n,g)))break;n=n[g]}return d||++p!=c?d:!!(c=null==n?0:n.length)&&s(c)&&o(g,c)&&(i(n)||a(n))}},function(n,e,t){var r=t(221),a=t(222),i=t(45),o=t(23);n.exports=function(n){return i(n)?r(o(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(86);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(47),a=t(224),i=t(226);n.exports=function(n,e){return i(a(n,e,r),n+"")}},function(n,e,t){var r=t(225),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=a(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var p=Array(e+1);++o<e;)p[o]=i[o];return p[e]=t(l),r(n,this,p)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(227),a=t(230)(r);n.exports=a},function(n,e,t){var r=t(228),a=t(229),i=t(47),o=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),i=16-(a-r);if(r=a,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(76),a=t(232),i=t(237),o=t(77),s=t(238),l=t(43);n.exports=function(n,e,t){var p=-1,c=a,d=n.length,g=!0,u=[],m=u;if(t)g=!1,c=i;else if(d>=200){var b=e?null:s(n);if(b)return l(b);g=!1,c=o,m=new r}else m=e?[]:u;n:for(;++p<d;){var f=n[p],h=e?e(f):f;if(f=t||0!==f?f:0,g&&h==h){for(var v=m.length;v--;)if(m[v]===h)continue n;e&&m.push(h),u.push(f)}else c(m,h,t)||(m!==u&&m.push(h),u.push(f))}return u}},function(n,e,t){var r=t(233);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(234),a=t(235),i=t(236);n.exports=function(n,e,t){return e==e?i(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,i=t+(r?1:-1);r?i--:++i<a;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(83),a=t(239),i=t(43),o=r&&1/i(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(82),a=t(12);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){},function(n,e,t){},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var a=n[r];"."===a?n.splice(r,1):".."===a?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,a=arguments.length-1;a>=-1&&!e;a--){var i=a>=0?arguments[a]:process.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(n=i+"/"+n,e="/"===i.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var i=e.isAbsolute(n),o="/"===a(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!i).join("/"))||i||(n="."),n&&o&&(n+="/"),(i?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var a=r(n.split("/")),i=r(t.split("/")),o=Math.min(a.length,i.length),s=o,l=0;l<o;l++)if(a[l]!==i[l]){s=l;break}var p=[];for(l=s;l<a.length;l++)p.push("..");return(p=p.concat(i.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,a=!0,i=n.length-1;i>=1;--i)if(47===(e=n.charCodeAt(i))){if(!a){r=i;break}}else a=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,a=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!a){t=e+1;break}}else-1===r&&(a=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,a=!0,i=0,o=n.length-1;o>=0;--o){var s=n.charCodeAt(o);if(47!==s)-1===r&&(a=!1,r=o+1),46===s?-1===e?e=o:1!==i&&(i=1):-1!==e&&(i=-1);else if(!a){t=o+1;break}}return-1===e||-1===r||0===i||1===i&&e===r-1&&e===t+1?"":n.slice(e,r)};var a="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},i=/[&<>'"]/g;function o(n){return a[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(i,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var a=t[r];void 0!==e[a]&&(n[a]=e[a])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function p(n){return"function"==typeof n}function c(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function g(n){return"[object Object]"===d.call(n)}function u(n){return"[object RegExp]"===d.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function b(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||g(n)&&n.toString===d?JSON.stringify(n,h,2):String(n)}function h(n,e){return e&&e.__v_isRef?e.value:e}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function y(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}y("slot,component",!0);var x=y("key,ref,slot,slot-scope,is");function w(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var S=Object.prototype.hasOwnProperty;function k(n,e){return S.call(n,e)}function j(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var C=/-(\w)/g,T=j((function(n){return n.replace(C,(function(n,e){return e?e.toUpperCase():""}))})),A=j((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),B=/\B([A-Z])/g,I=j((function(n){return n.replace(B,"-$1").toLowerCase()}));var E=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function P(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function _(n,e){for(var t in e)n[t]=e[t];return n}function M(n){for(var e={},t=0;t<n.length;t++)n[t]&&_(e,n[t]);return e}function R(n,e,t){}var D=function(n,e,t){return!1},z=function(n){return n};function O(n,e){if(n===e)return!0;var t=c(n),r=c(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),i=Array.isArray(e);if(a&&i)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function L(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function J(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function q(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],U=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:R,parsePlatformTagName:z,mustUseProp:D,async:!0,_lifecycleHooks:U},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function V(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function $(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var W=new RegExp("[^".concat(H.source,".$_\\d]"));var X="__proto__"in{},G="undefined"!=typeof window,Q=G&&window.navigator.userAgent.toLowerCase(),Y=Q&&/msie|trident/.test(Q),Z=Q&&Q.indexOf("msie 9.0")>0,K=Q&&Q.indexOf("edge/")>0;Q&&Q.indexOf("android");var nn=Q&&/iphone|ipad|ipod|ios/.test(Q);Q&&/chrome\/\d+/.test(Q),Q&&/phantomjs/.test(Q);var en,tn=Q&&Q.match(/firefox\/(\d+)/),rn={}.watch,an=!1;if(G)try{var on={};Object.defineProperty(on,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var sn=function(){return void 0===en&&(en=!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function pn(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&pn(Symbol)&&"undefined"!=typeof Reflect&&pn(Reflect.ownKeys);cn="undefined"!=typeof Set&&pn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var gn=null;function un(n){void 0===n&&(n=null),n||gn&&gn._scope.off(),gn=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,r,a,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),bn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function fn(n){return new mn(void 0,void 0,void 0,String(n))}function hn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var vn=0,yn=[],xn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,yn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();xn.target=null;var wn=[];function Sn(n){wn.push(n),xn.target=n}function kn(){wn.pop(),xn.target=wn[wn.length-1]}var jn=Array.prototype,Cn=Object.create(jn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=jn[n];$(Cn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&o.observeArray(a),o.dep.notify(),i}))}));var Tn=Object.getOwnPropertyNames(Cn),An={},Bn=!0;function In(n){Bn=n}var En={notify:R,depend:R,addSub:R,removeSub:R},Pn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?En:new xn,this.vmCount=0,$(n,"__ob__",this),a(n)){if(!t)if(X)n.__proto__=Cn;else for(var r=0,i=Tn.length;r<i;r++){$(n,s=Tn[r],Cn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(r=0;r<o.length;r++){var s;Mn(n,s=o[r],An,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)_n(n[e],!1,this.mock)},n}();function _n(n,e,t){return n&&k(n,"__ob__")&&n.__ob__ instanceof Pn?n.__ob__:!Bn||!t&&sn()||!a(n)&&!g(n)||!Object.isExtensible(n)||n.__v_skip||qn(n)||n instanceof mn?void 0:new Pn(n,e,t)}function Mn(n,e,t,r,i,o,s){void 0===s&&(s=!1);var l=new xn,p=Object.getOwnPropertyDescriptor(n,e);if(!p||!1!==p.configurable){var c=p&&p.get,d=p&&p.set;c&&!d||t!==An&&2!==arguments.length||(t=n[e]);var g=i?t&&t.__ob__:_n(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return xn.target&&(l.depend(),g&&(g.dep.depend(),a(e)&&zn(e))),qn(e)&&!i?e.value:e},set:function(e){var r=c?c.call(n):t;if(q(r,e)){if(d)d.call(n,e);else{if(c)return;if(!i&&qn(r)&&!qn(e))return void(r.value=e);t=e}g=i?e&&e.__ob__:_n(e,!1,o),l.notify()}}}),l}}function Rn(n,e,t){if(!Jn(n)){var r=n.__ob__;return a(n)&&m(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&_n(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(Mn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Dn(n,e){if(a(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Jn(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function zn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&zn(e)}function On(n){return Ln(n,!0),$(n,"__v_isShallow",!0),n}function Ln(n,e){if(!Jn(n)){_n(n,e,sn());0}}function Jn(n){return!(!n||!n.__v_isReadonly)}function qn(n){return!(!n||!0!==n.__v_isRef)}function Fn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(qn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];qn(r)&&!qn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var Nn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Un,!n&&Un&&(this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Hn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Vn=j((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function $n(n,e){function t(){var n=t.fns;if(!a(n))return Be(n,null,arguments,e,"v-on handler");for(var r=n.slice(),i=0;i<r.length;i++)Be(r[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Wn(n,e,t,r,a,o){var l,p,c,d;for(l in n)p=n[l],c=e[l],d=Vn(l),i(p)||(i(c)?(i(p.fns)&&(p=n[l]=$n(p,o)),s(d.once)&&(p=n[l]=a(d.name,p,d.capture)),t(d.name,p,d.capture,d.passive,d.params)):p!==c&&(c.fns=p,n[l]=c));for(l in e)i(n[l])&&r((d=Vn(l)).name,e[l],d.capture)}function Xn(n,e,t){var r;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),w(r.fns,l)}i(a)?r=$n([l]):o(a.fns)&&s(a.merged)?(r=a).fns.push(l):r=$n([a,l]),r.merged=!0,n[e]=r}function Gn(n,e,t,r,a){if(o(e)){if(k(e,t))return n[t]=e[t],a||delete e[t],!0;if(k(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Qn(n){return l(n)?[fn(n)]:a(n)?function n(e,t){var r,p,c,d,g=[];for(r=0;r<e.length;r++)i(p=e[r])||"boolean"==typeof p||(c=g.length-1,d=g[c],a(p)?p.length>0&&(Yn((p=n(p,"".concat(t||"","_").concat(r)))[0])&&Yn(d)&&(g[c]=fn(d.text+p[0].text),p.shift()),g.push.apply(g,p)):l(p)?Yn(d)?g[c]=fn(d.text+p):""!==p&&g.push(fn(p)):Yn(p)&&Yn(d)?g[c]=fn(d.text+p.text):(s(e._isVList)&&o(p.tag)&&i(p.key)&&o(t)&&(p.key="__vlist".concat(t,"_").concat(r,"__")),g.push(p)));return g}(n):void 0}function Yn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Zn(n,e){var t,r,i,s,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(c(n))if(dn&&n[Symbol.iterator]){l=[];for(var p=n[Symbol.iterator](),d=p.next();!d.done;)l.push(e(d.value,l.length)),d=p.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,r=i.length;t<r;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Kn(n,e,t,r){var a,i=this.$scopedSlots[n];i?(t=t||{},r&&(t=_(_({},r),t)),a=i(t)||(p(e)?e():e)):a=this.$slots[n]||(p(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},a):a}function ne(n){return Pt(this.$options,"filters",n,!0)||z}function ee(n,e){return a(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,r,a){var i=N.keyCodes[e]||t;return a&&r&&!N.keyCodes[e]?ee(a,r):i?ee(i,n):r?I(r)!==e:void 0===n}function re(n,e,t,r,i){if(t)if(c(t)){a(t)&&(t=M(t));var o=void 0,s=function(a){if("class"===a||"style"===a||x(a))o=n;else{var s=n.attrs&&n.attrs.type;o=r||N.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=T(a),p=I(a);l in o||p in o||(o[a]=t[a],i&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)s(l)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||oe(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ie(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&se(n[r],"".concat(e,"_").concat(r),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(g(e)){var t=n.on=n.on?_({},n.on):{};for(var r in e){var a=t[r],i=e[r];t[r]=a?[].concat(a,i):i}}else;return n}function pe(n,e,t,r){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];a(o)?pe(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ge(n){n._o=ie,n._n=v,n._s=f,n._l=Zn,n._t=Kn,n._q=O,n._i=L,n._m=ae,n._f=ne,n._k=te,n._b=re,n._v=fn,n._e=bn,n._u=pe,n._g=le,n._d=ce,n._p=de}function ue(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var i=n[r],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var p in t)t[p].every(me)&&delete t[p];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function be(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,a){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==r&&l===a.$key&&!o&&!a.$hasNormal)return a;for(var p in i={},e)e[p]&&"$"!==p[0]&&(i[p]=he(n,t,p,e[p]))}else i={};for(var c in t)c in i||(i[c]=ve(t,c));return e&&Object.isExtensible(e)&&(e._normalized=i),$(i,"$stable",s),$(i,"$key",l),$(i,"$hasNormal",o),i}function he(n,e,t,r){var i=function(){var e=gn;un(n);var t=arguments.length?r.apply(null,arguments):r({}),i=(t=t&&"object"==typeof t&&!a(t)?[t]:Qn(t))&&t[0];return un(e),t&&(!i||1===t.length&&i.isComment&&!be(i))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function ve(n,e){return function(){return n[e]}}function ye(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};$(e,"_v_attr_proxy",!0),xe(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||Se(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:E(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Fn(n,e,t)}))}}}function xe(n,e,t,r,a){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,we(n,o,r,a));for(var o in n)o in e||(i=!0,delete n[o]);return i}function we(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function Se(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var ke=null;function je(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function Ce(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||be(t)))return t}}function Te(n,e,t,r,d,g){return(a(t)||l(t))&&(d=r,r=t,t=void 0),s(g)&&(d=2),function(n,e,t,r,l){if(o(t)&&o(t.__ob__))return bn();o(t)&&o(t.is)&&(e=t.is);if(!e)return bn();0;a(r)&&p(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Qn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,g;if("string"==typeof e){var u=void 0;g=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),d=N.isReservedTag(e)?new mn(N.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(u=Pt(n.$options,"components",e))?new mn(e,t,r,void 0,void 0,n):wt(u,t,n,r,e)}else d=wt(e,t,n,r);return a(d)?d:o(d)?(o(g)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var a=0,l=e.children.length;a<l;a++){var p=e.children[a];o(p.tag)&&(i(p.ns)||s(r)&&"svg"!==p.tag)&&n(p,t,r)}}(d,g),o(t)&&function(n){c(n.style)&&Ne(n.style);c(n.class)&&Ne(n.class)}(t),d):bn()}(n,e,t,r,d)}function Ae(n,e,t){Sn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var i=0;i<a.length;i++)try{if(!1===a[i].call(r,n,e,t))return}catch(n){Ie(n,r,"errorCaptured hook")}}Ie(n,e,t)}finally{kn()}}function Be(n,e,t,r,a){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&b(i)&&!i._handled&&(i.catch((function(n){return Ae(n,r,a+" (Promise/async)")})),i._handled=!0)}catch(n){Ae(n,r,a)}return i}function Ie(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ee(e,null,"config.errorHandler")}Ee(n,e,t)}function Ee(n,e,t){if(!G||"undefined"==typeof console)throw n;console.error(n)}var Pe,_e=!1,Me=[],Re=!1;function De(){Re=!1;var n=Me.slice(0);Me.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&pn(Promise)){var ze=Promise.resolve();Pe=function(){ze.then(De),nn&&setTimeout(R)},_e=!0}else if(Y||"undefined"==typeof MutationObserver||!pn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Pe="undefined"!=typeof setImmediate&&pn(setImmediate)?function(){setImmediate(De)}:function(){setTimeout(De,0)};else{var Oe=1,Le=new MutationObserver(De),Je=document.createTextNode(String(Oe));Le.observe(Je,{characterData:!0}),Pe=function(){Oe=(Oe+1)%2,Je.data=String(Oe)},_e=!0}function qe(n,e){var t;if(Me.push((function(){if(n)try{n.call(e)}catch(n){Ae(n,e,"nextTick")}else t&&t(e)})),Re||(Re=!0,Pe()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Fe(n){return function(e,t){if(void 0===t&&(t=gn),t)return function(n,e,t){var r=n.$options;r[e]=At(r[e],t)}(t,n,e)}}Fe("beforeMount"),Fe("mounted"),Fe("beforeUpdate"),Fe("updated"),Fe("beforeDestroy"),Fe("destroyed"),Fe("activated"),Fe("deactivated"),Fe("serverPrefetch"),Fe("renderTracked"),Fe("renderTriggered"),Fe("errorCaptured");var Ue=new cn;function Ne(n){return function n(e,t){var r,i,o=a(e);if(!o&&!c(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(r=e.length;r--;)n(e[r],t);else if(qn(e))n(e.value,t);else for(i=Object.keys(e),r=i.length;r--;)n(e[i[r]],t)}(n,Ue),Ue.clear(),n}var He,Ve=0,$e=function(){function n(n,e,t,r,a){var i,o;i=this,void 0===(o=Un&&!Un._vm?Un:n?n._scope:void 0)&&(o=Un),o&&o.active&&o.effects.push(i),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ve,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",p(e)?this.getter=e:(this.getter=function(n){if(!W.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=R)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;Sn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ae(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ne(n),kn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ut(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Be(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&w(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function We(n,e){He.$on(n,e)}function Xe(n,e){He.$off(n,e)}function Ge(n,e){var t=He;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Qe(n,e,t){He=n,Wn(e,t||{},We,Xe,Ge,n),He=void 0}var Ye=null;function Ze(n){var e=Ye;return Ye=n,function(){Ye=e}}function Ke(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Ke(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,r){void 0===r&&(r=!0),Sn();var a=gn,i=Un;r&&un(n);var o=n.$options[e],s="".concat(e," hook");if(o)for(var l=0,p=o.length;l<p;l++)Be(o[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),r&&(un(a),i&&i.on()),kn()}var tt=[],rt=[],at={},it=!1,ot=!1,st=0;var lt=0,pt=Date.now;if(G&&!Y){var ct=window.performance;ct&&"function"==typeof ct.now&&pt()>document.createEvent("Event").timeStamp&&(pt=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function gt(){var n,e;for(lt=pt(),ot=!0,tt.sort(dt),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=rt.slice(),r=tt.slice();st=tt.length=rt.length=0,at={},it=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),function(){for(var n=0;n<yn.length;n++){var e=yn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}yn.length=0}(),ln&&N.devtools&&ln.emit("flush")}function ut(n){var e=n.id;if(null==at[e]&&(n!==xn.target||!n.noRecurse)){if(at[e]=!0,ot){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);it||(it=!0,qe(gt))}}function mt(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var i=r[a];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=p(s)?s.call(e):s}else 0}}return t}}function bt(n,e,t,i,o){var l,p=this,c=o.options;k(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var d=s(c._compiled),g=!d;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||r,this.injections=mt(c.inject,i),this.slots=function(){return p.$slots||fe(i,n.scopedSlots,p.$slots=ue(t,i)),p.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(i,n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=fe(i,n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,r){var o=Te(l,n,e,t,r,g);return o&&!a(o)&&(o.fnScopeId=c._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,r){return Te(l,n,e,t,r,g)}}function ft(n,e,t,r,a){var i=hn(n);return i.fnContext=t,i.fnOptions=r,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function ht(n,e){for(var t in e)n[T(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}ge(bt.prototype);var yt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;yt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,i){var o=a.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),p=!!(i||n.$options._renderChildren||l),c=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=i;var d=a.data.attrs||r;n._attrsProxy&&xe(n._attrsProxy,d,c.data&&c.data.attrs||r,n,"$attrs")&&(p=!0),n.$attrs=d,t=t||r;var g=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,g||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Qe(n,t,g),e&&n.$options.props){In(!1);for(var u=n._props,m=n.$options._propKeys||[],b=0;b<m.length;b++){var f=m[b],h=n.$options.props;u[f]=_t(f,h,e,n)}In(!0),n.$options.propsData=e}p&&(n.$slots=ue(i,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ke(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(yt);function wt(n,e,t,l,p){if(!i(n)){var d=t.$options._base;if(c(n)&&(n=d.extend(n)),"function"==typeof n){var g;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=ke;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],a=!0,l=null,p=null;t.$on("hook:destroyed",(function(){return w(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==p&&(clearTimeout(p),p=null))},g=J((function(t){n.resolved=je(t,e),a?r.length=0:d(!0)})),u=J((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),m=n(g,u);return c(m)&&(b(m)?i(n.resolved)&&m.then(g,u):b(m.component)&&(m.component.then(g,u),o(m.error)&&(n.errorComp=je(m.error,e)),o(m.loading)&&(n.loadingComp=je(m.loading,e),0===m.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,d(!1))}),m.delay||200)),o(m.timeout)&&(p=setTimeout((function(){p=null,i(n.resolved)&&u(null)}),m.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(g=n,d)))return function(n,e,t,r,a){var i=bn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:r,tag:a},i}(g,e,t,l,p);e=e||{},$t(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[r],l=e.model.callback;o(s)?(a(s)?-1===s.indexOf(l):s!==l)&&(i[r]=[l].concat(s)):i[r]=l}(n.options,e);var u=function(n,e,t){var r=e.options.props;if(!i(r)){var a={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var p in r){var c=I(p);Gn(a,l,p,c,!0)||Gn(a,s,p,c,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,p={},c=l.props;if(o(c))for(var d in c)p[d]=_t(d,c,e||r);else o(t.attrs)&&ht(p,t.attrs),o(t.props)&&ht(p,t.props);var g=new bt(t,p,s,i,n),u=l.render.call(null,g._c,g);if(u instanceof mn)return ft(u,t,g.parent,l,g);if(a(u)){for(var m=Qn(u)||[],b=new Array(m.length),f=0;f<m.length;f++)b[f]=ft(m[f],t,g.parent,l,g);return b}}(n,u,e,t,l);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var r=xt[t],a=e[r],i=yt[r];a===i||a&&a._merged||(e[r]=a?St(i,a):i)}}(e);var h=vt(n.options)||p;return new mn("vue-component-".concat(n.cid).concat(h?"-".concat(h):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:m,tag:p,children:l},g)}}}function St(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var kt=R,jt=N.optionMergeStrategies;function Ct(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,a,i,o=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(r=o[s])&&(a=n[r],i=e[r],t&&k(n,r)?a!==i&&g(a)&&g(i)&&Ct(a,i):Rn(n,r,i));return n}function Tt(n,e,t){return t?function(){var r=p(e)?e.call(t,t):e,a=p(n)?n.call(t,t):n;return r?Ct(r,a):a}:e?n?function(){return Ct(p(e)?e.call(this,this):e,p(n)?n.call(this,this):n)}:e:n}function At(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Bt(n,e,t,r){var a=Object.create(n||null);return e?_(a,e):a}jt.data=function(n,e,t){return t?Tt(n,e,t):e&&"function"!=typeof e?n:Tt(n,e)},U.forEach((function(n){jt[n]=At})),F.forEach((function(n){jt[n+"s"]=Bt})),jt.watch=function(n,e,t,r){if(n===rn&&(n=void 0),e===rn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in _(i,n),e){var s=i[o],l=e[o];s&&!a(s)&&(s=[s]),i[o]=s?s.concat(l):a(l)?l:[l]}return i},jt.props=jt.methods=jt.inject=jt.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return _(a,n),e&&_(a,e),a},jt.provide=function(n,e){return n?function(){var t=Object.create(null);return Ct(t,p(n)?n.call(this):n),e&&Ct(t,p(e)?e.call(this):e,!1),t}:e};var It=function(n,e){return void 0===e?n:e};function Et(n,e,t){if(p(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,i,o={};if(a(t))for(r=t.length;r--;)"string"==typeof(i=t[r])&&(o[T(i)]={type:null});else if(g(t))for(var s in t)i=t[s],o[T(s)]=g(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var i=0;i<t.length;i++)r[t[i]]={from:t[i]};else if(g(t))for(var o in t){var s=t[o];r[o]=g(s)?_({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];p(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Et(n,e.extends,t)),e.mixins))for(var r=0,i=e.mixins.length;r<i;r++)n=Et(n,e.mixins[r],t);var o,s={};for(o in n)l(o);for(o in e)k(n,o)||l(o);function l(r){var a=jt[r]||It;s[r]=a(n[r],e[r],t,r)}return s}function Pt(n,e,t,r){if("string"==typeof t){var a=n[e];if(k(a,t))return a[t];var i=T(t);if(k(a,i))return a[i];var o=A(i);return k(a,o)?a[o]:a[t]||a[i]||a[o]}}function _t(n,e,t,r){var a=e[n],i=!k(t,n),o=t[n],s=zt(Boolean,a.type);if(s>-1)if(i&&!k(a,"default"))o=!1;else if(""===o||o===I(n)){var l=zt(String,a.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return p(r)&&"Function"!==Rt(e.type)?r.call(n):r}(r,a,n);var c=Bn;In(!0),_n(o),In(c)}return o}var Mt=/^\s*function (\w+)/;function Rt(n){var e=n&&n.toString().match(Mt);return e?e[1]:""}function Dt(n,e){return Rt(n)===Rt(e)}function zt(n,e){if(!a(e))return Dt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Dt(e[t],n))return t;return-1}var Ot={enumerable:!0,configurable:!0,get:R,set:R};function Lt(n,e,t){Ot.get=function(){return this[e][t]},Ot.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ot)}function Jt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=On({}),a=n.$options._propKeys=[];n.$parent&&In(!1);var i=function(i){a.push(i);var o=_t(i,e,t,n);Mn(r,i,o,void 0,!0),i in n||Lt(n,"_props",i)};for(var o in e)i(o);In(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ye(n);un(n),Sn();var a=Be(t,null,[n._props||On({}),r],n,"setup");if(kn(),un(),p(a))e.render=a;else if(c(a))if(n._setupState=a,a.__sfc){var i=n._setupProxy={};for(var o in a)"__sfc"!==o&&Fn(i,a,o)}else for(var o in a)V(o)||Fn(n,a,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?R:E(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;g(e=n._data=p(e)?function(n,e){Sn();try{return n.call(e,e)}catch(n){return Ae(n,e,"data()"),{}}finally{kn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var i=t[a];0,r&&k(r,i)||V(i)||Lt(n,"_data",i)}var o=_n(e);o&&o.vmCount++}(n);else{var t=_n(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=sn();for(var a in e){var i=e[a],o=p(i)?i:i.get;0,r||(t[a]=new $e(n,o||R,R,qt)),a in n||Ft(n,a,i)}}(n,e.computed),e.watch&&e.watch!==rn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var i=0;i<r.length;i++)Ht(n,t,r[i]);else Ht(n,t,r)}}(n,e.watch)}var qt={lazy:!0};function Ft(n,e,t){var r=!sn();p(t)?(Ot.get=r?Ut(e):Nt(t),Ot.set=R):(Ot.get=t.get?r&&!1!==t.cache?Ut(e):Nt(t.get):R,Ot.set=t.set||R),Object.defineProperty(n,e,Ot)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function Nt(n){return function(){return n.call(this,this)}}function Ht(n,e,t,r){return g(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Vt=0;function $t(n){var e=n.options;if(n.super){var t=$t(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&_(n.extendOptions,r),(e=n.options=Et(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Wt(n){this._init(n)}function Xt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var i=vt(n)||vt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Et(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Lt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ft(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,F.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=_({},o.options),a[r]=o,o}}function Gt(n){return n&&(vt(n.Ctor.options)||n.tag)}function Qt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!u(n)&&n.test(e)}function Yt(n,e){var t=n.cache,r=n.keys,a=n._vnode,i=n.$vnode;for(var o in t){var s=t[o];if(s){var l=s.name;l&&!e(l)&&Zt(t,o,r,a)}}i.componentOptions.children=void 0}function Zt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,w(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Vt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Nn(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Et($t(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=ue(e._renderChildren,a),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,a){return Te(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Te(n,e,t,r,a,!0)};var i=t&&t.data;Mn(n,"$attrs",i&&i.attrs||r,null,!0),Mn(n,"$listeners",e._parentListeners||r,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(In(!1),Object.keys(e).forEach((function(t){Mn(n,t,e[t])})),In(!0))}(e),Jt(e),function(n){var e=n.$options.provide;if(e){var t=p(e)?e.call(n):e;if(!c(t))return;for(var r=Hn(n),a=dn?Reflect.ownKeys(t):Object.keys(t),i=0;i<a.length;i++){var o=a[i];Object.defineProperty(r,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Wt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Rn,n.prototype.$delete=Dn,n.prototype.$watch=function(n,e,t){if(g(e))return Ht(this,n,e,t);(t=t||{}).user=!0;var r=new $e(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');Sn(),Be(e,this,[r.value],this,a),kn()}return function(){r.teardown()}}}(Wt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var i=0,o=n.length;i<o;i++)r.$on(n[i],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,i=n.length;r<i;r++)t.$off(n[r],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?P(t):t;for(var r=P(arguments,1),a='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Be(t[i],e,r,e,a)}return e}}(Wt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,i=Ze(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),i(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||w(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Wt),function(n){ge(n.prototype),n.prototype.$nextTick=function(n){return qe(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,r=e._parentVnode;r&&n._isMounted&&(n.$scopedSlots=fe(n.$parent,r.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&Se(n._slotsProxy,n.$scopedSlots)),n.$vnode=r;var i,o=gn,s=ke;try{un(n),ke=n,i=t.call(n._renderProxy,n.$createElement)}catch(e){Ae(e,n,"render"),i=n._vnode}finally{ke=s,un(o)}return a(i)&&1===i.length&&(i=i[0]),i instanceof mn||(i=bn()),i.parent=r,i}}(Wt);var Kt=[String,RegExp,Array],nr={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Kt,exclude:Kt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,i=t.componentInstance,o=t.componentOptions;n[r]={name:Gt(o),tag:a,componentInstance:i},e.push(r),this.max&&e.length>parseInt(this.max)&&Zt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Zt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Yt(n,(function(n){return Qt(e,n)}))})),this.$watch("exclude",(function(e){Yt(n,(function(n){return!Qt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ce(n),t=e&&e.componentOptions;if(t){var r=Gt(t),a=this.include,i=this.exclude;if(a&&(!r||!Qt(a,r))||i&&r&&Qt(i,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,w(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:kt,extend:_,mergeOptions:Et,defineReactive:Mn},n.set=Rn,n.delete=Dn,n.nextTick=qe,n.observable=function(n){return _n(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,_(n.options.components,nr),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=P(arguments,1);return t.unshift(this),p(n.install)?n.install.apply(n,t):p(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Et(this.options,n),this}}(n),Xt(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&g(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&p(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Wt),Object.defineProperty(Wt.prototype,"$isServer",{get:sn}),Object.defineProperty(Wt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Wt,"FunctionalRenderContext",{value:bt}),Wt.version="2.7.16";var er=y("style,class"),tr=y("input,textarea,option,select,progress"),rr=y("contenteditable,draggable,spellcheck"),ar=y("events,caret,typing,plaintext-only"),ir=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),or="http://www.w3.org/1999/xlink",sr=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},lr=function(n){return sr(n)?n.slice(6,n.length):""},pr=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=dr(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=dr(e,t.data));return function(n,e){if(o(n)||o(e))return gr(n,ur(e));return""}(e.staticClass,e.class)}function dr(n,e){return{staticClass:gr(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function gr(n,e){return n?e?n+" "+e:n:e||""}function ur(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)o(e=ur(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var mr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},br=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fr=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),hr=function(n){return br(n)||fr(n)};var vr=Object.create(null);var yr=y("text,number,password,search,email,tel,url");var xr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(mr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wr={create:function(n,e){Sr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Sr(n,!0),Sr(e))},destroy:function(n){Sr(n,!0)}};function Sr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(p(t))Be(t,r,[s],r,"template ref function");else{var c=n.data.refInFor,d="string"==typeof t||"number"==typeof t,g=qn(t),u=r.$refs;if(d||g)if(c){var m=d?u[t]:t.value;e?a(m)&&w(m,i):a(m)?m.includes(i)||m.push(i):d?(u[t]=[i],kr(r,t,u[t])):t.value=[i]}else if(d){if(e&&u[t]!==i)return;u[t]=l,kr(r,t,s)}else if(g){if(e&&t.value!==i)return;t.value=s}else 0}}}function kr(n,e,t){var r=n._setupState;r&&k(r,e)&&(qn(r[e])?r[e].value=t:r[e]=t)}var jr=new mn("",{},[]),Cr=["create","activate","update","remove","destroy"];function Tr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,a=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===a||yr(r)&&yr(a)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Ar(n,e,t){var r,a,i={};for(r=e;r<=t;++r)o(a=n[r].key)&&(i[a]=r);return i}var Br={create:Ir,update:Ir,destroy:function(n){Ir(n,jr)}};function Ir(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,i=n===jr,o=e===jr,s=Pr(n.data.directives,n.context),l=Pr(e.data.directives,e.context),p=[],c=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,Mr(a,"update",e,n),a.def&&a.def.componentUpdated&&c.push(a)):(Mr(a,"bind",e,n),a.def&&a.def.inserted&&p.push(a));if(p.length){var d=function(){for(var t=0;t<p.length;t++)Mr(p[t],"inserted",e,n)};i?Xn(e,"insert",d):d()}c.length&&Xn(e,"postpatch",(function(){for(var t=0;t<c.length;t++)Mr(c[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||Mr(s[t],"unbind",n,n,o)}(n,e)}var Er=Object.create(null);function Pr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Er),a[_r(r)]=r,e._setupState&&e._setupState.__sfc){var i=r.def||Pt(e,"_setupState","v-"+r.name);r.def="function"==typeof i?{bind:i,update:i}:i}r.def=r.def||Pt(e.$options,"directives",r.name)}return a}function _r(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Mr(n,e,t,r,a){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,r,a)}catch(r){Ae(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Rr=[wr,Br];function Dr(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var r,a,l=e.elm,p=n.data.attrs||{},c=e.data.attrs||{};for(r in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.attrs=_({},c)),c)a=c[r],p[r]!==a&&zr(l,r,a,e.data.pre);for(r in(Y||K)&&c.value!==p.value&&zr(l,"value",c.value),p)i(c[r])&&(sr(r)?l.removeAttributeNS(or,lr(r)):rr(r)||l.removeAttribute(r))}}function zr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Or(n,e,t):ir(e)?pr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):rr(e)?n.setAttribute(e,function(n,e){return pr(e)||"false"===e?"false":"contenteditable"===n&&ar(e)?e:"true"}(e,t)):sr(e)?pr(t)?n.removeAttributeNS(or,lr(e)):n.setAttributeNS(or,e,t):Or(n,e,t)}function Or(n,e,t){if(pr(t))n.removeAttribute(e);else{if(Y&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Lr={create:Dr,update:Dr};function Jr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(i(r.staticClass)&&i(r.class)&&(i(a)||i(a.staticClass)&&i(a.class)))){var s=cr(e),l=t._transitionClasses;o(l)&&(s=gr(s,ur(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var qr,Fr={create:Jr,update:Jr};function Ur(n,e,t){var r=qr;return function a(){var i=e.apply(null,arguments);null!==i&&Vr(n,a,t,r)}}var Nr=_e&&!(tn&&Number(tn[1])<=53);function Hr(n,e,t,r){if(Nr){var a=lt,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}qr.addEventListener(n,e,an?{capture:t,passive:r}:t)}function Vr(n,e,t,r){(r||qr).removeEventListener(n,e._wrapper||e,t)}function $r(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},r=n.data.on||{};qr=e.elm||n.elm,function(n){if(o(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Wn(t,r,Hr,Vr,Ur,e.context),qr=void 0}}var Wr,Xr={create:$r,update:$r,destroy:function(n){return $r(n,jr)}};function Gr(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},p=e.data.domProps||{};for(t in(o(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.domProps=_({},p)),l)t in p||(a[t]="");for(t in p){if(r=p[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var c=i(r)?"":String(r);Qr(a,c)&&(a.value=c)}else if("innerHTML"===t&&fr(a.tagName)&&i(a.innerHTML)){(Wr=Wr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=Wr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;d.firstChild;)a.appendChild(d.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Qr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Yr={create:Gr,update:Gr},Zr=j((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Kr(n){var e=na(n.style);return n.staticStyle?_(n.staticStyle,e):e}function na(n){return Array.isArray(n)?M(n):"string"==typeof n?Zr(n):n}var ea,ta=/^--/,ra=/\s*!important$/,aa=function(n,e,t){if(ta.test(e))n.style.setProperty(e,t);else if(ra.test(t))n.style.setProperty(I(e),t.replace(ra,""),"important");else{var r=oa(e);if(Array.isArray(t))for(var a=0,i=t.length;a<i;a++)n.style[r]=t[a];else n.style[r]=t}},ia=["Webkit","Moz","ms"],oa=j((function(n){if(ea=ea||document.createElement("div").style,"filter"!==(n=T(n))&&n in ea)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ia.length;t++){var r=ia[t]+e;if(r in ea)return r}}));function sa(n,e){var t=e.data,r=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(r.staticStyle)&&i(r.style))){var a,s,l=e.elm,p=r.staticStyle,c=r.normalizedStyle||r.style||{},d=p||c,g=na(e.data.style)||{};e.data.normalizedStyle=o(g.__ob__)?_({},g):g;var u=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Kr(a.data))&&_(r,t);(t=Kr(n.data))&&_(r,t);for(var i=n;i=i.parent;)i.data&&(t=Kr(i.data))&&_(r,t);return r}(e,!0);for(s in d)i(u[s])&&aa(l,s,"");for(s in u)a=u[s],aa(l,s,null==a?"":a)}}var la={create:sa,update:sa},pa=/\s+/;function ca(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(pa).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function da(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(pa).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ga(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&_(e,ua(n.name||"v")),_(e,n),e}return"string"==typeof n?ua(n):void 0}}var ua=j((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ma=G&&!Z,ba="transition",fa="transitionend",ha="animation",va="animationend";ma&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ba="WebkitTransition",fa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(ha="WebkitAnimation",va="webkitAnimationEnd"));var ya=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xa(n){ya((function(){ya(n)}))}function wa(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ca(n,e))}function Sa(n,e){n._transitionClasses&&w(n._transitionClasses,e),da(n,e)}function ka(n,e,t){var r=Ca(n,e),a=r.type,i=r.timeout,o=r.propCount;if(!a)return t();var s="transition"===a?fa:va,l=0,p=function(){n.removeEventListener(s,c),t()},c=function(e){e.target===n&&++l>=o&&p()};setTimeout((function(){l<o&&p()}),i+1),n.addEventListener(s,c)}var ja=/\b(transform|all)(,|$)/;function Ca(n,e){var t,r=window.getComputedStyle(n),a=(r[ba+"Delay"]||"").split(", "),i=(r[ba+"Duration"]||"").split(", "),o=Ta(a,i),s=(r[ha+"Delay"]||"").split(", "),l=(r[ha+"Duration"]||"").split(", "),p=Ta(s,l),c=0,d=0;return"transition"===e?o>0&&(t="transition",c=o,d=i.length):"animation"===e?p>0&&(t="animation",c=p,d=l.length):d=(t=(c=Math.max(o,p))>0?o>p?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:c,propCount:d,hasTransform:"transition"===t&&ja.test(r[ba+"Property"])}}function Ta(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Aa(e)+Aa(n[t])})))}function Aa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ba(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ga(n.data.transition);if(!i(r)&&!o(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,l=r.enterClass,d=r.enterToClass,g=r.enterActiveClass,u=r.appearClass,m=r.appearToClass,b=r.appearActiveClass,f=r.beforeEnter,h=r.enter,y=r.afterEnter,x=r.enterCancelled,w=r.beforeAppear,S=r.appear,k=r.afterAppear,j=r.appearCancelled,C=r.duration,T=Ye,A=Ye.$vnode;A&&A.parent;)T=A.context,A=A.parent;var B=!T._isMounted||!n.isRootInsert;if(!B||S||""===S){var I=B&&u?u:l,E=B&&b?b:g,P=B&&m?m:d,_=B&&w||f,M=B&&p(S)?S:h,R=B&&k||y,D=B&&j||x,z=v(c(C)?C.enter:C);0;var O=!1!==a&&!Z,L=Pa(M),q=t._enterCb=J((function(){O&&(Sa(t,P),Sa(t,E)),q.cancelled?(O&&Sa(t,I),D&&D(t)):R&&R(t),t._enterCb=null}));n.data.show||Xn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),M&&M(t,q)})),_&&_(t),O&&(wa(t,I),wa(t,E),xa((function(){Sa(t,I),q.cancelled||(wa(t,P),L||(Ea(z)?setTimeout(q,z):ka(t,s,q)))}))),n.data.show&&(e&&e(),M&&M(t,q)),O||L||q()}}}function Ia(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ga(n.data.transition);if(i(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var a=r.css,s=r.type,l=r.leaveClass,p=r.leaveToClass,d=r.leaveActiveClass,g=r.beforeLeave,u=r.leave,m=r.afterLeave,b=r.leaveCancelled,f=r.delayLeave,h=r.duration,y=!1!==a&&!Z,x=Pa(u),w=v(c(h)?h.leave:h);0;var S=t._leaveCb=J((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Sa(t,p),Sa(t,d)),S.cancelled?(y&&Sa(t,l),b&&b(t)):(e(),m&&m(t)),t._leaveCb=null}));f?f(k):k()}function k(){S.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),g&&g(t),y&&(wa(t,l),wa(t,d),xa((function(){Sa(t,l),S.cancelled||(wa(t,p),x||(Ea(w)?setTimeout(S,w):ka(t,s,S)))}))),u&&u(t,S),y||x||S())}}function Ea(n){return"number"==typeof n&&!isNaN(n)}function Pa(n){if(i(n))return!1;var e=n.fns;return o(e)?Pa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function _a(n,e){!0!==e.data.show&&Ba(e)}var Ma=function(n){var e,t,r={},p=n.modules,c=n.nodeOps;for(e=0;e<Cr.length;++e)for(r[Cr[e]]=[],t=0;t<p.length;++t)o(p[t][Cr[e]])&&r[Cr[e]].push(p[t][Cr[e]]);function d(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function g(n,e,t,a,i,l,p){if(o(n.elm)&&o(l)&&(n=l[p]=hn(n)),n.isRootInsert=!i,!function(n,e,t,a){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return u(n,e),m(t,n.elm,a),s(l)&&function(n,e,t,a){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<r.activate.length;++i)r.activate[i](jr,s);e.push(s);break}m(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var d=n.data,g=n.children,f=n.tag;o(f)?(n.elm=n.ns?c.createElementNS(n.ns,f):c.createElement(f,n),v(n),b(n,g,e),o(d)&&h(n,e),m(t,n.elm,a)):s(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,a)):(n.elm=c.createTextNode(n.text),m(t,n.elm,a))}}function u(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(h(n,e),v(n)):(Sr(n),e.push(n))}function m(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function b(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)g(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function h(n,t){for(var a=0;a<r.create.length;++a)r.create[a](jr,n);o(e=n.data.hook)&&(o(e.create)&&e.create(jr,n),o(e.insert)&&t.push(n))}function v(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=Ye)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function x(n,e,t,r,a,i){for(;r<=a;++r)g(t[r],i,n,e,!1,t,r)}function w(n){var e,t,a=n.data;if(o(a))for(o(e=a.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function S(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(k(r),w(r)):d(r.elm))}}function k(n,e){if(o(e)||o(n.data)){var t,a=r.remove.length+1;for(o(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,a),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function j(n,e,t,r){for(var a=t;a<r;a++){var i=e[a];if(o(i)&&Tr(n,i))return a}}function C(n,e,t,a,l,p){if(n!==e){o(e.elm)&&o(a)&&(e=a[l]=hn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?B(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var u,m=e.data;o(m)&&o(u=m.hook)&&o(u=u.prepatch)&&u(n,e);var b=n.children,h=e.children;if(o(m)&&f(e)){for(u=0;u<r.update.length;++u)r.update[u](n,e);o(u=m.hook)&&o(u=u.update)&&u(n,e)}i(e.text)?o(b)&&o(h)?b!==h&&function(n,e,t,r,a){var s,l,p,d=0,u=0,m=e.length-1,b=e[0],f=e[m],h=t.length-1,v=t[0],y=t[h],w=!a;for(0;d<=m&&u<=h;)i(b)?b=e[++d]:i(f)?f=e[--m]:Tr(b,v)?(C(b,v,r,t,u),b=e[++d],v=t[++u]):Tr(f,y)?(C(f,y,r,t,h),f=e[--m],y=t[--h]):Tr(b,y)?(C(b,y,r,t,h),w&&c.insertBefore(n,b.elm,c.nextSibling(f.elm)),b=e[++d],y=t[--h]):Tr(f,v)?(C(f,v,r,t,u),w&&c.insertBefore(n,f.elm,b.elm),f=e[--m],v=t[++u]):(i(s)&&(s=Ar(e,d,m)),i(l=o(v.key)?s[v.key]:j(v,e,d,m))?g(v,r,n,b.elm,!1,t,u):Tr(p=e[l],v)?(C(p,v,r,t,u),e[l]=void 0,w&&c.insertBefore(n,p.elm,b.elm)):g(v,r,n,b.elm,!1,t,u),v=t[++u]);d>m?x(n,i(t[h+1])?null:t[h+1].elm,t,u,h,r):u>h&&S(e,d,m)}(d,b,h,t,p):o(h)?(o(n.text)&&c.setTextContent(d,""),x(d,null,h,0,h.length-1,t)):o(b)?S(b,0,b.length-1):o(n.text)&&c.setTextContent(d,""):n.text!==e.text&&c.setTextContent(d,e.text),o(m)&&o(u=m.hook)&&o(u=u.postpatch)&&u(n,e)}}}function T(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var A=y("attrs,class,staticClass,staticStyle,key");function B(n,e,t,r){var a,i=e.tag,l=e.data,p=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(a=l.hook)&&o(a=a.init)&&a(e,!0),o(a=e.componentInstance)))return u(e,t),!0;if(o(i)){if(o(p))if(n.hasChildNodes())if(o(a=l)&&o(a=a.domProps)&&o(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var c=!0,d=n.firstChild,g=0;g<p.length;g++){if(!d||!B(d,p[g],t,r)){c=!1;break}d=d.nextSibling}if(!c||d)return!1}else b(e,p,t);if(o(l)){var m=!1;for(var f in l)if(!A(f)){m=!0,h(e,t);break}!m&&l.class&&Ne(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!i(e)){var l,p=!1,d=[];if(i(n))p=!0,g(e,d);else{var u=o(n.nodeType);if(!u&&Tr(n,e))C(n,e,d,null,null,a);else{if(u){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&B(n,e,d))return T(e,d,!0),n;l=n,n=new mn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var m=n.elm,b=c.parentNode(m);if(g(e,d,m._leaveCb?null:b,c.nextSibling(m)),o(e.parent))for(var h=e.parent,v=f(e);h;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](h);if(h.elm=e.elm,v){for(var x=0;x<r.create.length;++x)r.create[x](jr,h);var k=h.data.hook.insert;if(k.merged)for(var j=k.fns.slice(1),A=0;A<j.length;A++)j[A]()}else Sr(h);h=h.parent}o(b)?S([n],0,0):o(n.tag)&&w(n)}}return T(e,d,p),e.elm}o(n)&&w(n)}}({nodeOps:xr,modules:[Lr,Fr,Xr,Yr,la,G?{create:_a,activate:_a,remove:function(n,e){!0!==n.data.show?Ia(n,e):e()}}:{}].concat(Rr)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Fa(n,"input")}));var Ra={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Xn(t,"postpatch",(function(){Ra.componentUpdated(n,e,t)})):Da(n,e,t.context),n._vOptions=[].map.call(n.options,La)):("textarea"===t.tag||yr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Ja),n.addEventListener("compositionend",qa),n.addEventListener("change",qa),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Da(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,La);if(a.some((function(n,e){return!O(n,r[e])})))(n.multiple?e.value.some((function(n){return Oa(n,a)})):e.value!==e.oldValue&&Oa(e.value,a))&&Fa(n,"change")}}};function Da(n,e,t){za(n,e,t),(Y||K)&&setTimeout((function(){za(n,e,t)}),0)}function za(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],a)i=L(r,La(o))>-1,o.selected!==i&&(o.selected=i);else if(O(La(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function Oa(n,e){return e.every((function(e){return!O(e,n)}))}function La(n){return"_value"in n?n._value:n.value}function Ja(n){n.target.composing=!0}function qa(n){n.target.composing&&(n.target.composing=!1,Fa(n.target,"input"))}function Fa(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ua(n){return!n.componentInstance||n.data&&n.data.transition?n:Ua(n.componentInstance._vnode)}var Na={model:Ra,show:{bind:function(n,e,t){var r=e.value,a=(t=Ua(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,Ba(t,(function(){n.style.display=i}))):n.style.display=r?i:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Ua(t)).data&&t.data.transition?(t.data.show=!0,r?Ba(t,(function(){n.style.display=n.__vOriginalDisplay})):Ia(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Ha={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Va(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Va(Ce(e.children)):n}function $a(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[T(r)]=a[r];return e}function Wa(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Xa=function(n){return n.tag||be(n)},Ga=function(n){return"show"===n.name},Qa={name:"transition",props:Ha,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Xa)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var i=Va(a);if(!i)return a;if(this._leaving)return Wa(n,a);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=$a(this),p=this._vnode,c=Va(p);if(i.data.directives&&i.data.directives.some(Ga)&&(i.data.show=!0),c&&c.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,c)&&!be(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var d=c.data.transition=_({},s);if("out-in"===r)return this._leaving=!0,Xn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Wa(n,a);if("in-out"===r){if(be(i))return p;var g,u=function(){g()};Xn(s,"afterEnter",u),Xn(s,"enterCancelled",u),Xn(d,"delayLeave",(function(n){g=n}))}}return a}}},Ya=_({tag:String,moveClass:String},Ha);function Za(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ka(n){n.data.newPos=n.elm.getBoundingClientRect()}function ni(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),i.transitionDuration="0s"}}delete Ya.mode;var ei={Transition:Qa,TransitionGroup:{props:Ya,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],i=this.children=[],o=$a(this),s=0;s<a.length;s++){if((c=a[s]).tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))i.push(c),t[c.key]=c,(c.data||(c.data={})).transition=o;else;}if(r){var l=[],p=[];for(s=0;s<r.length;s++){var c;(c=r[s]).data.transition=o,c.data.pos=c.elm.getBoundingClientRect(),t[c.key]?l.push(c):p.push(c)}this.kept=n(e,null,l),this.removed=p}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Za),n.forEach(Ka),n.forEach(ni),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;wa(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(fa,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(fa,n),t._moveCb=null,Sa(t,e))})}})))},methods:{hasMove:function(n,e){if(!ma)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){da(t,n)})),ca(t,e),t.style.display="none",this.$el.appendChild(t);var r=Ca(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ti(n,e){for(var t in e)n[t]=e[t];return n}Wt.config.mustUseProp=function(n,e,t){return"value"===t&&tr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Wt.config.isReservedTag=hr,Wt.config.isReservedAttr=er,Wt.config.getTagNamespace=function(n){return fr(n)?"svg":"math"===n?"math":void 0},Wt.config.isUnknownElement=function(n){if(!G)return!0;if(hr(n))return!1;if(n=n.toLowerCase(),null!=vr[n])return vr[n];var e=document.createElement(n);return n.indexOf("-")>-1?vr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:vr[n]=/HTMLUnknownElement/.test(e.toString())},_(Wt.options.directives,Na),_(Wt.options.components,ei),Wt.prototype.__patch__=G?Ma:R,Wt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=bn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new $e(n,r,R,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var i=0;i<a.length;i++)a[i].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&G?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},G&&setTimeout((function(){N.devtools&&ln&&ln.emit("init",Wt)}),0);var ri=/[!'()*]/g,ai=function(n){return"%"+n.charCodeAt(0).toString(16)},ii=/%2C/g,oi=function(n){return encodeURIComponent(n).replace(ri,ai).replace(ii,",")};function si(n){try{return decodeURIComponent(n)}catch(n){0}return n}var li=function(n){return null==n||"object"==typeof n?n:String(n)};function pi(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=si(t.shift()),a=t.length>0?si(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function ci(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oi(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(oi(e)):r.push(oi(e)+"="+oi(n)))})),r.join("&")}return oi(e)+"="+oi(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var di=/\/?$/;function gi(n,e,t,r){var a=r&&r.options.stringifyQuery,i=e.query||{};try{i=ui(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:fi(e,a),matched:n?bi(n):[]};return t&&(o.redirectedFrom=fi(t,a)),Object.freeze(o)}function ui(n){if(Array.isArray(n))return n.map(ui);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ui(n[t]);return e}return n}var mi=gi(null,{path:"/"});function bi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function fi(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||ci)(r)+a}function hi(n,e,t){return e===mi?n===e:!!e&&(n.path&&e.path?n.path.replace(di,"")===e.path.replace(di,"")&&(t||n.hash===e.hash&&vi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&vi(n.query,e.query)&&vi(n.params,e.params))))}function vi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var i=n[t];if(r[a]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?vi(i,o):String(i)===String(o)}))}function yi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],i=t.enteredCbs[r];if(a&&i){delete t.enteredCbs[r];for(var o=0;o<i.length;o++)a._isBeingDestroyed||i[o](a)}}}}var xi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var o=a.$createElement,s=t.name,l=a.$route,p=a._routerViewCache||(a._routerViewCache={}),c=0,d=!1;a&&a._routerRoot!==a;){var g=a.$vnode?a.$vnode.data:{};g.routerView&&c++,g.keepAlive&&a._directInactive&&a._inactive&&(d=!0),a=a.$parent}if(i.routerViewDepth=c,d){var u=p[s],m=u&&u.component;return m?(u.configProps&&wi(m,i,u.route,u.configProps),o(m,i,r)):o()}var b=l.matched[c],f=b&&b.components[s];if(!b||!f)return p[s]=null,o();p[s]={component:f},i.registerRouteInstance=function(n,e){var t=b.instances[s];(e&&t!==n||!e&&t===n)&&(b.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){b.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==b.instances[s]&&(b.instances[s]=n.componentInstance),yi(l)};var h=b.props&&b.props[s];return h&&(ti(p[s],{route:l,configProps:h}),wi(f,i,l,h)),o(f,i,r)}};function wi(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=ti({},a);var i=e.attrs=e.attrs||{};for(var o in a)n.props&&o in n.props||(i[o]=a[o],delete a[o])}}function Si(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function ki(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ji=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Ci=Ji,Ti=Pi,Ai=function(n,e){return Mi(Pi(n,e),e)},Bi=Mi,Ii=Li,Ei=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Pi(n,e){for(var t,r=[],a=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=Ei.exec(n));){var l=t[0],p=t[1],c=t.index;if(o+=n.slice(i,c),i=c+l.length,p)o+=p[1];else{var d=n[i],g=t[2],u=t[3],m=t[4],b=t[5],f=t[6],h=t[7];o&&(r.push(o),o="");var v=null!=g&&null!=d&&d!==g,y="+"===f||"*"===f,x="?"===f||"*"===f,w=t[2]||s,S=m||b;r.push({name:u||a++,prefix:g||"",delimiter:w,optional:x,repeat:y,partial:v,asterisk:!!h,pattern:S?Di(S):h?".*":"[^"+Ri(w)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&r.push(o),r}function _i(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Mi(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Oi(e)));return function(e,r){for(var a="",i=e||{},o=(r||{}).pretty?_i:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var p,c=i[l.name];if(null==c){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ji(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<c.length;d++){if(p=o(c[d]),!t[s].test(p))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(p)+"`");a+=(0===d?l.prefix:l.delimiter)+p}}else{if(p=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(c),!t[s].test(p))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+p+'"');a+=l.prefix+p}}else a+=l}return a}}function Ri(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Di(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function zi(n,e){return n.keys=e,n}function Oi(n){return n&&n.sensitive?"":"i"}function Li(n,e,t){ji(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=Ri(s);else{var l=Ri(s.prefix),p="(?:"+s.pattern+")";e.push(s),s.repeat&&(p+="(?:"+l+p+")*"),i+=p=s.optional?s.partial?l+"("+p+")?":"(?:"+l+"("+p+"))?":l+"("+p+")"}}var c=Ri(t.delimiter||"/"),d=i.slice(-c.length)===c;return r||(i=(d?i.slice(0,-c.length):i)+"(?:"+c+"(?=$))?"),i+=a?"$":r&&d?"":"(?="+c+"|$)",zi(new RegExp("^"+i,Oi(t)),e)}function Ji(n,e,t){return ji(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return zi(n,e)}(n,e):ji(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(Ji(n[a],e,t).source);return zi(new RegExp("(?:"+r.join("|")+")",Oi(t)),e)}(n,e,t):function(n,e,t){return Li(Pi(n,t),e,t)}(n,e,t)}Ci.parse=Ti,Ci.compile=Ai,Ci.tokensToFunction=Bi,Ci.tokensToRegExp=Ii;var qi=Object.create(null);function Fi(n,e,t){e=e||{};try{var r=qi[n]||(qi[n]=Ci.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ui(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=ti({},n)).params;return i&&"object"==typeof i&&(a.params=ti({},i)),a}if(!a.path&&a.params&&e){(a=ti({},a))._normalized=!0;var o=ti(ti({},e.params),a.params);if(e.name)a.name=e.name,a.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;a.path=Fi(s,o,e.path)}else 0;return a}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),p=e&&e.path||"/",c=l.path?Si(l.path,p,t||a.append):p,d=function(n,e,t){void 0===e&&(e={});var r,a=t||pi;try{r=a(n||"")}catch(n){r={}}for(var i in e){var o=e[i];r[i]=Array.isArray(o)?o.map(li):li(o)}return r}(l.query,a.query,r&&r.options.parseQuery),g=a.hash||l.hash;return g&&"#"!==g.charAt(0)&&(g="#"+g),{_normalized:!0,path:c,query:d,hash:g}}var Ni,Hi=function(){},Vi={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),i=a.location,o=a.route,s=a.href,l={},p=t.options.linkActiveClass,c=t.options.linkExactActiveClass,d=null==p?"router-link-active":p,g=null==c?"router-link-exact-active":c,u=null==this.activeClass?d:this.activeClass,m=null==this.exactActiveClass?g:this.exactActiveClass,b=o.redirectedFrom?gi(null,Ui(o.redirectedFrom),null,t):o;l[m]=hi(r,b,this.exactPath),l[u]=this.exact||this.exactPath?l[m]:function(n,e){return 0===n.path.replace(di,"/").indexOf(e.path.replace(di,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,b);var f=l[m]?this.ariaCurrentValue:null,h=function(n){$i(n)&&(e.replace?t.replace(i,Hi):t.push(i,Hi))},v={click:$i};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=h})):v[this.event]=h;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:h,isActive:l[u],isExactActive:l[m]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=v,y.attrs={href:s,"aria-current":f};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var S=w.data=ti({},w.data);for(var k in S.on=S.on||{},S.on){var j=S.on[k];k in v&&(S.on[k]=Array.isArray(j)?j:[j])}for(var C in v)C in S.on?S.on[C].push(v[C]):S.on[C]=h;var T=w.data.attrs=ti({},w.data.attrs);T.href=s,T["aria-current"]=f}else y.on=v}return n(this.tag,y,this.$slots.default)}};function $i(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Wi="undefined"!=typeof window;function Xi(n,e,t,r,a){var i=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,i,o){var s=a.path,l=a.name;0;var p=a.pathToRegexpOptions||{},c=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ki(e.path+"/"+n)}(s,i,p.strict);"boolean"==typeof a.caseSensitive&&(p.sensitive=a.caseSensitive);var d={path:c,regex:Gi(c,p),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var i=o?ki(o+"/"+a.path):void 0;n(e,t,r,a,d,i)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==a.alias)for(var g=Array.isArray(a.alias)?a.alias:[a.alias],u=0;u<g.length;++u){0;var m={path:g[u],children:a.children};n(e,t,r,m,i,d.path||"/")}l&&(r[l]||(r[l]=d))}(i,o,s,n,a)}));for(var l=0,p=i.length;l<p;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),p--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Gi(n,e){return Ci(n,[],e)}function Qi(n,e){var t=Xi(n),r=t.pathList,a=t.pathMap,i=t.nameMap;function o(n,t,o){var s=Ui(n,t,!1,e),p=s.name;if(p){var c=i[p];if(!c)return l(null,s);var d=c.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var g in t.params)!(g in s.params)&&d.indexOf(g)>-1&&(s.params[g]=t.params[g]);return s.path=Fi(c.path,s.params),l(c,s,o)}if(s.path){s.params={};for(var u=0;u<r.length;u++){var m=r[u],b=a[m];if(Yi(b.regex,s.path,s.params))return l(b,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(gi(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,p=s.name,c=s.path,d=t.query,g=t.hash,u=t.params;if(d=s.hasOwnProperty("query")?s.query:d,g=s.hasOwnProperty("hash")?s.hash:g,u=s.hasOwnProperty("params")?s.params:u,p){i[p];return o({_normalized:!0,name:p,query:d,hash:g,params:u},void 0,t)}if(c){var m=function(n,e){return Si(n,e.parent?e.parent.path:"/",!0)}(c,n);return o({_normalized:!0,path:Fi(m,u),query:d,hash:g},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:Fi(t,e.params)});if(r){var a=r.matched,i=a[a.length-1];return e.params=r.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):gi(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Xi([e||n],r,a,i,t),t&&t.alias.length&&Xi(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,i,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){Xi(n,r,a,i)}}}function Yi(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,i=r.length;a<i;++a){var o=n.keys[a-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[a]?si(r[a]):r[a])}return!0}var Zi=Wi&&window.performance&&window.performance.now?window.performance:Date;function Ki(){return Zi.now().toFixed(3)}var no=Ki();function eo(){return no}function to(n){return no=n}var ro=Object.create(null);function ao(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ti({},window.history.state);return t.key=eo(),window.history.replaceState(t,"",e),window.addEventListener("popstate",so),function(){window.removeEventListener("popstate",so)}}function io(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var i=function(){var n=eo();if(n)return ro[n]}(),o=a.call(n,e,t,r?i:null);o&&("function"==typeof o.then?o.then((function(n){uo(n,i)})).catch((function(n){0})):uo(o,i))}))}}function oo(){var n=eo();n&&(ro[n]={x:window.pageXOffset,y:window.pageYOffset})}function so(n){oo(),n.state&&n.state.key&&to(n.state.key)}function lo(n){return co(n.x)||co(n.y)}function po(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var go=/^#\d/;function uo(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=go.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,i={x:co((t=i).x)?t.x:0,y:co(t.y)?t.y:0})}else lo(n)&&(e=po(n))}else r&&lo(n)&&(e=po(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var mo,bo=Wi&&((-1===(mo=window.navigator.userAgent).indexOf("Android 2.")&&-1===mo.indexOf("Android 4.0")||-1===mo.indexOf("Mobile Safari")||-1!==mo.indexOf("Chrome")||-1!==mo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function fo(n,e){oo();var t=window.history;try{if(e){var r=ti({},t.state);r.key=eo(),t.replaceState(r,"",n)}else t.pushState({key:to(Ki())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function ho(n){fo(n,!0)}var vo={redirected:2,aborted:4,cancelled:8,duplicated:16};function yo(n,e){return wo(n,e,vo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return So.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xo(n,e){return wo(n,e,vo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function wo(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var So=["params","query","hash"];function ko(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function jo(n,e){return ko(n)&&n._isRouter&&(null==e||n.type===e)}function Co(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}function To(n){return function(e,t,r){var a=!1,i=0,o=null;Ao(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,i++;var l,p=Eo((function(e){var a;((a=e).__esModule||Io&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ni.extend(e),t.components[s]=e,--i<=0&&r()})),c=Eo((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=ko(n)?n:new Error(e),r(o))}));try{l=n(p,c)}catch(n){c(n)}if(l)if("function"==typeof l.then)l.then(p,c);else{var d=l.component;d&&"function"==typeof d.then&&d.then(p,c)}}})),a||r()}}function Ao(n,e){return Bo(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Bo(n){return Array.prototype.concat.apply([],n)}var Io="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Eo(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Po=function(n,e){this.router=n,this.base=function(n){if(!n)if(Wi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=mi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function _o(n,e,t,r){var a=Ao(n,(function(n,r,a,i){var o=function(n,e){"function"!=typeof n&&(n=Ni.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,a,i)})):t(o,r,a,i)}));return Bo(r?a.reverse():a)}function Mo(n,e){if(e)return function(){return n.apply(e,arguments)}}Po.prototype.listen=function(n){this.cb=n},Po.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Po.prototype.onError=function(n){this.errorCbs.push(n)},Po.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,i)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(jo(n,vo.redirected)&&i===mi||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Po.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var i,o,s=function(n){!jo(n)&&ko(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,p=a.matched.length-1;if(hi(n,a)&&l===p&&n.matched[l]===a.matched[p])return this.ensureURL(),n.hash&&io(this.router,a,n,!1),s(((o=wo(i=a,n,vo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var c=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=c.updated,g=c.deactivated,u=c.activated,m=[].concat(function(n){return _o(n,"beforeRouteLeave",Mo,!0)}(g),this.router.beforeHooks,function(n){return _o(n,"beforeRouteUpdate",Mo)}(d),u.map((function(n){return n.beforeEnter})),To(u)),b=function(e,t){if(r.pending!==n)return s(xo(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return wo(n,e,vo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):ko(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(yo(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Co(m,b,(function(){Co(function(n){return _o(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,i){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,r)}))}(u).concat(r.router.resolveHooks),b,(function(){if(r.pending!==n)return s(xo(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){yi(n)}))}))}))},Po.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Po.prototype.setupListeners=function(){},Po.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=mi,this.pending=null};var Ro=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Do(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=bo&&t;r&&this.listeners.push(ao());var a=function(){var t=n.current,a=Do(n.base);n.current===mi&&a===n._startLocation||n.transitionTo(a,(function(n){r&&io(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){fo(ki(r.base+n.fullPath)),io(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){ho(ki(r.base+n.fullPath)),io(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Do(this.base)!==this.current.fullPath){var e=ki(this.base+this.current.fullPath);n?fo(e):ho(e)}},e.prototype.getCurrentLocation=function(){return Do(this.base)},e}(Po);function Do(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ki(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var zo=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Do(n);if(!/^\/#/.test(e))return window.location.replace(ki(n+"/#"+e)),!0}(this.base)||Oo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=bo&&e;t&&this.listeners.push(ao());var r=function(){var e=n.current;Oo()&&n.transitionTo(Lo(),(function(r){t&&io(n.router,r,e,!0),bo||Fo(r.fullPath)}))},a=bo?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){qo(n.fullPath),io(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Fo(n.fullPath),io(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Lo()!==e&&(n?qo(e):Fo(e))},e.prototype.getCurrentLocation=function(){return Lo()},e}(Po);function Oo(){var n=Lo();return"/"===n.charAt(0)||(Fo("/"+n),!1)}function Lo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Jo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function qo(n){bo?fo(Jo(n)):window.location.hash=n}function Fo(n){bo?ho(Jo(n)):window.location.replace(Jo(n))}var Uo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){jo(n,vo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Po),No=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Qi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!bo&&!1!==n.fallback,this.fallback&&(e="hash"),Wi||(e="abstract"),this.mode=e,e){case"history":this.history=new Ro(this,n.base);break;case"hash":this.history=new zo(this,n.base,this.fallback);break;case"abstract":this.history=new Uo(this,n.base);break;default:0}},Ho={currentRoute:{configurable:!0}};No.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ho.currentRoute.get=function(){return this.history&&this.history.current},No.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Ro||t instanceof zo){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;bo&&a&&"fullPath"in n&&io(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},No.prototype.beforeEach=function(n){return $o(this.beforeHooks,n)},No.prototype.beforeResolve=function(n){return $o(this.resolveHooks,n)},No.prototype.afterEach=function(n){return $o(this.afterHooks,n)},No.prototype.onReady=function(n,e){this.history.onReady(n,e)},No.prototype.onError=function(n){this.history.onError(n)},No.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},No.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},No.prototype.go=function(n){this.history.go(n)},No.prototype.back=function(){this.go(-1)},No.prototype.forward=function(){this.go(1)},No.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},No.prototype.resolve=function(n,e,t){var r=Ui(n,e=e||this.history.current,t,this),a=this.match(r,e),i=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ki(n+"/"+r):r}(this.history.base,i,this.mode),normalizedTo:r,resolved:a}},No.prototype.getRoutes=function(){return this.matcher.getRoutes()},No.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},No.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(No.prototype,Ho);var Vo=No;function $o(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}No.install=function n(e){if(!n.installed||Ni!==e){n.installed=!0,Ni=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",xi),e.component("RouterLink",Vi);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},No.version="3.6.5",No.isNavigationFailure=jo,No.NavigationFailureType=vo,No.START_LOCATION=mi,Wi&&window.Vue&&window.Vue.use(No);t(107);t(129),t(16);var Wo={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,342)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,341))},Xo={"v-4f55c4ec":()=>t.e(5).then(t.bind(null,343)),"v-55b8f14c":()=>t.e(7).then(t.bind(null,344)),"v-7f7df8a0":()=>t.e(9).then(t.bind(null,345)),"v-b55d218c":()=>t.e(6).then(t.bind(null,346)),"v-ad888434":()=>t.e(8).then(t.bind(null,347)),"v-cbe3e38e":()=>t.e(10).then(t.bind(null,348)),"v-4c6b8695":()=>t.e(11).then(t.bind(null,349)),"v-0a3e806a":()=>t.e(12).then(t.bind(null,350)),"v-a011e00e":()=>t.e(13).then(t.bind(null,351)),"v-b5170794":()=>t.e(14).then(t.bind(null,352)),"v-359ace56":()=>t.e(15).then(t.bind(null,353)),"v-0ef44af3":()=>t.e(16).then(t.bind(null,354)),"v-ec12120a":()=>t.e(17).then(t.bind(null,355)),"v-a873abde":()=>t.e(19).then(t.bind(null,356)),"v-6447466a":()=>t.e(18).then(t.bind(null,357)),"v-bc19b5fc":()=>t.e(20).then(t.bind(null,358)),"v-464c8937":()=>t.e(21).then(t.bind(null,359)),"v-12c0ceb0":()=>t.e(22).then(t.bind(null,360)),"v-32803cf9":()=>t.e(24).then(t.bind(null,361)),"v-1a5daf91":()=>t.e(23).then(t.bind(null,362)),"v-26a96ffb":()=>t.e(25).then(t.bind(null,363)),"v-77b7c09e":()=>t.e(26).then(t.bind(null,364)),"v-60d8b9e6":()=>t.e(27).then(t.bind(null,365)),"v-8f04575e":()=>t.e(29).then(t.bind(null,366)),"v-6cd7991c":()=>t.e(28).then(t.bind(null,367)),"v-11054c30":()=>t.e(30).then(t.bind(null,368)),"v-5bd37d3c":()=>t.e(31).then(t.bind(null,369)),"v-ca7af3d6":()=>t.e(32).then(t.bind(null,370)),"v-4d1c67ea":()=>t.e(33).then(t.bind(null,371)),"v-9a6a8e22":()=>t.e(35).then(t.bind(null,372)),"v-b009604a":()=>t.e(34).then(t.bind(null,373)),"v-ab53d220":()=>t.e(36).then(t.bind(null,374)),"v-44814011":()=>t.e(37).then(t.bind(null,375)),"v-1eb14240":()=>t.e(38).then(t.bind(null,376)),"v-5be0fc7d":()=>t.e(40).then(t.bind(null,377)),"v-35ee501b":()=>t.e(39).then(t.bind(null,378)),"v-361cf50d":()=>t.e(41).then(t.bind(null,379)),"v-f86530fc":()=>t.e(43).then(t.bind(null,380)),"v-c6474816":()=>t.e(42).then(t.bind(null,381)),"v-443c98b2":()=>t.e(44).then(t.bind(null,382)),"v-cab5a862":()=>t.e(45).then(t.bind(null,383)),"v-06bc9c3d":()=>t.e(46).then(t.bind(null,384)),"v-059d2e9c":()=>t.e(47).then(t.bind(null,385)),"v-3cee8b95":()=>t.e(48).then(t.bind(null,386)),"v-63e74542":()=>t.e(49).then(t.bind(null,387)),"v-27e9310e":()=>t.e(51).then(t.bind(null,388)),"v-3caac053":()=>t.e(50).then(t.bind(null,389)),"v-515c830f":()=>t.e(52).then(t.bind(null,390)),"v-2460a6bd":()=>t.e(53).then(t.bind(null,391)),"v-72547bfe":()=>t.e(54).then(t.bind(null,392)),"v-3a1ac617":()=>t.e(56).then(t.bind(null,393)),"v-30e174be":()=>t.e(55).then(t.bind(null,394)),"v-9761e2fa":()=>t.e(59).then(t.bind(null,395)),"v-94543dd8":()=>t.e(57).then(t.bind(null,396)),"v-6078057e":()=>t.e(58).then(t.bind(null,397)),"v-a6563758":()=>t.e(60).then(t.bind(null,398)),"v-2541fab0":()=>t.e(61).then(t.bind(null,399)),"v-033e2880":()=>t.e(63).then(t.bind(null,400)),"v-65fa0e1c":()=>t.e(62).then(t.bind(null,401)),"v-1a8a1886":()=>t.e(64).then(t.bind(null,402)),"v-07a8e71a":()=>t.e(65).then(t.bind(null,403)),"v-7765fe32":()=>t.e(67).then(t.bind(null,404)),"v-3d0b52f2":()=>t.e(66).then(t.bind(null,405)),"v-3b93de07":()=>t.e(68).then(t.bind(null,406)),"v-fe19e418":()=>t.e(69).then(t.bind(null,407))};function Go(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Qo=/-(\w)/g,Yo=Go(n=>n.replace(Qo,(n,e)=>e?e.toUpperCase():"")),Zo=/\B([A-Z])/g,Ko=Go(n=>n.replace(Zo,"-$1").toLowerCase()),ns=Go(n=>n.charAt(0).toUpperCase()+n.slice(1));function es(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(ns(Yo(e))):n(ns(e))||n(Ko(e))}const ts=Object.assign({},Wo,Xo),rs=n=>ts[n],as=n=>Xo[n],is=n=>Wo[n],os=n=>Wt.component(n);function ss(n){return es(as,n)}function ls(n){return es(is,n)}function ps(n){return es(rs,n)}function cs(n){return es(os,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ps(n)){const e=await ps(n)();Wt.component(n,e.default)}}))}function gs(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var us=t(92),ms=t.n(us),bs=t(93),fs=t.n(bs),hs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=ys(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ms()([{name:"description",content:this.$description}],n,this.siteMeta,ws)},updateCanonicalLink(){vs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",ys(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xs(null,this.currentMetaTags),vs()}};function vs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function ys(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ws(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Ss=t(52),ks={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Ss)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},js=t(24),Cs=t.n(js),Ts={mounted(){Cs.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Wt.component(n.name)||Cs.a.start(),t()}),this.$router.afterEach(()=>{Cs.a.done(),this.isSidebarOpen=!1})}};t(241),t(242);class As{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Bs={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new As).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Is={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Es={},Ps=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},_s=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Is[n]},Ms=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,i=e.children;a.appendChild(n(t,r,i))})),a},Rs=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},Ds=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Ps(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,i=[eval][0](a);return i.template=e,i}(s.js,s.html);var l=_s("vue");return s.jsLib.unshift(l),s},zs=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Os=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ls(){var n=Rs(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Rs(n,"vuepress-plugin-demo-block__code"),t=Rs(n,"vuepress-plugin-demo-block__display"),r=Rs(n,"vuepress-plugin-demo-block__footer"),a=Rs(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,p="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),i={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Os(n),htmlTpl:Ps("")},o=_s("react"),s=_s("reactDOM");return i.jsLib.unshift(o,s),i}(i,o):"vanilla"===s?zs(i,o):Ds(i,o),c=Ms("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(c),c.addEventListener("click",Js.bind(null,c,l,e,r)),_s("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,i=n.cssLib,o=a.concat(i).concat(_s("cssLib")).concat(_s("jsLib")).join(",");return Ms("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(p)),_s("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(_s("jsLib")).join(";"),css_external:i.concat(_s("cssLib")).join(";"),layout:_s("codepenLayout"),js_pre_processor:_s("codepenJsProcessor"),editors:_s("codepenEditors")});return Ms("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(p)),void 0!==o.horizontal?o.horizontal:_s("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(p.css&&function(n){if(!Es[n]){var e=Ms("style",{innerHTML:n});document.body.appendChild(e),Es[n]=!0}}(p.css),"react"===s)ReactDOM.render(React.createElement(p.js),a);else if("vue"===s){var g=(new(Vue.extend(p.script))).$mount();a.appendChild(g.$el)}else"vanilla"===s&&(a.innerHTML=p.html,new Function("return (function(){".concat(p.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ls()}),300)}function Js(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var qs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ls()},updated:function(){Ls()}},Fs="auto",Us="zoom-in",Ns="zoom-out",Hs="grab",Vs="move";function $s(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Ws(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Xs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Gs(n,e,t){!function(n){var e=Qs,t=Ys;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var i in e)t&&(a[i]=r[i]||""),r[i]=e[i];return a}var Qs="transition",Ys="transform",Zs="transform",Ks="transitionend";var nl=function(){},el={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:nl,onClose:nl,onGrab:nl,onMove:nl,onRelease:nl,onBeforeOpen:nl,onBeforeClose:nl,onBeforeGrab:nl,onBeforeRelease:nl,onImageLoading:nl,onImageLoaded:nl},tl={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),al(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(a)>=i||Math.abs(r)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(rl(n)&&!al(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){rl(n)&&!al(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function rl(n){return 0===n.button}function al(n){return n.metaKey||n.ctrlKey}var il={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Gs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),$s(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Gs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ol="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},sl=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),ll=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},pl={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Xs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Hs:Ns,transition:Zs+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Gs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Gs(this.el,{transform:"none"})},grab:function(n,e,t){var r=cl(),a=r.x-n,i=r.y-e;Gs(this.el,{cursor:Vs,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=cl(),a=r.x-n,i=r.y-e;Gs(this.el,{transition:Zs,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Gs(this.el,this.styleClose)},restoreOpenStyle:function(){Gs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,i=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":ol(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=cl(),p={x:l.x-o,y:l.y-s},c=p.x/o,d=p.y/s,g=i+Math.min(c,d);if(a&&"string"==typeof a){var u=t||this.el.naturalWidth,m=e||this.el.naturalHeight,b=parseFloat(a)*u/(100*this.rect.width),f=parseFloat(a)*m/(100*this.rect.height);if(g>b||g>f)return{x:b,y:f}}return{x:g,y:g}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function dl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){$s(n,r,e[r],t)}))}var gl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(pl),this.overlay=Object.create(il),this.handler=Object.create(tl),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ll({},el,e),this.overlay.init(this),this.handler.init(this)}return sl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Us,$s(n,"click",this.handler.click),this.options.preloadImage&&Ws(Xs(n)));return this}},{key:"config",value:function(n){return n?(ll(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),Ws(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),$s(document,"scroll",this.handler.scroll),$s(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&$s(window,"resize",this.handler.resizeWindow);var i=function n(){$s(r,Ks,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&dl(document,e.handler,!0),t(r)};return $s(r,Ks,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Fs,this.overlay.fadeOut(),this.target.zoomOut(),$s(document,"scroll",this.handler.scroll,!1),$s(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&$s(window,"resize",this.handler.resizeWindow,!1);var r=function r(){$s(t,Ks,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&dl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return $s(t,Ks,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var i=function n(){$s(a,Ks,n,!1),r(a)};return $s(a,Ks,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Vs,this.target.move(n,e,t);var a=this.target.el,i=function n(){$s(a,Ks,n,!1),r(a)};return $s(a,Ks,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Fs,this.target.restoreOpenStyle();var r=function r(){$s(t,Ks,r,!1),n.lock=!1,n.released=!0,e(t)};return $s(t,Ks,r),this}}}]),n}();const ul=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ml=Number("500");class bl{constructor(){this.instance=new gl(ul)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ml){setTimeout(()=>this.update(n),e)}}var fl=[hs,ks,Ts,Bs,qs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new bl,this.$vuepress.zooming.updateDelay()}}],hl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return gs("layout",n),Wt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vl=t(4),yl=Object(vl.a)(hl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(yl,"mixins",fl);const xl=[{name:"v-4f55c4ec",path:"/pages/9d3091/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-4f55c4ec").then(t)}},{path:"/pages/9d3091/index.html",redirect:"/pages/9d3091/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/01.Spring概述.html",redirect:"/pages/9d3091/"},{name:"v-55b8f14c",path:"/pages/dbf521/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-55b8f14c").then(t)}},{path:"/pages/dbf521/index.html",redirect:"/pages/dbf521/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/22.SpringBoot基本原理.html",redirect:"/pages/dbf521/"},{name:"v-7f7df8a0",path:"/pages/9e0b67/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-7f7df8a0").then(t)}},{path:"/pages/9e0b67/index.html",redirect:"/pages/9e0b67/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/",redirect:"/pages/9e0b67/"},{name:"v-b55d218c",path:"/pages/430f53/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-b55d218c").then(t)}},{path:"/pages/430f53/index.html",redirect:"/pages/430f53/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/21.SpringBoot知识图谱.html",redirect:"/pages/430f53/"},{name:"v-ad888434",path:"/pages/db33b0/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-ad888434").then(t)}},{path:"/pages/db33b0/index.html",redirect:"/pages/db33b0/"},{path:"/01.Java/13.框架/01.Spring/00.Spring综合/99.Spring面试.html",redirect:"/pages/db33b0/"},{name:"v-cbe3e38e",path:"/pages/68097d/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-cbe3e38e").then(t)}},{path:"/pages/68097d/index.html",redirect:"/pages/68097d/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/01.SpringBean.html",redirect:"/pages/68097d/"},{name:"v-4c6b8695",path:"/pages/915530/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-4c6b8695").then(t)}},{path:"/pages/915530/index.html",redirect:"/pages/915530/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/02.SpringIoC.html",redirect:"/pages/915530/"},{name:"v-0a3e806a",path:"/pages/9a6f6b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-0a3e806a").then(t)}},{path:"/pages/9a6f6b/index.html",redirect:"/pages/9a6f6b/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/03.Spring依赖查找.html",redirect:"/pages/9a6f6b/"},{name:"v-a011e00e",path:"/pages/f61a1c/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-a011e00e").then(t)}},{path:"/pages/f61a1c/index.html",redirect:"/pages/f61a1c/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/04.Spring依赖注入.html",redirect:"/pages/f61a1c/"},{name:"v-b5170794",path:"/pages/a5f257/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-b5170794").then(t)}},{path:"/pages/a5f257/index.html",redirect:"/pages/a5f257/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/05.SpringIoC依赖来源.html",redirect:"/pages/a5f257/"},{name:"v-359ace56",path:"/pages/8289f5/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-359ace56").then(t)}},{path:"/pages/8289f5/index.html",redirect:"/pages/8289f5/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/06.SpringBean作用域.html",redirect:"/pages/8289f5/"},{name:"v-0ef44af3",path:"/pages/4ab176/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-0ef44af3").then(t)}},{path:"/pages/4ab176/index.html",redirect:"/pages/4ab176/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/07.SpringBean生命周期.html",redirect:"/pages/4ab176/"},{name:"v-ec12120a",path:"/pages/55f315/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-ec12120a").then(t)}},{path:"/pages/55f315/index.html",redirect:"/pages/55f315/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/08.Spring配置元数据.html",redirect:"/pages/55f315/"},{name:"v-a873abde",path:"/pages/53aedb/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-a873abde").then(t)}},{path:"/pages/53aedb/index.html",redirect:"/pages/53aedb/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/10.SpringAop.html",redirect:"/pages/53aedb/"},{name:"v-6447466a",path:"/pages/ad472e/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-6447466a").then(t)}},{path:"/pages/ad472e/index.html",redirect:"/pages/ad472e/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/09.Spring应用上下文生命周期.html",redirect:"/pages/ad472e/"},{name:"v-bc19b5fc",path:"/pages/a1549f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-bc19b5fc").then(t)}},{path:"/pages/a1549f/index.html",redirect:"/pages/a1549f/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/20.Spring资源管理.html",redirect:"/pages/a1549f/"},{name:"v-464c8937",path:"/pages/fe6aad/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-464c8937").then(t)}},{path:"/pages/fe6aad/index.html",redirect:"/pages/fe6aad/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/21.Spring校验.html",redirect:"/pages/fe6aad/"},{name:"v-12c0ceb0",path:"/pages/267b4c/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-12c0ceb0").then(t)}},{path:"/pages/267b4c/index.html",redirect:"/pages/267b4c/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/22.Spring数据绑定.html",redirect:"/pages/267b4c/"},{name:"v-32803cf9",path:"/pages/1f743f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-32803cf9").then(t)}},{path:"/pages/1f743f/index.html",redirect:"/pages/1f743f/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/24.SpringEL.html",redirect:"/pages/1f743f/"},{name:"v-1a5daf91",path:"/pages/6662dc/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1a5daf91").then(t)}},{path:"/pages/6662dc/index.html",redirect:"/pages/6662dc/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/23.Spring类型转换.html",redirect:"/pages/6662dc/"},{name:"v-26a96ffb",path:"/pages/cca414/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-26a96ffb").then(t)}},{path:"/pages/cca414/index.html",redirect:"/pages/cca414/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/25.Spring事件.html",redirect:"/pages/cca414/"},{name:"v-77b7c09e",path:"/pages/b5b8ad/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-77b7c09e").then(t)}},{path:"/pages/b5b8ad/index.html",redirect:"/pages/b5b8ad/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/26.Spring国际化.html",redirect:"/pages/b5b8ad/"},{name:"v-60d8b9e6",path:"/pages/175cbd/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-60d8b9e6").then(t)}},{path:"/pages/175cbd/index.html",redirect:"/pages/175cbd/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/27.Spring泛型处理.html",redirect:"/pages/175cbd/"},{name:"v-8f04575e",path:"/pages/03d838/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-8f04575e").then(t)}},{path:"/pages/03d838/index.html",redirect:"/pages/03d838/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/29.SpringEnvironment抽象.html",redirect:"/pages/03d838/"},{name:"v-6cd7991c",path:"/pages/b6556f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-6cd7991c").then(t)}},{path:"/pages/b6556f/index.html",redirect:"/pages/b6556f/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/28.Spring注解.html",redirect:"/pages/b6556f/"},{name:"v-11054c30",path:"/pages/950e4d/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-11054c30").then(t)}},{path:"/pages/950e4d/index.html",redirect:"/pages/950e4d/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/31.SpringBoot之快速入门.html",redirect:"/pages/950e4d/"},{name:"v-5bd37d3c",path:"/pages/0fb992/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5bd37d3c").then(t)}},{path:"/pages/0fb992/index.html",redirect:"/pages/0fb992/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/32.SpringBoot之属性加载.html",redirect:"/pages/0fb992/"},{name:"v-ca7af3d6",path:"/pages/cb598e/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-ca7af3d6").then(t)}},{path:"/pages/cb598e/index.html",redirect:"/pages/cb598e/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/33.SpringBoot之Profile.html",redirect:"/pages/cb598e/"},{name:"v-4d1c67ea",path:"/pages/5e7c20/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-4d1c67ea").then(t)}},{path:"/pages/5e7c20/index.html",redirect:"/pages/5e7c20/"},{path:"/01.Java/13.框架/01.Spring/01.Spring核心/",redirect:"/pages/5e7c20/"},{name:"v-9a6a8e22",path:"/pages/cf19fd/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-9a6a8e22").then(t)}},{path:"/pages/cf19fd/index.html",redirect:"/pages/cf19fd/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/02.Spring之JDBC.html",redirect:"/pages/cf19fd/"},{name:"v-b009604a",path:"/pages/1b774c/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-b009604a").then(t)}},{path:"/pages/1b774c/index.html",redirect:"/pages/1b774c/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/01.Spring之数据源.html",redirect:"/pages/1b774c/"},{name:"v-ab53d220",path:"/pages/128c54/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-ab53d220").then(t)}},{path:"/pages/128c54/index.html",redirect:"/pages/128c54/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/03.Spring之事务.html",redirect:"/pages/128c54/"},{name:"v-44814011",path:"/pages/a03d7b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-44814011").then(t)}},{path:"/pages/a03d7b/index.html",redirect:"/pages/a03d7b/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/04.Spring之JPA.html",redirect:"/pages/a03d7b/"},{name:"v-1eb14240",path:"/pages/88219e/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1eb14240").then(t)}},{path:"/pages/88219e/index.html",redirect:"/pages/88219e/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/10.Spring集成Mybatis.html",redirect:"/pages/88219e/"},{name:"v-5be0fc7d",path:"/pages/65e4a2/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-5be0fc7d").then(t)}},{path:"/pages/65e4a2/index.html",redirect:"/pages/65e4a2/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/21.Spring访问Redis.html",redirect:"/pages/65e4a2/"},{name:"v-35ee501b",path:"/pages/191cdb/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-35ee501b").then(t)}},{path:"/pages/191cdb/index.html",redirect:"/pages/191cdb/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/20.SpringData综合.html",redirect:"/pages/191cdb/"},{name:"v-361cf50d",path:"/pages/db2a41/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-361cf50d").then(t)}},{path:"/pages/db2a41/index.html",redirect:"/pages/db2a41/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/22.Spring访问MongoDB.html",redirect:"/pages/db2a41/"},{name:"v-f86530fc",path:"/pages/b912d1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-f86530fc").then(t)}},{path:"/pages/b912d1/index.html",redirect:"/pages/b912d1/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/",redirect:"/pages/b912d1/"},{name:"v-c6474816",path:"/pages/fac14c/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-c6474816").then(t)}},{path:"/pages/fac14c/index.html",redirect:"/pages/fac14c/"},{path:"/01.Java/13.框架/01.Spring/02.Spring数据/23.Spring访问Elasticsearch.html",redirect:"/pages/fac14c/"},{name:"v-443c98b2",path:"/pages/65351b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-443c98b2").then(t)}},{path:"/pages/65351b/index.html",redirect:"/pages/65351b/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/01.SpringWeb综述.html",redirect:"/pages/65351b/"},{name:"v-cab5a862",path:"/pages/5d002f/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-cab5a862").then(t)}},{path:"/pages/5d002f/index.html",redirect:"/pages/5d002f/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/02.SpringWeb应用.html",redirect:"/pages/5d002f/"},{name:"v-06bc9c3d",path:"/pages/20287b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-06bc9c3d").then(t)}},{path:"/pages/20287b/index.html",redirect:"/pages/20287b/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/03.DispatcherServlet.html",redirect:"/pages/20287b/"},{name:"v-059d2e9c",path:"/pages/4a164d/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-059d2e9c").then(t)}},{path:"/pages/4a164d/index.html",redirect:"/pages/4a164d/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/04.Spring过滤器.html",redirect:"/pages/4a164d/"},{name:"v-3cee8b95",path:"/pages/1d2954/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-3cee8b95").then(t)}},{path:"/pages/1d2954/index.html",redirect:"/pages/1d2954/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/05.Spring跨域.html",redirect:"/pages/1d2954/"},{name:"v-63e74542",path:"/pages/251e31/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-63e74542").then(t)}},{path:"/pages/251e31/index.html",redirect:"/pages/251e31/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/06.Spring视图.html",redirect:"/pages/251e31/"},{name:"v-27e9310e",path:"/pages/e2586a/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-27e9310e").then(t)}},{path:"/pages/e2586a/index.html",redirect:"/pages/e2586a/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/",redirect:"/pages/e2586a/"},{name:"v-3caac053",path:"/pages/ad0516/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-3caac053").then(t)}},{path:"/pages/ad0516/index.html",redirect:"/pages/ad0516/"},{path:"/01.Java/13.框架/01.Spring/03.SpringWeb/21.SpringBoot之应用EasyUI.html",redirect:"/pages/ad0516/"},{name:"v-515c830f",path:"/pages/92add2/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-515c830f").then(t)}},{path:"/pages/92add2/index.html",redirect:"/pages/92add2/"},{path:"/01.Java/13.框架/01.Spring/04.SpringIO/01.SpringBoot之异步请求.html",redirect:"/pages/92add2/"},{name:"v-2460a6bd",path:"/pages/676725/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-2460a6bd").then(t)}},{path:"/pages/676725/index.html",redirect:"/pages/676725/"},{path:"/01.Java/13.框架/01.Spring/04.SpringIO/02.SpringBoot之Json.html",redirect:"/pages/676725/"},{name:"v-72547bfe",path:"/pages/2586f1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-72547bfe").then(t)}},{path:"/pages/2586f1/index.html",redirect:"/pages/2586f1/"},{path:"/01.Java/13.框架/01.Spring/04.SpringIO/03.SpringBoot之邮件.html",redirect:"/pages/2586f1/"},{name:"v-3a1ac617",path:"/pages/a311cb/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-3a1ac617").then(t)}},{path:"/pages/a311cb/index.html",redirect:"/pages/a311cb/"},{path:"/01.Java/13.框架/01.Spring/05.Spring集成/01.Spring集成缓存.html",redirect:"/pages/a311cb/"},{name:"v-30e174be",path:"/pages/56581b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-30e174be").then(t)}},{path:"/pages/56581b/index.html",redirect:"/pages/56581b/"},{path:"/01.Java/13.框架/01.Spring/04.SpringIO/",redirect:"/pages/56581b/"},{name:"v-9761e2fa",path:"/pages/d6025b/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-9761e2fa").then(t)}},{path:"/pages/d6025b/index.html",redirect:"/pages/d6025b/"},{path:"/01.Java/13.框架/01.Spring/05.Spring集成/",redirect:"/pages/d6025b/"},{name:"v-94543dd8",path:"/pages/a187f0/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-94543dd8").then(t)}},{path:"/pages/a187f0/index.html",redirect:"/pages/a187f0/"},{path:"/01.Java/13.框架/01.Spring/05.Spring集成/02.Spring集成调度器.html",redirect:"/pages/a187f0/"},{name:"v-6078057e",path:"/pages/274fd7/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-6078057e").then(t)}},{path:"/pages/274fd7/index.html",redirect:"/pages/274fd7/"},{path:"/01.Java/13.框架/01.Spring/05.Spring集成/03.Spring集成Dubbo.html",redirect:"/pages/274fd7/"},{name:"v-a6563758",path:"/pages/568352/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-a6563758").then(t)}},{path:"/pages/568352/index.html",redirect:"/pages/568352/"},{path:"/01.Java/13.框架/01.Spring/10.Spring安全/01.SpringBoot之安全快速入门.html",redirect:"/pages/568352/"},{name:"v-2541fab0",path:"/pages/752c6a/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-2541fab0").then(t)}},{path:"/pages/752c6a/index.html",redirect:"/pages/752c6a/"},{path:"/01.Java/13.框架/01.Spring/99.Spring其他/01.Spring4升级.html",redirect:"/pages/752c6a/"},{name:"v-033e2880",path:"/pages/c013cc/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-033e2880").then(t)}},{path:"/pages/c013cc/index.html",redirect:"/pages/c013cc/"},{path:"/01.Java/13.框架/01.Spring/99.Spring其他/22.SpringBoot之Actuator.html",redirect:"/pages/c013cc/"},{name:"v-65fa0e1c",path:"/pages/bac2ce/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-65fa0e1c").then(t)}},{path:"/pages/bac2ce/index.html",redirect:"/pages/bac2ce/"},{path:"/01.Java/13.框架/01.Spring/99.Spring其他/21.SpringBoot之banner.html",redirect:"/pages/bac2ce/"},{name:"v-1a8a1886",path:"/pages/6bb8c1/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-1a8a1886").then(t)}},{path:"/pages/6bb8c1/index.html",redirect:"/pages/6bb8c1/"},{path:"/01.Java/13.框架/01.Spring/99.Spring其他/",redirect:"/pages/6bb8c1/"},{name:"v-07a8e71a",path:"/pages/a1a3d3/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-07a8e71a").then(t)}},{path:"/pages/a1a3d3/index.html",redirect:"/pages/a1a3d3/"},{path:"/01.Java/13.框架/01.Spring/",redirect:"/pages/a1a3d3/"},{name:"v-7765fe32",path:"/categories/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-7765fe32").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-3d0b52f2",path:"/archives/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-3d0b52f2").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-3b93de07",path:"/tags/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-3b93de07").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-fe19e418",path:"/",component:yl,beforeEnter:(n,e,t)=>{ds("Layout","v-fe19e418").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:yl}],wl={title:"SPRING TUTORIAL",description:"💧 spring-tutorial 是一个 Spring 教程。",base:"/spring-tutorial/",headTags:[["link",{rel:"icon",href:"/spring-tutorial/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"wwads-cn-verify",content:"mxqWx62nfQQ9ocT4e5DzISHzOWyF4s"}],["script",{src:"https://cdn.wwads.cn/js/makemoney.js",type:"text/javascript"}]],pages:[{title:"Spring Framework 综述",frontmatter:{title:"Spring Framework 综述",date:"2019-11-22T10:46:02.000Z",order:1,categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring"],permalink:"/pages/9d3091/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/01.Spring%E6%A6%82%E8%BF%B0.html",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/01.Spring概述.md",key:"v-4f55c4ec",path:"/pages/9d3091/",headers:[{level:2,title:"Spring Framework 简介",slug:"spring-framework-简介",normalizedTitle:"spring framework 简介",charIndex:26},{level:2,title:"为什么使用 Spring",slug:"为什么使用-spring",normalizedTitle:"为什么使用 spring",charIndex:386},{level:2,title:"核心思想",slug:"核心思想",normalizedTitle:"核心思想",charIndex:1154},{level:3,title:"IoC",slug:"ioc",normalizedTitle:"ioc",charIndex:1179},{level:3,title:"Aop",slug:"aop",normalizedTitle:"aop",charIndex:1185},{level:2,title:"Spring 体系结构",slug:"spring-体系结构",normalizedTitle:"spring 体系结构",charIndex:2004},{level:3,title:"Core Container",slug:"core-container",normalizedTitle:"core container",charIndex:2138},{level:4,title:"BeanFactory",slug:"beanfactory",normalizedTitle:"beanfactory",charIndex:2167},{level:4,title:"ApplicationContext",slug:"applicationcontext",normalizedTitle:"applicationcontext",charIndex:2193},{level:3,title:"AOP and Instrumentation",slug:"aop-and-instrumentation",normalizedTitle:"aop and instrumentation",charIndex:2222},{level:3,title:"Messaging",slug:"messaging",normalizedTitle:"messaging",charIndex:2256},{level:3,title:"Data Access / Integaration",slug:"data-access-integaration",normalizedTitle:"data access / integaration",charIndex:2276},{level:3,title:"Web",slug:"web",normalizedTitle:"web",charIndex:2313},{level:3,title:"Test",slug:"test",normalizedTitle:"test",charIndex:2327},{level:2,title:"术语",slug:"术语",normalizedTitle:"术语",charIndex:2338}],headersStr:"Spring Framework 简介 为什么使用 Spring 核心思想 IoC Aop Spring 体系结构 Core Container BeanFactory ApplicationContext AOP and Instrumentation Messaging Data Access / Integaration Web Test 术语",content:'# Spring Framework 综述\n\n\n# Spring Framework 简介\n\nSpring Framework 是最受欢迎的企业级 Java 应用程序开发框架。用于构建企业级应用的轻量级、一站式解决方案。\n\n当谈论到大小和透明度时， Spring 是轻量级的。 Spring 框架的基础版本是在 2 MB 左右的。\n\nSpring 框架的核心特性可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。\n\nSpring Framework 设计理念如下：\n\n * 力争让选择无处不在\n * 体现海纳百川的精神\n * 保持后向兼容性\n * 专注 API 设计\n * 追求严苛的代码质量\n\n\n# 为什么使用 Spring\n\n下面列出的是使用 Spring 框架主要的好处：\n\n * Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。\n * Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只需要选择你需要的部分，而忽略剩余的那部分。\n * Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像几个 ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。\n * 测试一个用 Spring 编写的应用程序很容易，因为 environment-dependent 代码被放进了这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。\n * Spring 的 web 框架是一个设计良好的 web MVC 框架，它为 web 框架，比如 Structs 或者其他工程上的或者很少受欢迎的 web 框架，提供了一个很好的供替代的选择。\n * 为将特定技术的异常（例如，由 JDBC、Hibernate，或者 JDO 抛出的异常）翻译成一致的， Spring 提供了一个方便的 API，而这些都是未经检验的异常。\n * 轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。\n * Spring 提供了一个一致的事务管理界面，该界面可以缩小成一个本地事务（例如，使用一个单一的数据库）和扩展成一个全局事务（例如，使用 JTA）。\n\n\n# 核心思想\n\nSpring 最核心的两个技术思想是：IoC 和 Aop\n\n\n# IoC\n\nIoC 即 Inversion of Control ，意为控制反转。\n\nSpring 最认同的技术是控制反转的**依赖注入（DI）**模式。控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。\n\n当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能的独立于其他的 Java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入（或者有时被称为配线）有助于将这些类粘合在一起，并且在同一时间让它们保持独立。\n\n到底什么是依赖注入？让我们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 A 依赖于类 B。现在，让我们看一看第二部分，注入。所有这一切都意味着类 B 将通过 IoC 被注入到类 A 中。\n\n依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法 post-construction。由于依赖注入是 Spring 框架的核心部分，所以我将在一个单独的章节中利用很好的例子去解释这一概念。\n\n\n# Aop\n\nSpring 框架的一个关键组件是面向方面的程序设计（AOP）框架。一个程序中跨越多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。\n\n在 OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是方面。AOP 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。\n\nSpring 框架的 AOP 模块提供了面向方面的程序设计实现，允许你定义拦截器方法和切入点，可以实现将应该被分开的代码干净的分开功能。我将在一个独立的章节中讨论更多关于 Spring AOP 的概念。\n\n\n# Spring 体系结构\n\nSpring 当前框架有20个 jar 包，大致可以分为6大模块:\n\n * 1. 为什么使用 Spring\n * 2. 核心思想\n   * 2.1. IoC\n   * 2.2. Aop\n * 3. Spring 体系结构\n   * 3.1. Core Container\n     * 3.1.1. BeanFactory\n     * 3.1.2. ApplicationContext\n   * 3.2. AOP and Instrumentation\n   * 3.3. Messaging\n   * 3.4. Data Access / Integaration\n   * 3.5. Web\n   * 3.6. Test\n * 4. 术语\n\nSpring 框架提供了非常丰富的功能，因此整个架构也很庞大。 在我们实际的应用开发中，并不一定要使用所有的功能，而是可以根据需要选择合适的 Spring 模块。\n\n\n\n\n# Core Container\n\nIoC 容器是 Spring 框架的核心。spring 容器使用依赖注入管理构成应用的组件，它会创建相互协作的组件之间的关联。毫无疑问，这些对象更简单干净，更容易理解，也更容易重用和测试。 Spring 自带了几种容器的实现，可归纳为两种类型：\n\n# BeanFactory\n\n由 org.springframework.beans.factory.BeanFactory 接口定义。 它是最简单的容器，提供基本的 DI 支持。\n\n# ApplicationContext\n\n由 org.springframework.context.ApplicationContext 接口定义。 它是基于 BeanFactory 之上构建，并提供面向应用的服务，例如从属性文件解析文本信息的能力，以及发布应用事件给感兴趣的事件监听者的能力。 注：Bean 工厂对于大多数应用来说往往太低级了，所以应用上下文使用更广泛。推荐在开发中使用应用上下文容器。\n\nSpring 自带了多种应用上下文，最可能遇到的有以下几种： ClassPathXmlApplicationContext：从类路径下的 XML 配置文件中加载上下文定义，把应用上下文定义文件当做类资源。 FileSystemXmlApplicationContext：读取文件系统下的 XML 配置文件并加载上下文定义。 XmlWebApplicationContext：读取 Web 应用下的 XML 配置文件并装载上下文定义。\n\n范例\n\nApplicationContext context = new FileSystemXmlApplicationContext("D:\\Temp\\build.xml");\nApplicationContext context2 = new ClassPathXmlApplicationContext("build.xml");\n\n\n可以看到，加载 FileSystemXmlApplicationContext 和 ClassPathXmlApplicationContext 十分相似。 差异在于：前者在指定文件系统路径下查找 build.xml 文件；而后在所有类路径（包含 JAR 文件）下查找 build.xml 文件。 通过引用应用上下文，可以很方便的调用 getBean() 方法从 Spring 容器中获取 Bean。\n\n相关 jar 包\n\n * spring-core, spring-beans, 提供框架的基础部分，包括 IoC 和依赖注入特性。\n\n * spring-context, 在spring-core, spring-beans基础上构建。它提供一种框架式的访问对象的方法。它也支持类似 Java EE 特性，例如：EJB，JMX 和基本 remoting。ApplicationContext 接口是它的聚焦点。\n\n * springcontext-support, 集成第三方库到 Spring application context。\n\n * spring-expression，提供一种强有力的表达语言在运行时来查询和操纵一个对象图。\n\n\n# AOP and Instrumentation\n\n相关 jar 包\n\n * spring-aop，提供了对面向切面编程的丰富支持。\n * spring-aspects，提供了对 AspectJ 的集成。\n * spring-instrument，提供了对类 instrumentation 的支持和类加载器。\n * spring-instrument-tomcat，包含了 Spring 对 Tomcat 的 instrumentation 代理。\n\n\n# Messaging\n\n相关 jar 包\n\n * spring-messaging，包含 spring 的消息处理功能，如 Message，MessageChannel，MessageHandler。\n\n\n# Data Access / Integaration\n\nData Access/Integration 层包含了 JDBC / ORM / OXM / JMS 和 Transaction 模块。\n\n相关 jar 包\n\n * spring-jdbc，提供了一个 JDBC 抽象层。\n\n * spring-tx，支持编程和声明式事务管理类。\n\n * spring-orm，提供了流行的对象关系型映射 API 集，如 JPA，JDO，Hibernate。\n\n * spring-oxm，提供了一个抽象层以支持对象/XML 映射的实现，如 JAXB，Castor，XMLBeans，JiBX 和 XStream.\n\n * spring-jms，包含了生产和消费消息的功能。\n\n\n# Web\n\n相关 jar 包\n\n * spring-web，提供了基本的面向 web 的功能，如多文件上传、使用 Servlet 监听器的 Ioc 容器的初始化。一个面向 web 的应用层上下文。\n\n * spring-webmvc，包括 MVC 和 REST web 服务实现。\n\n * spring-webmvc-portlet，提供在 Protlet 环境的 MVC 实现和spring-webmvc功能的镜像。\n\n\n# Test\n\n相关 jar 包\n\n * spring-test，以 Junit 和 TestNG 来支持 spring 组件的单元测试和集成测试。\n\n\n# 术语\n\n * 应用程序：是能完成我们所需要功能的成品，比如购物网站、OA 系统。\n * 框架：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。\n * 非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。\n * 轻量级及重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。\n * POJO：POJO（Plain Old Java Objects）简单的 Java 对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。\n * 容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。\n * **控制反转：**即 Inversion of Control，缩写为 IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。\n * JavaBean：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。',normalizedContent:'# spring framework 综述\n\n\n# spring framework 简介\n\nspring framework 是最受欢迎的企业级 java 应用程序开发框架。用于构建企业级应用的轻量级、一站式解决方案。\n\n当谈论到大小和透明度时， spring 是轻量级的。 spring 框架的基础版本是在 2 mb 左右的。\n\nspring 框架的核心特性可以用于开发任何 java 应用程序，但是在 java ee 平台上构建 web 应用程序是需要扩展的。 spring 框架的目标是使 j2ee 开发变得更容易使用，通过启用基于 pojo 编程模型来促进良好的编程实践。\n\nspring framework 设计理念如下：\n\n * 力争让选择无处不在\n * 体现海纳百川的精神\n * 保持后向兼容性\n * 专注 api 设计\n * 追求严苛的代码质量\n\n\n# 为什么使用 spring\n\n下面列出的是使用 spring 框架主要的好处：\n\n * spring 可以使开发人员使用 pojos 开发企业级的应用程序。只使用 pojos 的好处是你不需要一个 ejb 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 tomcat 或者一些商业产品。\n * spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只需要选择你需要的部分，而忽略剩余的那部分。\n * spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像几个 orm 框架、日志框架、jee、quartz 和 jdk 计时器，其他视图技术。\n * 测试一个用 spring 编写的应用程序很容易，因为 environment-dependent 代码被放进了这个框架中。此外，通过使用 javabean-style pojos，它在使用依赖注入注入测试数据时变得更容易。\n * spring 的 web 框架是一个设计良好的 web mvc 框架，它为 web 框架，比如 structs 或者其他工程上的或者很少受欢迎的 web 框架，提供了一个很好的供替代的选择。\n * 为将特定技术的异常（例如，由 jdbc、hibernate，或者 jdo 抛出的异常）翻译成一致的， spring 提供了一个方便的 api，而这些都是未经检验的异常。\n * 轻量级的 ioc 容器往往是轻量级的，例如，特别是当与 ejb 容器相比的时候。这有利于在内存和 cpu 资源有限的计算机上开发和部署应用程序。\n * spring 提供了一个一致的事务管理界面，该界面可以缩小成一个本地事务（例如，使用一个单一的数据库）和扩展成一个全局事务（例如，使用 jta）。\n\n\n# 核心思想\n\nspring 最核心的两个技术思想是：ioc 和 aop\n\n\n# ioc\n\nioc 即 inversion of control ，意为控制反转。\n\nspring 最认同的技术是控制反转的**依赖注入（di）**模式。控制反转（ioc）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。\n\n当编写一个复杂的 java 应用程序时，应用程序类应该尽可能的独立于其他的 java 类来增加这些类可重用可能性，当进行单元测试时，可以使它们独立于其他类进行测试。依赖注入（或者有时被称为配线）有助于将这些类粘合在一起，并且在同一时间让它们保持独立。\n\n到底什么是依赖注入？让我们将这两个词分开来看一看。这里将依赖关系部分转化为两个类之间的关联。例如，类 a 依赖于类 b。现在，让我们看一看第二部分，注入。所有这一切都意味着类 b 将通过 ioc 被注入到类 a 中。\n\n依赖注入可以以向构造函数传递参数的方式发生，或者通过使用 setter 方法 post-construction。由于依赖注入是 spring 框架的核心部分，所以我将在一个单独的章节中利用很好的例子去解释这一概念。\n\n\n# aop\n\nspring 框架的一个关键组件是面向方面的程序设计（aop）框架。一个程序中跨越多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样常见的很好的关于方面的例子，比如日志记录、声明性事务、安全性，和缓存等等。\n\n在 oop 中模块化的关键单元是类，而在 aop 中模块化的关键单元是方面。aop 帮助你将横切关注点从它们所影响的对象中分离出来，然而依赖注入帮助你将你的应用程序对象从彼此中分离出来。\n\nspring 框架的 aop 模块提供了面向方面的程序设计实现，允许你定义拦截器方法和切入点，可以实现将应该被分开的代码干净的分开功能。我将在一个独立的章节中讨论更多关于 spring aop 的概念。\n\n\n# spring 体系结构\n\nspring 当前框架有20个 jar 包，大致可以分为6大模块:\n\n * 1. 为什么使用 spring\n * 2. 核心思想\n   * 2.1. ioc\n   * 2.2. aop\n * 3. spring 体系结构\n   * 3.1. core container\n     * 3.1.1. beanfactory\n     * 3.1.2. applicationcontext\n   * 3.2. aop and instrumentation\n   * 3.3. messaging\n   * 3.4. data access / integaration\n   * 3.5. web\n   * 3.6. test\n * 4. 术语\n\nspring 框架提供了非常丰富的功能，因此整个架构也很庞大。 在我们实际的应用开发中，并不一定要使用所有的功能，而是可以根据需要选择合适的 spring 模块。\n\n\n\n\n# core container\n\nioc 容器是 spring 框架的核心。spring 容器使用依赖注入管理构成应用的组件，它会创建相互协作的组件之间的关联。毫无疑问，这些对象更简单干净，更容易理解，也更容易重用和测试。 spring 自带了几种容器的实现，可归纳为两种类型：\n\n# beanfactory\n\n由 org.springframework.beans.factory.beanfactory 接口定义。 它是最简单的容器，提供基本的 di 支持。\n\n# applicationcontext\n\n由 org.springframework.context.applicationcontext 接口定义。 它是基于 beanfactory 之上构建，并提供面向应用的服务，例如从属性文件解析文本信息的能力，以及发布应用事件给感兴趣的事件监听者的能力。 注：bean 工厂对于大多数应用来说往往太低级了，所以应用上下文使用更广泛。推荐在开发中使用应用上下文容器。\n\nspring 自带了多种应用上下文，最可能遇到的有以下几种： classpathxmlapplicationcontext：从类路径下的 xml 配置文件中加载上下文定义，把应用上下文定义文件当做类资源。 filesystemxmlapplicationcontext：读取文件系统下的 xml 配置文件并加载上下文定义。 xmlwebapplicationcontext：读取 web 应用下的 xml 配置文件并装载上下文定义。\n\n范例\n\napplicationcontext context = new filesystemxmlapplicationcontext("d:\\temp\\build.xml");\napplicationcontext context2 = new classpathxmlapplicationcontext("build.xml");\n\n\n可以看到，加载 filesystemxmlapplicationcontext 和 classpathxmlapplicationcontext 十分相似。 差异在于：前者在指定文件系统路径下查找 build.xml 文件；而后在所有类路径（包含 jar 文件）下查找 build.xml 文件。 通过引用应用上下文，可以很方便的调用 getbean() 方法从 spring 容器中获取 bean。\n\n相关 jar 包\n\n * spring-core, spring-beans, 提供框架的基础部分，包括 ioc 和依赖注入特性。\n\n * spring-context, 在spring-core, spring-beans基础上构建。它提供一种框架式的访问对象的方法。它也支持类似 java ee 特性，例如：ejb，jmx 和基本 remoting。applicationcontext 接口是它的聚焦点。\n\n * springcontext-support, 集成第三方库到 spring application context。\n\n * spring-expression，提供一种强有力的表达语言在运行时来查询和操纵一个对象图。\n\n\n# aop and instrumentation\n\n相关 jar 包\n\n * spring-aop，提供了对面向切面编程的丰富支持。\n * spring-aspects，提供了对 aspectj 的集成。\n * spring-instrument，提供了对类 instrumentation 的支持和类加载器。\n * spring-instrument-tomcat，包含了 spring 对 tomcat 的 instrumentation 代理。\n\n\n# messaging\n\n相关 jar 包\n\n * spring-messaging，包含 spring 的消息处理功能，如 message，messagechannel，messagehandler。\n\n\n# data access / integaration\n\ndata access/integration 层包含了 jdbc / orm / oxm / jms 和 transaction 模块。\n\n相关 jar 包\n\n * spring-jdbc，提供了一个 jdbc 抽象层。\n\n * spring-tx，支持编程和声明式事务管理类。\n\n * spring-orm，提供了流行的对象关系型映射 api 集，如 jpa，jdo，hibernate。\n\n * spring-oxm，提供了一个抽象层以支持对象/xml 映射的实现，如 jaxb，castor，xmlbeans，jibx 和 xstream.\n\n * spring-jms，包含了生产和消费消息的功能。\n\n\n# web\n\n相关 jar 包\n\n * spring-web，提供了基本的面向 web 的功能，如多文件上传、使用 servlet 监听器的 ioc 容器的初始化。一个面向 web 的应用层上下文。\n\n * spring-webmvc，包括 mvc 和 rest web 服务实现。\n\n * spring-webmvc-portlet，提供在 protlet 环境的 mvc 实现和spring-webmvc功能的镜像。\n\n\n# test\n\n相关 jar 包\n\n * spring-test，以 junit 和 testng 来支持 spring 组件的单元测试和集成测试。\n\n\n# 术语\n\n * 应用程序：是能完成我们所需要功能的成品，比如购物网站、oa 系统。\n * 框架：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。\n * 非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。\n * 轻量级及重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。\n * pojo：pojo（plain old java objects）简单的 java 对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 java 框架的类或接口。\n * 容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。\n * **控制反转：**即 inversion of control，缩写为 ioc，控制反转还有一个名字叫做依赖注入（dependency injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。\n * javabean：一般指容器管理对象，在 spring 中指 spring ioc 容器管理对象。',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 基本原理",frontmatter:{title:"SpringBoot 基本原理",date:"2020-08-12T07:01:26.000Z",order:22,categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/dbf521/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/22.SpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/22.SpringBoot基本原理.md",key:"v-55b8f14c",path:"/pages/dbf521/",headers:[{level:2,title:"SpringBootApplication 背后的秘密",slug:"springbootapplication-背后的秘密",normalizedTitle:"springbootapplication 背后的秘密",charIndex:429},{level:2,title:"@Configuration",slug:"configuration",normalizedTitle:"@configuration",charIndex:1202},{level:2,title:"@ComponentScan",slug:"componentscan",normalizedTitle:"@componentscan",charIndex:870},{level:2,title:"@EnableAutoConfiguration",slug:"enableautoconfiguration",normalizedTitle:"@enableautoconfiguration",charIndex:780},{level:4,title:"AutoConfigurationPackage 注解：",slug:"autoconfigurationpackage-注解",normalizedTitle:"autoconfigurationpackage 注解：",charIndex:4561},{level:4,title:"Import(AutoConfigurationImportSelector.class)注解：",slug:"import-autoconfigurationimportselector-class-注解",normalizedTitle:"import(autoconfigurationimportselector.class)注解：",charIndex:5179},{level:3,title:"自动配置幕后英雄：SpringFactoriesLoader 详解",slug:"自动配置幕后英雄-springfactoriesloader-详解",normalizedTitle:"自动配置幕后英雄：springfactoriesloader 详解",charIndex:6686},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7738}],headersStr:"SpringBootApplication 背后的秘密 @Configuration @ComponentScan @EnableAutoConfiguration AutoConfigurationPackage 注解： Import(AutoConfigurationImportSelector.class)注解： 自动配置幕后英雄：SpringFactoriesLoader 详解 参考资料",content:'# SpringBoot 基本原理\n\nSpringBoot 为我们做的自动配置，确实方便快捷，但一直搞不明白它的内部启动原理，这次就来一步步解开 SpringBoot 的神秘面纱，让它不再神秘。\n\n\n\n----------------------------------------\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n\n从上面代码可以看出，**Annotation 定义（@SpringBootApplication）和类定义（SpringApplication.run）**最为耀眼，所以要揭开 SpringBoot 的神秘面纱，我们要从这两位开始就可以了。\n\n\n# SpringBootApplication 背后的秘密\n\n@Target(ElementType.TYPE)            // 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明\n@Retention(RetentionPolicy.RUNTIME)  // 注解的生命周期，保留到class文件中（三个生命周期）\n@Documented                          // 表明这个注解应该被javadoc记录\n@Inherited                           // 子类可以继承该注解\n@SpringBootConfiguration             // 继承了Configuration，表示当前是注解类\n@EnableAutoConfiguration             // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助\n@ComponentScan(excludeFilters = {    // 扫描路径设置（具体使用待确认）\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n...\n}\n\n\n虽然定义使用了多个 Annotation 进行了原信息标注，但实际上重要的只有三个 Annotation：\n\n@Configuration（@SpringBootConfiguration 点开查看发现里面还是应用了@Configuration） @EnableAutoConfiguration @ComponentScan 所以，如果我们使用如下的 SpringBoot 启动类，整个 SpringBoot 应用依然可以与之前的启动类功能对等：\n\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n\n每次写这 3 个比较累，所以写一个@SpringBootApplication 方便点。接下来分别介绍这 3 个 Annotation。\n\n\n# @Configuration\n\n这里的@Configuration 对我们来说不陌生，它就是 JavaConfig 形式的 Spring Ioc 容器的配置类使用的那个@Configuration，SpringBoot 社区推荐使用基于 JavaConfig 的配置形式，所以，这里的启动类标注了@Configuration 之后，本身其实也是一个 IoC 容器的配置类。 举几个简单例子回顾下，XML 跟 config 配置方式的区别：\n\n表达形式层面 基于 XML 配置的方式是这样：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"\n       default-lazy-init="true">\n    \x3c!--bean定义--\x3e\n</beans>\n\n\n而基于 JavaConfig 的配置方式是这样：\n\n@Configuration\npublic class MockConfiguration{\n    //bean定义\n}\n\n\n任何一个标注了@Configuration 的 Java 类定义都是一个 JavaConfig 配置类。\n\n注册 bean 定义层面 基于 XML 的配置形式是这样：\n\n<bean id="mockService" class="..MockServiceImpl">\n    ...\n</bean>\n\n\n而基于 JavaConfig 的配置形式是这样的：\n\n@Configuration\npublic class MockConfiguration{\n    @Bean\n    public MockService mockService(){\n        return new MockServiceImpl();\n    }\n}\n\n\n任何一个标注了@Bean 的方法，其返回值将作为一个 bean 定义注册到 Spring 的 IoC 容器，方法名将默认成该 bean 定义的 id。\n\n表达依赖注入关系层面 为了表达 bean 与 bean 之间的依赖关系，在 XML 形式中一般是这样：\n\n<bean id="mockService" class="..MockServiceImpl">\n    <propery name ="dependencyService" ref="dependencyService" />\n</bean>\n\n<bean id="dependencyService" class="DependencyServiceImpl"></bean>\n\n\n而基于 JavaConfig 的配置形式是这样的：\n\n@Configuration\npublic class MockConfiguration{\n    @Bean\n    public MockService mockService(){\n        return new MockServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public DependencyService dependencyService(){\n        return new DependencyServiceImpl();\n    }\n}\n\n\n如果一个 bean 的定义依赖其他 bean,则直接调用对应的 JavaConfig 类中依赖 bean 的创建方法就可以了。\n\n\n# @ComponentScan\n\n@ComponentScan 这个注解在 Spring 中很重要，它对应 XML 配置中的元素，@ComponentScan 的功能其实就是自动扫描并加载符合条件的组件（比如@Component 和@Repository 等）或者 bean 定义，最终将这些 bean 定义加载到 IoC 容器中。\n\n我们可以通过 basePackages 等属性来细粒度的定制@ComponentScan 自动扫描的范围，如果不指定，则默认 Spring 框架实现会从声明@ComponentScan 所在类的 package 进行扫描。\n\n> 注：所以 SpringBoot 的启动类最好是放在 root package 下，因为默认不指定 basePackages。\n\n\n# @EnableAutoConfiguration\n\n个人感觉**@EnableAutoConfiguration 这个 Annotation 最为重要**，所以放在最后来解读，大家是否还记得 Spring 框架提供的各种名字为@Enable 开头的 Annotation 定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport 等，@EnableAutoConfiguration 的理念和做事方式其实一脉相承，简单概括一下就是，借助@Import 的支持，收集和注册特定场景相关的 bean 定义。\n\n@EnableScheduling是通过@Import 将 Spring 调度框架相关的 bean 定义都加载到 IoC 容器。 @EnableMBeanExport是通过@Import 将 JMX 相关的 bean 定义加载到 IoC 容器。 而**@EnableAutoConfiguration**也是借助@Import 的帮助，将所有符合自动配置条件的 bean 定义加载到 IoC 容器，仅此而已！\n\n@EnableAutoConfiguration 作为一个复合 Annotation,其自身定义关键信息如下：\n\n@SuppressWarnings("deprecation")\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    ...\n}\n\n\n两个比较重要的注解：\n\n@AutoConfigurationPackage：自动配置包\n\n@Import: 导入自动配置的组件\n\n# AutoConfigurationPackage 注解：\n\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {\n\n        @Override\n        public void registerBeanDefinitions(AnnotationMetadata metadata,\n                BeanDefinitionRegistry registry) {\n            register(registry, new PackageImport(metadata).getPackageName());\n        }\n\n\n它其实是注册了一个 Bean 的定义。\n\nnew PackageImport(metadata).getPackageName()，它其实返回了当前主程序类的 同级以及子级 的包组件。\n\n\n\n以上图为例，DemoApplication 是和 demo 包同级，但是 demo2 这个类是 DemoApplication 的父级，和 example 包同级\n\n也就是说，DemoApplication 启动加载的 Bean 中，并不会加载 demo2，这也就是为什么，我们要把 DemoApplication 放在项目的最高级中。\n\n# Import(AutoConfigurationImportSelector.class)注解：\n\n\n\n可以从图中看出 AutoConfigurationImportSelector 继承了 DeferredImportSelector 继承了 ImportSelector\n\nImportSelector 有一个方法为：selectImports。\n\n@Override\n    public String[] selectImports(AnnotationMetadata annotationMetadata) {\n        if (!isEnabled(annotationMetadata)) {\n            return NO_IMPORTS;\n        }\n        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n                .loadMetadata(this.beanClassLoader);\n        AnnotationAttributes attributes = getAttributes(annotationMetadata);\n        List<String> configurations = getCandidateConfigurations(annotationMetadata,\n                attributes);\n        configurations = removeDuplicates(configurations);\n        Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n        checkExcludedClasses(configurations, exclusions);\n        configurations.removeAll(exclusions);\n        configurations = filter(configurations, autoConfigurationMetadata);\n        fireAutoConfigurationImportEvents(configurations, exclusions);\n        return StringUtils.toStringArray(configurations);\n    }\n\n\n可以看到第九行，它其实是去加载 public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";外部文件。这个外部文件，有很多自动配置的类。如下：\n\n\n\nimage\n\n其中，最关键的要属**@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector**，@EnableAutoConfiguration可以帮助 SpringBoot 应用将所有符合条件的**@Configuration**配置都加载到当前 SpringBoot 创建并使用的 IoC 容器。就像一只“八爪鱼”一样。\n\n\n\n\n# 自动配置幕后英雄：SpringFactoriesLoader 详解\n\n借助于 Spring 框架原有的一个工具类：SpringFactoriesLoader 的支持，@EnableAutoConfiguration 可以智能的自动配置功效才得以大功告成！\n\nSpringFactoriesLoader 属于 Spring 框架私有的一种扩展方案，其主要功能就是从指定的配置文件 META-INF/spring.factories 加载配置。\n\npublic abstract class SpringFactoriesLoader {\n    //...\n    public static <T> List<T> loadFactories(Class<T> factoryClass, ClassLoader classLoader) {\n        ...\n    }\n\n\n    public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n        ....\n    }\n}\n\n\n配合**@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration 的完整类名 org.springframework.boot.autoconfigure.EnableAutoConfiguration 作为查找的 Key,获取对应的一组@Configuration**类\n\n\n\n上图就是从 SpringBoot 的 autoconfigure 依赖包中的 META-INF/spring.factories 配置文件中摘录的一段内容，可以很好地说明问题。\n\n所以，@EnableAutoConfiguration 自动配置的魔法骑士就变成了：从 classpath 中搜寻所有的 META-INF/spring.factories 配置文件，并将其中 org.springframework.boot.autoconfigure.EnableutoConfiguration 对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration 的 JavaConfig 形式的 IoC 容器配置类，然后汇总为一个并加载到 IoC 容器。\n\n\n\n\n# 参考资料\n\n * 一文搞懂 springboot 启动原理',normalizedContent:'# springboot 基本原理\n\nspringboot 为我们做的自动配置，确实方便快捷，但一直搞不明白它的内部启动原理，这次就来一步步解开 springboot 的神秘面纱，让它不再神秘。\n\n\n\n----------------------------------------\n\n@springbootapplication\npublic class application {\n    public static void main(string[] args) {\n        springapplication.run(application.class, args);\n    }\n}\n\n\n从上面代码可以看出，**annotation 定义（@springbootapplication）和类定义（springapplication.run）**最为耀眼，所以要揭开 springboot 的神秘面纱，我们要从这两位开始就可以了。\n\n\n# springbootapplication 背后的秘密\n\n@target(elementtype.type)            // 注解的适用范围，其中type用于描述类、接口（包括包注解类型）或enum声明\n@retention(retentionpolicy.runtime)  // 注解的生命周期，保留到class文件中（三个生命周期）\n@documented                          // 表明这个注解应该被javadoc记录\n@inherited                           // 子类可以继承该注解\n@springbootconfiguration             // 继承了configuration，表示当前是注解类\n@enableautoconfiguration             // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助\n@componentscan(excludefilters = {    // 扫描路径设置（具体使用待确认）\n        @filter(type = filtertype.custom, classes = typeexcludefilter.class),\n        @filter(type = filtertype.custom, classes = autoconfigurationexcludefilter.class) })\npublic @interface springbootapplication {\n...\n}\n\n\n虽然定义使用了多个 annotation 进行了原信息标注，但实际上重要的只有三个 annotation：\n\n@configuration（@springbootconfiguration 点开查看发现里面还是应用了@configuration） @enableautoconfiguration @componentscan 所以，如果我们使用如下的 springboot 启动类，整个 springboot 应用依然可以与之前的启动类功能对等：\n\n@configuration\n@enableautoconfiguration\n@componentscan\npublic class application {\n    public static void main(string[] args) {\n        springapplication.run(application.class, args);\n    }\n}\n\n\n每次写这 3 个比较累，所以写一个@springbootapplication 方便点。接下来分别介绍这 3 个 annotation。\n\n\n# @configuration\n\n这里的@configuration 对我们来说不陌生，它就是 javaconfig 形式的 spring ioc 容器的配置类使用的那个@configuration，springboot 社区推荐使用基于 javaconfig 的配置形式，所以，这里的启动类标注了@configuration 之后，本身其实也是一个 ioc 容器的配置类。 举几个简单例子回顾下，xml 跟 config 配置方式的区别：\n\n表达形式层面 基于 xml 配置的方式是这样：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"\n       default-lazy-init="true">\n    \x3c!--bean定义--\x3e\n</beans>\n\n\n而基于 javaconfig 的配置方式是这样：\n\n@configuration\npublic class mockconfiguration{\n    //bean定义\n}\n\n\n任何一个标注了@configuration 的 java 类定义都是一个 javaconfig 配置类。\n\n注册 bean 定义层面 基于 xml 的配置形式是这样：\n\n<bean id="mockservice" class="..mockserviceimpl">\n    ...\n</bean>\n\n\n而基于 javaconfig 的配置形式是这样的：\n\n@configuration\npublic class mockconfiguration{\n    @bean\n    public mockservice mockservice(){\n        return new mockserviceimpl();\n    }\n}\n\n\n任何一个标注了@bean 的方法，其返回值将作为一个 bean 定义注册到 spring 的 ioc 容器，方法名将默认成该 bean 定义的 id。\n\n表达依赖注入关系层面 为了表达 bean 与 bean 之间的依赖关系，在 xml 形式中一般是这样：\n\n<bean id="mockservice" class="..mockserviceimpl">\n    <propery name ="dependencyservice" ref="dependencyservice" />\n</bean>\n\n<bean id="dependencyservice" class="dependencyserviceimpl"></bean>\n\n\n而基于 javaconfig 的配置形式是这样的：\n\n@configuration\npublic class mockconfiguration{\n    @bean\n    public mockservice mockservice(){\n        return new mockserviceimpl(dependencyservice());\n    }\n\n    @bean\n    public dependencyservice dependencyservice(){\n        return new dependencyserviceimpl();\n    }\n}\n\n\n如果一个 bean 的定义依赖其他 bean,则直接调用对应的 javaconfig 类中依赖 bean 的创建方法就可以了。\n\n\n# @componentscan\n\n@componentscan 这个注解在 spring 中很重要，它对应 xml 配置中的元素，@componentscan 的功能其实就是自动扫描并加载符合条件的组件（比如@component 和@repository 等）或者 bean 定义，最终将这些 bean 定义加载到 ioc 容器中。\n\n我们可以通过 basepackages 等属性来细粒度的定制@componentscan 自动扫描的范围，如果不指定，则默认 spring 框架实现会从声明@componentscan 所在类的 package 进行扫描。\n\n> 注：所以 springboot 的启动类最好是放在 root package 下，因为默认不指定 basepackages。\n\n\n# @enableautoconfiguration\n\n个人感觉**@enableautoconfiguration 这个 annotation 最为重要**，所以放在最后来解读，大家是否还记得 spring 框架提供的各种名字为@enable 开头的 annotation 定义？比如@enablescheduling、@enablecaching、@enablembeanexport 等，@enableautoconfiguration 的理念和做事方式其实一脉相承，简单概括一下就是，借助@import 的支持，收集和注册特定场景相关的 bean 定义。\n\n@enablescheduling是通过@import 将 spring 调度框架相关的 bean 定义都加载到 ioc 容器。 @enablembeanexport是通过@import 将 jmx 相关的 bean 定义加载到 ioc 容器。 而**@enableautoconfiguration**也是借助@import 的帮助，将所有符合自动配置条件的 bean 定义加载到 ioc 容器，仅此而已！\n\n@enableautoconfiguration 作为一个复合 annotation,其自身定义关键信息如下：\n\n@suppresswarnings("deprecation")\n@target(elementtype.type)\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@autoconfigurationpackage\n@import(enableautoconfigurationimportselector.class)\npublic @interface enableautoconfiguration {\n    ...\n}\n\n\n两个比较重要的注解：\n\n@autoconfigurationpackage：自动配置包\n\n@import: 导入自动配置的组件\n\n# autoconfigurationpackage 注解：\n\nstatic class registrar implements importbeandefinitionregistrar, determinableimports {\n\n        @override\n        public void registerbeandefinitions(annotationmetadata metadata,\n                beandefinitionregistry registry) {\n            register(registry, new packageimport(metadata).getpackagename());\n        }\n\n\n它其实是注册了一个 bean 的定义。\n\nnew packageimport(metadata).getpackagename()，它其实返回了当前主程序类的 同级以及子级 的包组件。\n\n\n\n以上图为例，demoapplication 是和 demo 包同级，但是 demo2 这个类是 demoapplication 的父级，和 example 包同级\n\n也就是说，demoapplication 启动加载的 bean 中，并不会加载 demo2，这也就是为什么，我们要把 demoapplication 放在项目的最高级中。\n\n# import(autoconfigurationimportselector.class)注解：\n\n\n\n可以从图中看出 autoconfigurationimportselector 继承了 deferredimportselector 继承了 importselector\n\nimportselector 有一个方法为：selectimports。\n\n@override\n    public string[] selectimports(annotationmetadata annotationmetadata) {\n        if (!isenabled(annotationmetadata)) {\n            return no_imports;\n        }\n        autoconfigurationmetadata autoconfigurationmetadata = autoconfigurationmetadataloader\n                .loadmetadata(this.beanclassloader);\n        annotationattributes attributes = getattributes(annotationmetadata);\n        list<string> configurations = getcandidateconfigurations(annotationmetadata,\n                attributes);\n        configurations = removeduplicates(configurations);\n        set<string> exclusions = getexclusions(annotationmetadata, attributes);\n        checkexcludedclasses(configurations, exclusions);\n        configurations.removeall(exclusions);\n        configurations = filter(configurations, autoconfigurationmetadata);\n        fireautoconfigurationimportevents(configurations, exclusions);\n        return stringutils.tostringarray(configurations);\n    }\n\n\n可以看到第九行，它其实是去加载 public static final string factories_resource_location = "meta-inf/spring.factories";外部文件。这个外部文件，有很多自动配置的类。如下：\n\n\n\nimage\n\n其中，最关键的要属**@import(enableautoconfigurationimportselector.class)，借助enableautoconfigurationimportselector**，@enableautoconfiguration可以帮助 springboot 应用将所有符合条件的**@configuration**配置都加载到当前 springboot 创建并使用的 ioc 容器。就像一只“八爪鱼”一样。\n\n\n\n\n# 自动配置幕后英雄：springfactoriesloader 详解\n\n借助于 spring 框架原有的一个工具类：springfactoriesloader 的支持，@enableautoconfiguration 可以智能的自动配置功效才得以大功告成！\n\nspringfactoriesloader 属于 spring 框架私有的一种扩展方案，其主要功能就是从指定的配置文件 meta-inf/spring.factories 加载配置。\n\npublic abstract class springfactoriesloader {\n    //...\n    public static <t> list<t> loadfactories(class<t> factoryclass, classloader classloader) {\n        ...\n    }\n\n\n    public static list<string> loadfactorynames(class<?> factoryclass, classloader classloader) {\n        ....\n    }\n}\n\n\n配合**@enableautoconfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@enableautoconfiguration 的完整类名 org.springframework.boot.autoconfigure.enableautoconfiguration 作为查找的 key,获取对应的一组@configuration**类\n\n\n\n上图就是从 springboot 的 autoconfigure 依赖包中的 meta-inf/spring.factories 配置文件中摘录的一段内容，可以很好地说明问题。\n\n所以，@enableautoconfiguration 自动配置的魔法骑士就变成了：从 classpath 中搜寻所有的 meta-inf/spring.factories 配置文件，并将其中 org.springframework.boot.autoconfigure.enableutoconfiguration 对应的配置项通过反射（java refletion）实例化为对应的标注了@configuration 的 javaconfig 形式的 ioc 容器配置类，然后汇总为一个并加载到 ioc 容器。\n\n\n\n\n# 参考资料\n\n * 一文搞懂 springboot 启动原理',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 综述",frontmatter:{title:"Spring 综述",date:"2020-02-26T23:48:06.000Z",categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/9e0b67/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/README.md",key:"v-7f7df8a0",path:"/pages/9e0b67/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:16},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:91},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:270}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring 综述\n\n\n# 📖 内容\n\n * Spring 概述\n * SpringBoot 知识图谱\n * SpringBoot 基本原理\n * Spring 面试\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# spring 综述\n\n\n# 📖 内容\n\n * spring 概述\n * springboot 知识图谱\n * springboot 基本原理\n * spring 面试\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 知识图谱",frontmatter:{title:"SpringBoot 知识图谱",date:"2020-08-12T07:01:26.000Z",order:21,categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/430f53/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/21.SpringBoot%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/21.SpringBoot知识图谱.md",key:"v-b55d218c",path:"/pages/430f53/",headers:[{level:2,title:"一、抛砖引玉：探索 Spring IoC 容器",slug:"一、抛砖引玉-探索-spring-ioc-容器",normalizedTitle:"一、抛砖引玉：探索 spring ioc 容器",charIndex:722},{level:3,title:"1.1、Spring IoC 容器",slug:"_1-1、spring-ioc-容器",normalizedTitle:"1.1、spring ioc 容器",charIndex:911},{level:3,title:"1.2、Spring 容器扩展机制",slug:"_1-2、spring-容器扩展机制",normalizedTitle:"1.2、spring 容器扩展机制",charIndex:4067},{level:2,title:"二、夯实基础：JavaConfig 与常见 Annotation",slug:"二、夯实基础-javaconfig-与常见-annotation",normalizedTitle:"二、夯实基础：javaconfig 与常见 annotation",charIndex:6857},{level:3,title:"2.1、JavaConfig",slug:"_2-1、javaconfig",normalizedTitle:"2.1、javaconfig",charIndex:6894},{level:3,title:"2.2、@ComponentScan",slug:"_2-2、-componentscan",normalizedTitle:"2.2、@componentscan",charIndex:8790},{level:3,title:"2.3、@Import",slug:"_2-3、-import",normalizedTitle:"2.3、@import",charIndex:9028},{level:3,title:"2.4、@Conditional",slug:"_2-4、-conditional",normalizedTitle:"2.4、@conditional",charIndex:9693},{level:3,title:"2.5、@ConfigurationProperties 与@EnableConfigurationProperties",slug:"_2-5、-configurationproperties-与-enableconfigurationproperties",normalizedTitle:"2.5、@configurationproperties 与@enableconfigurationproperties",charIndex:11433},{level:2,title:"三、削铁如泥：SpringFactoriesLoader 详解",slug:"三、削铁如泥-springfactoriesloader-详解",normalizedTitle:"三、削铁如泥：springfactoriesloader 详解",charIndex:14026},{level:2,title:"四、另一件武器：Spring 容器的事件监听机制",slug:"四、另一件武器-spring-容器的事件监听机制",normalizedTitle:"四、另一件武器：spring 容器的事件监听机制",charIndex:19858},{level:4,title:"Spring 容器内的事件监听机制",slug:"spring-容器内的事件监听机制",normalizedTitle:"spring 容器内的事件监听机制",charIndex:23057},{level:2,title:"五、出神入化：揭秘自动配置原理",slug:"五、出神入化-揭秘自动配置原理",normalizedTitle:"五、出神入化：揭秘自动配置原理",charIndex:24228},{level:2,title:"六、启动引导：Spring Boot 应用启动的秘密",slug:"六、启动引导-spring-boot-应用启动的秘密",normalizedTitle:"六、启动引导：spring boot 应用启动的秘密",charIndex:28598},{level:3,title:"6.1 SpringApplication 初始化",slug:"_6-1-springapplication-初始化",normalizedTitle:"6.1 springapplication 初始化",charIndex:28629},{level:3,title:"6.2 Spring Boot 启动流程",slug:"_6-2-spring-boot-启动流程",normalizedTitle:"6.2 spring boot 启动流程",charIndex:30395},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:36499}],headersStr:"一、抛砖引玉：探索 Spring IoC 容器 1.1、Spring IoC 容器 1.2、Spring 容器扩展机制 二、夯实基础：JavaConfig 与常见 Annotation 2.1、JavaConfig 2.2、@ComponentScan 2.3、@Import 2.4、@Conditional 2.5、@ConfigurationProperties 与@EnableConfigurationProperties 三、削铁如泥：SpringFactoriesLoader 详解 四、另一件武器：Spring 容器的事件监听机制 Spring 容器内的事件监听机制 五、出神入化：揭秘自动配置原理 六、启动引导：Spring Boot 应用启动的秘密 6.1 SpringApplication 初始化 6.2 Spring Boot 启动流程 参考资料",content:'# SpringBoot 知识图谱\n\n>  1. 预警：本文非常长，建议先 mark 后看，也许是最后一次写这么长的文章\n>  2. 说明：前面有 4 个小节关于 Spring 的基础知识，分别是：IOC 容器、JavaConfig、事件监听、SpringFactoriesLoader 详解，它们占据了本文的大部分内容，虽然它们之间可能没有太多的联系，但这些知识对于理解 Spring Boot 的核心原理至关重要，如果你对 Spring 框架烂熟于心，完全可以跳过这 4 个小节。正是因为这个系列的文章是由这些看似不相关的知识点组成，因此取名知识清单。\n\n在过去两三年的 Spring 生态圈，最让人兴奋的莫过于 Spring Boot 框架。或许从命名上就能看出这个框架的设计初衷：快速的启动 Spring 应用。因而 Spring Boot 应用本质上就是一个基于 Spring 框架的应用，它是 Spring 对“约定优先于配置”理念的最佳实践产物，它能够帮助开发者更快速高效地构建基于 Spring 生态圈的应用。\n\n那 Spring Boot 有何魔法？自动配置、起步依赖、Actuator、命令行界面(CLI) 是 Spring Boot 最重要的 4 大核心特性，其中 CLI 是 Spring Boot 的可选特性，虽然它功能强大，但也引入了一套不太常规的开发模型，因而这个系列的文章仅关注其它 3 种特性。如文章标题，本文是这个系列的第一部分，将为你打开 Spring Boot 的大门，重点为你剖析其启动流程以及自动配置实现原理。要掌握这部分核心内容，理解一些 Spring 框架的基础知识，将会让你事半功倍。\n\n\n# 一、抛砖引玉：探索 Spring IoC 容器\n\n如果有看过SpringApplication.run()方法的源码，Spring Boot 冗长无比的启动流程一定会让你抓狂，透过现象看本质，SpringApplication 只是将一个典型的 Spring 应用的启动流程进行了扩展，因此，透彻理解 Spring 容器是打开 Spring Boot 大门的一把钥匙。\n\n\n# 1.1、Spring IoC 容器\n\n可以把 Spring IoC 容器比作一间餐馆，当你来到餐馆，通常会直接招呼服务员：点菜！至于菜的原料是什么？如何用原料把菜做出来？可能你根本就不关心。IoC 容器也是一样，你只需要告诉它需要某个 bean，它就把对应的实例（instance）扔给你，至于这个 bean 是否依赖其他组件，怎样完成它的初始化，根本就不需要你关心。\n\n作为餐馆，想要做出菜肴，得知道菜的原料和菜谱，同样地，IoC 容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。BeanDefinition对象就承担了这个责任：容器中的每一个 bean 都会有一个对应的 BeanDefinition 实例，该实例负责保存 bean 对象的所有必要信息，包括 bean 对象的 class 类型、是否是抽象类、构造方法和参数、其它属性等等。当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的 bean 实例。\n\n原材料已经准备好（把 BeanDefinition 看着原料），开始做菜吧，等等，你还需要一份菜谱，BeanDefinitionRegistry和BeanFactory就是这份菜谱，BeanDefinitionRegistry 抽象出 bean 的注册逻辑，而 BeanFactory 则抽象出了 bean 的管理逻辑，而各个 BeanFactory 的实现类就具体承担了 bean 的注册以及管理工作。它们之间的关系就如下图：\n\nBeanFactory、BeanDefinitionRegistry 关系图（来自：Spring 揭秘）\n\nDefaultListableBeanFactory作为一个比较通用的 BeanFactory 实现，它同时也实现了 BeanDefinitionRegistry 接口，因此它就承担了 Bean 的注册管理工作。从图中也可以看出，BeanFactory 接口中主要包含 getBean、containBean、getType、getAliases 等管理 bean 的方法，而 BeanDefinitionRegistry 接口则包含 registerBeanDefinition、removeBeanDefinition、getBeanDefinition 等注册管理 BeanDefinition 的方法。\n\n下面通过一段简单的代码来模拟 BeanFactory 底层是如何工作的：\n\n// 默认容器实现\nDefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory();\n// 根据业务对象构造相应的BeanDefinition\nAbstractBeanDefinition definition = new RootBeanDefinition(Business.class,true);\n// 将bean定义注册到容器中\nbeanRegistry.registerBeanDefinition("beanName",definition);\n// 如果有多个bean，还可以指定各个bean之间的依赖关系\n// ........\n\n// 然后可以从容器中获取这个bean的实例\n// 注意：这里的beanRegistry其实实现了BeanFactory接口，所以可以强转，\n// 单纯的BeanDefinitionRegistry是无法强制转换到BeanFactory类型的\nBeanFactory container = (BeanFactory)beanRegistry;\nBusiness business = (Business)container.getBean("beanName");\n\n\n这段代码仅为了说明 BeanFactory 底层的大致工作流程，实际情况会更加复杂，比如 bean 之间的依赖关系可能定义在外部配置文件(XML/Properties)中、也可能是注解方式。Spring IoC 容器的整个工作流程大致可以分为两个阶段：\n\n①、容器启动阶段\n\n容器启动时，会通过某种途径加载Configuration MetaData。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如：BeanDefinitionReader，BeanDefinitionReader 会对加载的Configuration MetaData进行解析和分析，并将分析后的信息组装为相应的 BeanDefinition，最后把这些保存了 bean 定义的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器的启动工作就完成了。这个阶段主要完成一些准备性工作，更侧重于 bean 对象管理信息的收集，当然一些验证性或者辅助性的工作也在这一阶段完成。\n\n来看一个简单的例子吧，过往，所有的 bean 都定义在 XML 配置文件中，下面的代码将模拟 BeanFactory 如何从配置文件中加载 bean 的定义以及依赖关系：\n\n// 通常为BeanDefinitionRegistry的实现类，这里以DeFaultListabeBeanFactory为例\nBeanDefinitionRegistry beanRegistry = new DefaultListableBeanFactory();\n// XmlBeanDefinitionReader实现了BeanDefinitionReader接口，用于解析XML文件\nXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReaderImpl(beanRegistry);\n// 加载配置文件\nbeanDefinitionReader.loadBeanDefinitions("classpath:spring-bean.xml");\n\n// 从容器中获取bean实例\nBeanFactory container = (BeanFactory)beanRegistry;\nBusiness business = (Business)container.getBean("beanName");\n\n\n②、Bean 的实例化阶段\n\n经过第一阶段，所有 bean 定义都通过 BeanDefinition 的方式注册到 BeanDefinitionRegistry 中，当某个请求通过容器的 getBean 方法请求某个对象，或者因为依赖关系容器需要隐式的调用 getBean 时，就会触发第二阶段的活动：容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的 BeanDefinition 所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完毕后，容器会立即将其返回给请求方法使用。\n\nBeanFactory 只是 Spring IoC 容器的一种实现，如果没有特殊指定，它采用采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。而在实际场景下，我们更多的使用另外一种类型的容器：ApplicationContext，它构建在 BeanFactory 之上，属于更高级的容器，除了具有 BeanFactory 的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的 bean，在容器启动时全部完成初始化和依赖注入操作。\n\n\n# 1.2、Spring 容器扩展机制\n\nIoC 容器负责管理容器中所有 bean 的生命周期，而在 bean 生命周期的不同阶段，Spring 提供了不同的扩展点来改变 bean 的命运。在容器的启动阶段，BeanFactoryPostProcessor允许我们在容器实例化相应对象之前，对注册到容器的 BeanDefinition 所保存的信息做一些额外的操作，比如修改 bean 定义的某些属性或者增加其他信息等。\n\n如果要自定义扩展类，通常需要实现org.springframework.beans.factory.config.BeanFactoryPostProcessor接口，与此同时，因为容器中可能有多个 BeanFactoryPostProcessor，可能还需要实现org.springframework.core.Ordered接口，以保证 BeanFactoryPostProcessor 按照顺序执行。Spring 提供了为数不多的 BeanFactoryPostProcessor 实现，我们以PropertyPlaceholderConfigurer来说明其大致的工作流程。\n\n在 Spring 项目的 XML 配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置到独立的 properties 文件，这样可以将散落在不同 XML 文件中的配置集中管理，而且也方便运维根据不同的环境进行配置不同的值。这个非常实用的功能就是由 PropertyPlaceholderConfigurer 负责实现的。\n\n根据前文，当 BeanFactory 在第一阶段加载完所有配置信息时，BeanFactory 中保存的对象的属性还是以占位符方式存在的，比如${jdbc.mysql.url}。当 PropertyPlaceholderConfigurer 作为 BeanFactoryPostProcessor 被应用时，它会使用 properties 配置文件中的值来替换相应的 BeanDefinition 中占位符所表示的属性值。当需要实例化 bean 时，bean 定义中的属性值就已经被替换成我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考其源码。\n\n与之相似的，还有BeanPostProcessor，其存在于对象实例化阶段。跟 BeanFactoryPostProcessor 类似，它会处理容器内所有符合条件并且已经实例化后的对象。简单的对比，BeanFactoryPostProcessor 处理 bean 的定义，而 BeanPostProcessor 则处理 bean 完成实例化后的对象。BeanPostProcessor 定义了两个接口：\n\npublic interface BeanPostProcessor {\n    // 前置处理\n    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n    // 后置处理\n    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n}\n\n\n为了理解这两个方法执行的时机，简单的了解下 bean 的整个生命周期：\n\npostProcessBeforeInitialization()方法与postProcessAfterInitialization()分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法中都传入了 bean 对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这儿几乎可以对传入的实例执行任何操作。注解、AOP 等功能的实现均大量使用了BeanPostProcessor，比如有一个自定义注解，你完全可以实现 BeanPostProcessor 的接口，在其中判断 bean 对象的脑袋上是否有该注解，如果有，你可以对这个 bean 实例执行任何操作，想想是不是非常的简单？\n\n再来看一个更常见的例子，在 Spring 中经常能够看到各种各样的 Aware 接口，其作用就是在对象实例化完成以后将 Aware 接口定义中规定的依赖注入到当前实例中。比如最常见的ApplicationContextAware接口，实现了这个接口的类都可以获取到一个 ApplicationContext 对象。当容器中每个对象的实例化过程走到 BeanPostProcessor 前置处理这一步时，容器会检测到之前注册到容器的 ApplicationContextAwareProcessor，然后就会调用其 postProcessBeforeInitialization()方法，检查并设置 Aware 相关依赖。看看代码吧，是不是很简单：\n\n// 代码来自：org.springframework.context.support.ApplicationContextAwareProcessor\n// 其postProcessBeforeInitialization方法调用了invokeAwareInterfaces方法\nprivate void invokeAwareInterfaces(Object bean) {\n    if (bean instanceof EnvironmentAware) {\n        ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\n    }\n    if (bean instanceof ApplicationContextAware) {\n        ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);\n    }\n    // ......\n}\n\n\n最后总结一下，本小节内容和你一起回顾了 Spring 容器的部分核心内容，限于篇幅不能写更多，但理解这部分内容，足以让您轻松理解 Spring Boot 的启动原理，如果在后续的学习过程中遇到一些晦涩难懂的知识，再回过头来看看 Spring 的核心知识，也许有意想不到的效果。也许 Spring Boot 的中文资料很少，但 Spring 的中文资料和书籍有太多太多，总有东西能给你启发。\n\n\n# 二、夯实基础：JavaConfig 与常见 Annotation\n\n\n# 2.1、JavaConfig\n\n我们知道bean是 Spring IOC 中非常核心的概念，Spring 容器负责 bean 的生命周期的管理。在最初，Spring 使用 XML 配置文件的方式来描述 bean 的定义以及相互间的依赖关系，但随着 Spring 的发展，越来越多的人对这种方式表示不满，因为 Spring 项目的所有业务类均以 bean 的形式配置在 XML 文件中，造成了大量的 XML 文件，使项目变得复杂且难以管理。\n\n后来，基于纯 Java Annotation 依赖注入框架Guice出世，其性能明显优于采用 XML 方式的 Spring，甚至有部分人认为，Guice可以完全取代 Spring（Guice仅是一个轻量级 IOC 框架，取代 Spring 还差的挺远）。正是这样的危机感，促使 Spring 及社区推出并持续完善了JavaConfig子项目，它基于 Java 代码和 Annotation 注解来描述 bean 之间的依赖绑定关系。比如，下面是使用 XML 配置方式来描述 bean 的定义：\n\n<bean id="bookService" class="cn.moondev.service.BookServiceImpl"></bean>\n\n\n而基于 JavaConfig 的配置形式是这样的：\n\n@Configuration\npublic class MoonBookConfiguration {\n\n    // 任何标志了@Bean的方法，其返回值将作为一个bean注册到Spring的IOC容器中\n    // 方法名默认成为该bean定义的id\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl();\n    }\n}\n\n\n如果两个 bean 之间有依赖关系的话，在 XML 配置中应该是这样：\n\n<bean id="bookService" class="cn.moondev.service.BookServiceImpl">\n    <property name="dependencyService" ref="dependencyService"/>\n</bean>\n\n<bean id="otherService" class="cn.moondev.service.OtherServiceImpl">\n    <property name="dependencyService" ref="dependencyService"/>\n</bean>\n\n<bean id="dependencyService" class="DependencyServiceImpl"/>\n\n\n而在 JavaConfig 中则是这样：\n\n@Configuration\npublic class MoonBookConfiguration {\n\n    // 如果一个bean依赖另一个bean，则直接调用对应JavaConfig类中依赖bean的创建方法即可\n    // 这里直接调用dependencyService()\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public OtherService otherService() {\n        return new OtherServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public DependencyService dependencyService() {\n        return new DependencyServiceImpl();\n    }\n}\n\n\n你可能注意到这个示例中，有两个 bean 都依赖于 dependencyService，也就是说当初始化 bookService 时会调用dependencyService()，在初始化 otherService 时也会调用dependencyService()，那么问题来了？这时候 IOC 容器中是有一个 dependencyService 实例还是两个？这个问题留着大家思考吧，这里不再赘述。\n\n\n# 2.2、@ComponentScan\n\n@ComponentScan注解对应 XML 配置形式中的``元素，表示启用组件扫描，Spring 会自动扫描所有通过注解配置的 bean，然后将其注册到 IOC 容器中。我们可以通过basePackages等属性来指定@ComponentScan自动扫描的范围，如果不指定，默认从声明@ComponentScan所在类的package进行扫描。正因为如此，SpringBoot 的启动类都默认在src/main/java下。\n\n\n# 2.3、@Import\n\n@Import注解用于导入配置类，举个简单的例子：\n\n@Configuration\npublic class MoonBookConfiguration {\n    @Bean\n    public BookService bookService() {\n        return new BookServiceImpl();\n    }\n}\n\n\n现在有另外一个配置类，比如：MoonUserConfiguration，这个配置类中有一个 bean 依赖于MoonBookConfiguration中的 bookService，如何将这两个 bean 组合在一起？借助@Import即可：\n\n@Configuration\n// 可以同时导入多个配置类，比如：@Import({A.class,B.class})\n@Import(MoonBookConfiguration.class)\npublic class MoonUserConfiguration {\n    @Bean\n    public UserService userService(BookService bookService) {\n        return new BookServiceImpl(bookService);\n    }\n}\n\n\n需要注意的是，在 4.2 之前，@Import注解只支持导入配置类，但是在 4.2 之后，它支持导入普通类，并将这个类作为一个 bean 的定义注册到 IOC 容器中。\n\n\n# 2.4、@Conditional\n\n@Conditional注解表示在满足某种条件后才初始化一个 bean 或者启用某些配置。它一般用在由@Component、@Service、@Configuration等注解标识的类上面，或者由@Bean标记的方法上。如果一个@Configuration类标记了@Conditional，则该类中所有标识了@Bean的方法和@Import注解导入的相关类将遵从这些条件。\n\n在 Spring 里可以很方便的编写你自己的条件类，所要做的就是实现Condition接口，并覆盖它的matches()方法。举个例子，下面的简单条件类表示只有在Classpath里存在JdbcTemplate类时才生效：\n\npublic class JdbcTemplateCondition implements Condition {\n\n    @Override\n    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {\n        try {\n        conditionContext.getClassLoader().loadClass("org.springframework.jdbc.core.JdbcTemplate");\n            return true;\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n}\n\n\n当你用 Java 来声明 bean 的时候，可以使用这个自定义条件类：\n\n@Conditional(JdbcTemplateCondition.class)\n@Service\npublic MyService service() {\n    ......\n}\n\n\n这个例子中只有当JdbcTemplateCondition类的条件成立时才会创建 MyService 这个 bean。也就是说 MyService 这 bean 的创建条件是classpath里面包含JdbcTemplate，否则这个 bean 的声明就会被忽略掉。\n\nSpring Boot定义了很多有趣的条件，并把他们运用到了配置类上，这些配置类构成了Spring Boot的自动配置的基础。Spring Boot运用条件化配置的方法是：定义多个特殊的条件化注解，并将它们用到配置类上。下面列出了Spring Boot提供的部分条件化注解：\n\n条件化注解                             配置生效条件\n@ConditionalOnBean                配置了某个特定 bean\n@ConditionalOnMissingBean         没有配置特定的 bean\n@ConditionalOnClass               Classpath 里有指定的类\n@ConditionalOnMissingClass        Classpath 里没有指定的类\n@ConditionalOnExpression          给定的 Spring Expression Language 表达式计算结果为 true\n@ConditionalOnJava                Java 的版本匹配特定指或者一个范围值\n@ConditionalOnProperty            指定的配置属性要有一个明确的值\n@ConditionalOnResource            Classpath 里有指定的资源\n@ConditionalOnWebApplication      这是一个 Web 应用程序\n@ConditionalOnNotWebApplication   这不是一个 Web 应用程序\n\n\n# 2.5、@ConfigurationProperties 与@EnableConfigurationProperties\n\n当某些属性的值需要配置的时候，我们一般会在application.properties文件中新建配置项，然后在 bean 中使用@Value注解来获取配置的值，比如下面配置数据源的代码。\n\n// jdbc config\njdbc.mysql.url=jdbc:mysql://localhost:3306/sampledb\njdbc.mysql.username=root\njdbc.mysql.password=123456\n......\n\n// 配置数据源\n@Configuration\npublic class HikariDataSourceConfiguration {\n\n    @Value("jdbc.mysql.url")\n    public String url;\n    @Value("jdbc.mysql.username")\n    public String user;\n    @Value("jdbc.mysql.password")\n    public String password;\n\n    @Bean\n    public HikariDataSource dataSource() {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setJdbcUrl(url);\n        hikariConfig.setUsername(user);\n        hikariConfig.setPassword(password);\n        // 省略部分代码\n        return new HikariDataSource(hikariConfig);\n    }\n}\n\n\n使用@Value注解注入的属性通常都比较简单，如果同一个配置在多个地方使用，也存在不方便维护的问题（考虑下，如果有几十个地方在使用某个配置，而现在你想改下名字，你改怎么做？）。对于更为复杂的配置，Spring Boot 提供了更优雅的实现方式，那就是@ConfigurationProperties注解。我们可以通过下面的方式来改写上面的代码：\n\n@Component\n//  还可以通过@PropertySource("classpath:jdbc.properties")来指定配置文件\n@ConfigurationProperties("jdbc.mysql")\n// 前缀=jdbc.mysql，会在配置文件中寻找jdbc.mysql.*的配置项\npulic class JdbcConfig {\n    public String url;\n    public String username;\n    public String password;\n}\n\n@Configuration\npublic class HikariDataSourceConfiguration {\n\n    @AutoWired\n    public JdbcConfig config;\n\n    @Bean\n    public HikariDataSource dataSource() {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setJdbcUrl(config.url);\n        hikariConfig.setUsername(config.username);\n        hikariConfig.setPassword(config.password);\n        // 省略部分代码\n        return new HikariDataSource(hikariConfig);\n    }\n}\n\n\n@ConfigurationProperties对于更为复杂的配置，处理起来也是得心应手，比如有如下配置文件：\n\n#App\napp.menus[0].title=Home\napp.menus[0].name=Home\napp.menus[0].path=/\napp.menus[1].title=Login\napp.menus[1].name=Login\napp.menus[1].path=/login\n\napp.compiler.timeout=5\napp.compiler.output-folder=/temp/\n\napp.error=/error/\n\n\n可以定义如下配置类来接收这些属性\n\n@Component\n@ConfigurationProperties("app")\npublic class AppProperties {\n\n    public String error;\n    public List<Menu> menus = new ArrayList<>();\n    public Compiler compiler = new Compiler();\n\n    public static class Menu {\n        public String name;\n        public String path;\n        public String title;\n    }\n\n    public static class Compiler {\n        public String timeout;\n        public String outputFolder;\n    }\n}\n\n\n@EnableConfigurationProperties注解表示对@ConfigurationProperties的内嵌支持，默认会将对应 Properties Class 作为 bean 注入的 IOC 容器中，即在相应的 Properties 类上不用加@Component注解。\n\n\n# 三、削铁如泥：SpringFactoriesLoader 详解\n\nJVM 提供了 3 种类加载器：BootstrapClassLoader、ExtClassLoader、AppClassLoader分别加载 Java 核心类库、扩展类库以及应用的类路径(CLASSPATH)下的类库。JVM 通过双亲委派模型进行类的加载，我们也可以通过继承java.lang.classloader实现自己的类加载器。\n\n何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的 BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。\n\n采用双亲委派模型的一个好处是保证使用不同类加载器最终得到的都是同一个对象，这样就可以保证 Java 核心库的类型安全，比如，加载位于 rt.jar 包中的java.lang.Object类，不管是哪个加载器加载这个类，最终都是委托给顶层的 BootstrapClassLoader 来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个 Object 对象。查看 ClassLoader 的源码，对双亲委派模型会有更直观的认识：\n\nprotected Class<?> loadClass(String name, boolean resolve) {\n    synchronized (getClassLoadingLock(name)) {\n    // 首先，检查该类是否已经被加载，如果从JVM缓存中找到该类，则直接返回\n    Class<?> c = findLoadedClass(name);\n    if (c == null) {\n        try {\n            // 遵循双亲委派的模型，首先会通过递归从父加载器开始找，\n            // 直到父类加载器是BootstrapClassLoader为止\n            if (parent != null) {\n                c = parent.loadClass(name, false);\n            } else {\n                c = findBootstrapClassOrNull(name);\n            }\n        } catch (ClassNotFoundException e) {}\n        if (c == null) {\n            // 如果还找不到，尝试通过findClass方法去寻找\n            // findClass是留给开发者自己实现的，也就是说\n            // 自定义类加载器时，重写此方法即可\n           c = findClass(name);\n        }\n    }\n    if (resolve) {\n        resolveClass(c);\n    }\n    return c;\n    }\n}\n\n\n但双亲委派模型并不能解决所有的类加载器问题，比如，Java 提供了很多服务提供者接口(Service Provider Interface，SPI)，允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JNDI、JAXP 等，这些 SPI 的接口由核心类库提供，却由第三方实现，这样就存在一个问题：SPI 的接口是 Java 核心库的一部分，是由 BootstrapClassLoader 加载的；SPI 实现的 Java 类一般是由 AppClassLoader 来加载的。BootstrapClassLoader 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。\n\n线程上下文类加载器(ContextClassLoader)正好解决了这个问题。从名称上看，可能会误解为它是一种新的类加载器，实际上，它仅仅是 Thread 类的一个变量而已，可以通过setContextClassLoader(ClassLoader cl)和getContextClassLoader()来设置和获取该对象。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是 AppClassLoader。在核心类库使用 SPI 接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。但在 JDBC 中，你可能会看到一种更直接的实现方式，比如，JDBC 驱动管理java.sql.Driver中的loadInitialDrivers()方法中，你可以直接看到 JDK 是如何加载驱动的：\n\nfor (String aDriver : driversList) {\n    try {\n        // 直接使用AppClassLoader\n        Class.forName(aDriver, true, ClassLoader.getSystemClassLoader());\n    } catch (Exception ex) {\n        println("DriverManager.Initialize: load failed: " + ex);\n    }\n}\n\n\n其实讲解线程上下文类加载器，最主要是让大家在看到Thread.currentThread().getClassLoader()和Thread.currentThread().getContextClassLoader()时不会一脸懵逼，这两者除了在许多底层框架中取得的 ClassLoader 可能会有所不同外，其他大多数业务场景下都是一样的，大家只要知道它是为了解决什么问题而存在的即可。\n\n类加载器除了加载 class 外，还有一个非常重要功能，就是加载资源，它可以从 jar 包中读取任何资源文件，比如，ClassLoader.getResources(String name)方法就是用于读取 jar 包中的资源文件，其代码如下：\n\npublic Enumeration<URL> getResources(String name) throws IOException {\n    Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];\n    if (parent != null) {\n        tmp[0] = parent.getResources(name);\n    } else {\n        tmp[0] = getBootstrapResources(name);\n    }\n    tmp[1] = findResources(name);\n    return new CompoundEnumeration<>(tmp);\n}\n\n\n是不是觉得有点眼熟，不错，它的逻辑其实跟类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到 BootstrapClassLoader，最后才轮到自己查找。而不同的类加载器负责扫描不同路径下的 jar 包，就如同加载 class 一样，最后会扫描所有的 jar 包，找到符合条件的资源文件。\n\n类加载器的findResources(name)方法会遍历其负责加载的所有 jar 包，找到 jar 包中名称为 name 的资源文件，这里的资源可以是任何文件，甚至是.class 文件，比如下面的示例，用于查找 Array.class 文件：\n\n// 寻找Array.class文件\npublic static void main(String[] args) throws Exception{\n    // Array.class的完整路径\n    String name = "java/sql/Array.class";\n    Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(name);\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        System.out.println(url.toString());\n    }\n}\n\n\n运行后可以得到如下结果：\n\n$JAVA_HOME/jre/lib/rt.jar!/java/sql/Array.class\n\n\n根据资源文件的 URL，可以构造相应的文件来读取资源内容。\n\n看到这里，你可能会感到挺奇怪的，你不是要详解SpringFactoriesLoader吗？上来讲了一堆 ClassLoader 是几个意思？看下它的源码你就知道了：\n\npublic static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";\n// spring.factories文件的格式为：key=value1,value2,value3\n// 从所有的jar包中找到META-INF/spring.factories文件\n// 然后从文件中解析出key=factoryClass类名称的所有value值\npublic static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n    String factoryClassName = factoryClass.getName();\n    // 取得资源文件的URL\n    Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n    List<String> result = new ArrayList<String>();\n    // 遍历所有的URL\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        // 根据资源文件URL解析properties文件\n        Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n        String factoryClassNames = properties.getProperty(factoryClassName);\n        // 组装数据，并返回\n        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n    }\n    return result;\n}\n\n\n有了前面关于 ClassLoader 的知识，再来理解这段代码，是不是感觉豁然开朗：从CLASSPATH下的每个 Jar 包中搜寻所有META-INF/spring.factories配置文件，然后将解析 properties 文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去 ClassPath 路径下查找，会扫描所有路径下的 Jar 包，只不过这个文件只会在 Classpath 下的 jar 包中。来简单看下spring.factories文件的内容吧：\n\n// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories\n// EnableAutoConfiguration后文会讲到，它用于开启Spring Boot自动配置功能\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\\\n\n\n执行loadFactoryNames(EnableAutoConfiguration.class, classLoader)后，得到对应的一组@Configuration类， 我们就可以通过反射实例化这些类然后注入到 IOC 容器中，最后容器里就有了一系列标注了@Configuration的 JavaConfig 形式的配置类。\n\n这就是SpringFactoriesLoader，它本质上属于 Spring 框架私有的一种扩展方案，类似于 SPI，Spring Boot 在 Spring 基础上的很多核心功能都是基于此，希望大家可以理解。\n\n\n# 四、另一件武器：Spring 容器的事件监听机制\n\n过去，事件监听机制多用于图形界面编程，比如：点击按钮、在文本框输入内容等操作被称为事件，而当事件触发时，应用程序作出一定的响应则表示应用监听了这个事件，而在服务器端，事件的监听机制更多的用于异步通知以及监控和异常处理。Java 提供了实现事件监听机制的两个基础类：自定义事件类型扩展自java.util.EventObject、事件的监听器扩展自java.util.EventListener。来看一个简单的实例：简单的监控一个方法的耗时。\n\n首先定义事件类型，通常的做法是扩展 EventObject，随着事件的发生，相应的状态通常都封装在此类中：\n\npublic class MethodMonitorEvent extends EventObject {\n    // 时间戳，用于记录方法开始执行的时间\n    public long timestamp;\n\n    public MethodMonitorEvent(Object source) {\n        super(source);\n    }\n}\n\n\n事件发布之后，相应的监听器即可对该类型的事件进行处理，我们可以在方法开始执行之前发布一个 begin 事件，在方法执行结束之后发布一个 end 事件，相应地，事件监听器需要提供方法对这两种情况下接收到的事件进行处理：\n\n// 1、定义事件监听接口\npublic interface MethodMonitorEventListener extends EventListener {\n    // 处理方法执行之前发布的事件\n    public void onMethodBegin(MethodMonitorEvent event);\n    // 处理方法结束时发布的事件\n    public void onMethodEnd(MethodMonitorEvent event);\n}\n// 2、事件监听接口的实现：如何处理\npublic class AbstractMethodMonitorEventListener implements MethodMonitorEventListener {\n\n    @Override\n    public void onMethodBegin(MethodMonitorEvent event) {\n        // 记录方法开始执行时的时间\n        event.timestamp = System.currentTimeMillis();\n    }\n\n    @Override\n    public void onMethodEnd(MethodMonitorEvent event) {\n        // 计算方法耗时\n        long duration = System.currentTimeMillis() - event.timestamp;\n        System.out.println("耗时：" + duration);\n    }\n}\n\n\n事件监听器接口针对不同的事件发布实际提供相应的处理方法定义，最重要的是，其方法只接收 MethodMonitorEvent 参数，说明这个监听器类只负责监听器对应的事件并进行处理。有了事件和监听器，剩下的就是发布事件，然后让相应的监听器监听并处理。通常情况，我们会有一个事件发布者，它本身作为事件源，在合适的时机，将相应的事件发布给对应的事件监听器：\n\npublic class MethodMonitorEventPublisher {\n\n    private List<MethodMonitorEventListener> listeners = new ArrayList<MethodMonitorEventListener>();\n\n    public void methodMonitor() {\n        MethodMonitorEvent eventObject = new MethodMonitorEvent(this);\n        publishEvent("begin",eventObject);\n        // 模拟方法执行：休眠5秒钟\n        TimeUnit.SECONDS.sleep(5);\n        publishEvent("end",eventObject);\n\n    }\n\n    private void publishEvent(String status,MethodMonitorEvent event) {\n        // 避免在事件处理期间，监听器被移除，这里为了安全做一个复制操作\n        List<MethodMonitorEventListener> copyListeners = ➥ new ArrayList<MethodMonitorEventListener>(listeners);\n        for (MethodMonitorEventListener listener : copyListeners) {\n            if ("begin".equals(status)) {\n                listener.onMethodBegin(event);\n            } else {\n                listener.onMethodEnd(event);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MethodMonitorEventPublisher publisher = new MethodMonitorEventPublisher();\n        publisher.addEventListener(new AbstractMethodMonitorEventListener());\n        publisher.methodMonitor();\n    }\n    // 省略实现\n    public void addEventListener(MethodMonitorEventListener listener) {}\n    public void removeEventListener(MethodMonitorEventListener listener) {}\n    public void removeAllListeners() {}\n\n\n对于事件发布者（事件源）通常需要关注两点：\n\n 1. 在合适的时机发布事件。此例中的 methodMonitor()方法是事件发布的源头，其在方法执行之前和结束之后两个时间点发布 MethodMonitorEvent 事件，每个时间点发布的事件都会传给相应的监听器进行处理。在具体实现时需要注意的是，事件发布是顺序执行，为了不影响处理性能，事件监听器的处理逻辑应尽量简单。\n 2. 事件监听器的管理。publisher 类中提供了事件监听器的注册与移除方法，这样客户端可以根据实际情况决定是否需要注册新的监听器或者移除某个监听器。如果这里没有提供 remove 方法，那么注册的监听器示例将一直被 MethodMonitorEventPublisher 引用，即使已经废弃不用了，也依然在发布者的监听器列表中，这会导致隐性的内存泄漏。\n\n# Spring 容器内的事件监听机制\n\nSpring 的 ApplicationContext 容器内部中的所有事件类型均继承自org.springframework.context.ApplicationEvent，容器中的所有监听器都实现org.springframework.context.ApplicationListener接口，并且以 bean 的形式注册在容器中。一旦在容器内发布 ApplicationEvent 及其子类型的事件，注册到容器的 ApplicationListener 就会对这些事件进行处理。\n\n你应该已经猜到是怎么回事了。\n\nApplicationEvent 继承自 EventObject，Spring 提供了一些默认的实现，比如：ContextClosedEvent表示容器在即将关闭时发布的事件类型，ContextRefreshedEvent表示容器在初始化或者刷新的时候发布的事件类型......\n\n容器内部使用 ApplicationListener 作为事件监听器接口定义，它继承自 EventListener。ApplicationContext 容器在启动时，会自动识别并加载 EventListener 类型的 bean，一旦容器内有事件发布，将通知这些注册到容器的 EventListener。\n\nApplicationContext 接口继承了 ApplicationEventPublisher 接口，该接口提供了void publishEvent(ApplicationEvent event)方法定义，不难看出，ApplicationContext 容器担当的就是事件发布者的角色。如果有兴趣可以查看AbstractApplicationContext.publishEvent(ApplicationEvent event)方法的源码：ApplicationContext 将事件的发布以及监听器的管理工作委托给ApplicationEventMulticaster接口的实现类。在容器启动时，会检查容器内是否存在名为 applicationEventMulticaster 的 ApplicationEventMulticaster 对象实例。如果有就使用其提供的实现，没有就默认初始化一个 SimpleApplicationEventMulticaster 作为实现。\n\n最后，如果我们业务需要在容器内部发布事件，只需要为其注入 ApplicationEventPublisher 依赖即可：实现 ApplicationEventPublisherAware 接口或者 ApplicationContextAware 接口(Aware 接口相关内容请回顾上文)。\n\n\n# 五、出神入化：揭秘自动配置原理\n\n典型的 Spring Boot 应用的启动类一般均位于src/main/java根路径下，比如MoonApplication类：\n\n@SpringBootApplication\npublic class MoonApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MoonApplication.class, args);\n    }\n}\n\n\n其中@SpringBootApplication开启组件扫描和自动配置，而SpringApplication.run则负责启动引导应用程序。@SpringBootApplication是一个复合Annotation，它将三个有用的注解组合在一起：\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    // ......\n}\n\n\n@SpringBootConfiguration就是@Configuration，它是 Spring 框架的注解，标明该类是一个JavaConfig配置类。而@ComponentScan启用组件扫描，前文已经详细讲解过，这里着重关注@EnableAutoConfiguration。\n\n@EnableAutoConfiguration注解表示开启 Spring Boot 自动配置功能，Spring Boot 会根据应用的依赖、自定义的 bean、classpath 下有没有某个类 等等因素来猜测你需要的 bean，然后注册到 IOC 容器中。那@EnableAutoConfiguration是如何推算出你的需求？首先看下它的定义：\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    // ......\n}\n\n\n你的关注点应该在@Import(EnableAutoConfigurationImportSelector.class)上了，前文说过，@Import注解用于导入类，并将这个类作为一个 bean 的定义注册到容器中，这里它将把EnableAutoConfigurationImportSelector作为 bean 注入到容器中，而这个类会将所有符合条件的@Configuration 配置都加载到容器中，看看它的代码：\n\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n    // 省略了大部分代码，保留一句核心代码\n    // 注意：SpringBoot最近版本中，这句代码被封装在一个单独的方法中\n    // SpringFactoriesLoader相关知识请参考前文\n    List<String> factories = new ArrayList<String>(new LinkedHashSet<String>(\n        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, this.beanClassLoader)));\n}\n\n\n这个类会扫描所有的 jar 包，将所有符合条件的@Configuration 配置类注入的容器中，何为符合条件，看看META-INF/spring.factories的文件内容：\n\n// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories\n// 配置的key = EnableAutoConfiguration，与代码中一致\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\\\n.....\n\n\n以DataSourceAutoConfiguration为例，看看 Spring Boot 是如何自动配置的：\n\n@Configuration\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })\npublic class DataSourceAutoConfiguration {\n}\n\n\n分别说一说：\n\n * @ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })：当 Classpath 中存在 DataSource 或者 EmbeddedDatabaseType 类时才启用这个配置，否则这个配置将被忽略。\n * @EnableConfigurationProperties(DataSourceProperties.class)：将 DataSource 的默认配置类注入到 IOC 容器中，DataSourceproperties 定义为：\n\n// 提供对datasource配置信息的支持，所有的配置前缀为：spring.datasource\n@ConfigurationProperties(prefix = "spring.datasource")\npublic class DataSourceProperties  {\n    private ClassLoader classLoader;\n    private Environment environment;\n    private String name = "testdb";\n    ......\n}\n\n\n * @Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })：导入其他额外的配置，就以DataSourcePoolMetadataProvidersConfiguration为例吧。\n\n@Configuration\npublic class DataSourcePoolMetadataProvidersConfiguration {\n\n    @Configuration\n    @ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)\n    static class TomcatDataSourcePoolMetadataProviderConfiguration {\n        @Bean\n        public DataSourcePoolMetadataProvider tomcatPoolDataSourceMetadataProvider() {\n            .....\n        }\n    }\n  ......\n}\n\n\nDataSourcePoolMetadataProvidersConfiguration 是数据库连接池提供者的一个配置类，即 Classpath 中存在org.apache.tomcat.jdbc.pool.DataSource.class，则使用 tomcat-jdbc 连接池，如果 Classpath 中存在HikariDataSource.class则使用 Hikari 连接池。\n\n这里仅描述了 DataSourceAutoConfiguration 的冰山一角，但足以说明 Spring Boot 如何利用条件话配置来实现自动配置的。回顾一下，@EnableAutoConfiguration中导入了 EnableAutoConfigurationImportSelector 类，而这个类的selectImports()通过 SpringFactoriesLoader 得到了大量的配置类，而每一个配置类则根据条件化配置来做出决策，以实现自动配置。\n\n整个流程很清晰，但漏了一个大问题：EnableAutoConfigurationImportSelector.selectImports()是何时执行的？其实这个方法会在容器启动过程中执行：AbstractApplicationContext.refresh()，更多的细节在下一小节中说明。\n\n\n# 六、启动引导：Spring Boot 应用启动的秘密\n\n\n# 6.1 SpringApplication 初始化\n\nSpringBoot 整个启动流程分为两个步骤：初始化一个 SpringApplication 对象、执行该对象的 run 方法。看下 SpringApplication 的初始化流程，SpringApplication 的构造方法中调用 initialize(Object[] sources)方法，其代码如下：\n\nprivate void initialize(Object[] sources) {\n     if (sources != null && sources.length > 0) {\n         this.sources.addAll(Arrays.asList(sources));\n     }\n     // 判断是否是Web项目\n     this.webEnvironment = deduceWebEnvironment();\n     setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n     setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n     // 找到入口类\n     this.mainApplicationClass = deduceMainApplicationClass();\n}\n\n\n初始化流程中最重要的就是通过 SpringFactoriesLoader 找到spring.factories文件中配置的ApplicationContextInitializer和ApplicationListener两个接口的实现类名称，以便后期构造相应的实例。ApplicationContextInitializer的主要目的是在ConfigurableApplicationContext做 refresh 之前，对 ConfigurableApplicationContext 实例做进一步的设置或处理。ConfigurableApplicationContext 继承自 ApplicationContext，其主要提供了对 ApplicationContext 进行设置的能力。\n\n实现一个 ApplicationContextInitializer 非常简单，因为它只有一个方法，但大多数情况下我们没有必要自定义一个 ApplicationContextInitializer，即便是 Spring Boot 框架，它默认也只是注册了两个实现，毕竟 Spring 的容器已经非常成熟和稳定，你没有必要来改变它。\n\n而ApplicationListener的目的就没什么好说的了，它是 Spring 框架对 Java 事件监听机制的一种框架实现，具体内容在前文 Spring 事件监听机制这个小节有详细讲解。这里主要说说，如果你想为 Spring Boot 应用添加监听器，该如何实现？\n\nSpring Boot 提供两种方式来添加自定义监听器：\n\n * 通过SpringApplication.addListeners(ApplicationListener... listeners)或者SpringApplication.setListeners(Collection> listeners)两个方法来添加一个或者多个自定义监听器\n * 既然 SpringApplication 的初始化流程中已经从spring.factories中获取到ApplicationListener的实现类，那么我们直接在自己的 jar 包的META-INF/spring.factories文件中新增配置即可：\n\norg.springframework.context.ApplicationListener=\\\ncn.moondev.listeners.xxxxListener\\\n\n\n关于 SpringApplication 的初始化，我们就说这么多。\n\n\n# 6.2 Spring Boot 启动流程\n\nSpring Boot 应用的整个启动流程都封装在 SpringApplication.run 方法中，其整个流程真的是太长太长了，但本质上就是在 Spring 容器启动的基础上做了大量的扩展，按照这个思路来看看源码：\n\npublic ConfigurableApplicationContext run(String... args) {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        ConfigurableApplicationContext context = null;\n        FailureAnalyzers analyzers = null;\n        configureHeadlessProperty();\n        // ①\n        SpringApplicationRunListeners listeners = getRunListeners(args);\n        listeners.starting();\n        try {\n            // ②\n            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n            ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);\n            // ③\n            Banner printedBanner = printBanner(environment);\n            // ④\n            context = createApplicationContext();\n            // ⑤\n            analyzers = new FailureAnalyzers(context);\n            // ⑥\n            prepareContext(context, environment, listeners, applicationArguments,printedBanner);\n            // ⑦\n            refreshContext(context);\n            // ⑧\n            afterRefresh(context, applicationArguments);\n            // ⑨\n            listeners.finished(context, null);\n            stopWatch.stop();\n            return context;\n        }\n        catch (Throwable ex) {\n            handleRunFailure(context, listeners, analyzers, ex);\n            throw new IllegalStateException(ex);\n        }\n    }\n\n\n① 通过 SpringFactoriesLoader 查找并加载所有的SpringApplicationRunListeners，通过调用 starting()方法通知所有的 SpringApplicationRunListeners：应用开始启动了。SpringApplicationRunListeners 其本质上就是一个事件发布者，它在 SpringBoot 应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理。还记得初始化流程中，SpringApplication 加载了一系列 ApplicationListener 吗？这个启动流程中没有发现有发布事件的代码，其实都已经在 SpringApplicationRunListeners 这儿实现了。\n\n简单的分析一下其实现流程，首先看下 SpringApplicationRunListener 的源码：\n\npublic interface SpringApplicationRunListener {\n\n    // 运行run方法时立即调用此方法，可以用户非常早期的初始化工作\n    void starting();\n\n    // Environment准备好后，并且ApplicationContext创建之前调用\n    void environmentPrepared(ConfigurableEnvironment environment);\n\n    // ApplicationContext创建好后立即调用\n    void contextPrepared(ConfigurableApplicationContext context);\n\n    // ApplicationContext加载完成，在refresh之前调用\n    void contextLoaded(ConfigurableApplicationContext context);\n\n    // 当run方法结束之前调用\n    void finished(ConfigurableApplicationContext context, Throwable exception);\n\n}\n\n\nSpringApplicationRunListener 只有一个实现类：EventPublishingRunListener。① 处的代码只会获取到一个 EventPublishingRunListener 的实例，我们来看看 starting()方法的内容：\n\npublic void starting() {\n    // 发布一个ApplicationStartedEvent\n    this.initialMulticaster.multicastEvent(new ApplicationStartedEvent(this.application, this.args));\n}\n\n\n顺着这个逻辑，你可以在 ② 处的prepareEnvironment()方法的源码中找到listeners.environmentPrepared(environment);即 SpringApplicationRunListener 接口的第二个方法，那不出你所料，environmentPrepared()又发布了另外一个事件ApplicationEnvironmentPreparedEvent。接下来会发生什么，就不用我多说了吧。\n\n② 创建并配置当前应用将要使用的Environment，Environment 用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当 Environment 准备好后，在整个应用的任何时候，都可以从 Environment 中获取资源。\n\n总结起来，② 处的两句代码，主要完成以下几件事：\n\n * 判断 Environment 是否存在，不存在就创建（如果是 web 项目就创建StandardServletEnvironment，否则创建StandardEnvironment）\n * 配置 Environment：配置 profile 以及 properties\n * 调用 SpringApplicationRunListener 的environmentPrepared()方法，通知事件监听者：应用的 Environment 已经准备好\n\n③、SpringBoot 应用在启动时会输出这样的东西：\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.5.6.RELEASE)\n\n\n如果想把这个东西改成自己的涂鸦，你可以研究以下 Banner 的实现，这个任务就留给你们吧。\n\n④、根据是否是 web 项目，来创建不同的 ApplicationContext 容器。\n\n⑤、创建一系列FailureAnalyzer，创建流程依然是通过 SpringFactoriesLoader 获取到所有实现 FailureAnalyzer 接口的 class，然后在创建对应的实例。FailureAnalyzer 用于分析故障并提供相关诊断信息。\n\n⑥、初始化 ApplicationContext，主要完成以下工作：\n\n * 将准备好的 Environment 设置给 ApplicationContext\n * 遍历调用所有的 ApplicationContextInitializer 的initialize()方法来对已经创建好的 ApplicationContext 进行进一步的处理\n * 调用 SpringApplicationRunListener 的contextPrepared()方法，通知所有的监听者：ApplicationContext 已经准备完毕\n * 将所有的 bean 加载到容器中\n * 调用 SpringApplicationRunListener 的contextLoaded()方法，通知所有的监听者：ApplicationContext 已经装载完毕\n\n⑦、调用 ApplicationContext 的refresh()方法，完成 IoC 容器可用的最后一道工序。从名字上理解为刷新容器，那何为刷新？就是插手容器的启动，联系一下第一小节的内容。那如何刷新呢？且看下面代码：\n\n// 摘自refresh()方法中一句代码\ninvokeBeanFactoryPostProcessors(beanFactory);\n\n\n看看这个方法的实现：\n\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n    ......\n}\n\n\n获取到所有的BeanFactoryPostProcessor来对容器做一些额外的操作。BeanFactoryPostProcessor 允许我们在容器实例化相应对象之前，对注册到容器的 BeanDefinition 所保存的信息做一些额外的操作。这里的 getBeanFactoryPostProcessors()方法可以获取到 3 个 Processor：\n\nConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor\nSharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor\nConfigFileApplicationListener$PropertySourceOrderingPostProcessor\n\n\n不是有那么多 BeanFactoryPostProcessor 的实现类，为什么这儿只有这 3 个？因为在初始化流程获取到的各种 ApplicationContextInitializer 和 ApplicationListener 中，只有上文 3 个做了类似于如下操作：\n\npublic void initialize(ConfigurableApplicationContext context) {\n    context.addBeanFactoryPostProcessor(new ConfigurationWarningsPostProcessor(getChecks()));\n}\n\n\n然后你就可以进入到PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()方法了，这个方法除了会遍历上面的 3 个 BeanFactoryPostProcessor 处理外，还会获取类型为BeanDefinitionRegistryPostProcessor的 bean：org.springframework.context.annotation.internalConfigurationAnnotationProcessor，对应的 Class 为ConfigurationClassPostProcessor。ConfigurationClassPostProcessor用于解析处理各种注解，包括：@Configuration、@ComponentScan、@Import、@PropertySource、@ImportResource、@Bean。当处理@import注解的时候，就会调用自动配置这一小节中的EnableAutoConfigurationImportSelector.selectImports()来完成自动配置功能。其他的这里不再多讲，如果你有兴趣，可以查阅参考资料 6。\n\n⑧、查找当前 context 中是否注册有 CommandLineRunner 和 ApplicationRunner，如果有则遍历执行它们。\n\n⑨、执行所有 SpringApplicationRunListener 的 finished()方法。\n\n这就是 Spring Boot 的整个启动流程，其核心就是在 Spring 容器初始化并启动的基础上加入各种扩展点，这些扩展点包括：ApplicationContextInitializer、ApplicationListener 以及各种 BeanFactoryPostProcessor 等等。你对整个流程的细节不必太过关注，甚至没弄明白也没有关系，你只要理解这些扩展点是在何时如何工作的，能让它们为你所用即可。\n\n整个启动流程确实非常复杂，可以查询参考资料中的部分章节和内容，对照着源码，多看看，我想最终你都能弄清楚的。言而总之，Spring 才是核心，理解清楚 Spring 容器的启动流程，那 Spring Boot 启动流程就不在话下了。\n\n\n# 参考资料\n\n[1]王福强 著；springboot 揭秘：快速构建微服务体系; 机械工业出版社, 2016 [2]王福强 著；spring 揭秘; 人民邮件出版社, 2009 [3]craig walls 著；丁雪丰 译；spring boot 实战；中国工信出版集团 人民邮电出版社，2016 [4]深入探讨 java 类加载器 : www.ibm.com/developerwo… [5]spring boot 实战：自动配置原理分析 : blog.csdn.net/liaokailin/… [6]spring boot实战：spring boot bean加载源码分析： blog.csdn.net/liaokailin/…',normalizedContent:'# springboot 知识图谱\n\n>  1. 预警：本文非常长，建议先 mark 后看，也许是最后一次写这么长的文章\n>  2. 说明：前面有 4 个小节关于 spring 的基础知识，分别是：ioc 容器、javaconfig、事件监听、springfactoriesloader 详解，它们占据了本文的大部分内容，虽然它们之间可能没有太多的联系，但这些知识对于理解 spring boot 的核心原理至关重要，如果你对 spring 框架烂熟于心，完全可以跳过这 4 个小节。正是因为这个系列的文章是由这些看似不相关的知识点组成，因此取名知识清单。\n\n在过去两三年的 spring 生态圈，最让人兴奋的莫过于 spring boot 框架。或许从命名上就能看出这个框架的设计初衷：快速的启动 spring 应用。因而 spring boot 应用本质上就是一个基于 spring 框架的应用，它是 spring 对“约定优先于配置”理念的最佳实践产物，它能够帮助开发者更快速高效地构建基于 spring 生态圈的应用。\n\n那 spring boot 有何魔法？自动配置、起步依赖、actuator、命令行界面(cli) 是 spring boot 最重要的 4 大核心特性，其中 cli 是 spring boot 的可选特性，虽然它功能强大，但也引入了一套不太常规的开发模型，因而这个系列的文章仅关注其它 3 种特性。如文章标题，本文是这个系列的第一部分，将为你打开 spring boot 的大门，重点为你剖析其启动流程以及自动配置实现原理。要掌握这部分核心内容，理解一些 spring 框架的基础知识，将会让你事半功倍。\n\n\n# 一、抛砖引玉：探索 spring ioc 容器\n\n如果有看过springapplication.run()方法的源码，spring boot 冗长无比的启动流程一定会让你抓狂，透过现象看本质，springapplication 只是将一个典型的 spring 应用的启动流程进行了扩展，因此，透彻理解 spring 容器是打开 spring boot 大门的一把钥匙。\n\n\n# 1.1、spring ioc 容器\n\n可以把 spring ioc 容器比作一间餐馆，当你来到餐馆，通常会直接招呼服务员：点菜！至于菜的原料是什么？如何用原料把菜做出来？可能你根本就不关心。ioc 容器也是一样，你只需要告诉它需要某个 bean，它就把对应的实例（instance）扔给你，至于这个 bean 是否依赖其他组件，怎样完成它的初始化，根本就不需要你关心。\n\n作为餐馆，想要做出菜肴，得知道菜的原料和菜谱，同样地，ioc 容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。beandefinition对象就承担了这个责任：容器中的每一个 bean 都会有一个对应的 beandefinition 实例，该实例负责保存 bean 对象的所有必要信息，包括 bean 对象的 class 类型、是否是抽象类、构造方法和参数、其它属性等等。当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的 bean 实例。\n\n原材料已经准备好（把 beandefinition 看着原料），开始做菜吧，等等，你还需要一份菜谱，beandefinitionregistry和beanfactory就是这份菜谱，beandefinitionregistry 抽象出 bean 的注册逻辑，而 beanfactory 则抽象出了 bean 的管理逻辑，而各个 beanfactory 的实现类就具体承担了 bean 的注册以及管理工作。它们之间的关系就如下图：\n\nbeanfactory、beandefinitionregistry 关系图（来自：spring 揭秘）\n\ndefaultlistablebeanfactory作为一个比较通用的 beanfactory 实现，它同时也实现了 beandefinitionregistry 接口，因此它就承担了 bean 的注册管理工作。从图中也可以看出，beanfactory 接口中主要包含 getbean、containbean、gettype、getaliases 等管理 bean 的方法，而 beandefinitionregistry 接口则包含 registerbeandefinition、removebeandefinition、getbeandefinition 等注册管理 beandefinition 的方法。\n\n下面通过一段简单的代码来模拟 beanfactory 底层是如何工作的：\n\n// 默认容器实现\ndefaultlistablebeanfactory beanregistry = new defaultlistablebeanfactory();\n// 根据业务对象构造相应的beandefinition\nabstractbeandefinition definition = new rootbeandefinition(business.class,true);\n// 将bean定义注册到容器中\nbeanregistry.registerbeandefinition("beanname",definition);\n// 如果有多个bean，还可以指定各个bean之间的依赖关系\n// ........\n\n// 然后可以从容器中获取这个bean的实例\n// 注意：这里的beanregistry其实实现了beanfactory接口，所以可以强转，\n// 单纯的beandefinitionregistry是无法强制转换到beanfactory类型的\nbeanfactory container = (beanfactory)beanregistry;\nbusiness business = (business)container.getbean("beanname");\n\n\n这段代码仅为了说明 beanfactory 底层的大致工作流程，实际情况会更加复杂，比如 bean 之间的依赖关系可能定义在外部配置文件(xml/properties)中、也可能是注解方式。spring ioc 容器的整个工作流程大致可以分为两个阶段：\n\n①、容器启动阶段\n\n容器启动时，会通过某种途径加载configuration metadata。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如：beandefinitionreader，beandefinitionreader 会对加载的configuration metadata进行解析和分析，并将分析后的信息组装为相应的 beandefinition，最后把这些保存了 bean 定义的 beandefinition，注册到相应的 beandefinitionregistry，这样容器的启动工作就完成了。这个阶段主要完成一些准备性工作，更侧重于 bean 对象管理信息的收集，当然一些验证性或者辅助性的工作也在这一阶段完成。\n\n来看一个简单的例子吧，过往，所有的 bean 都定义在 xml 配置文件中，下面的代码将模拟 beanfactory 如何从配置文件中加载 bean 的定义以及依赖关系：\n\n// 通常为beandefinitionregistry的实现类，这里以defaultlistabebeanfactory为例\nbeandefinitionregistry beanregistry = new defaultlistablebeanfactory();\n// xmlbeandefinitionreader实现了beandefinitionreader接口，用于解析xml文件\nxmlbeandefinitionreader beandefinitionreader = new xmlbeandefinitionreaderimpl(beanregistry);\n// 加载配置文件\nbeandefinitionreader.loadbeandefinitions("classpath:spring-bean.xml");\n\n// 从容器中获取bean实例\nbeanfactory container = (beanfactory)beanregistry;\nbusiness business = (business)container.getbean("beanname");\n\n\n②、bean 的实例化阶段\n\n经过第一阶段，所有 bean 定义都通过 beandefinition 的方式注册到 beandefinitionregistry 中，当某个请求通过容器的 getbean 方法请求某个对象，或者因为依赖关系容器需要隐式的调用 getbean 时，就会触发第二阶段的活动：容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的 beandefinition 所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完毕后，容器会立即将其返回给请求方法使用。\n\nbeanfactory 只是 spring ioc 容器的一种实现，如果没有特殊指定，它采用采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。而在实际场景下，我们更多的使用另外一种类型的容器：applicationcontext，它构建在 beanfactory 之上，属于更高级的容器，除了具有 beanfactory 的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的 bean，在容器启动时全部完成初始化和依赖注入操作。\n\n\n# 1.2、spring 容器扩展机制\n\nioc 容器负责管理容器中所有 bean 的生命周期，而在 bean 生命周期的不同阶段，spring 提供了不同的扩展点来改变 bean 的命运。在容器的启动阶段，beanfactorypostprocessor允许我们在容器实例化相应对象之前，对注册到容器的 beandefinition 所保存的信息做一些额外的操作，比如修改 bean 定义的某些属性或者增加其他信息等。\n\n如果要自定义扩展类，通常需要实现org.springframework.beans.factory.config.beanfactorypostprocessor接口，与此同时，因为容器中可能有多个 beanfactorypostprocessor，可能还需要实现org.springframework.core.ordered接口，以保证 beanfactorypostprocessor 按照顺序执行。spring 提供了为数不多的 beanfactorypostprocessor 实现，我们以propertyplaceholderconfigurer来说明其大致的工作流程。\n\n在 spring 项目的 xml 配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置到独立的 properties 文件，这样可以将散落在不同 xml 文件中的配置集中管理，而且也方便运维根据不同的环境进行配置不同的值。这个非常实用的功能就是由 propertyplaceholderconfigurer 负责实现的。\n\n根据前文，当 beanfactory 在第一阶段加载完所有配置信息时，beanfactory 中保存的对象的属性还是以占位符方式存在的，比如${jdbc.mysql.url}。当 propertyplaceholderconfigurer 作为 beanfactorypostprocessor 被应用时，它会使用 properties 配置文件中的值来替换相应的 beandefinition 中占位符所表示的属性值。当需要实例化 bean 时，bean 定义中的属性值就已经被替换成我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考其源码。\n\n与之相似的，还有beanpostprocessor，其存在于对象实例化阶段。跟 beanfactorypostprocessor 类似，它会处理容器内所有符合条件并且已经实例化后的对象。简单的对比，beanfactorypostprocessor 处理 bean 的定义，而 beanpostprocessor 则处理 bean 完成实例化后的对象。beanpostprocessor 定义了两个接口：\n\npublic interface beanpostprocessor {\n    // 前置处理\n    object postprocessbeforeinitialization(object bean, string beanname) throws beansexception;\n    // 后置处理\n    object postprocessafterinitialization(object bean, string beanname) throws beansexception;\n}\n\n\n为了理解这两个方法执行的时机，简单的了解下 bean 的整个生命周期：\n\npostprocessbeforeinitialization()方法与postprocessafterinitialization()分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法中都传入了 bean 对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这儿几乎可以对传入的实例执行任何操作。注解、aop 等功能的实现均大量使用了beanpostprocessor，比如有一个自定义注解，你完全可以实现 beanpostprocessor 的接口，在其中判断 bean 对象的脑袋上是否有该注解，如果有，你可以对这个 bean 实例执行任何操作，想想是不是非常的简单？\n\n再来看一个更常见的例子，在 spring 中经常能够看到各种各样的 aware 接口，其作用就是在对象实例化完成以后将 aware 接口定义中规定的依赖注入到当前实例中。比如最常见的applicationcontextaware接口，实现了这个接口的类都可以获取到一个 applicationcontext 对象。当容器中每个对象的实例化过程走到 beanpostprocessor 前置处理这一步时，容器会检测到之前注册到容器的 applicationcontextawareprocessor，然后就会调用其 postprocessbeforeinitialization()方法，检查并设置 aware 相关依赖。看看代码吧，是不是很简单：\n\n// 代码来自：org.springframework.context.support.applicationcontextawareprocessor\n// 其postprocessbeforeinitialization方法调用了invokeawareinterfaces方法\nprivate void invokeawareinterfaces(object bean) {\n    if (bean instanceof environmentaware) {\n        ((environmentaware) bean).setenvironment(this.applicationcontext.getenvironment());\n    }\n    if (bean instanceof applicationcontextaware) {\n        ((applicationcontextaware) bean).setapplicationcontext(this.applicationcontext);\n    }\n    // ......\n}\n\n\n最后总结一下，本小节内容和你一起回顾了 spring 容器的部分核心内容，限于篇幅不能写更多，但理解这部分内容，足以让您轻松理解 spring boot 的启动原理，如果在后续的学习过程中遇到一些晦涩难懂的知识，再回过头来看看 spring 的核心知识，也许有意想不到的效果。也许 spring boot 的中文资料很少，但 spring 的中文资料和书籍有太多太多，总有东西能给你启发。\n\n\n# 二、夯实基础：javaconfig 与常见 annotation\n\n\n# 2.1、javaconfig\n\n我们知道bean是 spring ioc 中非常核心的概念，spring 容器负责 bean 的生命周期的管理。在最初，spring 使用 xml 配置文件的方式来描述 bean 的定义以及相互间的依赖关系，但随着 spring 的发展，越来越多的人对这种方式表示不满，因为 spring 项目的所有业务类均以 bean 的形式配置在 xml 文件中，造成了大量的 xml 文件，使项目变得复杂且难以管理。\n\n后来，基于纯 java annotation 依赖注入框架guice出世，其性能明显优于采用 xml 方式的 spring，甚至有部分人认为，guice可以完全取代 spring（guice仅是一个轻量级 ioc 框架，取代 spring 还差的挺远）。正是这样的危机感，促使 spring 及社区推出并持续完善了javaconfig子项目，它基于 java 代码和 annotation 注解来描述 bean 之间的依赖绑定关系。比如，下面是使用 xml 配置方式来描述 bean 的定义：\n\n<bean id="bookservice" class="cn.moondev.service.bookserviceimpl"></bean>\n\n\n而基于 javaconfig 的配置形式是这样的：\n\n@configuration\npublic class moonbookconfiguration {\n\n    // 任何标志了@bean的方法，其返回值将作为一个bean注册到spring的ioc容器中\n    // 方法名默认成为该bean定义的id\n    @bean\n    public bookservice bookservice() {\n        return new bookserviceimpl();\n    }\n}\n\n\n如果两个 bean 之间有依赖关系的话，在 xml 配置中应该是这样：\n\n<bean id="bookservice" class="cn.moondev.service.bookserviceimpl">\n    <property name="dependencyservice" ref="dependencyservice"/>\n</bean>\n\n<bean id="otherservice" class="cn.moondev.service.otherserviceimpl">\n    <property name="dependencyservice" ref="dependencyservice"/>\n</bean>\n\n<bean id="dependencyservice" class="dependencyserviceimpl"/>\n\n\n而在 javaconfig 中则是这样：\n\n@configuration\npublic class moonbookconfiguration {\n\n    // 如果一个bean依赖另一个bean，则直接调用对应javaconfig类中依赖bean的创建方法即可\n    // 这里直接调用dependencyservice()\n    @bean\n    public bookservice bookservice() {\n        return new bookserviceimpl(dependencyservice());\n    }\n\n    @bean\n    public otherservice otherservice() {\n        return new otherserviceimpl(dependencyservice());\n    }\n\n    @bean\n    public dependencyservice dependencyservice() {\n        return new dependencyserviceimpl();\n    }\n}\n\n\n你可能注意到这个示例中，有两个 bean 都依赖于 dependencyservice，也就是说当初始化 bookservice 时会调用dependencyservice()，在初始化 otherservice 时也会调用dependencyservice()，那么问题来了？这时候 ioc 容器中是有一个 dependencyservice 实例还是两个？这个问题留着大家思考吧，这里不再赘述。\n\n\n# 2.2、@componentscan\n\n@componentscan注解对应 xml 配置形式中的``元素，表示启用组件扫描，spring 会自动扫描所有通过注解配置的 bean，然后将其注册到 ioc 容器中。我们可以通过basepackages等属性来指定@componentscan自动扫描的范围，如果不指定，默认从声明@componentscan所在类的package进行扫描。正因为如此，springboot 的启动类都默认在src/main/java下。\n\n\n# 2.3、@import\n\n@import注解用于导入配置类，举个简单的例子：\n\n@configuration\npublic class moonbookconfiguration {\n    @bean\n    public bookservice bookservice() {\n        return new bookserviceimpl();\n    }\n}\n\n\n现在有另外一个配置类，比如：moonuserconfiguration，这个配置类中有一个 bean 依赖于moonbookconfiguration中的 bookservice，如何将这两个 bean 组合在一起？借助@import即可：\n\n@configuration\n// 可以同时导入多个配置类，比如：@import({a.class,b.class})\n@import(moonbookconfiguration.class)\npublic class moonuserconfiguration {\n    @bean\n    public userservice userservice(bookservice bookservice) {\n        return new bookserviceimpl(bookservice);\n    }\n}\n\n\n需要注意的是，在 4.2 之前，@import注解只支持导入配置类，但是在 4.2 之后，它支持导入普通类，并将这个类作为一个 bean 的定义注册到 ioc 容器中。\n\n\n# 2.4、@conditional\n\n@conditional注解表示在满足某种条件后才初始化一个 bean 或者启用某些配置。它一般用在由@component、@service、@configuration等注解标识的类上面，或者由@bean标记的方法上。如果一个@configuration类标记了@conditional，则该类中所有标识了@bean的方法和@import注解导入的相关类将遵从这些条件。\n\n在 spring 里可以很方便的编写你自己的条件类，所要做的就是实现condition接口，并覆盖它的matches()方法。举个例子，下面的简单条件类表示只有在classpath里存在jdbctemplate类时才生效：\n\npublic class jdbctemplatecondition implements condition {\n\n    @override\n    public boolean matches(conditioncontext conditioncontext, annotatedtypemetadata annotatedtypemetadata) {\n        try {\n        conditioncontext.getclassloader().loadclass("org.springframework.jdbc.core.jdbctemplate");\n            return true;\n        } catch (classnotfoundexception e) {\n            e.printstacktrace();\n        }\n        return false;\n    }\n}\n\n\n当你用 java 来声明 bean 的时候，可以使用这个自定义条件类：\n\n@conditional(jdbctemplatecondition.class)\n@service\npublic myservice service() {\n    ......\n}\n\n\n这个例子中只有当jdbctemplatecondition类的条件成立时才会创建 myservice 这个 bean。也就是说 myservice 这 bean 的创建条件是classpath里面包含jdbctemplate，否则这个 bean 的声明就会被忽略掉。\n\nspring boot定义了很多有趣的条件，并把他们运用到了配置类上，这些配置类构成了spring boot的自动配置的基础。spring boot运用条件化配置的方法是：定义多个特殊的条件化注解，并将它们用到配置类上。下面列出了spring boot提供的部分条件化注解：\n\n条件化注解                             配置生效条件\n@conditionalonbean                配置了某个特定 bean\n@conditionalonmissingbean         没有配置特定的 bean\n@conditionalonclass               classpath 里有指定的类\n@conditionalonmissingclass        classpath 里没有指定的类\n@conditionalonexpression          给定的 spring expression language 表达式计算结果为 true\n@conditionalonjava                java 的版本匹配特定指或者一个范围值\n@conditionalonproperty            指定的配置属性要有一个明确的值\n@conditionalonresource            classpath 里有指定的资源\n@conditionalonwebapplication      这是一个 web 应用程序\n@conditionalonnotwebapplication   这不是一个 web 应用程序\n\n\n# 2.5、@configurationproperties 与@enableconfigurationproperties\n\n当某些属性的值需要配置的时候，我们一般会在application.properties文件中新建配置项，然后在 bean 中使用@value注解来获取配置的值，比如下面配置数据源的代码。\n\n// jdbc config\njdbc.mysql.url=jdbc:mysql://localhost:3306/sampledb\njdbc.mysql.username=root\njdbc.mysql.password=123456\n......\n\n// 配置数据源\n@configuration\npublic class hikaridatasourceconfiguration {\n\n    @value("jdbc.mysql.url")\n    public string url;\n    @value("jdbc.mysql.username")\n    public string user;\n    @value("jdbc.mysql.password")\n    public string password;\n\n    @bean\n    public hikaridatasource datasource() {\n        hikariconfig hikariconfig = new hikariconfig();\n        hikariconfig.setjdbcurl(url);\n        hikariconfig.setusername(user);\n        hikariconfig.setpassword(password);\n        // 省略部分代码\n        return new hikaridatasource(hikariconfig);\n    }\n}\n\n\n使用@value注解注入的属性通常都比较简单，如果同一个配置在多个地方使用，也存在不方便维护的问题（考虑下，如果有几十个地方在使用某个配置，而现在你想改下名字，你改怎么做？）。对于更为复杂的配置，spring boot 提供了更优雅的实现方式，那就是@configurationproperties注解。我们可以通过下面的方式来改写上面的代码：\n\n@component\n//  还可以通过@propertysource("classpath:jdbc.properties")来指定配置文件\n@configurationproperties("jdbc.mysql")\n// 前缀=jdbc.mysql，会在配置文件中寻找jdbc.mysql.*的配置项\npulic class jdbcconfig {\n    public string url;\n    public string username;\n    public string password;\n}\n\n@configuration\npublic class hikaridatasourceconfiguration {\n\n    @autowired\n    public jdbcconfig config;\n\n    @bean\n    public hikaridatasource datasource() {\n        hikariconfig hikariconfig = new hikariconfig();\n        hikariconfig.setjdbcurl(config.url);\n        hikariconfig.setusername(config.username);\n        hikariconfig.setpassword(config.password);\n        // 省略部分代码\n        return new hikaridatasource(hikariconfig);\n    }\n}\n\n\n@configurationproperties对于更为复杂的配置，处理起来也是得心应手，比如有如下配置文件：\n\n#app\napp.menus[0].title=home\napp.menus[0].name=home\napp.menus[0].path=/\napp.menus[1].title=login\napp.menus[1].name=login\napp.menus[1].path=/login\n\napp.compiler.timeout=5\napp.compiler.output-folder=/temp/\n\napp.error=/error/\n\n\n可以定义如下配置类来接收这些属性\n\n@component\n@configurationproperties("app")\npublic class appproperties {\n\n    public string error;\n    public list<menu> menus = new arraylist<>();\n    public compiler compiler = new compiler();\n\n    public static class menu {\n        public string name;\n        public string path;\n        public string title;\n    }\n\n    public static class compiler {\n        public string timeout;\n        public string outputfolder;\n    }\n}\n\n\n@enableconfigurationproperties注解表示对@configurationproperties的内嵌支持，默认会将对应 properties class 作为 bean 注入的 ioc 容器中，即在相应的 properties 类上不用加@component注解。\n\n\n# 三、削铁如泥：springfactoriesloader 详解\n\njvm 提供了 3 种类加载器：bootstrapclassloader、extclassloader、appclassloader分别加载 java 核心类库、扩展类库以及应用的类路径(classpath)下的类库。jvm 通过双亲委派模型进行类的加载，我们也可以通过继承java.lang.classloader实现自己的类加载器。\n\n何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的 bootstrapclassloader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。\n\n采用双亲委派模型的一个好处是保证使用不同类加载器最终得到的都是同一个对象，这样就可以保证 java 核心库的类型安全，比如，加载位于 rt.jar 包中的java.lang.object类，不管是哪个加载器加载这个类，最终都是委托给顶层的 bootstrapclassloader 来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个 object 对象。查看 classloader 的源码，对双亲委派模型会有更直观的认识：\n\nprotected class<?> loadclass(string name, boolean resolve) {\n    synchronized (getclassloadinglock(name)) {\n    // 首先，检查该类是否已经被加载，如果从jvm缓存中找到该类，则直接返回\n    class<?> c = findloadedclass(name);\n    if (c == null) {\n        try {\n            // 遵循双亲委派的模型，首先会通过递归从父加载器开始找，\n            // 直到父类加载器是bootstrapclassloader为止\n            if (parent != null) {\n                c = parent.loadclass(name, false);\n            } else {\n                c = findbootstrapclassornull(name);\n            }\n        } catch (classnotfoundexception e) {}\n        if (c == null) {\n            // 如果还找不到，尝试通过findclass方法去寻找\n            // findclass是留给开发者自己实现的，也就是说\n            // 自定义类加载器时，重写此方法即可\n           c = findclass(name);\n        }\n    }\n    if (resolve) {\n        resolveclass(c);\n    }\n    return c;\n    }\n}\n\n\n但双亲委派模型并不能解决所有的类加载器问题，比如，java 提供了很多服务提供者接口(service provider interface，spi)，允许第三方为这些接口提供实现。常见的 spi 有 jdbc、jndi、jaxp 等，这些 spi 的接口由核心类库提供，却由第三方实现，这样就存在一个问题：spi 的接口是 java 核心库的一部分，是由 bootstrapclassloader 加载的；spi 实现的 java 类一般是由 appclassloader 来加载的。bootstrapclassloader 是无法找到 spi 的实现类的，因为它只加载 java 的核心库。它也不能代理给 appclassloader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。\n\n线程上下文类加载器(contextclassloader)正好解决了这个问题。从名称上看，可能会误解为它是一种新的类加载器，实际上，它仅仅是 thread 类的一个变量而已，可以通过setcontextclassloader(classloader cl)和getcontextclassloader()来设置和获取该对象。如果不做任何的设置，java 应用的线程的上下文类加载器默认就是 appclassloader。在核心类库使用 spi 接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到 spi 实现的类。线程上下文类加载器在很多 spi 的实现中都会用到。但在 jdbc 中，你可能会看到一种更直接的实现方式，比如，jdbc 驱动管理java.sql.driver中的loadinitialdrivers()方法中，你可以直接看到 jdk 是如何加载驱动的：\n\nfor (string adriver : driverslist) {\n    try {\n        // 直接使用appclassloader\n        class.forname(adriver, true, classloader.getsystemclassloader());\n    } catch (exception ex) {\n        println("drivermanager.initialize: load failed: " + ex);\n    }\n}\n\n\n其实讲解线程上下文类加载器，最主要是让大家在看到thread.currentthread().getclassloader()和thread.currentthread().getcontextclassloader()时不会一脸懵逼，这两者除了在许多底层框架中取得的 classloader 可能会有所不同外，其他大多数业务场景下都是一样的，大家只要知道它是为了解决什么问题而存在的即可。\n\n类加载器除了加载 class 外，还有一个非常重要功能，就是加载资源，它可以从 jar 包中读取任何资源文件，比如，classloader.getresources(string name)方法就是用于读取 jar 包中的资源文件，其代码如下：\n\npublic enumeration<url> getresources(string name) throws ioexception {\n    enumeration<url>[] tmp = (enumeration<url>[]) new enumeration<?>[2];\n    if (parent != null) {\n        tmp[0] = parent.getresources(name);\n    } else {\n        tmp[0] = getbootstrapresources(name);\n    }\n    tmp[1] = findresources(name);\n    return new compoundenumeration<>(tmp);\n}\n\n\n是不是觉得有点眼熟，不错，它的逻辑其实跟类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到 bootstrapclassloader，最后才轮到自己查找。而不同的类加载器负责扫描不同路径下的 jar 包，就如同加载 class 一样，最后会扫描所有的 jar 包，找到符合条件的资源文件。\n\n类加载器的findresources(name)方法会遍历其负责加载的所有 jar 包，找到 jar 包中名称为 name 的资源文件，这里的资源可以是任何文件，甚至是.class 文件，比如下面的示例，用于查找 array.class 文件：\n\n// 寻找array.class文件\npublic static void main(string[] args) throws exception{\n    // array.class的完整路径\n    string name = "java/sql/array.class";\n    enumeration<url> urls = thread.currentthread().getcontextclassloader().getresources(name);\n    while (urls.hasmoreelements()) {\n        url url = urls.nextelement();\n        system.out.println(url.tostring());\n    }\n}\n\n\n运行后可以得到如下结果：\n\n$java_home/jre/lib/rt.jar!/java/sql/array.class\n\n\n根据资源文件的 url，可以构造相应的文件来读取资源内容。\n\n看到这里，你可能会感到挺奇怪的，你不是要详解springfactoriesloader吗？上来讲了一堆 classloader 是几个意思？看下它的源码你就知道了：\n\npublic static final string factories_resource_location = "meta-inf/spring.factories";\n// spring.factories文件的格式为：key=value1,value2,value3\n// 从所有的jar包中找到meta-inf/spring.factories文件\n// 然后从文件中解析出key=factoryclass类名称的所有value值\npublic static list<string> loadfactorynames(class<?> factoryclass, classloader classloader) {\n    string factoryclassname = factoryclass.getname();\n    // 取得资源文件的url\n    enumeration<url> urls = (classloader != null ? classloader.getresources(factories_resource_location) : classloader.getsystemresources(factories_resource_location));\n    list<string> result = new arraylist<string>();\n    // 遍历所有的url\n    while (urls.hasmoreelements()) {\n        url url = urls.nextelement();\n        // 根据资源文件url解析properties文件\n        properties properties = propertiesloaderutils.loadproperties(new urlresource(url));\n        string factoryclassnames = properties.getproperty(factoryclassname);\n        // 组装数据，并返回\n        result.addall(arrays.aslist(stringutils.commadelimitedlisttostringarray(factoryclassnames)));\n    }\n    return result;\n}\n\n\n有了前面关于 classloader 的知识，再来理解这段代码，是不是感觉豁然开朗：从classpath下的每个 jar 包中搜寻所有meta-inf/spring.factories配置文件，然后将解析 properties 文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去 classpath 路径下查找，会扫描所有路径下的 jar 包，只不过这个文件只会在 classpath 下的 jar 包中。来简单看下spring.factories文件的内容吧：\n\n// 来自 org.springframework.boot.autoconfigure下的meta-inf/spring.factories\n// enableautoconfiguration后文会讲到，它用于开启spring boot自动配置功能\norg.springframework.boot.autoconfigure.enableautoconfiguration=\\\norg.springframework.boot.autoconfigure.admin.springapplicationadminjmxautoconfiguration,\\\norg.springframework.boot.autoconfigure.aop.aopautoconfiguration,\\\norg.springframework.boot.autoconfigure.amqp.rabbitautoconfiguration\\\n\n\n执行loadfactorynames(enableautoconfiguration.class, classloader)后，得到对应的一组@configuration类， 我们就可以通过反射实例化这些类然后注入到 ioc 容器中，最后容器里就有了一系列标注了@configuration的 javaconfig 形式的配置类。\n\n这就是springfactoriesloader，它本质上属于 spring 框架私有的一种扩展方案，类似于 spi，spring boot 在 spring 基础上的很多核心功能都是基于此，希望大家可以理解。\n\n\n# 四、另一件武器：spring 容器的事件监听机制\n\n过去，事件监听机制多用于图形界面编程，比如：点击按钮、在文本框输入内容等操作被称为事件，而当事件触发时，应用程序作出一定的响应则表示应用监听了这个事件，而在服务器端，事件的监听机制更多的用于异步通知以及监控和异常处理。java 提供了实现事件监听机制的两个基础类：自定义事件类型扩展自java.util.eventobject、事件的监听器扩展自java.util.eventlistener。来看一个简单的实例：简单的监控一个方法的耗时。\n\n首先定义事件类型，通常的做法是扩展 eventobject，随着事件的发生，相应的状态通常都封装在此类中：\n\npublic class methodmonitorevent extends eventobject {\n    // 时间戳，用于记录方法开始执行的时间\n    public long timestamp;\n\n    public methodmonitorevent(object source) {\n        super(source);\n    }\n}\n\n\n事件发布之后，相应的监听器即可对该类型的事件进行处理，我们可以在方法开始执行之前发布一个 begin 事件，在方法执行结束之后发布一个 end 事件，相应地，事件监听器需要提供方法对这两种情况下接收到的事件进行处理：\n\n// 1、定义事件监听接口\npublic interface methodmonitoreventlistener extends eventlistener {\n    // 处理方法执行之前发布的事件\n    public void onmethodbegin(methodmonitorevent event);\n    // 处理方法结束时发布的事件\n    public void onmethodend(methodmonitorevent event);\n}\n// 2、事件监听接口的实现：如何处理\npublic class abstractmethodmonitoreventlistener implements methodmonitoreventlistener {\n\n    @override\n    public void onmethodbegin(methodmonitorevent event) {\n        // 记录方法开始执行时的时间\n        event.timestamp = system.currenttimemillis();\n    }\n\n    @override\n    public void onmethodend(methodmonitorevent event) {\n        // 计算方法耗时\n        long duration = system.currenttimemillis() - event.timestamp;\n        system.out.println("耗时：" + duration);\n    }\n}\n\n\n事件监听器接口针对不同的事件发布实际提供相应的处理方法定义，最重要的是，其方法只接收 methodmonitorevent 参数，说明这个监听器类只负责监听器对应的事件并进行处理。有了事件和监听器，剩下的就是发布事件，然后让相应的监听器监听并处理。通常情况，我们会有一个事件发布者，它本身作为事件源，在合适的时机，将相应的事件发布给对应的事件监听器：\n\npublic class methodmonitoreventpublisher {\n\n    private list<methodmonitoreventlistener> listeners = new arraylist<methodmonitoreventlistener>();\n\n    public void methodmonitor() {\n        methodmonitorevent eventobject = new methodmonitorevent(this);\n        publishevent("begin",eventobject);\n        // 模拟方法执行：休眠5秒钟\n        timeunit.seconds.sleep(5);\n        publishevent("end",eventobject);\n\n    }\n\n    private void publishevent(string status,methodmonitorevent event) {\n        // 避免在事件处理期间，监听器被移除，这里为了安全做一个复制操作\n        list<methodmonitoreventlistener> copylisteners = ➥ new arraylist<methodmonitoreventlistener>(listeners);\n        for (methodmonitoreventlistener listener : copylisteners) {\n            if ("begin".equals(status)) {\n                listener.onmethodbegin(event);\n            } else {\n                listener.onmethodend(event);\n            }\n        }\n    }\n\n    public static void main(string[] args) {\n        methodmonitoreventpublisher publisher = new methodmonitoreventpublisher();\n        publisher.addeventlistener(new abstractmethodmonitoreventlistener());\n        publisher.methodmonitor();\n    }\n    // 省略实现\n    public void addeventlistener(methodmonitoreventlistener listener) {}\n    public void removeeventlistener(methodmonitoreventlistener listener) {}\n    public void removealllisteners() {}\n\n\n对于事件发布者（事件源）通常需要关注两点：\n\n 1. 在合适的时机发布事件。此例中的 methodmonitor()方法是事件发布的源头，其在方法执行之前和结束之后两个时间点发布 methodmonitorevent 事件，每个时间点发布的事件都会传给相应的监听器进行处理。在具体实现时需要注意的是，事件发布是顺序执行，为了不影响处理性能，事件监听器的处理逻辑应尽量简单。\n 2. 事件监听器的管理。publisher 类中提供了事件监听器的注册与移除方法，这样客户端可以根据实际情况决定是否需要注册新的监听器或者移除某个监听器。如果这里没有提供 remove 方法，那么注册的监听器示例将一直被 methodmonitoreventpublisher 引用，即使已经废弃不用了，也依然在发布者的监听器列表中，这会导致隐性的内存泄漏。\n\n# spring 容器内的事件监听机制\n\nspring 的 applicationcontext 容器内部中的所有事件类型均继承自org.springframework.context.applicationevent，容器中的所有监听器都实现org.springframework.context.applicationlistener接口，并且以 bean 的形式注册在容器中。一旦在容器内发布 applicationevent 及其子类型的事件，注册到容器的 applicationlistener 就会对这些事件进行处理。\n\n你应该已经猜到是怎么回事了。\n\napplicationevent 继承自 eventobject，spring 提供了一些默认的实现，比如：contextclosedevent表示容器在即将关闭时发布的事件类型，contextrefreshedevent表示容器在初始化或者刷新的时候发布的事件类型......\n\n容器内部使用 applicationlistener 作为事件监听器接口定义，它继承自 eventlistener。applicationcontext 容器在启动时，会自动识别并加载 eventlistener 类型的 bean，一旦容器内有事件发布，将通知这些注册到容器的 eventlistener。\n\napplicationcontext 接口继承了 applicationeventpublisher 接口，该接口提供了void publishevent(applicationevent event)方法定义，不难看出，applicationcontext 容器担当的就是事件发布者的角色。如果有兴趣可以查看abstractapplicationcontext.publishevent(applicationevent event)方法的源码：applicationcontext 将事件的发布以及监听器的管理工作委托给applicationeventmulticaster接口的实现类。在容器启动时，会检查容器内是否存在名为 applicationeventmulticaster 的 applicationeventmulticaster 对象实例。如果有就使用其提供的实现，没有就默认初始化一个 simpleapplicationeventmulticaster 作为实现。\n\n最后，如果我们业务需要在容器内部发布事件，只需要为其注入 applicationeventpublisher 依赖即可：实现 applicationeventpublisheraware 接口或者 applicationcontextaware 接口(aware 接口相关内容请回顾上文)。\n\n\n# 五、出神入化：揭秘自动配置原理\n\n典型的 spring boot 应用的启动类一般均位于src/main/java根路径下，比如moonapplication类：\n\n@springbootapplication\npublic class moonapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(moonapplication.class, args);\n    }\n}\n\n\n其中@springbootapplication开启组件扫描和自动配置，而springapplication.run则负责启动引导应用程序。@springbootapplication是一个复合annotation，它将三个有用的注解组合在一起：\n\n@target(elementtype.type)\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@springbootconfiguration\n@enableautoconfiguration\n@componentscan(excludefilters = {\n        @filter(type = filtertype.custom, classes = typeexcludefilter.class),\n        @filter(type = filtertype.custom, classes = autoconfigurationexcludefilter.class) })\npublic @interface springbootapplication {\n    // ......\n}\n\n\n@springbootconfiguration就是@configuration，它是 spring 框架的注解，标明该类是一个javaconfig配置类。而@componentscan启用组件扫描，前文已经详细讲解过，这里着重关注@enableautoconfiguration。\n\n@enableautoconfiguration注解表示开启 spring boot 自动配置功能，spring boot 会根据应用的依赖、自定义的 bean、classpath 下有没有某个类 等等因素来猜测你需要的 bean，然后注册到 ioc 容器中。那@enableautoconfiguration是如何推算出你的需求？首先看下它的定义：\n\n@target(elementtype.type)\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@autoconfigurationpackage\n@import(enableautoconfigurationimportselector.class)\npublic @interface enableautoconfiguration {\n    // ......\n}\n\n\n你的关注点应该在@import(enableautoconfigurationimportselector.class)上了，前文说过，@import注解用于导入类，并将这个类作为一个 bean 的定义注册到容器中，这里它将把enableautoconfigurationimportselector作为 bean 注入到容器中，而这个类会将所有符合条件的@configuration 配置都加载到容器中，看看它的代码：\n\npublic string[] selectimports(annotationmetadata annotationmetadata) {\n    // 省略了大部分代码，保留一句核心代码\n    // 注意：springboot最近版本中，这句代码被封装在一个单独的方法中\n    // springfactoriesloader相关知识请参考前文\n    list<string> factories = new arraylist<string>(new linkedhashset<string>(\n        springfactoriesloader.loadfactorynames(enableautoconfiguration.class, this.beanclassloader)));\n}\n\n\n这个类会扫描所有的 jar 包，将所有符合条件的@configuration 配置类注入的容器中，何为符合条件，看看meta-inf/spring.factories的文件内容：\n\n// 来自 org.springframework.boot.autoconfigure下的meta-inf/spring.factories\n// 配置的key = enableautoconfiguration，与代码中一致\norg.springframework.boot.autoconfigure.enableautoconfiguration=\\\norg.springframework.boot.autoconfigure.jdbc.datasourceautoconfiguration,\\\norg.springframework.boot.autoconfigure.aop.aopautoconfiguration,\\\norg.springframework.boot.autoconfigure.amqp.rabbitautoconfiguration\\\n.....\n\n\n以datasourceautoconfiguration为例，看看 spring boot 是如何自动配置的：\n\n@configuration\n@conditionalonclass({ datasource.class, embeddeddatabasetype.class })\n@enableconfigurationproperties(datasourceproperties.class)\n@import({ registrar.class, datasourcepoolmetadataprovidersconfiguration.class })\npublic class datasourceautoconfiguration {\n}\n\n\n分别说一说：\n\n * @conditionalonclass({ datasource.class, embeddeddatabasetype.class })：当 classpath 中存在 datasource 或者 embeddeddatabasetype 类时才启用这个配置，否则这个配置将被忽略。\n * @enableconfigurationproperties(datasourceproperties.class)：将 datasource 的默认配置类注入到 ioc 容器中，datasourceproperties 定义为：\n\n// 提供对datasource配置信息的支持，所有的配置前缀为：spring.datasource\n@configurationproperties(prefix = "spring.datasource")\npublic class datasourceproperties  {\n    private classloader classloader;\n    private environment environment;\n    private string name = "testdb";\n    ......\n}\n\n\n * @import({ registrar.class, datasourcepoolmetadataprovidersconfiguration.class })：导入其他额外的配置，就以datasourcepoolmetadataprovidersconfiguration为例吧。\n\n@configuration\npublic class datasourcepoolmetadataprovidersconfiguration {\n\n    @configuration\n    @conditionalonclass(org.apache.tomcat.jdbc.pool.datasource.class)\n    static class tomcatdatasourcepoolmetadataproviderconfiguration {\n        @bean\n        public datasourcepoolmetadataprovider tomcatpooldatasourcemetadataprovider() {\n            .....\n        }\n    }\n  ......\n}\n\n\ndatasourcepoolmetadataprovidersconfiguration 是数据库连接池提供者的一个配置类，即 classpath 中存在org.apache.tomcat.jdbc.pool.datasource.class，则使用 tomcat-jdbc 连接池，如果 classpath 中存在hikaridatasource.class则使用 hikari 连接池。\n\n这里仅描述了 datasourceautoconfiguration 的冰山一角，但足以说明 spring boot 如何利用条件话配置来实现自动配置的。回顾一下，@enableautoconfiguration中导入了 enableautoconfigurationimportselector 类，而这个类的selectimports()通过 springfactoriesloader 得到了大量的配置类，而每一个配置类则根据条件化配置来做出决策，以实现自动配置。\n\n整个流程很清晰，但漏了一个大问题：enableautoconfigurationimportselector.selectimports()是何时执行的？其实这个方法会在容器启动过程中执行：abstractapplicationcontext.refresh()，更多的细节在下一小节中说明。\n\n\n# 六、启动引导：spring boot 应用启动的秘密\n\n\n# 6.1 springapplication 初始化\n\nspringboot 整个启动流程分为两个步骤：初始化一个 springapplication 对象、执行该对象的 run 方法。看下 springapplication 的初始化流程，springapplication 的构造方法中调用 initialize(object[] sources)方法，其代码如下：\n\nprivate void initialize(object[] sources) {\n     if (sources != null && sources.length > 0) {\n         this.sources.addall(arrays.aslist(sources));\n     }\n     // 判断是否是web项目\n     this.webenvironment = deducewebenvironment();\n     setinitializers((collection) getspringfactoriesinstances(applicationcontextinitializer.class));\n     setlisteners((collection) getspringfactoriesinstances(applicationlistener.class));\n     // 找到入口类\n     this.mainapplicationclass = deducemainapplicationclass();\n}\n\n\n初始化流程中最重要的就是通过 springfactoriesloader 找到spring.factories文件中配置的applicationcontextinitializer和applicationlistener两个接口的实现类名称，以便后期构造相应的实例。applicationcontextinitializer的主要目的是在configurableapplicationcontext做 refresh 之前，对 configurableapplicationcontext 实例做进一步的设置或处理。configurableapplicationcontext 继承自 applicationcontext，其主要提供了对 applicationcontext 进行设置的能力。\n\n实现一个 applicationcontextinitializer 非常简单，因为它只有一个方法，但大多数情况下我们没有必要自定义一个 applicationcontextinitializer，即便是 spring boot 框架，它默认也只是注册了两个实现，毕竟 spring 的容器已经非常成熟和稳定，你没有必要来改变它。\n\n而applicationlistener的目的就没什么好说的了，它是 spring 框架对 java 事件监听机制的一种框架实现，具体内容在前文 spring 事件监听机制这个小节有详细讲解。这里主要说说，如果你想为 spring boot 应用添加监听器，该如何实现？\n\nspring boot 提供两种方式来添加自定义监听器：\n\n * 通过springapplication.addlisteners(applicationlistener... listeners)或者springapplication.setlisteners(collection> listeners)两个方法来添加一个或者多个自定义监听器\n * 既然 springapplication 的初始化流程中已经从spring.factories中获取到applicationlistener的实现类，那么我们直接在自己的 jar 包的meta-inf/spring.factories文件中新增配置即可：\n\norg.springframework.context.applicationlistener=\\\ncn.moondev.listeners.xxxxlistener\\\n\n\n关于 springapplication 的初始化，我们就说这么多。\n\n\n# 6.2 spring boot 启动流程\n\nspring boot 应用的整个启动流程都封装在 springapplication.run 方法中，其整个流程真的是太长太长了，但本质上就是在 spring 容器启动的基础上做了大量的扩展，按照这个思路来看看源码：\n\npublic configurableapplicationcontext run(string... args) {\n        stopwatch stopwatch = new stopwatch();\n        stopwatch.start();\n        configurableapplicationcontext context = null;\n        failureanalyzers analyzers = null;\n        configureheadlessproperty();\n        // ①\n        springapplicationrunlisteners listeners = getrunlisteners(args);\n        listeners.starting();\n        try {\n            // ②\n            applicationarguments applicationarguments = new defaultapplicationarguments(args);\n            configurableenvironment environment = prepareenvironment(listeners,applicationarguments);\n            // ③\n            banner printedbanner = printbanner(environment);\n            // ④\n            context = createapplicationcontext();\n            // ⑤\n            analyzers = new failureanalyzers(context);\n            // ⑥\n            preparecontext(context, environment, listeners, applicationarguments,printedbanner);\n            // ⑦\n            refreshcontext(context);\n            // ⑧\n            afterrefresh(context, applicationarguments);\n            // ⑨\n            listeners.finished(context, null);\n            stopwatch.stop();\n            return context;\n        }\n        catch (throwable ex) {\n            handlerunfailure(context, listeners, analyzers, ex);\n            throw new illegalstateexception(ex);\n        }\n    }\n\n\n① 通过 springfactoriesloader 查找并加载所有的springapplicationrunlisteners，通过调用 starting()方法通知所有的 springapplicationrunlisteners：应用开始启动了。springapplicationrunlisteners 其本质上就是一个事件发布者，它在 springboot 应用启动的不同时间点发布不同应用事件类型(applicationevent)，如果有哪些事件监听者(applicationlistener)对这些事件感兴趣，则可以接收并且处理。还记得初始化流程中，springapplication 加载了一系列 applicationlistener 吗？这个启动流程中没有发现有发布事件的代码，其实都已经在 springapplicationrunlisteners 这儿实现了。\n\n简单的分析一下其实现流程，首先看下 springapplicationrunlistener 的源码：\n\npublic interface springapplicationrunlistener {\n\n    // 运行run方法时立即调用此方法，可以用户非常早期的初始化工作\n    void starting();\n\n    // environment准备好后，并且applicationcontext创建之前调用\n    void environmentprepared(configurableenvironment environment);\n\n    // applicationcontext创建好后立即调用\n    void contextprepared(configurableapplicationcontext context);\n\n    // applicationcontext加载完成，在refresh之前调用\n    void contextloaded(configurableapplicationcontext context);\n\n    // 当run方法结束之前调用\n    void finished(configurableapplicationcontext context, throwable exception);\n\n}\n\n\nspringapplicationrunlistener 只有一个实现类：eventpublishingrunlistener。① 处的代码只会获取到一个 eventpublishingrunlistener 的实例，我们来看看 starting()方法的内容：\n\npublic void starting() {\n    // 发布一个applicationstartedevent\n    this.initialmulticaster.multicastevent(new applicationstartedevent(this.application, this.args));\n}\n\n\n顺着这个逻辑，你可以在 ② 处的prepareenvironment()方法的源码中找到listeners.environmentprepared(environment);即 springapplicationrunlistener 接口的第二个方法，那不出你所料，environmentprepared()又发布了另外一个事件applicationenvironmentpreparedevent。接下来会发生什么，就不用我多说了吧。\n\n② 创建并配置当前应用将要使用的environment，environment 用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当 environment 准备好后，在整个应用的任何时候，都可以从 environment 中获取资源。\n\n总结起来，② 处的两句代码，主要完成以下几件事：\n\n * 判断 environment 是否存在，不存在就创建（如果是 web 项目就创建standardservletenvironment，否则创建standardenvironment）\n * 配置 environment：配置 profile 以及 properties\n * 调用 springapplicationrunlistener 的environmentprepared()方法，通知事件监听者：应用的 environment 已经准备好\n\n③、springboot 应用在启动时会输出这样的东西：\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::        (v1.5.6.release)\n\n\n如果想把这个东西改成自己的涂鸦，你可以研究以下 banner 的实现，这个任务就留给你们吧。\n\n④、根据是否是 web 项目，来创建不同的 applicationcontext 容器。\n\n⑤、创建一系列failureanalyzer，创建流程依然是通过 springfactoriesloader 获取到所有实现 failureanalyzer 接口的 class，然后在创建对应的实例。failureanalyzer 用于分析故障并提供相关诊断信息。\n\n⑥、初始化 applicationcontext，主要完成以下工作：\n\n * 将准备好的 environment 设置给 applicationcontext\n * 遍历调用所有的 applicationcontextinitializer 的initialize()方法来对已经创建好的 applicationcontext 进行进一步的处理\n * 调用 springapplicationrunlistener 的contextprepared()方法，通知所有的监听者：applicationcontext 已经准备完毕\n * 将所有的 bean 加载到容器中\n * 调用 springapplicationrunlistener 的contextloaded()方法，通知所有的监听者：applicationcontext 已经装载完毕\n\n⑦、调用 applicationcontext 的refresh()方法，完成 ioc 容器可用的最后一道工序。从名字上理解为刷新容器，那何为刷新？就是插手容器的启动，联系一下第一小节的内容。那如何刷新呢？且看下面代码：\n\n// 摘自refresh()方法中一句代码\ninvokebeanfactorypostprocessors(beanfactory);\n\n\n看看这个方法的实现：\n\nprotected void invokebeanfactorypostprocessors(configurablelistablebeanfactory beanfactory) {\n    postprocessorregistrationdelegate.invokebeanfactorypostprocessors(beanfactory, getbeanfactorypostprocessors());\n    ......\n}\n\n\n获取到所有的beanfactorypostprocessor来对容器做一些额外的操作。beanfactorypostprocessor 允许我们在容器实例化相应对象之前，对注册到容器的 beandefinition 所保存的信息做一些额外的操作。这里的 getbeanfactorypostprocessors()方法可以获取到 3 个 processor：\n\nconfigurationwarningsapplicationcontextinitializer$configurationwarningspostprocessor\nsharedmetadatareaderfactorycontextinitializer$cachingmetadatareaderfactorypostprocessor\nconfigfileapplicationlistener$propertysourceorderingpostprocessor\n\n\n不是有那么多 beanfactorypostprocessor 的实现类，为什么这儿只有这 3 个？因为在初始化流程获取到的各种 applicationcontextinitializer 和 applicationlistener 中，只有上文 3 个做了类似于如下操作：\n\npublic void initialize(configurableapplicationcontext context) {\n    context.addbeanfactorypostprocessor(new configurationwarningspostprocessor(getchecks()));\n}\n\n\n然后你就可以进入到postprocessorregistrationdelegate.invokebeanfactorypostprocessors()方法了，这个方法除了会遍历上面的 3 个 beanfactorypostprocessor 处理外，还会获取类型为beandefinitionregistrypostprocessor的 bean：org.springframework.context.annotation.internalconfigurationannotationprocessor，对应的 class 为configurationclasspostprocessor。configurationclasspostprocessor用于解析处理各种注解，包括：@configuration、@componentscan、@import、@propertysource、@importresource、@bean。当处理@import注解的时候，就会调用自动配置这一小节中的enableautoconfigurationimportselector.selectimports()来完成自动配置功能。其他的这里不再多讲，如果你有兴趣，可以查阅参考资料 6。\n\n⑧、查找当前 context 中是否注册有 commandlinerunner 和 applicationrunner，如果有则遍历执行它们。\n\n⑨、执行所有 springapplicationrunlistener 的 finished()方法。\n\n这就是 spring boot 的整个启动流程，其核心就是在 spring 容器初始化并启动的基础上加入各种扩展点，这些扩展点包括：applicationcontextinitializer、applicationlistener 以及各种 beanfactorypostprocessor 等等。你对整个流程的细节不必太过关注，甚至没弄明白也没有关系，你只要理解这些扩展点是在何时如何工作的，能让它们为你所用即可。\n\n整个启动流程确实非常复杂，可以查询参考资料中的部分章节和内容，对照着源码，多看看，我想最终你都能弄清楚的。言而总之，spring 才是核心，理解清楚 spring 容器的启动流程，那 spring boot 启动流程就不在话下了。\n\n\n# 参考资料\n\n[1]王福强 著；springboot 揭秘：快速构建微服务体系; 机械工业出版社, 2016 [2]王福强 著；spring 揭秘; 人民邮件出版社, 2009 [3]craig walls 著；丁雪丰 译；spring boot 实战；中国工信出版集团 人民邮电出版社，2016 [4]深入探讨 java 类加载器 : www.ibm.com/developerwo… [5]spring boot 实战：自动配置原理分析 : blog.csdn.net/liaokailin/… [6]spring boot实战：spring boot bean加载源码分析： blog.csdn.net/liaokailin/…',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 面试",frontmatter:{title:"Spring 面试",date:"2018-08-02T17:33:32.000Z",order:99,categories:["Java","框架","Spring","Spring综合"],tags:["Java","框架","Spring","面试"],permalink:"/pages/db33b0/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/00.Spring%E7%BB%BC%E5%90%88/99.Spring%E9%9D%A2%E8%AF%95.html",relativePath:"01.Java/13.框架/01.Spring/00.Spring综合/99.Spring面试.md",key:"v-ad888434",path:"/pages/db33b0/",headers:[{level:2,title:"综合篇",slug:"综合篇",normalizedTitle:"综合篇",charIndex:16},{level:3,title:"不同版本的 Spring Framework 有哪些主要功能？",slug:"不同版本的-spring-framework-有哪些主要功能",normalizedTitle:"不同版本的 spring framework 有哪些主要功能？",charIndex:24},{level:3,title:"什么是 Spring Framework？",slug:"什么是-spring-framework",normalizedTitle:"什么是 spring framework？",charIndex:222},{level:3,title:"列举 Spring Framework 的优点。",slug:"列举-spring-framework-的优点。",normalizedTitle:"列举 spring framework 的优点。",charIndex:404},{level:3,title:"Spring Framework 有哪些不同的功能？",slug:"spring-framework-有哪些不同的功能",normalizedTitle:"spring framework 有哪些不同的功能？",charIndex:588},{level:3,title:"Spring Framework 中有多少个模块，它们分别是什么？",slug:"spring-framework-中有多少个模块-它们分别是什么",normalizedTitle:"spring framework 中有多少个模块，它们分别是什么？",charIndex:891},{level:3,title:"什么是 Spring 配置文件？",slug:"什么是-spring-配置文件",normalizedTitle:"什么是 spring 配置文件？",charIndex:1605},{level:3,title:"Spring 应用程序有哪些不同组件？",slug:"spring-应用程序有哪些不同组件",normalizedTitle:"spring 应用程序有哪些不同组件？",charIndex:1726},{level:3,title:"使用 Spring 有哪些方式？",slug:"使用-spring-有哪些方式",normalizedTitle:"使用 spring 有哪些方式？",charIndex:1911},{level:2,title:"核心篇",slug:"核心篇",normalizedTitle:"核心篇",charIndex:2090},{level:3,title:"IoC",slug:"ioc",normalizedTitle:"ioc",charIndex:2098},{level:4,title:"什么是 IoC？什么是依赖注入？什么是 Spring IoC？",slug:"什么是-ioc-什么是依赖注入-什么是-spring-ioc",normalizedTitle:"什么是 ioc？什么是依赖注入？什么是 spring ioc？",charIndex:2105},{level:4,title:"依赖注入有哪些实现方式？",slug:"依赖注入有哪些实现方式",normalizedTitle:"依赖注入有哪些实现方式？",charIndex:2489},{level:4,title:"构造器注入 VS. setter 注入",slug:"构造器注入-vs-setter-注入",normalizedTitle:"构造器注入 vs. setter 注入",charIndex:2814},{level:4,title:"BeanFactory VS. ApplicationContext",slug:"beanfactory-vs-applicationcontext",normalizedTitle:"beanfactory vs. applicationcontext",charIndex:2991},{level:4,title:"BeanFactory VS. FactoryBean",slug:"beanfactory-vs-factorybean",normalizedTitle:"beanfactory vs. factorybean",charIndex:3371},{level:4,title:"Spring IoC 启动时做了哪些准备",slug:"spring-ioc-启动时做了哪些准备",normalizedTitle:"spring ioc 启动时做了哪些准备",charIndex:3477},{level:4,title:"Spring IoC 的实现机制是什么",slug:"spring-ioc-的实现机制是什么",normalizedTitle:"spring ioc 的实现机制是什么",charIndex:3553},{level:3,title:"Bean",slug:"bean",normalizedTitle:"bean",charIndex:727},{level:4,title:"什么是 Spring Bean",slug:"什么是-spring-bean",normalizedTitle:"什么是 spring bean",charIndex:4334},{level:4,title:"如何注册 Spring Bean",slug:"如何注册-spring-bean",normalizedTitle:"如何注册 spring bean",charIndex:4726},{level:4,title:"spring 提供了哪些配置方式？",slug:"spring-提供了哪些配置方式",normalizedTitle:"spring 提供了哪些配置方式？",charIndex:4777},{level:4,title:"spring 支持集中 bean scope？",slug:"spring-支持集中-bean-scope",normalizedTitle:"spring 支持集中 bean scope？",charIndex:5548},{level:4,title:"Spring Bean 的生命周期",slug:"spring-bean-的生命周期",normalizedTitle:"spring bean 的生命周期",charIndex:6126},{level:4,title:"什么是 spring 的内部 bean？",slug:"什么是-spring-的内部-bean",normalizedTitle:"什么是 spring 的内部 bean？",charIndex:7479},{level:4,title:"什么是 spring 装配",slug:"什么是-spring-装配",normalizedTitle:"什么是 spring 装配",charIndex:8264},{level:4,title:"自动装配有哪些方式？",slug:"自动装配有哪些方式",normalizedTitle:"自动装配有哪些方式？",charIndex:8387},{level:4,title:"自动装配有什么局限？",slug:"自动装配有什么局限",normalizedTitle:"自动装配有什么局限？",charIndex:8762},{level:3,title:"AOP",slug:"aop",normalizedTitle:"aop",charIndex:665},{level:4,title:"什么是 AOP？",slug:"什么是-aop",normalizedTitle:"什么是 aop？",charIndex:8930},{level:4,title:"AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？",slug:"aop-中的-aspect、advice、pointcut、jointpoint-和-advice-参数分别是什么",normalizedTitle:"aop 中的 aspect、advice、pointcut、jointpoint 和 advice 参数分别是什么？",charIndex:9117},{level:4,title:"什么是通知（Advice）？",slug:"什么是通知-advice",normalizedTitle:"什么是通知（advice）？",charIndex:9829},{level:4,title:"有哪些类型的通知（Advice）？",slug:"有哪些类型的通知-advice",normalizedTitle:"有哪些类型的通知（advice）？",charIndex:9943},{level:4,title:"指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。",slug:"指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。",normalizedTitle:"指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。",charIndex:10335},{level:4,title:"AOP 有哪些实现方式？",slug:"aop-有哪些实现方式",normalizedTitle:"aop 有哪些实现方式？",charIndex:10539},{level:4,title:"Spring AOP and AspectJ AOP 有什么区别？",slug:"spring-aop-and-aspectj-aop-有什么区别",normalizedTitle:"spring aop and aspectj aop 有什么区别？",charIndex:10756},{level:4,title:"如何理解 Spring 中的代理？",slug:"如何理解-spring-中的代理",normalizedTitle:"如何理解 spring 中的代理？",charIndex:10899},{level:4,title:"什么是编织（Weaving）？",slug:"什么是编织-weaving",normalizedTitle:"什么是编织（weaving）？",charIndex:11007},{level:2,title:"注解",slug:"注解",normalizedTitle:"注解",charIndex:109},{level:3,title:"你用过哪些重要的 Spring 注解？",slug:"你用过哪些重要的-spring-注解",normalizedTitle:"你用过哪些重要的 spring 注解？",charIndex:11122},{level:3,title:"如何在 spring 中启动注解装配？",slug:"如何在-spring-中启动注解装配",normalizedTitle:"如何在 spring 中启动注解装配？",charIndex:11611},{level:3,title:"@Component, @Controller, @Repository, @Service 有何区别？",slug:"component-controller-repository-service-有何区别",normalizedTitle:"@component, @controller, @repository, @service 有何区别？",charIndex:11732},{level:3,title:"@Required 注解有什么用？",slug:"required-注解有什么用",normalizedTitle:"@required 注解有什么用？",charIndex:12178},{level:3,title:"@Autowired 注解有什么用？",slug:"autowired-注解有什么用",normalizedTitle:"@autowired 注解有什么用？",charIndex:12535},{level:3,title:"@Qualifier 注解有什么用？",slug:"qualifier-注解有什么用",normalizedTitle:"@qualifier 注解有什么用？",charIndex:12853},{level:3,title:"@RequestMapping 注解有什么用？",slug:"requestmapping-注解有什么用",normalizedTitle:"@requestmapping 注解有什么用？",charIndex:13478},{level:2,title:"数据篇",slug:"数据篇",normalizedTitle:"数据篇",charIndex:13622},{level:3,title:"spring DAO 有什么用？",slug:"spring-dao-有什么用",normalizedTitle:"spring dao 有什么用？",charIndex:13630},{level:3,title:"列举 Spring DAO 抛出的异常。",slug:"列举-spring-dao-抛出的异常。",normalizedTitle:"列举 spring dao 抛出的异常。",charIndex:13757},{level:3,title:"spring JDBC API 中存在哪些类？",slug:"spring-jdbc-api-中存在哪些类",normalizedTitle:"spring jdbc api 中存在哪些类？",charIndex:13784},{level:3,title:"使用 Spring 访问 Hibernate 的方法有哪些？",slug:"使用-spring-访问-hibernate-的方法有哪些",normalizedTitle:"使用 spring 访问 hibernate 的方法有哪些？",charIndex:13919},{level:3,title:"列举 spring 支持的事务管理类型",slug:"列举-spring-支持的事务管理类型",normalizedTitle:"列举 spring 支持的事务管理类型",charIndex:14060},{level:3,title:"spring 支持哪些 ORM 框架",slug:"spring-支持哪些-orm-框架",normalizedTitle:"spring 支持哪些 orm 框架",charIndex:14209},{level:2,title:"MVC",slug:"mvc",normalizedTitle:"mvc",charIndex:745},{level:3,title:"Spring MVC 框架有什么用？",slug:"spring-mvc-框架有什么用",normalizedTitle:"spring mvc 框架有什么用？",charIndex:14285},{level:3,title:"描述一下 DispatcherServlet 的工作流程",slug:"描述一下-dispatcherservlet-的工作流程",normalizedTitle:"描述一下 dispatcherservlet 的工作流程",charIndex:14431},{level:3,title:"介绍一下 WebApplicationContext",slug:"介绍一下-webapplicationcontext",normalizedTitle:"介绍一下 webapplicationcontext",charIndex:15427},{level:2,title:"资料",slug:"资料",normalizedTitle:"资料",charIndex:15682}],headersStr:"综合篇 不同版本的 Spring Framework 有哪些主要功能？ 什么是 Spring Framework？ 列举 Spring Framework 的优点。 Spring Framework 有哪些不同的功能？ Spring Framework 中有多少个模块，它们分别是什么？ 什么是 Spring 配置文件？ Spring 应用程序有哪些不同组件？ 使用 Spring 有哪些方式？ 核心篇 IoC 什么是 IoC？什么是依赖注入？什么是 Spring IoC？ 依赖注入有哪些实现方式？ 构造器注入 VS. setter 注入 BeanFactory VS. ApplicationContext BeanFactory VS. FactoryBean Spring IoC 启动时做了哪些准备 Spring IoC 的实现机制是什么 Bean 什么是 Spring Bean 如何注册 Spring Bean spring 提供了哪些配置方式？ spring 支持集中 bean scope？ Spring Bean 的生命周期 什么是 spring 的内部 bean？ 什么是 spring 装配 自动装配有哪些方式？ 自动装配有什么局限？ AOP 什么是 AOP？ AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？ 什么是通知（Advice）？ 有哪些类型的通知（Advice）？ 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。 AOP 有哪些实现方式？ Spring AOP and AspectJ AOP 有什么区别？ 如何理解 Spring 中的代理？ 什么是编织（Weaving）？ 注解 你用过哪些重要的 Spring 注解？ 如何在 spring 中启动注解装配？ @Component, @Controller, @Repository, @Service 有何区别？ @Required 注解有什么用？ @Autowired 注解有什么用？ @Qualifier 注解有什么用？ @RequestMapping 注解有什么用？ 数据篇 spring DAO 有什么用？ 列举 Spring DAO 抛出的异常。 spring JDBC API 中存在哪些类？ 使用 Spring 访问 Hibernate 的方法有哪些？ 列举 spring 支持的事务管理类型 spring 支持哪些 ORM 框架 MVC Spring MVC 框架有什么用？ 描述一下 DispatcherServlet 的工作流程 介绍一下 WebApplicationContext 资料",content:'# Spring 面试\n\n\n# 综合篇\n\n\n# 不同版本的 Spring Framework 有哪些主要功能？\n\nVERSION      FEATURE\nSpring 2.5   发布于 2007 年。这是第一个支持注解的版本。\nSpring 3.0   发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。\nSpring 4.0   发布于 2013 年。这是第一个完全支持 JAVA8 的版本。\n\n\n# 什么是 Spring Framework？\n\n * Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。\n * 它是轻量级、松散耦合的。\n * 它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。\n * 它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。\n\n\n# 列举 Spring Framework 的优点。\n\n * 由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。\n * Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。\n * 由于依赖注入和控制反转，JDBC 得以简化。\n * 它是开源免费的。\n\n\n# Spring Framework 有哪些不同的功能？\n\n * 轻量级 - Spring 在代码量和透明度方面都很轻便。\n * IOC - 控制反转\n * AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。\n * 容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。\n * MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。\n * 事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。\n * JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。\n\n\n# Spring Framework 中有多少个模块，它们分别是什么？\n\n\n\n * Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：\n   * Spring Core\n   * Spring Bean\n   * SpEL (Spring Expression Language)\n   * Spring Context\n * 数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：\n   * JDBC (Java DataBase Connectivity)\n   * ORM (Object Relational Mapping)\n   * OXM (Object XML Mappers)\n   * JMS (Java Messaging Service)\n   * Transaction\n * Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：\n   * Web\n   * Web – Servlet\n   * Web – Socket\n   * Web – Portlet\n * AOP – 该层支持面向切面编程\n * Instrumentation – 该层为类检测和类加载器实现提供支持。\n * Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。\n * 几个杂项模块:\n   * Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。\n   * Aspects – 该模块为与 AspectJ 的集成提供支持。\n\n\n# 什么是 Spring 配置文件？\n\nSpring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。\n\n\n# Spring 应用程序有哪些不同组件？\n\nSpring 应用一般有以下组件：\n\n * 接口 - 定义功能。\n * Bean 类 - 它包含属性，setter 和 getter 方法，函数等。\n * Spring 面向切面编程（AOP） - 提供面向切面编程的功能。\n * Bean 配置文件 - 包含类的信息以及如何配置它们。\n * 用户程序 - 它使用接口。\n\n\n# 使用 Spring 有哪些方式？\n\n使用 Spring 有以下方式：\n\n * 作为一个成熟的 Spring Web 应用程序。\n * 作为第三方 Web 框架，使用 Spring Frameworks 中间层。\n * 用于远程使用。\n * 作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。\n\n\n# 核心篇\n\n\n# IoC\n\n# 什么是 IoC？什么是依赖注入？什么是 Spring IoC？\n\nIoC 即控制反转（Inversion of Control，缩写为 IoC）。IoC 又称为依赖倒置原则（设计模式六大原则之一），它的要点在于：程序要依赖于抽象接口，不要依赖于具体实现。它的作用就是用于降低代码间的耦合度。\n\nIoC 的实现方式有两种：\n\n * 依赖注入（Dependency Injection，简称 DI）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造器、函数参数等方式传递（或注入）给类使用。\n * 依赖查找（Dependency Lookup）：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。\n\nSpring IoC 是 IoC 的一种实现。DI 是 Spring IoC 的主要实现原则。\n\n\n\n# 依赖注入有哪些实现方式？\n\n依赖注入有如下方式：\n\n依赖注入方式        配置元数据举例\nSetter 方法注入   <proeprty name="user" ref="userBean"/>\n构造器注入         <constructor-arg name="user" ref="userBean" />\n字段注入          @Autowired User user;\n方法注入          @Autowired public void user(User user) { ... }\n接口回调注入        class MyBean implements BeanFactoryAware { ... }\n\n# 构造器注入 VS. setter 注入\n\n构造器注入            SETTER 注入\n没有部分注入           有部分注入\n不会覆盖 setter 属性   会覆盖 setter 属性\n任意修改都会创建一个新实例    任意修改不会创建一个新实例\n适用于设置很多属性        适用于设置少量属性\n\n官方推荐使用构造器注入。\n\n# BeanFactory VS. ApplicationContext\n\n在 Spring 中，有两种 IoC 容器：BeanFactory 和 ApplicationContext。\n\n * BeanFactory：BeanFactory 是 Spring 基础 IoC 容器。BeanFactory 提供了 Spring 容器的配置框架和基本功能。\n * ApplicationContext：ApplicationContext 是具备应用特性的 BeanFactory 的子接口。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 AOP、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 ApplicationContext 作为 IoC 容器，因为它的功能远多于 BeanFactory。\n\n# BeanFactory VS. FactoryBean\n\nBeanFactory 是 Spring 基础 IoC 容器。\n\nFactoryBean 是创建 Bean 的一种方式，帮助实现复杂的初始化逻辑。\n\n# Spring IoC 启动时做了哪些准备\n\nIoC 配置元信息读取和解析\n\nIoC 容器生命周期管理\n\nSpring 事件发布\n\n国际化\n\n等等\n\n# Spring IoC 的实现机制是什么\n\nSpring 中的 IoC 的实现原理就是工厂模式加反射机制。\n\n示例：\n\ninterface Fruit {\n     public abstract void eat();\n}\nclass Apple implements Fruit {\n    public void eat(){\n        System.out.println("Apple");\n    }\n}\nclass Orange implements Fruit {\n    public void eat(){\n        System.out.println("Orange");\n    }\n}\nclass Factory {\n    public static Fruit getInstance(String ClassName) {\n        Fruit f=null;\n        try {\n            f=(Fruit)Class.forName(ClassName).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\nclass Client {\n    public static void main(String[] a) {\n        Fruit f=Factory.getInstance("io.github.dunwu.spring.Apple");\n        if(f!=null){\n            f.eat();\n        }\n    }\n}\n\n\n\n# Bean\n\n# 什么是 Spring Bean\n\n在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。Bean 是由 Spring IoC 容器实例化、装配和管理的对象。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\nSpring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——BeanDefinition 对象。\n\nBeanDefinition 是 Spring 中定义 Bean 的配置元信息接口，它包含：\n\n * Bean 类名\n * Bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n * 其他 Bean 引用，也可称为合作者（Collaborators）或依赖（Dependencies）\n * 配置设置，如 Bean 属性（Properties）\n\n# 如何注册 Spring Bean\n\n通过 BeanDefinition 和外部单例对象来注册。\n\n# spring 提供了哪些配置方式？\n\n * 基于 xml 配置\n\nbean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：\n\n<bean id="studentbean" class="org.edureka.firstSpring.StudentBean">\n <property name="name" value="Edureka"></property>\n</bean>\n\n\n * 基于注解配置\n\n您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：\n\n<beans>\n<context:annotation-config/>\n\x3c!-- bean definitions go here --\x3e\n</beans>\n\n\n * 基于 Java API 配置\n\nSpring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。\n\n 1. @Bean 注解扮演与 <bean /> 元素相同的角色。\n 2. @Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。\n\n例如：\n\n@Configuration\npublic class StudentConfig {\n    @Bean\n    public StudentBean myStudent() {\n        return new StudentBean();\n    }\n}\n\n\n# spring 支持集中 bean scope？\n\nSpring bean 支持 5 种 scope：\n\n * Singleton - 每个 Spring IoC 容器仅有一个单实例。\n * Prototype - 每次请求都会产生一个新的实例。\n * Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。\n * Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。\n * Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。\n\n仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。\n\n# Spring Bean 的生命周期\n\n\n\nspring bean 容器的生命周期如下：\n\n 1.  Spring 对 Bean 进行实例化（相当于 new XXX()）\n\n 2.  Spring 将值和引用注入到 Bean 对应的属性中\n\n 3.  如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName 方法\n     \n     * 作用是通过 Bean 的引用来获得 Bean ID，一般业务中是很少有用到 Bean 的 ID 的\n\n 4.  如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanDactory 方法，并把 BeanFactory 容器实例作为参数传入。\n     \n     * 作用是获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等\n\n 5.  如果 Bean 实现了 ApplicationContextAware 接口，Spring 容器将调用 setApplicationContext 方法，把应用上下文作为参数传入\n     \n     * 作用与 BeanFactory 类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用 setApplicationContext 方法时会把它自己作为 setApplicationContext 的参数传入，而 Spring 容器在调用 setBeanFactory 前需要使用者自己指定（注入）setBeanFactory 里的参数 BeanFactory\n\n 6.  如果 Bean 实现了 BeanPostProcess 接口，Spring 将调用 postProcessBeforeInitialization 方法\n     \n     * 作用是在 Bean 实例创建成功后对其进行增强处理，如对 Bean 进行修改，增加某个功能\n\n 7.  如果 Bean 实现了 InitializingBean 接口，Spring 将调用 afterPropertiesSet 方法，作用与在配置文件中对 Bean 使用 init-method 声明初始化的作用一样，都是在 Bean 的全部属性设置成功后执行的初始化方法。\n\n 8.  如果 Bean 实现了 BeanPostProcess 接口，Spring 将调用 postProcessAfterInitialization 方法\n     \n     * postProcessBeforeInitialization 是在 Bean 初始化前执行的，而 postProcessAfterInitialization 是在 Bean 初始化后执行的\n\n 9.  经过以上的工作后，Bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n\n 10. 如果 Bean 实现了 DispostbleBean 接口，Spring 将调用它的 destory 方法，作用与在配置文件中对 Bean 使用 destory-method 属性的作用一样，都是在 Bean 实例销毁前执行的方法。\n\n# 什么是 spring 的内部 bean？\n\n只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或 <constructor-arg> 中提供了 <bean> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。\n\n例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。\n\nStudent.java\n\npublic class Student {\n    private Person person;\n    //Setters and Getters\n}\npublic class Person {\n    private String name;\n    private String address;\n    //Setters and Getters\n}\n\n\nbean.xml\n\n<bean id=“StudentBean" class="com.edureka.Student">\n    <property name="person">\n        \x3c!--This is inner bean --\x3e\n        <bean class="com.edureka.Person">\n            <property name="name" value=“Scott"></property>\n            <property name="address" value=“Bangalore"></property>\n        </bean>\n    </property>\n</bean>\n\n\n# 什么是 spring 装配\n\n当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。\n\n# 自动装配有哪些方式？\n\nSpring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。\n\n自动装配的不同模式：\n\n * no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。\n * byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。\n * byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。\n * 构造器 - 它通过调用类的构造器来注入依赖项。它有大量的参数。\n * autodetect - 首先容器尝试通过构造器使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。\n\n# 自动装配有什么局限？\n\n * 覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。\n * 基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。\n * 令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。\n\n\n# AOP\n\n# 什么是 AOP？\n\nAOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角. 在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)\n\n# AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？\n\n\n\n * Aspect - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。\n * Advice - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。\n * Advice Arguments - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。\n * Pointcut - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。 Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。\n * JoinPoint - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。\n\n# 什么是通知（Advice）？\n\n特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。\n\n# 有哪些类型的通知（Advice）？\n\n * Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。\n * After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。\n * After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。\n * After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。\n * Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。\n\n# 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。\n\nconcern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。\n\ncross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。\n\n# AOP 有哪些实现方式？\n\n实现 AOP 的技术，主要分为两大类：\n\n * 静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；\n   * 编译时编织（特殊编译器实现）\n   * 类加载时编织（特殊的类加载器实现）。\n * 动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。\n   * JDK 动态代理\n   * CGLIB\n\n# Spring AOP and AspectJ AOP 有什么区别？\n\nSpring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。 Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。\n\n# 如何理解 Spring 中的代理？\n\n将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。\n\nAdvice + Target Object = Proxy\n\n\n# 什么是编织（Weaving）？\n\n为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：\n\n\n\n\n# 注解\n\n\n# 你用过哪些重要的 Spring 注解？\n\n * @Controller - 用于 Spring MVC 项目中的控制器类。\n * @Service - 用于服务类。\n * @RequestMapping - 用于在控制器处理程序方法中配置 URI 映射。\n * @ResponseBody - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。\n * @PathVariable - 用于将动态值从 URI 映射到处理程序方法参数。\n * @Autowired - 用于在 spring bean 中自动装配依赖项。\n * @Qualifier - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。\n * @Scope - 用于配置 spring bean 的范围。\n * @Configuration，@ComponentScan 和 @Bean - 用于基于 java 的配置。\n * @Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程（AOP）。\n\n\n# 如何在 spring 中启动注解装配？\n\n默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<context：annotation-config /> 元素在 Spring 配置文件中启用它。\n\n\n# @Component, @Controller, @Repository, @Service 有何区别？\n\n * @Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。\n * @Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。\n * @Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。\n * @Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。\n\n\n# @Required 注解有什么用？\n\n@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。\n\n示例：\n\npublic class Employee {\n    private String name;\n    @Required\n    public void setName(String name){\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n\n\n\n# @Autowired 注解有什么用？\n\n@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造器，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。\n\npublic class Employee {\n    private String name;\n    @Autowired\n    public void setName(String name) {\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n\n\n\n# @Qualifier 注解有什么用？\n\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。\n\nEmployee.java\n\npublic class Employee {\n    private String name;\n    @Autowired\n    public void setName(String name) {\n        this.name=name;\n    }\n    public string getName() {\n        return name;\n    }\n}\n\n\nEmpAccount.java\n\npublic class EmpAccount {\n    private Employee emp;\n\n    @Autowired\n    @Qualifier(emp1)\n    public void showName() {\n        System.out.println(“Employee name : ”+emp.getName);\n    }\n}\n\n\n\n# @RequestMapping 注解有什么用？\n\n@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：\n\n * 类级别：映射请求的 URL\n * 方法级别：映射 URL 以及 HTTP 请求方法\n\n\n# 数据篇\n\n\n# spring DAO 有什么用？\n\nSpring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。\n\n\n# 列举 Spring DAO 抛出的异常。\n\n\n\n\n# spring JDBC API 中存在哪些类？\n\n * JdbcTemplate\n * SimpleJdbcTemplate\n * NamedParameterJdbcTemplate\n * SimpleJdbcInsert\n * SimpleJdbcCall\n\n\n# 使用 Spring 访问 Hibernate 的方法有哪些？\n\n我们可以通过两种方式使用 Spring 访问 Hibernate：\n\n 1. 使用 Hibernate 模板和回调进行控制反转\n 2. 扩展 HibernateDAOSupport 并应用 AOP 拦截器节点\n\n\n# 列举 spring 支持的事务管理类型\n\nSpring 支持两种类型的事务管理：\n\n 1. 程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。\n 2. 声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。\n\n\n# spring 支持哪些 ORM 框架\n\n * Hibernate\n * iBatis\n * JPA\n * JDO\n * OJB\n\n\n# MVC\n\n\n# Spring MVC 框架有什么用？\n\nSpring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。\n\n\n# 描述一下 DispatcherServlet 的工作流程\n\nDispatcherServlet 的工作流程可以用一幅图来说明：\n\n\n\n 1. 向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。\n 2. DispatcherServlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。\n 3. DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(...)方法）。\n 4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\n    * HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。\n    * 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。\n 5. Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；\n 6. 根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。\n 7. ViewResolver 结合Model和View，来渲染视图。\n 8. 视图负责将渲染结果返回给客户端。\n\n\n# 介绍一下 WebApplicationContext\n\nWebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。\n\n（完）\n\n----------------------------------------\n\n👉 想学习更多 Spring 内容可以访问我的 Spring 教程：spring-notes\n\n\n# 资料\n\n * Top 50 Spring Interview Questions You Must Prepare In 2018\n * Spring Interview Questions and Answers',normalizedContent:'# spring 面试\n\n\n# 综合篇\n\n\n# 不同版本的 spring framework 有哪些主要功能？\n\nversion      feature\nspring 2.5   发布于 2007 年。这是第一个支持注解的版本。\nspring 3.0   发布于 2009 年。它完全利用了 java5 中的改进，并为 jee6 提供了支持。\nspring 4.0   发布于 2013 年。这是第一个完全支持 java8 的版本。\n\n\n# 什么是 spring framework？\n\n * spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。\n * 它是轻量级、松散耦合的。\n * 它具有分层体系结构，允许用户选择组件，同时还为 j2ee 应用程序开发提供了一个有凝聚力的框架。\n * 它可以集成其他框架，如 structs、hibernate、ejb 等，所以又称为框架的框架。\n\n\n# 列举 spring framework 的优点。\n\n * 由于 spring frameworks 的分层架构，用户可以自由选择自己需要的组件。\n * spring framework 支持 pojo(plain old java object) 编程，从而具备持续集成和可测试性。\n * 由于依赖注入和控制反转，jdbc 得以简化。\n * 它是开源免费的。\n\n\n# spring framework 有哪些不同的功能？\n\n * 轻量级 - spring 在代码量和透明度方面都很轻便。\n * ioc - 控制反转\n * aop - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。\n * 容器 - spring 负责创建和管理对象（bean）的生命周期和配置。\n * mvc - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。\n * 事务管理 - 提供了用于事务管理的通用抽象层。spring 的事务支持也可用于容器较少的环境。\n * jdbc 异常 - spring 的 jdbc 抽象层提供了一个异常层次结构，简化了错误处理策略。\n\n\n# spring framework 中有多少个模块，它们分别是什么？\n\n\n\n * spring 核心容器 – 该层基本上是 spring framework 的核心。它包含以下模块：\n   * spring core\n   * spring bean\n   * spel (spring expression language)\n   * spring context\n * 数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：\n   * jdbc (java database connectivity)\n   * orm (object relational mapping)\n   * oxm (object xml mappers)\n   * jms (java messaging service)\n   * transaction\n * web – 该层提供了创建 web 应用程序的支持。它包含以下模块：\n   * web\n   * web – servlet\n   * web – socket\n   * web – portlet\n * aop – 该层支持面向切面编程\n * instrumentation – 该层为类检测和类加载器实现提供支持。\n * test – 该层为使用 junit 和 testng 进行测试提供支持。\n * 几个杂项模块:\n   * messaging – 该模块为 stomp 提供支持。它还支持注解编程模型，该模型用于从 websocket 客户端路由和处理 stomp 消息。\n   * aspects – 该模块为与 aspectj 的集成提供支持。\n\n\n# 什么是 spring 配置文件？\n\nspring 配置文件是 xml 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，xml 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。\n\n\n# spring 应用程序有哪些不同组件？\n\nspring 应用一般有以下组件：\n\n * 接口 - 定义功能。\n * bean 类 - 它包含属性，setter 和 getter 方法，函数等。\n * spring 面向切面编程（aop） - 提供面向切面编程的功能。\n * bean 配置文件 - 包含类的信息以及如何配置它们。\n * 用户程序 - 它使用接口。\n\n\n# 使用 spring 有哪些方式？\n\n使用 spring 有以下方式：\n\n * 作为一个成熟的 spring web 应用程序。\n * 作为第三方 web 框架，使用 spring frameworks 中间层。\n * 用于远程使用。\n * 作为企业级 java bean，它可以包装现有的 pojo（plain old java objects）。\n\n\n# 核心篇\n\n\n# ioc\n\n# 什么是 ioc？什么是依赖注入？什么是 spring ioc？\n\nioc 即控制反转（inversion of control，缩写为 ioc）。ioc 又称为依赖倒置原则（设计模式六大原则之一），它的要点在于：程序要依赖于抽象接口，不要依赖于具体实现。它的作用就是用于降低代码间的耦合度。\n\nioc 的实现方式有两种：\n\n * 依赖注入（dependency injection，简称 di）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造器、函数参数等方式传递（或注入）给类使用。\n * 依赖查找（dependency lookup）：容器中的受控对象通过容器的 api 来查找自己所依赖的资源和协作对象。\n\nspring ioc 是 ioc 的一种实现。di 是 spring ioc 的主要实现原则。\n\n\n\n# 依赖注入有哪些实现方式？\n\n依赖注入有如下方式：\n\n依赖注入方式        配置元数据举例\nsetter 方法注入   <proeprty name="user" ref="userbean"/>\n构造器注入         <constructor-arg name="user" ref="userbean" />\n字段注入          @autowired user user;\n方法注入          @autowired public void user(user user) { ... }\n接口回调注入        class mybean implements beanfactoryaware { ... }\n\n# 构造器注入 vs. setter 注入\n\n构造器注入            setter 注入\n没有部分注入           有部分注入\n不会覆盖 setter 属性   会覆盖 setter 属性\n任意修改都会创建一个新实例    任意修改不会创建一个新实例\n适用于设置很多属性        适用于设置少量属性\n\n官方推荐使用构造器注入。\n\n# beanfactory vs. applicationcontext\n\n在 spring 中，有两种 ioc 容器：beanfactory 和 applicationcontext。\n\n * beanfactory：beanfactory 是 spring 基础 ioc 容器。beanfactory 提供了 spring 容器的配置框架和基本功能。\n * applicationcontext：applicationcontext 是具备应用特性的 beanfactory 的子接口。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 aop、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 applicationcontext 作为 ioc 容器，因为它的功能远多于 beanfactory。\n\n# beanfactory vs. factorybean\n\nbeanfactory 是 spring 基础 ioc 容器。\n\nfactorybean 是创建 bean 的一种方式，帮助实现复杂的初始化逻辑。\n\n# spring ioc 启动时做了哪些准备\n\nioc 配置元信息读取和解析\n\nioc 容器生命周期管理\n\nspring 事件发布\n\n国际化\n\n等等\n\n# spring ioc 的实现机制是什么\n\nspring 中的 ioc 的实现原理就是工厂模式加反射机制。\n\n示例：\n\ninterface fruit {\n     public abstract void eat();\n}\nclass apple implements fruit {\n    public void eat(){\n        system.out.println("apple");\n    }\n}\nclass orange implements fruit {\n    public void eat(){\n        system.out.println("orange");\n    }\n}\nclass factory {\n    public static fruit getinstance(string classname) {\n        fruit f=null;\n        try {\n            f=(fruit)class.forname(classname).newinstance();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n        return f;\n    }\n}\nclass client {\n    public static void main(string[] a) {\n        fruit f=factory.getinstance("io.github.dunwu.spring.apple");\n        if(f!=null){\n            f.eat();\n        }\n    }\n}\n\n\n\n# bean\n\n# 什么是 spring bean\n\n在 spring 中，构成应用程序主体由 spring ioc 容器管理的对象称为 bean。bean 是由 spring ioc 容器实例化、装配和管理的对象。 bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\nspring ioc 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 spring 能识别的格式——beandefinition 对象。\n\nbeandefinition 是 spring 中定义 bean 的配置元信息接口，它包含：\n\n * bean 类名\n * bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n * 其他 bean 引用，也可称为合作者（collaborators）或依赖（dependencies）\n * 配置设置，如 bean 属性（properties）\n\n# 如何注册 spring bean\n\n通过 beandefinition 和外部单例对象来注册。\n\n# spring 提供了哪些配置方式？\n\n * 基于 xml 配置\n\nbean 所需的依赖项和服务在 xml 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：\n\n<bean id="studentbean" class="org.edureka.firstspring.studentbean">\n <property name="name" value="edureka"></property>\n</bean>\n\n\n * 基于注解配置\n\n您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 xml 来描述 bean 装配。默认情况下，spring 容器中未打开注解装配。因此，您需要在使用它之前在 spring 配置文件中启用它。例如：\n\n<beans>\n<context:annotation-config/>\n\x3c!-- bean definitions go here --\x3e\n</beans>\n\n\n * 基于 java api 配置\n\nspring 的 java 配置是通过使用 @bean 和 @configuration 来实现。\n\n 1. @bean 注解扮演与 <bean /> 元素相同的角色。\n 2. @configuration 类允许通过简单地调用同一个类中的其他 @bean 方法来定义 bean 间依赖关系。\n\n例如：\n\n@configuration\npublic class studentconfig {\n    @bean\n    public studentbean mystudent() {\n        return new studentbean();\n    }\n}\n\n\n# spring 支持集中 bean scope？\n\nspring bean 支持 5 种 scope：\n\n * singleton - 每个 spring ioc 容器仅有一个单实例。\n * prototype - 每次请求都会产生一个新的实例。\n * request - 每一次 http 请求都会产生一个新的实例，并且该 bean 仅在当前 http 请求内有效。\n * session - 每一次 http 请求都会产生一个新的 bean，同时该 bean 仅在当前 http session 内有效。\n * global-session - 类似于标准的 http session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。portlet 规范定义了全局 session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。\n\n仅当用户使用支持 web 的 applicationcontext 时，最后三个才可用。\n\n# spring bean 的生命周期\n\n\n\nspring bean 容器的生命周期如下：\n\n 1.  spring 对 bean 进行实例化（相当于 new xxx()）\n\n 2.  spring 将值和引用注入到 bean 对应的属性中\n\n 3.  如果 bean 实现了 beannameaware 接口，spring 将 bean 的 id 传递给 setbeanname 方法\n     \n     * 作用是通过 bean 的引用来获得 bean id，一般业务中是很少有用到 bean 的 id 的\n\n 4.  如果 bean 实现了 beanfactoryaware 接口，spring 将调用 setbeandactory 方法，并把 beanfactory 容器实例作为参数传入。\n     \n     * 作用是获取 spring 容器，如 bean 通过 spring 容器发布事件等\n\n 5.  如果 bean 实现了 applicationcontextaware 接口，spring 容器将调用 setapplicationcontext 方法，把应用上下文作为参数传入\n     \n     * 作用与 beanfactory 类似都是为了获取 spring 容器，不同的是 spring 容器在调用 setapplicationcontext 方法时会把它自己作为 setapplicationcontext 的参数传入，而 spring 容器在调用 setbeanfactory 前需要使用者自己指定（注入）setbeanfactory 里的参数 beanfactory\n\n 6.  如果 bean 实现了 beanpostprocess 接口，spring 将调用 postprocessbeforeinitialization 方法\n     \n     * 作用是在 bean 实例创建成功后对其进行增强处理，如对 bean 进行修改，增加某个功能\n\n 7.  如果 bean 实现了 initializingbean 接口，spring 将调用 afterpropertiesset 方法，作用与在配置文件中对 bean 使用 init-method 声明初始化的作用一样，都是在 bean 的全部属性设置成功后执行的初始化方法。\n\n 8.  如果 bean 实现了 beanpostprocess 接口，spring 将调用 postprocessafterinitialization 方法\n     \n     * postprocessbeforeinitialization 是在 bean 初始化前执行的，而 postprocessafterinitialization 是在 bean 初始化后执行的\n\n 9.  经过以上的工作后，bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n\n 10. 如果 bean 实现了 dispostblebean 接口，spring 将调用它的 destory 方法，作用与在配置文件中对 bean 使用 destory-method 属性的作用一样，都是在 bean 实例销毁前执行的方法。\n\n# 什么是 spring 的内部 bean？\n\n只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，spring 的基于 xml 的配置元数据在 <property> 或 <constructor-arg> 中提供了 <bean> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。\n\n例如，假设我们有一个 student 类，其中引用了 person 类。这里我们将只创建一个 person 类实例并在 student 中使用它。\n\nstudent.java\n\npublic class student {\n    private person person;\n    //setters and getters\n}\npublic class person {\n    private string name;\n    private string address;\n    //setters and getters\n}\n\n\nbean.xml\n\n<bean id=“studentbean" class="com.edureka.student">\n    <property name="person">\n        \x3c!--this is inner bean --\x3e\n        <bean class="com.edureka.person">\n            <property name="name" value=“scott"></property>\n            <property name="address" value=“bangalore"></property>\n        </bean>\n    </property>\n</bean>\n\n\n# 什么是 spring 装配\n\n当 bean 在 spring 容器中组合在一起时，它被称为装配或 bean 装配。 spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。\n\n# 自动装配有哪些方式？\n\nspring 容器能够自动装配 bean。也就是说，可以通过检查 beanfactory 的内容让 spring 自动解析 bean 的协作者。\n\n自动装配的不同模式：\n\n * no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。\n * byname - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 xml 文件中由相同名称定义的 bean。\n * bytype - 它根据类型注入对象依赖项。如果属性的类型与 xml 文件中的一个 bean 名称匹配，则匹配并装配属性。\n * 构造器 - 它通过调用类的构造器来注入依赖项。它有大量的参数。\n * autodetect - 首先容器尝试通过构造器使用 autowire 装配，如果不能，则尝试通过 bytype 自动装配。\n\n# 自动装配有什么局限？\n\n * 覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。\n * 基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。\n * 令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。\n\n\n# aop\n\n# 什么是 aop？\n\naop(aspect-oriented programming), 即 面向切面编程, 它与 oop( object-oriented programming, 面向对象编程) 相辅相成, 提供了与 oop 不同的抽象软件结构的视角. 在 oop 中, 我们以类(class)作为我们的基本单元, 而 aop 中的基本单元是 aspect(切面)\n\n# aop 中的 aspect、advice、pointcut、jointpoint 和 advice 参数分别是什么？\n\n\n\n * aspect - aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 spring bean 配置文件中配置，或者我们可以使用 spring aspectj 支持使用 @aspect 注解将类声明为 aspect。\n * advice - advice 是针对特定 joinpoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 joinpoint 时执行的方法。您可以将 advice 视为 spring 拦截器（interceptor）或 servlet 过滤器（filter）。\n * advice arguments - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。\n * pointcut - pointcut 是与 joinpoint 匹配的正则表达式，用于确定是否需要执行 advice。 pointcut 使用与 joinpoint 匹配的不同类型的表达式。spring 框架使用 aspectj pointcut 表达式语言来确定将应用通知方法的 joinpoint。\n * joinpoint - joinpoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 spring aop 中，joinpoint 始终是方法的执行器。\n\n# 什么是通知（advice）？\n\n特定 joinpoint 处的 aspect 所采取的动作称为 advice。spring aop 使用一个 advice 作为拦截器，在 joinpoint “周围”维护一系列的拦截器。\n\n# 有哪些类型的通知（advice）？\n\n * before - 这些类型的 advice 在 joinpoint 方法之前执行，并使用 @before 注解标记进行配置。\n * after returning - 这些类型的 advice 在连接点方法正常执行后执行，并使用@afterreturning 注解标记进行配置。\n * after throwing - 这些类型的 advice 仅在 joinpoint 方法通过抛出异常退出并使用 @afterthrowing 注解标记配置时执行。\n * after (finally) - 这些类型的 advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @after 注解标记进行配置。\n * around - 这些类型的 advice 在连接点之前和之后执行，并使用 @around 注解标记进行配置。\n\n# 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。\n\nconcern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。\n\ncross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。\n\n# aop 有哪些实现方式？\n\n实现 aop 的技术，主要分为两大类：\n\n * 静态代理 - 指使用 aop 框架提供的命令进行编译，从而在编译阶段就可生成 aop 代理类，因此也称为编译时增强；\n   * 编译时编织（特殊编译器实现）\n   * 类加载时编织（特殊的类加载器实现）。\n * 动态代理 - 在运行时在内存中“临时”生成 aop 动态代理类，因此也被称为运行时增强。\n   * jdk 动态代理\n   * cglib\n\n# spring aop and aspectj aop 有什么区别？\n\nspring aop 基于动态代理方式实现；aspectj 基于静态代理方式实现。 spring aop 仅支持方法级别的 pointcut；提供了完全的 aop 支持，它还支持属性级别的 pointcut。\n\n# 如何理解 spring 中的代理？\n\n将 advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。\n\nadvice + target object = proxy\n\n\n# 什么是编织（weaving）？\n\n为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（weaving）。在 spring aop 中，编织在运行时执行。请参考下图：\n\n\n\n\n# 注解\n\n\n# 你用过哪些重要的 spring 注解？\n\n * @controller - 用于 spring mvc 项目中的控制器类。\n * @service - 用于服务类。\n * @requestmapping - 用于在控制器处理程序方法中配置 uri 映射。\n * @responsebody - 用于发送 object 作为响应，通常用于发送 xml 或 json 数据作为响应。\n * @pathvariable - 用于将动态值从 uri 映射到处理程序方法参数。\n * @autowired - 用于在 spring bean 中自动装配依赖项。\n * @qualifier - 使用 @autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。\n * @scope - 用于配置 spring bean 的范围。\n * @configuration，@componentscan 和 @bean - 用于基于 java 的配置。\n * @aspect，@before，@after，@around，@pointcut - 用于切面编程（aop）。\n\n\n# 如何在 spring 中启动注解装配？\n\n默认情况下，spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<context：annotation-config /> 元素在 spring 配置文件中启用它。\n\n\n# @component, @controller, @repository, @service 有何区别？\n\n * @component：这将 java 类标记为 bean。它是任何 spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。\n * @controller：这将一个类标记为 spring web mvc 控制器。标有它的 bean 会自动导入到 ioc 容器中。\n * @service：此注解是组件注解的特化。它不会对 @component 注解提供任何其他行为。您可以在服务层类中使用 @service 而不是 @component，因为它以更好的方式指定了意图。\n * @repository：这个注解是具有类似用途和功能的 @component 注解的特化。它为 dao 提供了额外的好处。它将 dao 导入 ioc 容器，并使未经检查的异常有资格转换为 spring dataaccessexception。\n\n\n# @required 注解有什么用？\n\n@required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 beaninitializationexception。\n\n示例：\n\npublic class employee {\n    private string name;\n    @required\n    public void setname(string name){\n        this.name=name;\n    }\n    public string getname(){\n        return name;\n    }\n}\n\n\n\n# @autowired 注解有什么用？\n\n@autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造器，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。\n\npublic class employee {\n    private string name;\n    @autowired\n    public void setname(string name) {\n        this.name=name;\n    }\n    public string getname(){\n        return name;\n    }\n}\n\n\n\n# @qualifier 注解有什么用？\n\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@qualifier 注解和 @autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n例如，这里我们分别有两个类，employee 和 empaccount。在 empaccount 中，使用@qualifier 指定了必须装配 id 为 emp1 的 bean。\n\nemployee.java\n\npublic class employee {\n    private string name;\n    @autowired\n    public void setname(string name) {\n        this.name=name;\n    }\n    public string getname() {\n        return name;\n    }\n}\n\n\nempaccount.java\n\npublic class empaccount {\n    private employee emp;\n\n    @autowired\n    @qualifier(emp1)\n    public void showname() {\n        system.out.println(“employee name : ”+emp.getname);\n    }\n}\n\n\n\n# @requestmapping 注解有什么用？\n\n@requestmapping 注解用于将特定 http 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：\n\n * 类级别：映射请求的 url\n * 方法级别：映射 url 以及 http 请求方法\n\n\n# 数据篇\n\n\n# spring dao 有什么用？\n\nspring dao 使得 jdbc，hibernate 或 jdo 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。\n\n\n# 列举 spring dao 抛出的异常。\n\n\n\n\n# spring jdbc api 中存在哪些类？\n\n * jdbctemplate\n * simplejdbctemplate\n * namedparameterjdbctemplate\n * simplejdbcinsert\n * simplejdbccall\n\n\n# 使用 spring 访问 hibernate 的方法有哪些？\n\n我们可以通过两种方式使用 spring 访问 hibernate：\n\n 1. 使用 hibernate 模板和回调进行控制反转\n 2. 扩展 hibernatedaosupport 并应用 aop 拦截器节点\n\n\n# 列举 spring 支持的事务管理类型\n\nspring 支持两种类型的事务管理：\n\n 1. 程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。\n 2. 声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 xml 的配置来管理事务。\n\n\n# spring 支持哪些 orm 框架\n\n * hibernate\n * ibatis\n * jpa\n * jdo\n * ojb\n\n\n# mvc\n\n\n# spring mvc 框架有什么用？\n\nspring web mvc 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 web 应用程序。 mvc 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 ui 逻辑，同时在所有这些元素之间提供松散耦合。\n\n\n# 描述一下 dispatcherservlet 的工作流程\n\ndispatcherservlet 的工作流程可以用一幅图来说明：\n\n\n\n 1. 向服务器发送 http 请求，请求被前端控制器 dispatcherservlet 捕获。\n 2. dispatcherservlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 url 进行解析，得到请求资源标识符（uri）。然后根据该 uri，调用 handlermapping 获得该 handler 配置的所有相关的对象（包括 handler 对象以及 handler 对象对应的拦截器），最后以handlerexecutionchain 对象的形式返回。\n 3. dispatcherservlet 根据获得的handler，选择一个合适的 handleradapter。（附注：如果成功获得handleradapter后，此时将开始执行拦截器的 prehandler(...)方法）。\n 4. 提取request中的模型数据，填充handler入参，开始执行handler（controller)。 在填充handler的入参过程中，根据你的配置，spring 将帮你做一些额外的工作：\n    * httpmessageconveter： 将请求消息（如 json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如string转换成integer、double等。\n    * 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到bindingresult或error中。\n 5. handler(controller)执行完成后，向 dispatcherservlet 返回一个 modelandview 对象；\n 6. 根据返回的modelandview，选择一个适合的 viewresolver（必须是已经注册到 spring 容器中的viewresolver)返回给dispatcherservlet。\n 7. viewresolver 结合model和view，来渲染视图。\n 8. 视图负责将渲染结果返回给客户端。\n\n\n# 介绍一下 webapplicationcontext\n\nwebapplicationcontext 是 applicationcontext 的扩展。它具有 web 应用程序所需的一些额外功能。它与普通的 applicationcontext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。\n\n（完）\n\n----------------------------------------\n\n👉 想学习更多 spring 内容可以访问我的 spring 教程：spring-notes\n\n\n# 资料\n\n * top 50 spring interview questions you must prepare in 2018\n * spring interview questions and answers',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring Bean",frontmatter:{title:"Spring Bean",date:"2021-12-10T19:15:42.000Z",order:1,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Bean","BeanDefinition"],permalink:"/pages/68097d/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/01.SpringBean.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/01.SpringBean.md",key:"v-cbe3e38e",path:"/pages/68097d/",headers:[{level:2,title:"Spring Bean 定义",slug:"spring-bean-定义",normalizedTitle:"spring bean 定义",charIndex:133},{level:3,title:"BeanDefinition",slug:"beandefinition",normalizedTitle:"beandefinition",charIndex:152},{level:4,title:"BeanDefinition 元信息",slug:"beandefinition-元信息",normalizedTitle:"beandefinition 元信息",charIndex:428},{level:4,title:"BeanDefinition 构建",slug:"beandefinition-构建",normalizedTitle:"beandefinition 构建",charIndex:931},{level:3,title:"Spring Bean 命名",slug:"spring-bean-命名",normalizedTitle:"spring bean 命名",charIndex:1085},{level:4,title:"Spring Bean 命名规则",slug:"spring-bean-命名规则",normalizedTitle:"spring bean 命名规则",charIndex:1103},{level:4,title:"Spring Bean 命名生成器",slug:"spring-bean-命名生成器",normalizedTitle:"spring bean 命名生成器",charIndex:1469},{level:4,title:"Spring Bean 别名",slug:"spring-bean-别名",normalizedTitle:"spring bean 别名",charIndex:1769},{level:2,title:"Spring Bean 生命周期",slug:"spring-bean-生命周期",normalizedTitle:"spring bean 生命周期",charIndex:2166},{level:2,title:"Spring Bean 注册",slug:"spring-bean-注册",normalizedTitle:"spring bean 注册",charIndex:3495},{level:3,title:"XML 配置元信息",slug:"xml-配置元信息",normalizedTitle:"xml 配置元信息",charIndex:3564},{level:3,title:"注解配置元信息",slug:"注解配置元信息",normalizedTitle:"注解配置元信息",charIndex:3651},{level:3,title:"Java API 配置元信息",slug:"java-api-配置元信息",normalizedTitle:"java api 配置元信息",charIndex:3710},{level:2,title:"Spring Bean 实例化",slug:"spring-bean-实例化",normalizedTitle:"spring bean 实例化",charIndex:4016},{level:2,title:"Spring Bean 初始化和销毁",slug:"spring-bean-初始化和销毁",normalizedTitle:"spring bean 初始化和销毁",charIndex:4546},{level:2,title:"Spring Bean 垃圾回收",slug:"spring-bean-垃圾回收",normalizedTitle:"spring bean 垃圾回收",charIndex:5589},{level:2,title:"Spring Bean 作用范围",slug:"spring-bean-作用范围",normalizedTitle:"spring bean 作用范围",charIndex:5703},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6830}],headersStr:"Spring Bean 定义 BeanDefinition BeanDefinition 元信息 BeanDefinition 构建 Spring Bean 命名 Spring Bean 命名规则 Spring Bean 命名生成器 Spring Bean 别名 Spring Bean 生命周期 Spring Bean 注册 XML 配置元信息 注解配置元信息 Java API 配置元信息 Spring Bean 实例化 Spring Bean 初始化和销毁 Spring Bean 垃圾回收 Spring Bean 作用范围 参考资料",content:'# Spring Bean\n\n在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。Bean 是由 Spring IoC 容器实例化、装配和管理的对象。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\n\n# Spring Bean 定义\n\n\n# BeanDefinition\n\nSpring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——BeanDefinition 对象。\n\nBeanDefinition 是 Spring 中定义 Bean 的配置元信息接口，它包含：\n\n * Bean 类名\n * Bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n * 其他 Bean 引用，也可称为合作者（Collaborators）或依赖（Dependencies）\n * 配置设置，如 Bean 属性（Properties）\n\n# BeanDefinition 元信息\n\nBeanDefinition 元信息如下：\n\n属性（PROPERTY）               说明\nClass                      全类名，必须是具体类，不能用抽象类或接口\nName                       Bean 的名称或者 ID\nScope                      Bean 的作用域（如：singleton、prototype 等）\nConstructor arguments      Bean 构造器参数（用于依赖注入）\nProperties                 Bean 属性设置（用于依赖注入）\nAutowiring mode            Bean 自动绑定模式（如：通过名称 byName）\nLazy initialization mode   Bean 延迟初始化模式（延迟和非延迟）\nInitialization method      Bean 初始化回调方法名称\nDestruction method         Bean 销毁回调方法名称\n\n# BeanDefinition 构建\n\nBeanDefinition 构建方式：\n\n * 通过 BeanDefinitionBuilder\n\n * 通过 AbstractBeanDefinition 以及派生类\n\n> 💻 Spring Bean 定义示例源码：BeanDefinitionTests\n\n\n# Spring Bean 命名\n\n# Spring Bean 命名规则\n\n每个 Bean 拥有一个或多个标识符（identifiers），这些标识符在 Bean 所在的容器必须是唯一的。通常，一个 Bean 仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。\n\n在基于 XML 的配置元信息中，开发人员可以使用 id 属性、name 属性或来指定 Bean 标识符。通常，Bean 的标识符由字母组成，允许出现特殊字符。如果要想引入 Bean 的别名的话，可在 name 属性使用半角逗号（“,”）或分号（“;”) 来间隔。\n\nSpring 中，为 Bean 指定 id 和 name 属性不是必须的。如果不指定，Spring 会自动为 Bean 分配一个唯一的名称。尽管 Bean 的命名没有限制，不过官方建议采用驼峰命名法来命名 Bean。\n\n# Spring Bean 命名生成器\n\nSpring 提供了两种 Spring Bean 命名生成器：\n\n * DefaultBeanNameGenerator：默认通用 BeanNameGenerator 实现。\n * AnnotationBeanNameGenerator：基于注解扫描的 BeanNameGenerator 实现。\n\npublic interface BeanNameGenerator {\n   String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry);\n}\n\n\n# Spring Bean 别名\n\nSpring 支持通过 <alias> 属性为 Bean 设置别名。\n\nBean 别名（Alias）的作用：\n\n * 复用现有的 BeanDefinition\n * 更具有场景化的命名方法，比如：\n   * <alias name="myApp-dataSource" alias="subsystemA-dataSource"/>\n   * <alias name="myApp-dataSource" alias="subsystemB-dataSource"/>\n\n<bean id="user" class="io.github.dunwu.spring.core.bean.entity.person.User">\n  \x3c!-- 属性略 --\x3e\n</bean>\n<alias name="user" alias="aliasUser" />\n\n\n\n# Spring Bean 生命周期\n\n\n\n 1.  Spring 对 Bean 进行实例化（相当于 new XXX()）\n\n 2.  Spring 将值和引用注入到 Bean 对应的属性中\n\n 3.  如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName 方法\n     \n     * 作用是通过 Bean 的引用来获得 Bean ID，一般业务中是很少有用到 Bean 的 ID 的\n\n 4.  如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanDactory 方法，并把 BeanFactory 容器实例作为参数传入。\n     \n     * 作用是获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等\n\n 5.  如果 Bean 实现了 ApplicationContextAware 接口，Spring 容器将调用 setApplicationContext 方法，把应用上下文作为参数传入\n     \n     * 作用与 BeanFactory 类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用 setApplicationContext 方法时会把它自己作为 setApplicationContext 的参数传入，而 Spring 容器在调用 setBeanFactory 前需要使用者自己指定（注入）setBeanFactory 里的参数 BeanFactory\n\n 6.  如果 Bean 实现了 BeanPostProcess 接口，Spring 将调用 postProcessBeforeInitialization 方法\n     \n     * 作用是在 Bean 实例创建成功后对其进行增强处理，如对 Bean 进行修改，增加某个功能\n\n 7.  如果 Bean 实现了 InitializingBean 接口，Spring 将调用 afterPropertiesSet 方法，作用与在配置文件中对 Bean 使用 init-method 声明初始化的作用一样，都是在 Bean 的全部属性设置成功后执行的初始化方法。\n\n 8.  如果 Bean 实现了 BeanPostProcess 接口，Spring 将调用 postProcessAfterInitialization 方法\n     \n     * postProcessBeforeInitialization 是在 Bean 初始化前执行的，而 postProcessAfterInitialization 是在 Bean 初始化后执行的\n\n 9.  经过以上的工作后，Bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n\n 10. 如果 Bean 实现了 DispostbleBean 接口，Spring 将调用它的 destory 方法，作用与在配置文件中对 Bean 使用 destory-method 属性的作用一样，都是在 Bean 实例销毁前执行的方法。\n\n\n# Spring Bean 注册\n\n注册 Spring Bean 实际上是将 BeanDefinition 注册到 IoC 容器中。\n\n\n# XML 配置元信息\n\nSpring 的传统配置方式。在 <bean> 标签中配置元数据内容。\n\n缺点是当 JavaBean 过多时，产生的配置文件足以让你眼花缭乱。\n\n\n# 注解配置元信息\n\n使用 @Bean、@Component、@Import 注解注册 Spring Bean。\n\n\n# Java API 配置元信息\n\n * 命名方式：BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)\n * 非命名方式：BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,BeanDefinitionRegistry)\n * 配置类方式：AnnotatedBeanDefinitionReader#register(Class...)\n\n> 💻 Spring Bean 注册示例源码：BeanRegistryTests\n\n\n# Spring Bean 实例化\n\nSpring Bean 实例化方式：\n\n * 常规方式\n   * 通过构造器（配置元信息：XML、Java 注解和 Java API）\n   * 通过静态方法（配置元信息：XML、Java 注解和 Java API）\n   * 通过 Bean 工厂方法（配置元信息：XML、Java 注解和 Java API）\n   * 通过 FactoryBean（配置元信息：XML、Java 注解和 Java API）\n * 特殊方式\n   * 通过 ServiceLoaderFactoryBean（配置元信息：XML、Java 注解和 Java API ）\n   * 通过 AutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)\n   * 通过 BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)\n\n> 💻 Spring Bean 实例化示例源码：BeanInstantiationTests、BeanInstantiationSpecialTests\n\n\n# Spring Bean 初始化和销毁\n\nSpring Bean 初始化和销毁的方式有以下几种：\n\n 1. 使用 @PostConstruct 和 @PreDestroy 注解分别指定相应的初始化方法和销毁方法。\n\n 2. 实现 InitializingBean 接口的 afterPropertiesSet() 方法来编写初始化方法；实现 DisposableBean 接口的 destroy() 方法来编写销毁方法。\n    \n    * InitializingBean 接口包含一个 afterPropertiesSet 方法，可以通过实现该接口，然后在这个方法中编写初始化逻辑。\n    * DisposableBean接口包含一个 destory 方法，可以通过实现该接口，然后在这个方法中编写销毁逻辑。\n\n 3. 自定义初始化方法\n    \n    * XML 配置：<bean init-method="init" destroy="destroy" ... />\n    * Java 注解：@Bean(initMethod = "init", destroyMethod = "destroy")\n    * Java API：AbstractBeanDefinition#setInitMethodName(String) 和 AbstractBeanDefinition#setDestroyMethodName(String) 分别定义初始化和销毁方法\n\n注意：如果同时存在，执行顺序会按照序列执行。\n\nBean 的延迟初始化\n\n * xml 方式：<bean lazy-init="true" ... />\n * 注解方式：@Lazy\n\nSpring 提供了一个 BeanPostProcessor 接口，提供了两个方法 postProcessBeforeInitialization 和 postProcessAfterInitialization。其中postProcessBeforeInitialization 在组件的初始化方法调用之前执行，postProcessAfterInitialization 在组件的初始化方法调用之后执行。它们都包含两个入参：\n\n * bean：当前组件对象；\n * beanName：当前组件在容器中的名称。\n\n> 💻 Spring Bean 初始化和销毁示例源码：BeanInitDestroyTests\n\n\n# Spring Bean 垃圾回收\n\nSpring Bean 垃圾回收步骤：\n\n 1. 关闭 Spring 容器（应用上下文）\n 2. 执行 GC\n 3. Spring Bean 覆盖的 finalize() 方法被回调\n\n\n# Spring Bean 作用范围\n\nSCOPE         DESCRIPTION\nsingleton     (Default) Scopes a single bean definition to a single object\n              instance for each Spring IoC container.\nprototype     Scopes a single bean definition to any number of object\n              instances.\nrequest       Scopes a single bean definition to the lifecycle of a single\n              HTTP request. That is, each HTTP request has its own\n              instance of a bean created off the back of a single bean\n              definition. Only valid in the context of a web-aware Spring\n              ApplicationContext.\nsession       Scopes a single bean definition to the lifecycle of an HTTP\n              Session. Only valid in the context of a web-aware Spring\n              ApplicationContext.\napplication   Scopes a single bean definition to the lifecycle of a\n              ServletContext. Only valid in the context of a web-aware\n              Spring ApplicationContext.\nwebsocket     Scopes a single bean definition to the lifecycle of a\n              WebSocket. Only valid in the context of a web-aware Spring\n              ApplicationContext.\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring bean\n\n在 spring 中，构成应用程序主体由 spring ioc 容器管理的对象称为 bean。bean 是由 spring ioc 容器实例化、装配和管理的对象。 bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n\n\n# spring bean 定义\n\n\n# beandefinition\n\nspring ioc 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 spring 能识别的格式——beandefinition 对象。\n\nbeandefinition 是 spring 中定义 bean 的配置元信息接口，它包含：\n\n * bean 类名\n * bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\n * 其他 bean 引用，也可称为合作者（collaborators）或依赖（dependencies）\n * 配置设置，如 bean 属性（properties）\n\n# beandefinition 元信息\n\nbeandefinition 元信息如下：\n\n属性（property）               说明\nclass                      全类名，必须是具体类，不能用抽象类或接口\nname                       bean 的名称或者 id\nscope                      bean 的作用域（如：singleton、prototype 等）\nconstructor arguments      bean 构造器参数（用于依赖注入）\nproperties                 bean 属性设置（用于依赖注入）\nautowiring mode            bean 自动绑定模式（如：通过名称 byname）\nlazy initialization mode   bean 延迟初始化模式（延迟和非延迟）\ninitialization method      bean 初始化回调方法名称\ndestruction method         bean 销毁回调方法名称\n\n# beandefinition 构建\n\nbeandefinition 构建方式：\n\n * 通过 beandefinitionbuilder\n\n * 通过 abstractbeandefinition 以及派生类\n\n> 💻 spring bean 定义示例源码：beandefinitiontests\n\n\n# spring bean 命名\n\n# spring bean 命名规则\n\n每个 bean 拥有一个或多个标识符（identifiers），这些标识符在 bean 所在的容器必须是唯一的。通常，一个 bean 仅有一个标识符，如果需要额外的，可考虑使用别名（alias）来扩充。\n\n在基于 xml 的配置元信息中，开发人员可以使用 id 属性、name 属性或来指定 bean 标识符。通常，bean 的标识符由字母组成，允许出现特殊字符。如果要想引入 bean 的别名的话，可在 name 属性使用半角逗号（“,”）或分号（“;”) 来间隔。\n\nspring 中，为 bean 指定 id 和 name 属性不是必须的。如果不指定，spring 会自动为 bean 分配一个唯一的名称。尽管 bean 的命名没有限制，不过官方建议采用驼峰命名法来命名 bean。\n\n# spring bean 命名生成器\n\nspring 提供了两种 spring bean 命名生成器：\n\n * defaultbeannamegenerator：默认通用 beannamegenerator 实现。\n * annotationbeannamegenerator：基于注解扫描的 beannamegenerator 实现。\n\npublic interface beannamegenerator {\n   string generatebeanname(beandefinition definition, beandefinitionregistry registry);\n}\n\n\n# spring bean 别名\n\nspring 支持通过 <alias> 属性为 bean 设置别名。\n\nbean 别名（alias）的作用：\n\n * 复用现有的 beandefinition\n * 更具有场景化的命名方法，比如：\n   * <alias name="myapp-datasource" alias="subsystema-datasource"/>\n   * <alias name="myapp-datasource" alias="subsystemb-datasource"/>\n\n<bean id="user" class="io.github.dunwu.spring.core.bean.entity.person.user">\n  \x3c!-- 属性略 --\x3e\n</bean>\n<alias name="user" alias="aliasuser" />\n\n\n\n# spring bean 生命周期\n\n\n\n 1.  spring 对 bean 进行实例化（相当于 new xxx()）\n\n 2.  spring 将值和引用注入到 bean 对应的属性中\n\n 3.  如果 bean 实现了 beannameaware 接口，spring 将 bean 的 id 传递给 setbeanname 方法\n     \n     * 作用是通过 bean 的引用来获得 bean id，一般业务中是很少有用到 bean 的 id 的\n\n 4.  如果 bean 实现了 beanfactoryaware 接口，spring 将调用 setbeandactory 方法，并把 beanfactory 容器实例作为参数传入。\n     \n     * 作用是获取 spring 容器，如 bean 通过 spring 容器发布事件等\n\n 5.  如果 bean 实现了 applicationcontextaware 接口，spring 容器将调用 setapplicationcontext 方法，把应用上下文作为参数传入\n     \n     * 作用与 beanfactory 类似都是为了获取 spring 容器，不同的是 spring 容器在调用 setapplicationcontext 方法时会把它自己作为 setapplicationcontext 的参数传入，而 spring 容器在调用 setbeanfactory 前需要使用者自己指定（注入）setbeanfactory 里的参数 beanfactory\n\n 6.  如果 bean 实现了 beanpostprocess 接口，spring 将调用 postprocessbeforeinitialization 方法\n     \n     * 作用是在 bean 实例创建成功后对其进行增强处理，如对 bean 进行修改，增加某个功能\n\n 7.  如果 bean 实现了 initializingbean 接口，spring 将调用 afterpropertiesset 方法，作用与在配置文件中对 bean 使用 init-method 声明初始化的作用一样，都是在 bean 的全部属性设置成功后执行的初始化方法。\n\n 8.  如果 bean 实现了 beanpostprocess 接口，spring 将调用 postprocessafterinitialization 方法\n     \n     * postprocessbeforeinitialization 是在 bean 初始化前执行的，而 postprocessafterinitialization 是在 bean 初始化后执行的\n\n 9.  经过以上的工作后，bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\n\n 10. 如果 bean 实现了 dispostblebean 接口，spring 将调用它的 destory 方法，作用与在配置文件中对 bean 使用 destory-method 属性的作用一样，都是在 bean 实例销毁前执行的方法。\n\n\n# spring bean 注册\n\n注册 spring bean 实际上是将 beandefinition 注册到 ioc 容器中。\n\n\n# xml 配置元信息\n\nspring 的传统配置方式。在 <bean> 标签中配置元数据内容。\n\n缺点是当 javabean 过多时，产生的配置文件足以让你眼花缭乱。\n\n\n# 注解配置元信息\n\n使用 @bean、@component、@import 注解注册 spring bean。\n\n\n# java api 配置元信息\n\n * 命名方式：beandefinitionregistry#registerbeandefinition(string,beandefinition)\n * 非命名方式：beandefinitionreaderutils#registerwithgeneratedname(abstractbeandefinition,beandefinitionregistry)\n * 配置类方式：annotatedbeandefinitionreader#register(class...)\n\n> 💻 spring bean 注册示例源码：beanregistrytests\n\n\n# spring bean 实例化\n\nspring bean 实例化方式：\n\n * 常规方式\n   * 通过构造器（配置元信息：xml、java 注解和 java api）\n   * 通过静态方法（配置元信息：xml、java 注解和 java api）\n   * 通过 bean 工厂方法（配置元信息：xml、java 注解和 java api）\n   * 通过 factorybean（配置元信息：xml、java 注解和 java api）\n * 特殊方式\n   * 通过 serviceloaderfactorybean（配置元信息：xml、java 注解和 java api ）\n   * 通过 autowirecapablebeanfactory#createbean(java.lang.class, int, boolean)\n   * 通过 beandefinitionregistry#registerbeandefinition(string,beandefinition)\n\n> 💻 spring bean 实例化示例源码：beaninstantiationtests、beaninstantiationspecialtests\n\n\n# spring bean 初始化和销毁\n\nspring bean 初始化和销毁的方式有以下几种：\n\n 1. 使用 @postconstruct 和 @predestroy 注解分别指定相应的初始化方法和销毁方法。\n\n 2. 实现 initializingbean 接口的 afterpropertiesset() 方法来编写初始化方法；实现 disposablebean 接口的 destroy() 方法来编写销毁方法。\n    \n    * initializingbean 接口包含一个 afterpropertiesset 方法，可以通过实现该接口，然后在这个方法中编写初始化逻辑。\n    * disposablebean接口包含一个 destory 方法，可以通过实现该接口，然后在这个方法中编写销毁逻辑。\n\n 3. 自定义初始化方法\n    \n    * xml 配置：<bean init-method="init" destroy="destroy" ... />\n    * java 注解：@bean(initmethod = "init", destroymethod = "destroy")\n    * java api：abstractbeandefinition#setinitmethodname(string) 和 abstractbeandefinition#setdestroymethodname(string) 分别定义初始化和销毁方法\n\n注意：如果同时存在，执行顺序会按照序列执行。\n\nbean 的延迟初始化\n\n * xml 方式：<bean lazy-init="true" ... />\n * 注解方式：@lazy\n\nspring 提供了一个 beanpostprocessor 接口，提供了两个方法 postprocessbeforeinitialization 和 postprocessafterinitialization。其中postprocessbeforeinitialization 在组件的初始化方法调用之前执行，postprocessafterinitialization 在组件的初始化方法调用之后执行。它们都包含两个入参：\n\n * bean：当前组件对象；\n * beanname：当前组件在容器中的名称。\n\n> 💻 spring bean 初始化和销毁示例源码：beaninitdestroytests\n\n\n# spring bean 垃圾回收\n\nspring bean 垃圾回收步骤：\n\n 1. 关闭 spring 容器（应用上下文）\n 2. 执行 gc\n 3. spring bean 覆盖的 finalize() 方法被回调\n\n\n# spring bean 作用范围\n\nscope         description\nsingleton     (default) scopes a single bean definition to a single object\n              instance for each spring ioc container.\nprototype     scopes a single bean definition to any number of object\n              instances.\nrequest       scopes a single bean definition to the lifecycle of a single\n              http request. that is, each http request has its own\n              instance of a bean created off the back of a single bean\n              definition. only valid in the context of a web-aware spring\n              applicationcontext.\nsession       scopes a single bean definition to the lifecycle of an http\n              session. only valid in the context of a web-aware spring\n              applicationcontext.\napplication   scopes a single bean definition to the lifecycle of a\n              servletcontext. only valid in the context of a web-aware\n              spring applicationcontext.\nwebsocket     scopes a single bean definition to the lifecycle of a\n              websocket. only valid in the context of a web-aware spring\n              applicationcontext.\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring IoC",frontmatter:{title:"Spring IoC",date:"2020-08-30T16:06:10.000Z",order:2,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","IOC"],permalink:"/pages/915530/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/02.SpringIoC.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/02.SpringIoC.md",key:"v-4c6b8695",path:"/pages/915530/",headers:[{level:2,title:"IoC 简介",slug:"ioc-简介",normalizedTitle:"ioc 简介",charIndex:17},{level:3,title:"IoC 是什么",slug:"ioc-是什么",normalizedTitle:"ioc 是什么",charIndex:28},{level:3,title:"IoC 能做什么",slug:"ioc-能做什么",normalizedTitle:"ioc 能做什么",charIndex:671},{level:3,title:"IoC 和 DI",slug:"ioc-和-di",normalizedTitle:"ioc 和 di",charIndex:1081},{level:3,title:"IoC 容器",slug:"ioc-容器",normalizedTitle:"ioc 容器",charIndex:471},{level:3,title:"Bean",slug:"bean",normalizedTitle:"bean",charIndex:1497},{level:3,title:"Spring IoC",slug:"spring-ioc-2",normalizedTitle:"spring ioc",charIndex:2},{level:2,title:"IoC 容器",slug:"ioc-容器-2",normalizedTitle:"ioc 容器",charIndex:471},{level:3,title:"配置元数据",slug:"配置元数据",normalizedTitle:"配置元数据",charIndex:1586},{level:3,title:"实例化容器",slug:"实例化容器",normalizedTitle:"实例化容器",charIndex:3390},{level:3,title:"使用容器",slug:"使用容器",normalizedTitle:"使用容器",charIndex:3519},{level:2,title:"IoC 依赖来源",slug:"ioc-依赖来源",normalizedTitle:"ioc 依赖来源",charIndex:8776},{level:2,title:"IoC 配置元数据",slug:"ioc-配置元数据",normalizedTitle:"ioc 配置元数据",charIndex:8821},{level:3,title:"Xml 配置",slug:"xml-配置",normalizedTitle:"xml 配置",charIndex:9025},{level:4,title:"实例化容器",slug:"实例化容器-2",normalizedTitle:"实例化容器",charIndex:3390},{level:4,title:"使用容器",slug:"使用容器-2",normalizedTitle:"使用容器",charIndex:3519},{level:3,title:"注解配置",slug:"注解配置",normalizedTitle:"注解配置",charIndex:3758},{level:4,title:"启动注解",slug:"启动注解",normalizedTitle:"启动注解",charIndex:11107},{level:4,title:"@Required",slug:"required",normalizedTitle:"@required",charIndex:11365},{level:4,title:"@Autowired",slug:"autowired",normalizedTitle:"@autowired",charIndex:11337},{level:4,title:"@Qualifier",slug:"qualifier",normalizedTitle:"@qualifier",charIndex:13969},{level:4,title:"@Resource",slug:"resource",normalizedTitle:"@resource",charIndex:15630},{level:4,title:"@PostConstruct 和 @PreDestroy",slug:"postconstruct-和-predestroy",normalizedTitle:"@postconstruct 和 @predestroy",charIndex:17189},{level:4,title:"@Inject",slug:"inject",normalizedTitle:"@inject",charIndex:12176},{level:3,title:"Java 配置",slug:"java-配置",normalizedTitle:"java 配置",charIndex:3810},{level:4,title:"@Bean",slug:"bean-2",normalizedTitle:"@bean",charIndex:3888},{level:4,title:"声明一个 bean",slug:"声明一个-bean",normalizedTitle:"声明一个 bean",charIndex:19723},{level:4,title:"@Configuration",slug:"configuration",normalizedTitle:"@configuration",charIndex:3865},{level:2,title:"依赖解决过程",slug:"依赖解决过程",normalizedTitle:"依赖解决过程",charIndex:21290},{level:2,title:"最佳实践",slug:"最佳实践",normalizedTitle:"最佳实践",charIndex:22326},{level:3,title:"singleton 的 Bean 如何注入 prototype 的 Bean",slug:"singleton-的-bean-如何注入-prototype-的-bean",normalizedTitle:"singleton 的 bean 如何注入 prototype 的 bean",charIndex:22335},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:24298}],headersStr:"IoC 简介 IoC 是什么 IoC 能做什么 IoC 和 DI IoC 容器 Bean Spring IoC IoC 容器 配置元数据 实例化容器 使用容器 IoC 依赖来源 IoC 配置元数据 Xml 配置 实例化容器 使用容器 注解配置 启动注解 @Required @Autowired @Qualifier @Resource @PostConstruct 和 @PreDestroy @Inject Java 配置 @Bean 声明一个 bean @Configuration 依赖解决过程 最佳实践 singleton 的 Bean 如何注入 prototype 的 Bean 参考资料",content:'# Spring IoC\n\n\n# IoC 简介\n\n\n# IoC 是什么\n\nIoC 即控制反转（Inversion of Control，缩写为 IoC）。IoC 又称为依赖倒置原则（设计模式六大原则之一），它的要点在于：程序要依赖于抽象接口，不要依赖于具体实现。它的作用就是用于降低代码间的耦合度。\n\nIoC 的实现方式有两种：\n\n * 依赖注入（Dependency Injection，简称 DI）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n * 依赖查找（Dependency Lookup）：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。\n\n理解 Ioc 的关键是要明确两个要点：\n\n * 谁控制谁，控制什么：传统 Java SE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IoC 是有专门一个容器来创建这些对象，即由 Ioc 容器来控制对象的创建；谁控制谁？当然是 IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。\n * 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\n\n\n\n\n# IoC 能做什么\n\nIoC 不是一种技术，而是编程思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n\n其实 IoC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IoC/DI 思想中，应用程序就变成被动的了，被动的等待 IoC 容器来创建并注入它所需要的资源了。\n\nIoC 很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n\n# IoC 和 DI\n\n其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。\n\n> 注：如果想要更加深入的了解 IoC 和 DI，请参考大师级人物 Martin Fowler 的一篇经典文章 Inversion of Control Containers and the Dependency Injection pattern 。\n\n\n# IoC 容器\n\nIoC 容器就是具有依赖注入功能的容器。IoC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 IoC 容器进行组装。在 Spring 中 BeanFactory 是 IoC 容器的实际代表者。\n\nSpring IoC 容器如何知道哪些是它管理的对象呢？这就需要配置文件，Spring IoC 容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于 xml 配置文件进行配置元数据，而且 Spring 与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于 java 文件的、基于属性文件的配置都可以。\n\n\n# Bean\n\n> JavaBean 是一种 JAVA 语言写成的可重用组件。为写成 JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 对外部通过提供 getter / setter 方法来访问其成员。\n\n由 IoC 容器管理的那些组成你应用程序的对象我们就叫它 Bean。Bean 就是由 Spring 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。那 IoC 怎样确定如何实例化 Bean、管理 Bean 之间的依赖关系以及管理 Bean 呢？这就需要配置元数据，在 Spring 中由 BeanDefinition 代表，后边会详细介绍，配置元数据指定如何实例化 Bean、如何组装 Bean 等。\n\n\n# Spring IoC\n\nSpring IoC 容器中的对象仅通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖关系（即与它们一起工作的其他对象）。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖关系的实例化或位置的逆过程（因此称为控制反转）。\n\norg.springframework.beans 和 org.springframework.context 是 IoC 容器的基础。\n\n\n# IoC 容器\n\n在 Spring 中，有两种 IoC 容器：BeanFactory 和 ApplicationContext。\n\n * BeanFactory：BeanFactory 是 Spring 基础 IoC 容器。BeanFactory 提供了 Spring 容器的配置框架和基本功能。\n * ApplicationContext：ApplicationContext 是具备应用特性的 BeanFactory 的子接口。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 AOP、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 ApplicationContext 作为 IoC 容器，因为它的功能远多于 BeanFactory。\n\norg.springframework.context.ApplicationContext 接口代表 Spring IoC 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据来获取关于要实例化、配置和组装哪些对象的指令。配置元数据以 XML、Java 注释或 Java 代码表示。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。\n\nSpring 提供了 ApplicationContext 接口的几个实现，例如：\n\n * ClassPathXmlApplicationContext：ApplicationContext 的实现，从 classpath 获取配置信息。\n\nBeanFactory beanFactory = new ClassPathXmlApplicationContext("classpath.xml");\n\n\n * FileSystemXmlApplicationContext：ApplicationContext 的实现，从文件系统获取配置信息。\n\nBeanFactory beanFactory = new FileSystemXmlApplicationContext("fileSystemConfig.xml");\n\n\n在大多数应用场景中，不需要显式通过用户代码来实例化 Spring IoC 容器的一个或多个实例。\n\n下图显示了 Spring IoC 容器的工作步骤\n\n\n\n使用 IoC 容器可分为三步骤：\n\n 1. 配置元数据：需要配置一些元数据来告诉 Spring，你希望容器如何工作，具体来说，就是如何去初始化、配置、管理 JavaBean 对象。\n 2. 实例化容器：由 IoC 容器解析配置的元数据。IoC 容器的 Bean Reader 读取并解析配置文件，根据定义生成 BeanDefinition 配置元数据对象，IoC 容器根据 BeanDefinition 进行实例化、配置及组装 Bean。\n 3. 使用容器：由客户端实例化容器，获取需要的 Bean。\n\n\n# 配置元数据\n\n**元数据（Metadata）**又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息。\n\n配置元数据的方式：\n\n * 基于 xml 配置：Spring 的传统配置方式。通常是在顶级元素 <beans> 中通过 <bean>元素配置元数据。这种方式的缺点是：如果 JavaBean 过多，则产生的配置文件足以让你眼花缭乱。\n * 基于注解配置：Spring 2.5 引入了对基于注解的配置元数据的支持。可以大大简化你的配置。\n * 基于 Java 配置：从 Spring 3.0 开始，Spring 支持使用 Java 代码来配置元数据。通常是在 @Configuration 修饰的类中通过 @Bean 指定实例化 Bean 的方法。更多详情，可以参阅 @Configuration、@Bean、@Import 和 @DependsOn 注释。\n\n这些 bean 定义对应于构成应用程序的实际对象。例如：定义服务层对象、数据访问对象 (DAO)、表示对象（如 Struts Action 实例）、基础设施对象（如 Hibernate SessionFactories、JMS 队列等）。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是 DAO 和业务逻辑的责任。但是，可以使用 Spring 与 AspectJ 的集成来配置在 IoC 容器控制之外创建的对象。\n\n以下示例显示了基于 XML 的配置元数据的基本结构：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--id 属性用于唯一标识单个 bean 定义--\x3e\n    \x3c!--class 属性用于指明 bean 类型的完全限定名--\x3e\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 Bean 的属性 --\x3e\n    </bean>\n\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 Bean 的属性 --\x3e\n    </bean>\n\n    \x3c!-- 更多的 Bean 定义 --\x3e\n\n</beans>\n\n\n\n# 实例化容器\n\n可以通过为 ApplicationContext 的构造函数指定外部资源路径，来加载配置元数据。\n\nApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");\n\n\n以下示例显示了服务层对象 (services.xml) 配置文件：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- services --\x3e\n\n    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">\n        <property name="accountDao" ref="accountDao"/>\n        <property name="itemDao" ref="itemDao"/>\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for services go here --\x3e\n\n</beans>\n\n\n以下示例显示了数据访问对象 (daos.xml) 配置文件：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="accountDao"\n        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for data access objects go here --\x3e\n\n</beans>\n\n\n上面的示例中，服务层由 PetStoreServiceImpl 类和类型为 JpaAccountDao 和 JpaItemDao 的两个数据访问对象（基于 JPA 对象关系映射标准）组成。 property name 元素指的是 JavaBean 属性的名称，ref 元素指的是另一个 bean 定义的名称。 id 和 ref 元素之间的这种联系表达了协作对象之间的依赖关系。\n\nSpring 支持通过多个 xml 文件来定义 Bean，每个单独的 XML 配置文件都代表架构中的一个逻辑层或模块。可以使用 ApplicationContext 构造函数从所有这些 XML 片段加载 bean 定义。或者，使用 <import/> 元素从另一个或多个文件加载 bean 定义。如下所示：\n\n<beans>\n    <import resource="services.xml"/>\n    <import resource="resources/messageSource.xml"/>\n    <import resource="/resources/themeSource.xml"/>\n\n    <bean id="bean1" class="..."/>\n    <bean id="bean2" class="..."/>\n</beans>\n\n\n在上面的示例中，外部 bean 定义从三个文件加载：services.xml、messageSource.xml 和 themeSource.xml。services.xml 文件必须和当前 xml 文件位于同一目录或类路径位置；而 messageSource.xml 和 themeSource.xml 必须位于当前文件所在目录的子目录 resources 下。/resources 的 / 会被忽略。但是，鉴于这些路径是相对的，最好不要使用 /。根据 Spring Schema，被导入文件的内容，包括顶级 <beans/> 元素，必须是有效的 XML bean 定义。\n\n> 注意：\n> \n> 可以，但不推荐使用相对 “../” 路径来引用父目录中的文件。这样做会创建对当前应用程序之外的文件的依赖。特别是，不建议将此引用用于 classpath：URL（例如， classpath:../services.xml），其中运行时解析过程会选择“最近的”类路径根，然后查看其父目录。类路径配置更改可能会导致选择不同的、不正确的目录。\n> \n> 可以使用完全限定的资源位置而不是相对路径：例如，file:C:/config/services.xml 或 classpath:/config/services.xml。建议为此类绝对路径保留一定的间接性  —  例如，通过 “${...}” 占位符来引用运行时指定 的 JVM 参数。\n\n命名空间本身提供了导入指令功能。 Spring 提供的一系列 XML 命名空间中提供了除了普通 bean 定义之外的更多配置特性  —  例如，context 和 util 命名空间。\n\n\n# 使用容器\n\nApplicationContext 能够维护不同 bean 及其依赖项的注册表。通过使用方法 T getBean(String name, Class T requiredType)，可以检索并获取 bean 的实例。\n\nApplicationContext 允许读取 bean 定义并访问它们，如以下示例所示：\n\n// create and configure beans\nApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");\n\n// retrieve configured instance\nPetStoreService service = context.getBean("petStore", PetStoreService.class);\n\n// use configured instance\nList<String> userList = service.getUsernameList();\n\n\n最灵活的变体是 GenericApplicationContext 结合阅读器委托  —  例如，结合 XML 文件的 XmlBeanDefinitionReader，如下例所示：\n\nGenericApplicationContext context = new GenericApplicationContext();\nnew XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");\ncontext.refresh();\n\n\n可以在同一个 ApplicationContext 上混合和匹配此类读取器委托，从不同的配置源读取 bean 定义。\n\n然后，可以使用 getBean 检索 bean 的实例。 ApplicationContext 接口还有一些其他方法用于检索 bean，但理想情况下，应用程序代码不应该使用它们。实际上，应用程序代码根本不应该调用 getBean() 方法，因此根本不依赖 Spring API。例如，Spring 与 Web 框架的集成为各种 Web 框架组件（例如控制器和 JSF 管理的 bean）提供了依赖注入，让您可以通过元数据（例如自动装配注释）声明对特定 bean 的依赖。\n\n\n# IoC 依赖来源\n\n自定义 Bean\n\n容器内建 Bean 对象\n\n容器内建依赖\n\n\n# IoC 配置元数据\n\nIoC 容器的配置有三种方式：\n\n * 基于 xml 配置\n * 基于 properties 配置\n * 基于注解配置\n * 基于 Java 配置\n\n作为 Spring 传统的配置方式，xml 配置方式一般为大家所熟知。\n\n如果厌倦了 xml 配置，Spring 也提供了注解配置方式或 Java 配置方式来简化配置。\n\n本文，将对 Java 配置 IoC 容器做详细的介绍。\n\n\n# Xml 配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd">\n  <import resource="resource1.xml" />\n  <bean id="bean1" class=""></bean>\n  <bean id="bean2" class=""></bean>\n  <bean name="bean2" class=""></bean>\n\n  <alias alias="bean3" name="bean2"/>\n  <import resource="resource2.xml" />\n</beans>\n\n\n标签说明：\n\n * <beans> 是 Spring 配置文件的根节点。\n * <bean> 用来定义一个 JavaBean。id 属性是它的标识，在文件中必须唯一；class 属性是它关联的类。\n * <alias> 用来定义 Bean 的别名。\n * <import> 用来导入其他配置文件的 Bean 定义。这是为了加载多个配置文件，当然也可以把这些配置文件构造为一个数组（new String[] {“config1.xml”, config2.xml}）传给 ApplicationContext 实现类进行加载多个配置文件，那一个更适合由用户决定；这两种方式都是通过调用 Bean Definition Reader 读取 Bean 定义，内部实现没有任何区别。<import> 标签可以放在 <beans> 下的任何位置，没有顺序关系。\n\n# 实例化容器\n\n实例化容器的过程： 定位资源（XML 配置文件） 读取配置信息(Resource) 转化为 Spring 可识别的数据形式（BeanDefinition）\n\nApplicationContext context =\n      new ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});\n\n\n组合 xml 配置文件 配置的 Bean 功能各不相同，都放在一个 xml 文件中，不便管理。 Java 设计模式讲究职责单一原则。配置其实也是如此，功能不同的 JavaBean 应该被组织在不同的 xml 文件中。然后使用 import 标签把它们统一导入。\n\n<import resource="classpath:spring/applicationContext.xml"/>\n<import resource="/WEB-INF/spring/service.xml"/>\n\n\n# 使用容器\n\n使用容器的方式就是通过getBean获取 IoC 容器中的 JavaBean。 Spring 也有其他方法去获得 JavaBean，但是 Spring 并不推荐其他方式。\n\n// create and configure beans\nApplicationContext context =\nnew ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});\n// retrieve configured instance\nPetStoreService service = context.getBean("petStore", PetStoreService.class);\n// use configured instance\nList<String> userList = service.getUsernameList();\n\n\n\n# 注解配置\n\nSpring2.5 引入了注解。 于是，一个问题产生了：使用注解方式注入 JavaBean 是不是一定完爆 xml 方式？ 未必。正所谓，仁者见仁智者见智。任何事物都有其优缺点，看你如何取舍。来看看注解的优缺点： 优点：大大减少了配置，并且可以使配置更加精细——类，方法，字段都可以用注解去标记。 缺点：使用注解，不可避免产生了侵入式编程，也产生了一些问题。\n\n * 你需要将注解加入你的源码并编译它；\n\n * 注解往往比较分散，不易管控。\n\n> 注：spring 中，先进行注解注入，然后才是 xml 注入，因此如果注入的目标相同，后者会覆盖前者。\n\n# 启动注解\n\nSpring 默认是不启用注解的。如果想使用注解，需要先在 xml 中启动注解。 启动方式：在 xml 中加入一个标签，很简单吧。\n\n<context:annotation-config/>\n\n\n> 注：<context:annotation-config/> 只会检索定义它的上下文。什么意思呢？就是说，如果你 为 DispatcherServlet 指定了一个WebApplicationContext，那么它只在 controller 中查找@Autowired注解，而不会检查其它的路径。\n\n# @Required\n\n@Required 注解只能用于修饰 bean 属性的 setter 方法。受影响的 bean 属性必须在配置时被填充在 xml 配置文件中，否则容器将抛出BeanInitializationException。\n\npublic class AnnotationRequired {\n    private String name;\n    private String sex;\n\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @Required 注解用于bean属性的setter方法并且它指示，受影响的bean属性必须在配置时被填充在xml配置文件中，\n     *           否则容器将抛出BeanInitializationException。\n     */\n    @Required\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n}\n\n\n# @Autowired\n\n@Autowired注解可用于修饰属性、setter 方法、构造方法。\n\n@Autowired 注入过程\n\n * 元信息解析\n * 依赖查找\n * 依赖注入（字段、方法）\n\n> 注：@Autowired注解也可用于修饰构造方法，但如果类中只有默认构造方法，则没有必要。如果有多个构造器，至少应该修饰一个，来告诉容器哪一个必须使用。\n\n可以使用 JSR330 的注解@Inject来替代@Autowired。\n\n范例\n\npublic class AnnotationAutowired {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationRequired.class);\n\n    @Autowired\n    private Apple fieldA;\n\n    private Banana fieldB;\n\n    private Orange fieldC;\n\n    public Apple getFieldA() {\n        return fieldA;\n    }\n\n    public void setFieldA(Apple fieldA) {\n        this.fieldA = fieldA;\n    }\n\n    public Banana getFieldB() {\n        return fieldB;\n    }\n\n    @Autowired\n    public void setFieldB(Banana fieldB) {\n        this.fieldB = fieldB;\n    }\n\n    public Orange getFieldC() {\n        return fieldC;\n    }\n\n    public void setFieldC(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public AnnotationAutowired() {}\n\n    @Autowired\n    public AnnotationAutowired(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationAutowired annotationAutowired =\n                        (AnnotationAutowired) ctx.getBean("annotationAutowired");\n        log.debug("fieldA: {}, fieldB:{}, fieldC:{}", annotationAutowired.getFieldA().getName(),\n                        annotationAutowired.getFieldB().getName(),\n                        annotationAutowired.getFieldC().getName());\n        ctx.close();\n    }\n}\n\n\nxml 中的配置\n\n\x3c!-- 测试@Autowired --\x3e\n<bean id="apple" class="org.zp.notes.spring.beans.annotation.sample.Apple"/>\n<bean id="potato" class="org.zp.notes.spring.beans.annotation.sample.Banana"/>\n<bean id="tomato" class="org.zp.notes.spring.beans.annotation.sample.Orange"/>\n<bean id="annotationAutowired" class="org.zp.notes.spring.beans.annotation.sample.AnnotationAutowired"/>\n\n\n# @Qualifier\n\n在@Autowired注解中，提到了如果发现有多个候选的 bean 都符合修饰类型，Spring 就会抓瞎了。\n\n那么，如何解决这个问题。\n\n可以通过@Qualifier指定 bean 名称来锁定真正需要的那个 bean。\n\n范例\n\npublic class AnnotationQualifier {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationQualifier.class);\n\n    @Autowired\n    @Qualifier("dog") /** 去除这行，会报异常 */\n    Animal dog;\n\n    Animal cat;\n\n    public Animal getDog() {\n        return dog;\n    }\n\n    public void setDog(Animal dog) {\n        this.dog = dog;\n    }\n\n    public Animal getCat() {\n        return cat;\n    }\n\n    @Autowired\n    public void setCat(@Qualifier("cat") Animal cat) {\n        this.cat = cat;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationQualifier annotationQualifier =\n                (AnnotationQualifier) ctx.getBean("annotationQualifier");\n\n        log.debug("Dog name: {}", annotationQualifier.getDog().getName());\n        log.debug("Cat name: {}", annotationQualifier.getCat().getName());\n        ctx.close();\n    }\n}\n\nabstract class Animal {\n    public String getName() {\n        return null;\n    }\n}\n\nclass Dog extends Animal {\n    public String getName() {\n        return "狗";\n    }\n}\n\nclass Cat extends Animal {\n    public String getName() {\n        return "猫";\n    }\n}\n\n\nxml 中的配置\n\n\x3c!-- 测试@Qualifier --\x3e\n<bean id="dog" class="org.zp.notes.spring.beans.annotation.sample.Dog"/>\n<bean id="cat" class="org.zp.notes.spring.beans.annotation.sample.Cat"/>\n<bean id="annotationQualifier" class="org.zp.notes.spring.beans.annotation.sample.AnnotationQualifier"/>\n\n\n# @Resource\n\nSpring 支持 JSP250 规定的注解@Resource。这个注解根据指定的名称来注入 bean。\n\n如果没有为@Resource指定名称，它会像@Autowired一样按照类型去寻找匹配。\n\n在 Spring 中，由CommonAnnotationBeanPostProcessor来处理@Resource注解。\n\n范例\n\npublic class AnnotationResource {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationResource.class);\n\n    @Resource(name = "flower")\n    Plant flower;\n\n    @Resource(name = "tree")\n    Plant tree;\n\n    public Plant getFlower() {\n        return flower;\n    }\n\n    public void setFlower(Plant flower) {\n        this.flower = flower;\n    }\n\n    public Plant getTree() {\n        return tree;\n    }\n\n    public void setTree(Plant tree) {\n        this.tree = tree;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n\n        AnnotationResource annotationResource =\n                        (AnnotationResource) ctx.getBean("annotationResource");\n        log.debug("type: {}, name: {}", annotationResource.getFlower().getClass(), annotationResource.getFlower().getName());\n        log.debug("type: {}, name: {}", annotationResource.getTree().getClass(), annotationResource.getTree().getName());\n        ctx.close();\n    }\n}\n\n\nxml 的配置\n\n\x3c!-- 测试@Resource --\x3e\n<bean id="flower" class="org.zp.notes.spring.beans.annotation.sample.Flower"/>\n<bean id="tree" class="org.zp.notes.spring.beans.annotation.sample.Tree"/>\n<bean id="annotationResource" class="org.zp.notes.spring.beans.annotation.sample.AnnotationResource"/>\n\n\n# @PostConstruct 和 @PreDestroy\n\n@PostConstruct 和 @PreDestroy 是 JSR 250 规定的用于生命周期的注解。\n\n从其名号就可以看出，一个是在构造之后调用的方法，一个是销毁之前调用的方法。\n\npublic class AnnotationPostConstructAndPreDestroy {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationPostConstructAndPreDestroy.class);\n\n    @PostConstruct\n    public void init() {\n        log.debug("call @PostConstruct method");\n    }\n\n    @PreDestroy\n    public void destroy() {\n        log.debug("call @PreDestroy method");\n    }\n}\n\n\n# @Inject\n\n从 Spring3.0 开始，Spring 支持 JSR 330 标准注解（依赖注入）。\n\n注：如果要使用 JSR 330 注解，需要使用外部 jar 包。\n\n若你使用 maven 管理 jar 包，只需要添加依赖到 pom.xml 即可：\n\n<dependency>\n  <groupId>javax.inject</groupId>\n  <artifactId>javax.inject</artifactId>\n  <version>1</version>\n</dependency>\n\n\n@Inject 和 @Autowired 一样，可以修饰属性、setter 方法、构造方法。\n\n范例\n\npublic class AnnotationInject {\n    private static final Logger log = LoggerFactory.getLogger(AnnotationInject.class);\n    @Inject\n    Apple fieldA;\n\n    Banana fieldB;\n\n    Orange fieldC;\n\n    public Apple getFieldA() {\n        return fieldA;\n    }\n\n    public void setFieldA(Apple fieldA) {\n        this.fieldA = fieldA;\n    }\n\n    public Banana getFieldB() {\n        return fieldB;\n    }\n\n    @Inject\n    public void setFieldB(Banana fieldB) {\n        this.fieldB = fieldB;\n    }\n\n    public Orange getFieldC() {\n        return fieldC;\n    }\n\n    public AnnotationInject() {}\n\n    @Inject\n    public AnnotationInject(Orange fieldC) {\n        this.fieldC = fieldC;\n    }\n\n    public static void main(String[] args) throws Exception {\n        AbstractApplicationContext ctx =\n                        new ClassPathXmlApplicationContext("spring/spring-annotation.xml");\n        AnnotationInject annotationInject = (AnnotationInject) ctx.getBean("annotationInject");\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldA().getClass(),\n                        annotationInject.getFieldA().getName());\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldB().getClass(),\n                        annotationInject.getFieldB().getName());\n\n        log.debug("type: {}, name: {}", annotationInject.getFieldC().getClass(),\n                        annotationInject.getFieldC().getName());\n\n        ctx.close();\n    }\n}\n\n\n\n# Java 配置\n\n基于 Java 配置 Spring IoC 容器，实际上是Spring 允许用户定义一个类，在这个类中去管理 IoC 容器的配置。\n\n为了让 Spring 识别这个定义类为一个 Spring 配置类，需要用到两个注解：@Configuration和@Bean。\n\n如果你熟悉 Spring 的 xml 配置方式，你可以将@Configuration等价于<beans>标签；将@Bean等价于<bean>标签。\n\n# @Bean\n\n@Bean 的修饰目标只能是方法或注解。\n\n@Bean 只能定义在 @Configuration 或 @Component 注解修饰的类中。\n\n# 声明一个 bean\n\n此外，@Configuration 类允许在同一个类中通过@Bean 定义内部 bean 依赖。\n\n声明一个 bean，只需要在 bean 属性的 set 方法上标注@Bean 即可。\n\n@Configuration\npublic class AnnotationConfiguration {\n    private static final Logger log = LoggerFactory.getLogger(JavaComponentScan.class);\n\n    @Bean\n    public Job getPolice() {\n        return new Police();\n    }\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AnnotationConfiguration.class);\n        ctx.scan("org.zp.notes.spring.beans");\n        ctx.refresh();\n        Job job = (Job) ctx.getBean("police");\n        log.debug("job: {}, work: {}", job.getClass(), job.work());\n    }\n}\n\npublic interface Job {\n    String work();\n}\n\n@Component("police")\npublic class Police implements Job {\n    @Override\n    public String work() {\n        return "抓罪犯";\n    }\n}\n\n\n这等价于配置\n\n<beans>\n\t<bean id="police" class="org.zp.notes.spring.ioc.sample.job.Police"/>\n</beans>\n\n\n@Bean 注解用来表明一个方法实例化、配置合初始化一个被 Spring IoC 容器管理的新对象。\n\n如果你熟悉 Spring 的 xml 配置，你可以将@Bean 视为等价于<beans>标签。\n\n@Bean 注解可以用于任何的 Spring @Component bean，然而，通常被用于@Configuration bean。\n\n# @Configuration\n\n@Configuration 是一个类级别的注解，用来标记被修饰类的对象是一个BeanDefinition。\n\n@Configuration 声明 bean 是通过被 @Bean 修饰的公共方法。此外，@Configuration 允许在同一个类中通过 @Bean 定义内部 bean 依赖。\n\n@Configuration\npublic class AppConfig {\n    @Bean\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}\n\n\n这等价于配置\n\n<beans>\n\t<bean id="myService" class="com.acme.services.MyServiceImpl"/>\n</beans>\n\n\n用 AnnotationConfigApplicationContext 实例化 IoC 容器。\n\n\n# 依赖解决过程\n\n容器执行 bean 依赖解析如下：\n\n * ApplicationContext 使用配置元数据创建和初始化 Bean。配置元数据可以由 XML、Java 代码或注解指定。\n * 对于每个 bean，其依赖关系以属性、构造函数参数或静态工厂方法的参数的形式表示。这些依赖项在实际创建 bean 时提供给 bean。\n * 每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。\n * 作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，例如 int、long、String、boolean 等。\n\nSpring 容器在创建容器时验证每个 bean 的配置。但是，在实际创建 bean 之前，不会设置 bean 属性本身。在创建容器时会创建 singleton 型的实例并设置为默认的 Bean。否则，只有在请求时才会创建 bean。\n\n需注意：构造器注入，可能会导致无法解决循环依赖问题。\n\n例如：A 类通过构造器注入需要 B 类的实例，B 类通过构造器注入需要 A 类的实例。Spring IoC 容器会在运行时检测到此循环引用，并抛出 BeanCurrentlyInCreationException。\n\n一种解决方案是使用 setter 方法注入替代构造器注入。\n\n另一种解决方案是：bean A 和 bean B 之间的循环依赖关系，强制其中一个 bean 在完全初始化之前注入另一个 bean（典型的先有鸡还是先有蛋的场景）。\n\nSpring 会在容器加载时检测配置问题，例如引用不存在的 bean 或循环依赖。在实际创建 bean 时，Spring 会尽可能晚地设置属性并解析依赖关系。这意味着，如果在创建该对象或其依赖项之一时出现问题，则正确加载的 Spring 容器稍后可以在您请求对象时生成异常  —  例如，bean 由于丢失或无效而引发异常。某些配置问题的这种潜在的延迟可见性是默认情况下 ApplicationContext 实现预实例化单例 bean 的原因。以在实际需要之前创建这些 bean 的一些前期时间和内存为代价，您会在创建 ApplicationContext 时发现配置问题，而不是稍后。您仍然可以覆盖此默认行为，以便单例 bean 延迟初始化，而不是急切地预先实例化。\n\n\n# 最佳实践\n\n\n# singleton 的 Bean 如何注入 prototype 的 Bean\n\nSpring 创建的 Bean 默认是单例的，但当 Bean 遇到继承的时候，可能会忽略这一点。\n\n假设有一个 SayService 抽象类，其中维护了一个类型是 ArrayList 的字段 data，用于保存方法处理的中间数据。每次调用 say 方法都会往 data 加入新数据，可以认为 SayService 是有状态，如果 SayService 是单例的话必然会 OOM。\n\n/**\n * SayService 是有状态，如果 SayService 是单例的话必然会 OOM\n */\n@Slf4j\npublic abstract class SayService {\n\n   List<String> data = new ArrayList<>();\n\n   public void say() {\n      data.add(IntStream.rangeClosed(1, 1000000)\n         .mapToObj(__ -> "a")\n         .collect(Collectors.joining("")) + UUID.randomUUID().toString());\n      log.info("I\'m {} size:{}", this, data.size());\n   }\n\n}\n\n\n但实际开发的时候，开发同学没有过多思考就把 SayHello 和 SayBye 类加上了 @Service 注解，让它们成为了 Bean，也没有考虑到父类是有状态的。\n\n@Service\n@Slf4j\npublic class SayBye extends SayService {\n\n   @Override\n   public void say() {\n      super.say();\n      log.info("bye");\n   }\n\n}\n\n@Service\n@Slf4j\npublic class SayHello extends SayService {\n\n\t@Override\n\tpublic void say() {\n\t\tsuper.say();\n\t\tlog.info("hello");\n\t}\n\n}\n\n\n在为类标记上 @Service 注解把类型交由容器管理前，首先评估一下类是否有状态，然后为 Bean 设置合适的 Scope。\n\n调用代码：\n\n@Slf4j\n@RestController\n@RequestMapping("beansingletonandorder")\npublic class BeanSingletonAndOrderController {\n\n   @Autowired\n   List<SayService> sayServiceList;\n   @Autowired\n   private ApplicationContext applicationContext;\n\n   @GetMapping("test")\n   public void test() {\n      log.info("====================");\n      sayServiceList.forEach(SayService::say);\n   }\n\n}\n\n\n可能有人认为，为 SayHello 和 SayBye 两个类都标记了 @Scope 注解，设置了 PROTOTYPE 的生命周期就可以解决上面的问题。\n\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n\n\n但实际上还是有问题。因为@RestController 注解 =@Controller 注解 +@ResponseBody 注解，又因为 @Controller 标记了 @Component 元注解，所以 @RestController 注解其实也是一个 Spring Bean。\n\nBean 默认是单例的，所以单例的 Controller 注入的 Service 也是一次性创建的，即使 Service 本身标识了 prototype 的范围也没用。\n\n修复方式是，让 Service 以代理方式注入。这样虽然 Controller 本身是单例的，但每次都能从代理获取 Service。这样一来，prototype 范围的配置才能真正生效。\n\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProx)\n\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring ioc\n\n\n# ioc 简介\n\n\n# ioc 是什么\n\nioc 即控制反转（inversion of control，缩写为 ioc）。ioc 又称为依赖倒置原则（设计模式六大原则之一），它的要点在于：程序要依赖于抽象接口，不要依赖于具体实现。它的作用就是用于降低代码间的耦合度。\n\nioc 的实现方式有两种：\n\n * 依赖注入（dependency injection，简称 di）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。\n * 依赖查找（dependency lookup）：容器中的受控对象通过容器的 api 来查找自己所依赖的资源和协作对象。\n\n理解 ioc 的关键是要明确两个要点：\n\n * 谁控制谁，控制什么：传统 java se 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 ioc 是有专门一个容器来创建这些对象，即由 ioc 容器来控制对象的创建；谁控制谁？当然是 ioc 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。\n * 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\n\n\n\n\n# ioc 能做什么\n\nioc 不是一种技术，而是编程思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 ioc 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n\n其实 ioc 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 ioc/di 思想中，应用程序就变成被动的了，被动的等待 ioc 容器来创建并注入它所需要的资源了。\n\nioc 很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由 ioc 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n\n# ioc 和 di\n\n其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 martin fowler 又给出了一个新的名字：“依赖注入”，相对 ioc 而言，“依赖注入”明确描述了“被注入对象依赖 ioc 容器配置依赖对象”。\n\n> 注：如果想要更加深入的了解 ioc 和 di，请参考大师级人物 martin fowler 的一篇经典文章 inversion of control containers and the dependency injection pattern 。\n\n\n# ioc 容器\n\nioc 容器就是具有依赖注入功能的容器。ioc 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 ioc 容器进行组装。在 spring 中 beanfactory 是 ioc 容器的实际代表者。\n\nspring ioc 容器如何知道哪些是它管理的对象呢？这就需要配置文件，spring ioc 容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于 xml 配置文件进行配置元数据，而且 spring 与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于 java 文件的、基于属性文件的配置都可以。\n\n\n# bean\n\n> javabean 是一种 java 语言写成的可重用组件。为写成 javabean，类必须是具体的和公共的，并且具有无参数的构造器。javabean 对外部通过提供 getter / setter 方法来访问其成员。\n\n由 ioc 容器管理的那些组成你应用程序的对象我们就叫它 bean。bean 就是由 spring 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。那 ioc 怎样确定如何实例化 bean、管理 bean 之间的依赖关系以及管理 bean 呢？这就需要配置元数据，在 spring 中由 beandefinition 代表，后边会详细介绍，配置元数据指定如何实例化 bean、如何组装 bean 等。\n\n\n# spring ioc\n\nspring ioc 容器中的对象仅通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖关系（即与它们一起工作的其他对象）。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身通过使用类的直接构造或诸如服务定位器模式之类的机制来控制其依赖关系的实例化或位置的逆过程（因此称为控制反转）。\n\norg.springframework.beans 和 org.springframework.context 是 ioc 容器的基础。\n\n\n# ioc 容器\n\n在 spring 中，有两种 ioc 容器：beanfactory 和 applicationcontext。\n\n * beanfactory：beanfactory 是 spring 基础 ioc 容器。beanfactory 提供了 spring 容器的配置框架和基本功能。\n * applicationcontext：applicationcontext 是具备应用特性的 beanfactory 的子接口。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 aop、在 web 应用中指定应用层上下文等。\n\n实际开发中，更推荐使用 applicationcontext 作为 ioc 容器，因为它的功能远多于 beanfactory。\n\norg.springframework.context.applicationcontext 接口代表 spring ioc 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据来获取关于要实例化、配置和组装哪些对象的指令。配置元数据以 xml、java 注释或 java 代码表示。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。\n\nspring 提供了 applicationcontext 接口的几个实现，例如：\n\n * classpathxmlapplicationcontext：applicationcontext 的实现，从 classpath 获取配置信息。\n\nbeanfactory beanfactory = new classpathxmlapplicationcontext("classpath.xml");\n\n\n * filesystemxmlapplicationcontext：applicationcontext 的实现，从文件系统获取配置信息。\n\nbeanfactory beanfactory = new filesystemxmlapplicationcontext("filesystemconfig.xml");\n\n\n在大多数应用场景中，不需要显式通过用户代码来实例化 spring ioc 容器的一个或多个实例。\n\n下图显示了 spring ioc 容器的工作步骤\n\n\n\n使用 ioc 容器可分为三步骤：\n\n 1. 配置元数据：需要配置一些元数据来告诉 spring，你希望容器如何工作，具体来说，就是如何去初始化、配置、管理 javabean 对象。\n 2. 实例化容器：由 ioc 容器解析配置的元数据。ioc 容器的 bean reader 读取并解析配置文件，根据定义生成 beandefinition 配置元数据对象，ioc 容器根据 beandefinition 进行实例化、配置及组装 bean。\n 3. 使用容器：由客户端实例化容器，获取需要的 bean。\n\n\n# 配置元数据\n\n**元数据（metadata）**又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息。\n\n配置元数据的方式：\n\n * 基于 xml 配置：spring 的传统配置方式。通常是在顶级元素 <beans> 中通过 <bean>元素配置元数据。这种方式的缺点是：如果 javabean 过多，则产生的配置文件足以让你眼花缭乱。\n * 基于注解配置：spring 2.5 引入了对基于注解的配置元数据的支持。可以大大简化你的配置。\n * 基于 java 配置：从 spring 3.0 开始，spring 支持使用 java 代码来配置元数据。通常是在 @configuration 修饰的类中通过 @bean 指定实例化 bean 的方法。更多详情，可以参阅 @configuration、@bean、@import 和 @dependson 注释。\n\n这些 bean 定义对应于构成应用程序的实际对象。例如：定义服务层对象、数据访问对象 (dao)、表示对象（如 struts action 实例）、基础设施对象（如 hibernate sessionfactories、jms 队列等）。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是 dao 和业务逻辑的责任。但是，可以使用 spring 与 aspectj 的集成来配置在 ioc 容器控制之外创建的对象。\n\n以下示例显示了基于 xml 的配置元数据的基本结构：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!--id 属性用于唯一标识单个 bean 定义--\x3e\n    \x3c!--class 属性用于指明 bean 类型的完全限定名--\x3e\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 bean 的属性 --\x3e\n    </bean>\n\n    <bean id="..." class="...">\n        \x3c!-- 这里配置 bean 的属性 --\x3e\n    </bean>\n\n    \x3c!-- 更多的 bean 定义 --\x3e\n\n</beans>\n\n\n\n# 实例化容器\n\n可以通过为 applicationcontext 的构造函数指定外部资源路径，来加载配置元数据。\n\napplicationcontext context = new classpathxmlapplicationcontext("services.xml", "daos.xml");\n\n\n以下示例显示了服务层对象 (services.xml) 配置文件：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- services --\x3e\n\n    <bean id="petstore" class="org.springframework.samples.jpetstore.services.petstoreserviceimpl">\n        <property name="accountdao" ref="accountdao"/>\n        <property name="itemdao" ref="itemdao"/>\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for services go here --\x3e\n\n</beans>\n\n\n以下示例显示了数据访问对象 (daos.xml) 配置文件：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="accountdao"\n        class="org.springframework.samples.jpetstore.dao.jpa.jpaaccountdao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    <bean id="itemdao" class="org.springframework.samples.jpetstore.dao.jpa.jpaitemdao">\n        \x3c!-- additional collaborators and configuration for this bean go here --\x3e\n    </bean>\n\n    \x3c!-- more bean definitions for data access objects go here --\x3e\n\n</beans>\n\n\n上面的示例中，服务层由 petstoreserviceimpl 类和类型为 jpaaccountdao 和 jpaitemdao 的两个数据访问对象（基于 jpa 对象关系映射标准）组成。 property name 元素指的是 javabean 属性的名称，ref 元素指的是另一个 bean 定义的名称。 id 和 ref 元素之间的这种联系表达了协作对象之间的依赖关系。\n\nspring 支持通过多个 xml 文件来定义 bean，每个单独的 xml 配置文件都代表架构中的一个逻辑层或模块。可以使用 applicationcontext 构造函数从所有这些 xml 片段加载 bean 定义。或者，使用 <import/> 元素从另一个或多个文件加载 bean 定义。如下所示：\n\n<beans>\n    <import resource="services.xml"/>\n    <import resource="resources/messagesource.xml"/>\n    <import resource="/resources/themesource.xml"/>\n\n    <bean id="bean1" class="..."/>\n    <bean id="bean2" class="..."/>\n</beans>\n\n\n在上面的示例中，外部 bean 定义从三个文件加载：services.xml、messagesource.xml 和 themesource.xml。services.xml 文件必须和当前 xml 文件位于同一目录或类路径位置；而 messagesource.xml 和 themesource.xml 必须位于当前文件所在目录的子目录 resources 下。/resources 的 / 会被忽略。但是，鉴于这些路径是相对的，最好不要使用 /。根据 spring schema，被导入文件的内容，包括顶级 <beans/> 元素，必须是有效的 xml bean 定义。\n\n> 注意：\n> \n> 可以，但不推荐使用相对 “../” 路径来引用父目录中的文件。这样做会创建对当前应用程序之外的文件的依赖。特别是，不建议将此引用用于 classpath：url（例如， classpath:../services.xml），其中运行时解析过程会选择“最近的”类路径根，然后查看其父目录。类路径配置更改可能会导致选择不同的、不正确的目录。\n> \n> 可以使用完全限定的资源位置而不是相对路径：例如，file:c:/config/services.xml 或 classpath:/config/services.xml。建议为此类绝对路径保留一定的间接性  —  例如，通过 “${...}” 占位符来引用运行时指定 的 jvm 参数。\n\n命名空间本身提供了导入指令功能。 spring 提供的一系列 xml 命名空间中提供了除了普通 bean 定义之外的更多配置特性  —  例如，context 和 util 命名空间。\n\n\n# 使用容器\n\napplicationcontext 能够维护不同 bean 及其依赖项的注册表。通过使用方法 t getbean(string name, class t requiredtype)，可以检索并获取 bean 的实例。\n\napplicationcontext 允许读取 bean 定义并访问它们，如以下示例所示：\n\n// create and configure beans\napplicationcontext context = new classpathxmlapplicationcontext("services.xml", "daos.xml");\n\n// retrieve configured instance\npetstoreservice service = context.getbean("petstore", petstoreservice.class);\n\n// use configured instance\nlist<string> userlist = service.getusernamelist();\n\n\n最灵活的变体是 genericapplicationcontext 结合阅读器委托  —  例如，结合 xml 文件的 xmlbeandefinitionreader，如下例所示：\n\ngenericapplicationcontext context = new genericapplicationcontext();\nnew xmlbeandefinitionreader(context).loadbeandefinitions("services.xml", "daos.xml");\ncontext.refresh();\n\n\n可以在同一个 applicationcontext 上混合和匹配此类读取器委托，从不同的配置源读取 bean 定义。\n\n然后，可以使用 getbean 检索 bean 的实例。 applicationcontext 接口还有一些其他方法用于检索 bean，但理想情况下，应用程序代码不应该使用它们。实际上，应用程序代码根本不应该调用 getbean() 方法，因此根本不依赖 spring api。例如，spring 与 web 框架的集成为各种 web 框架组件（例如控制器和 jsf 管理的 bean）提供了依赖注入，让您可以通过元数据（例如自动装配注释）声明对特定 bean 的依赖。\n\n\n# ioc 依赖来源\n\n自定义 bean\n\n容器内建 bean 对象\n\n容器内建依赖\n\n\n# ioc 配置元数据\n\nioc 容器的配置有三种方式：\n\n * 基于 xml 配置\n * 基于 properties 配置\n * 基于注解配置\n * 基于 java 配置\n\n作为 spring 传统的配置方式，xml 配置方式一般为大家所熟知。\n\n如果厌倦了 xml 配置，spring 也提供了注解配置方式或 java 配置方式来简化配置。\n\n本文，将对 java 配置 ioc 容器做详细的介绍。\n\n\n# xml 配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd">\n  <import resource="resource1.xml" />\n  <bean id="bean1" class=""></bean>\n  <bean id="bean2" class=""></bean>\n  <bean name="bean2" class=""></bean>\n\n  <alias alias="bean3" name="bean2"/>\n  <import resource="resource2.xml" />\n</beans>\n\n\n标签说明：\n\n * <beans> 是 spring 配置文件的根节点。\n * <bean> 用来定义一个 javabean。id 属性是它的标识，在文件中必须唯一；class 属性是它关联的类。\n * <alias> 用来定义 bean 的别名。\n * <import> 用来导入其他配置文件的 bean 定义。这是为了加载多个配置文件，当然也可以把这些配置文件构造为一个数组（new string[] {“config1.xml”, config2.xml}）传给 applicationcontext 实现类进行加载多个配置文件，那一个更适合由用户决定；这两种方式都是通过调用 bean definition reader 读取 bean 定义，内部实现没有任何区别。<import> 标签可以放在 <beans> 下的任何位置，没有顺序关系。\n\n# 实例化容器\n\n实例化容器的过程： 定位资源（xml 配置文件） 读取配置信息(resource) 转化为 spring 可识别的数据形式（beandefinition）\n\napplicationcontext context =\n      new classpathxmlapplicationcontext(new string[] {"services.xml", "daos.xml"});\n\n\n组合 xml 配置文件 配置的 bean 功能各不相同，都放在一个 xml 文件中，不便管理。 java 设计模式讲究职责单一原则。配置其实也是如此，功能不同的 javabean 应该被组织在不同的 xml 文件中。然后使用 import 标签把它们统一导入。\n\n<import resource="classpath:spring/applicationcontext.xml"/>\n<import resource="/web-inf/spring/service.xml"/>\n\n\n# 使用容器\n\n使用容器的方式就是通过getbean获取 ioc 容器中的 javabean。 spring 也有其他方法去获得 javabean，但是 spring 并不推荐其他方式。\n\n// create and configure beans\napplicationcontext context =\nnew classpathxmlapplicationcontext(new string[] {"services.xml", "daos.xml"});\n// retrieve configured instance\npetstoreservice service = context.getbean("petstore", petstoreservice.class);\n// use configured instance\nlist<string> userlist = service.getusernamelist();\n\n\n\n# 注解配置\n\nspring2.5 引入了注解。 于是，一个问题产生了：使用注解方式注入 javabean 是不是一定完爆 xml 方式？ 未必。正所谓，仁者见仁智者见智。任何事物都有其优缺点，看你如何取舍。来看看注解的优缺点： 优点：大大减少了配置，并且可以使配置更加精细——类，方法，字段都可以用注解去标记。 缺点：使用注解，不可避免产生了侵入式编程，也产生了一些问题。\n\n * 你需要将注解加入你的源码并编译它；\n\n * 注解往往比较分散，不易管控。\n\n> 注：spring 中，先进行注解注入，然后才是 xml 注入，因此如果注入的目标相同，后者会覆盖前者。\n\n# 启动注解\n\nspring 默认是不启用注解的。如果想使用注解，需要先在 xml 中启动注解。 启动方式：在 xml 中加入一个标签，很简单吧。\n\n<context:annotation-config/>\n\n\n> 注：<context:annotation-config/> 只会检索定义它的上下文。什么意思呢？就是说，如果你 为 dispatcherservlet 指定了一个webapplicationcontext，那么它只在 controller 中查找@autowired注解，而不会检查其它的路径。\n\n# @required\n\n@required 注解只能用于修饰 bean 属性的 setter 方法。受影响的 bean 属性必须在配置时被填充在 xml 配置文件中，否则容器将抛出beaninitializationexception。\n\npublic class annotationrequired {\n    private string name;\n    private string sex;\n\n    public string getname() {\n        return name;\n    }\n\n    /**\n     * @required 注解用于bean属性的setter方法并且它指示，受影响的bean属性必须在配置时被填充在xml配置文件中，\n     *           否则容器将抛出beaninitializationexception。\n     */\n    @required\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public string getsex() {\n        return sex;\n    }\n\n    public void setsex(string sex) {\n        this.sex = sex;\n    }\n}\n\n\n# @autowired\n\n@autowired注解可用于修饰属性、setter 方法、构造方法。\n\n@autowired 注入过程\n\n * 元信息解析\n * 依赖查找\n * 依赖注入（字段、方法）\n\n> 注：@autowired注解也可用于修饰构造方法，但如果类中只有默认构造方法，则没有必要。如果有多个构造器，至少应该修饰一个，来告诉容器哪一个必须使用。\n\n可以使用 jsr330 的注解@inject来替代@autowired。\n\n范例\n\npublic class annotationautowired {\n    private static final logger log = loggerfactory.getlogger(annotationrequired.class);\n\n    @autowired\n    private apple fielda;\n\n    private banana fieldb;\n\n    private orange fieldc;\n\n    public apple getfielda() {\n        return fielda;\n    }\n\n    public void setfielda(apple fielda) {\n        this.fielda = fielda;\n    }\n\n    public banana getfieldb() {\n        return fieldb;\n    }\n\n    @autowired\n    public void setfieldb(banana fieldb) {\n        this.fieldb = fieldb;\n    }\n\n    public orange getfieldc() {\n        return fieldc;\n    }\n\n    public void setfieldc(orange fieldc) {\n        this.fieldc = fieldc;\n    }\n\n    public annotationautowired() {}\n\n    @autowired\n    public annotationautowired(orange fieldc) {\n        this.fieldc = fieldc;\n    }\n\n    public static void main(string[] args) throws exception {\n        abstractapplicationcontext ctx =\n                        new classpathxmlapplicationcontext("spring/spring-annotation.xml");\n\n        annotationautowired annotationautowired =\n                        (annotationautowired) ctx.getbean("annotationautowired");\n        log.debug("fielda: {}, fieldb:{}, fieldc:{}", annotationautowired.getfielda().getname(),\n                        annotationautowired.getfieldb().getname(),\n                        annotationautowired.getfieldc().getname());\n        ctx.close();\n    }\n}\n\n\nxml 中的配置\n\n\x3c!-- 测试@autowired --\x3e\n<bean id="apple" class="org.zp.notes.spring.beans.annotation.sample.apple"/>\n<bean id="potato" class="org.zp.notes.spring.beans.annotation.sample.banana"/>\n<bean id="tomato" class="org.zp.notes.spring.beans.annotation.sample.orange"/>\n<bean id="annotationautowired" class="org.zp.notes.spring.beans.annotation.sample.annotationautowired"/>\n\n\n# @qualifier\n\n在@autowired注解中，提到了如果发现有多个候选的 bean 都符合修饰类型，spring 就会抓瞎了。\n\n那么，如何解决这个问题。\n\n可以通过@qualifier指定 bean 名称来锁定真正需要的那个 bean。\n\n范例\n\npublic class annotationqualifier {\n    private static final logger log = loggerfactory.getlogger(annotationqualifier.class);\n\n    @autowired\n    @qualifier("dog") /** 去除这行，会报异常 */\n    animal dog;\n\n    animal cat;\n\n    public animal getdog() {\n        return dog;\n    }\n\n    public void setdog(animal dog) {\n        this.dog = dog;\n    }\n\n    public animal getcat() {\n        return cat;\n    }\n\n    @autowired\n    public void setcat(@qualifier("cat") animal cat) {\n        this.cat = cat;\n    }\n\n    public static void main(string[] args) throws exception {\n        abstractapplicationcontext ctx =\n                new classpathxmlapplicationcontext("spring/spring-annotation.xml");\n\n        annotationqualifier annotationqualifier =\n                (annotationqualifier) ctx.getbean("annotationqualifier");\n\n        log.debug("dog name: {}", annotationqualifier.getdog().getname());\n        log.debug("cat name: {}", annotationqualifier.getcat().getname());\n        ctx.close();\n    }\n}\n\nabstract class animal {\n    public string getname() {\n        return null;\n    }\n}\n\nclass dog extends animal {\n    public string getname() {\n        return "狗";\n    }\n}\n\nclass cat extends animal {\n    public string getname() {\n        return "猫";\n    }\n}\n\n\nxml 中的配置\n\n\x3c!-- 测试@qualifier --\x3e\n<bean id="dog" class="org.zp.notes.spring.beans.annotation.sample.dog"/>\n<bean id="cat" class="org.zp.notes.spring.beans.annotation.sample.cat"/>\n<bean id="annotationqualifier" class="org.zp.notes.spring.beans.annotation.sample.annotationqualifier"/>\n\n\n# @resource\n\nspring 支持 jsp250 规定的注解@resource。这个注解根据指定的名称来注入 bean。\n\n如果没有为@resource指定名称，它会像@autowired一样按照类型去寻找匹配。\n\n在 spring 中，由commonannotationbeanpostprocessor来处理@resource注解。\n\n范例\n\npublic class annotationresource {\n    private static final logger log = loggerfactory.getlogger(annotationresource.class);\n\n    @resource(name = "flower")\n    plant flower;\n\n    @resource(name = "tree")\n    plant tree;\n\n    public plant getflower() {\n        return flower;\n    }\n\n    public void setflower(plant flower) {\n        this.flower = flower;\n    }\n\n    public plant gettree() {\n        return tree;\n    }\n\n    public void settree(plant tree) {\n        this.tree = tree;\n    }\n\n    public static void main(string[] args) throws exception {\n        abstractapplicationcontext ctx =\n                        new classpathxmlapplicationcontext("spring/spring-annotation.xml");\n\n        annotationresource annotationresource =\n                        (annotationresource) ctx.getbean("annotationresource");\n        log.debug("type: {}, name: {}", annotationresource.getflower().getclass(), annotationresource.getflower().getname());\n        log.debug("type: {}, name: {}", annotationresource.gettree().getclass(), annotationresource.gettree().getname());\n        ctx.close();\n    }\n}\n\n\nxml 的配置\n\n\x3c!-- 测试@resource --\x3e\n<bean id="flower" class="org.zp.notes.spring.beans.annotation.sample.flower"/>\n<bean id="tree" class="org.zp.notes.spring.beans.annotation.sample.tree"/>\n<bean id="annotationresource" class="org.zp.notes.spring.beans.annotation.sample.annotationresource"/>\n\n\n# @postconstruct 和 @predestroy\n\n@postconstruct 和 @predestroy 是 jsr 250 规定的用于生命周期的注解。\n\n从其名号就可以看出，一个是在构造之后调用的方法，一个是销毁之前调用的方法。\n\npublic class annotationpostconstructandpredestroy {\n    private static final logger log = loggerfactory.getlogger(annotationpostconstructandpredestroy.class);\n\n    @postconstruct\n    public void init() {\n        log.debug("call @postconstruct method");\n    }\n\n    @predestroy\n    public void destroy() {\n        log.debug("call @predestroy method");\n    }\n}\n\n\n# @inject\n\n从 spring3.0 开始，spring 支持 jsr 330 标准注解（依赖注入）。\n\n注：如果要使用 jsr 330 注解，需要使用外部 jar 包。\n\n若你使用 maven 管理 jar 包，只需要添加依赖到 pom.xml 即可：\n\n<dependency>\n  <groupid>javax.inject</groupid>\n  <artifactid>javax.inject</artifactid>\n  <version>1</version>\n</dependency>\n\n\n@inject 和 @autowired 一样，可以修饰属性、setter 方法、构造方法。\n\n范例\n\npublic class annotationinject {\n    private static final logger log = loggerfactory.getlogger(annotationinject.class);\n    @inject\n    apple fielda;\n\n    banana fieldb;\n\n    orange fieldc;\n\n    public apple getfielda() {\n        return fielda;\n    }\n\n    public void setfielda(apple fielda) {\n        this.fielda = fielda;\n    }\n\n    public banana getfieldb() {\n        return fieldb;\n    }\n\n    @inject\n    public void setfieldb(banana fieldb) {\n        this.fieldb = fieldb;\n    }\n\n    public orange getfieldc() {\n        return fieldc;\n    }\n\n    public annotationinject() {}\n\n    @inject\n    public annotationinject(orange fieldc) {\n        this.fieldc = fieldc;\n    }\n\n    public static void main(string[] args) throws exception {\n        abstractapplicationcontext ctx =\n                        new classpathxmlapplicationcontext("spring/spring-annotation.xml");\n        annotationinject annotationinject = (annotationinject) ctx.getbean("annotationinject");\n\n        log.debug("type: {}, name: {}", annotationinject.getfielda().getclass(),\n                        annotationinject.getfielda().getname());\n\n        log.debug("type: {}, name: {}", annotationinject.getfieldb().getclass(),\n                        annotationinject.getfieldb().getname());\n\n        log.debug("type: {}, name: {}", annotationinject.getfieldc().getclass(),\n                        annotationinject.getfieldc().getname());\n\n        ctx.close();\n    }\n}\n\n\n\n# java 配置\n\n基于 java 配置 spring ioc 容器，实际上是spring 允许用户定义一个类，在这个类中去管理 ioc 容器的配置。\n\n为了让 spring 识别这个定义类为一个 spring 配置类，需要用到两个注解：@configuration和@bean。\n\n如果你熟悉 spring 的 xml 配置方式，你可以将@configuration等价于<beans>标签；将@bean等价于<bean>标签。\n\n# @bean\n\n@bean 的修饰目标只能是方法或注解。\n\n@bean 只能定义在 @configuration 或 @component 注解修饰的类中。\n\n# 声明一个 bean\n\n此外，@configuration 类允许在同一个类中通过@bean 定义内部 bean 依赖。\n\n声明一个 bean，只需要在 bean 属性的 set 方法上标注@bean 即可。\n\n@configuration\npublic class annotationconfiguration {\n    private static final logger log = loggerfactory.getlogger(javacomponentscan.class);\n\n    @bean\n    public job getpolice() {\n        return new police();\n    }\n\n    public static void main(string[] args) {\n        annotationconfigapplicationcontext ctx = new annotationconfigapplicationcontext(annotationconfiguration.class);\n        ctx.scan("org.zp.notes.spring.beans");\n        ctx.refresh();\n        job job = (job) ctx.getbean("police");\n        log.debug("job: {}, work: {}", job.getclass(), job.work());\n    }\n}\n\npublic interface job {\n    string work();\n}\n\n@component("police")\npublic class police implements job {\n    @override\n    public string work() {\n        return "抓罪犯";\n    }\n}\n\n\n这等价于配置\n\n<beans>\n\t<bean id="police" class="org.zp.notes.spring.ioc.sample.job.police"/>\n</beans>\n\n\n@bean 注解用来表明一个方法实例化、配置合初始化一个被 spring ioc 容器管理的新对象。\n\n如果你熟悉 spring 的 xml 配置，你可以将@bean 视为等价于<beans>标签。\n\n@bean 注解可以用于任何的 spring @component bean，然而，通常被用于@configuration bean。\n\n# @configuration\n\n@configuration 是一个类级别的注解，用来标记被修饰类的对象是一个beandefinition。\n\n@configuration 声明 bean 是通过被 @bean 修饰的公共方法。此外，@configuration 允许在同一个类中通过 @bean 定义内部 bean 依赖。\n\n@configuration\npublic class appconfig {\n    @bean\n    public myservice myservice() {\n        return new myserviceimpl();\n    }\n}\n\n\n这等价于配置\n\n<beans>\n\t<bean id="myservice" class="com.acme.services.myserviceimpl"/>\n</beans>\n\n\n用 annotationconfigapplicationcontext 实例化 ioc 容器。\n\n\n# 依赖解决过程\n\n容器执行 bean 依赖解析如下：\n\n * applicationcontext 使用配置元数据创建和初始化 bean。配置元数据可以由 xml、java 代码或注解指定。\n * 对于每个 bean，其依赖关系以属性、构造函数参数或静态工厂方法的参数的形式表示。这些依赖项在实际创建 bean 时提供给 bean。\n * 每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。\n * 作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，spring 可以将以字符串格式提供的值转换为所有内置类型，例如 int、long、string、boolean 等。\n\nspring 容器在创建容器时验证每个 bean 的配置。但是，在实际创建 bean 之前，不会设置 bean 属性本身。在创建容器时会创建 singleton 型的实例并设置为默认的 bean。否则，只有在请求时才会创建 bean。\n\n需注意：构造器注入，可能会导致无法解决循环依赖问题。\n\n例如：a 类通过构造器注入需要 b 类的实例，b 类通过构造器注入需要 a 类的实例。spring ioc 容器会在运行时检测到此循环引用，并抛出 beancurrentlyincreationexception。\n\n一种解决方案是使用 setter 方法注入替代构造器注入。\n\n另一种解决方案是：bean a 和 bean b 之间的循环依赖关系，强制其中一个 bean 在完全初始化之前注入另一个 bean（典型的先有鸡还是先有蛋的场景）。\n\nspring 会在容器加载时检测配置问题，例如引用不存在的 bean 或循环依赖。在实际创建 bean 时，spring 会尽可能晚地设置属性并解析依赖关系。这意味着，如果在创建该对象或其依赖项之一时出现问题，则正确加载的 spring 容器稍后可以在您请求对象时生成异常  —  例如，bean 由于丢失或无效而引发异常。某些配置问题的这种潜在的延迟可见性是默认情况下 applicationcontext 实现预实例化单例 bean 的原因。以在实际需要之前创建这些 bean 的一些前期时间和内存为代价，您会在创建 applicationcontext 时发现配置问题，而不是稍后。您仍然可以覆盖此默认行为，以便单例 bean 延迟初始化，而不是急切地预先实例化。\n\n\n# 最佳实践\n\n\n# singleton 的 bean 如何注入 prototype 的 bean\n\nspring 创建的 bean 默认是单例的，但当 bean 遇到继承的时候，可能会忽略这一点。\n\n假设有一个 sayservice 抽象类，其中维护了一个类型是 arraylist 的字段 data，用于保存方法处理的中间数据。每次调用 say 方法都会往 data 加入新数据，可以认为 sayservice 是有状态，如果 sayservice 是单例的话必然会 oom。\n\n/**\n * sayservice 是有状态，如果 sayservice 是单例的话必然会 oom\n */\n@slf4j\npublic abstract class sayservice {\n\n   list<string> data = new arraylist<>();\n\n   public void say() {\n      data.add(intstream.rangeclosed(1, 1000000)\n         .maptoobj(__ -> "a")\n         .collect(collectors.joining("")) + uuid.randomuuid().tostring());\n      log.info("i\'m {} size:{}", this, data.size());\n   }\n\n}\n\n\n但实际开发的时候，开发同学没有过多思考就把 sayhello 和 saybye 类加上了 @service 注解，让它们成为了 bean，也没有考虑到父类是有状态的。\n\n@service\n@slf4j\npublic class saybye extends sayservice {\n\n   @override\n   public void say() {\n      super.say();\n      log.info("bye");\n   }\n\n}\n\n@service\n@slf4j\npublic class sayhello extends sayservice {\n\n\t@override\n\tpublic void say() {\n\t\tsuper.say();\n\t\tlog.info("hello");\n\t}\n\n}\n\n\n在为类标记上 @service 注解把类型交由容器管理前，首先评估一下类是否有状态，然后为 bean 设置合适的 scope。\n\n调用代码：\n\n@slf4j\n@restcontroller\n@requestmapping("beansingletonandorder")\npublic class beansingletonandordercontroller {\n\n   @autowired\n   list<sayservice> sayservicelist;\n   @autowired\n   private applicationcontext applicationcontext;\n\n   @getmapping("test")\n   public void test() {\n      log.info("====================");\n      sayservicelist.foreach(sayservice::say);\n   }\n\n}\n\n\n可能有人认为，为 sayhello 和 saybye 两个类都标记了 @scope 注解，设置了 prototype 的生命周期就可以解决上面的问题。\n\n@scope(value = configurablebeanfactory.scope_prototype)\n\n\n但实际上还是有问题。因为@restcontroller 注解 =@controller 注解 +@responsebody 注解，又因为 @controller 标记了 @component 元注解，所以 @restcontroller 注解其实也是一个 spring bean。\n\nbean 默认是单例的，所以单例的 controller 注入的 service 也是一次性创建的，即使 service 本身标识了 prototype 的范围也没用。\n\n修复方式是，让 service 以代理方式注入。这样虽然 controller 本身是单例的，但每次都能从代理获取 service。这样一来，prototype 范围的配置才能真正生效。\n\n@scope(value = configurablebeanfactory.scope_prototype, proxymode = scopedprox)\n\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 依赖查找",frontmatter:{title:"Spring 依赖查找",date:"2020-08-30T16:06:10.000Z",order:3,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","IOC","依赖查找"],permalink:"/pages/9a6f6b/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/03.Spring%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/03.Spring依赖查找.md",key:"v-0a3e806a",path:"/pages/9a6f6b/",headers:[{level:2,title:"单一类型依赖查找",slug:"单一类型依赖查找",normalizedTitle:"单一类型依赖查找",charIndex:200},{level:2,title:"集合类型依赖查找",slug:"集合类型依赖查找",normalizedTitle:"集合类型依赖查找",charIndex:577},{level:2,title:"层次性依赖查找",slug:"层次性依赖查找",normalizedTitle:"层次性依赖查找",charIndex:1141},{level:2,title:"延迟依赖查找",slug:"延迟依赖查找",normalizedTitle:"延迟依赖查找",charIndex:1493},{level:2,title:"安全依赖查找",slug:"安全依赖查找",normalizedTitle:"安全依赖查找",charIndex:1736},{level:2,title:"内建可查找的依赖",slug:"内建可查找的依赖",normalizedTitle:"内建可查找的依赖",charIndex:2132},{level:2,title:"依赖查找中的经典异常",slug:"依赖查找中的经典异常",normalizedTitle:"依赖查找中的经典异常",charIndex:3799},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4338}],headersStr:"单一类型依赖查找 集合类型依赖查找 层次性依赖查找 延迟依赖查找 安全依赖查找 内建可查找的依赖 依赖查找中的经典异常 参考资料",content:"# Spring 依赖查找\n\n依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准 API 实现。\n\nIoC 依赖查找大致可以分为以下几类：\n\n * 根据 Bean 名称查找\n * 根据 Bean 类型查找\n * 根据 Bean 名称 + 类型查找\n * 根据 Java 注解查找\n\n此外，根据查找的 Bean 对象是单一或集合对象，是否需要延迟查找等特定常见，有相应不同的 API。\n\n\n# 单一类型依赖查找\n\n单一类型依赖查找接口- BeanFactory\n\n * 根据 Bean 名称查找\n   * getBean(String)\n   * Spring 2.5 覆盖默认参数：getBean(String,Object...)\n * 根据 Bean 类型查找\n   * Bean 实时查找\n     * Spring 3.0 getBean(Class)\n     * Spring 4.1 覆盖默认参数：getBean(Class,Object...)\n   * Spring 5.1 Bean 延迟查找\n     * getBeanProvider(Class)\n     * getBeanProvider(ResolvableType)\n * 根据 Bean 名称 + 类型查找：getBean(String,Class)\n\n\n# 集合类型依赖查找\n\n集合类型依赖查找接口- ListableBeanFactory\n\n * 根据 Bean 类型查找\n   \n   * 获取同类型 Bean 名称列表\n     * getBeanNamesForType(Class)\n     * Spring 4.2 getBeanNamesForType(ResolvableType)\n   * 获取同类型 Bean 实例列表\n     * getBeansOfType(Class) 以及重载方法\n\n * 通过注解类型查找\n   \n   * Spring 3.0 获取标注类型 Bean 名称列表\n     \n     * getBeanNamesForAnnotation(Class<? extends Annotation>)\n   \n   * Spring 3.0 获取标注类型 Bean 实例列表\n     \n     * getBeansWithAnnotation(Class<? extends Annotation>)\n   \n   * Spring 3.0 获取指定名称+ 标注类型 Bean 实例\n     \n     * findAnnotationOnBean(String,Class<? extends Annotation>)\n\n\n# 层次性依赖查找\n\n层次性依赖查找接口- HierarchicalBeanFactory\n\n * 双亲 BeanFactory：getParentBeanFactory()\n * 层次性查找\n   * 根据 Bean 名称查找\n     * 基于 containsLocalBean 方法实现\n   * 根据 Bean 类型查找实例列表\n     * 单一类型：BeanFactoryUtils#beanOfType\n     * 集合类型：BeanFactoryUtils#beansOfTypeIncludingAncestors\n   * 根据 Java 注解查找名称列表\n     * BeanFactoryUtils#beanNamesForTypeIncludingAncestors\n\n\n# 延迟依赖查找\n\nBean 延迟依赖查找接口\n\n * org.springframework.beans.factory.ObjectFactory\n * org.springframework.beans.factory.ObjectProvider（Spring 5 对 Java 8 特性扩展）\n * 函数式接口\n   * getIfAvailable(Supplier)\n   * ifAvailable(Consumer)\n * Stream 扩展- stream()\n\n\n# 安全依赖查找\n\n依赖查找类型   代表实现                                 是否安全\n单一类型查找   BeanFactory#getBean                  否\n         ObjectFactory#getObject              否\n         ObjectProvider#getIfAvailable        是\n                                              \n集合类型查找   ListableBeanFactory#getBeansOfType   是\n         ObjectProvider#stream                是\n\n注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的 BeanFactory 接口\n\n\n# 内建可查找的依赖\n\nAbstractApplicationContext 内建可查找的依赖\n\nBEAN                          名称 BEAN                          实例使用场景\nenvironment                   Environment 对象                   外部化配置以及 Profiles\nsystemProperties              java.util.Properties 对象          Java 系统属性\nsystemEnvironment             java.util.Map 对象                 操作系统环境变量\nmessageSource                 MessageSource 对象                 国际化文案\nlifecycleProcessor            LifecycleProcessor 对象            Lifecycle Bean 处理器\napplicationEventMulticaster   ApplicationEventMulticaster 对象   Spring 事件广播器\n\n注解驱动 Spring 应用上下文内建可查找的依赖（部分）\n\nBEAN 名称                                                                           BEAN 实例                                     使用场景\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor   ConfigurationClassPostProcessor 对象          处理 Spring 配置类\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor       AutowiredAnnotationBeanPostProcessor 对象     处理@Autowired 以及@Value 注解\norg.springframework.context.annotation.internalCommonAnnotationProcessor          CommonAnnotationBeanPostProcessor 对象        （条件激活）处理 JSR-250 注解，如@PostConstruct 等\norg.springframework.context.event.internalEventListenerProcessor                  EventListenerMethodProcessor 对象             处理标注@EventListener 的 Spring 事件监听方法\norg.springframework.context.event.internalEventListenerFactory                    DefaultEventListenerFactory 对象              @EventListener 事件监听方法适配为 ApplicationListener\norg.springframework.context.annotation.internalPersistenceAnnotationProcessor     PersistenceAnnotationBeanPostProcessor 对象   （条件激活）处理 JPA 注解场景\n\n\n# 依赖查找中的经典异常\n\nBeansException 子类型\n\n异常类型                              触发条件（举例）                     场景举例\nNoSuchBeanDefinitionException     当查找 Bean 不存在于 IoC 容器时        BeanFactory#getBeanObjectFactory#getObject\nNoUniqueBeanDefinitionException   类型依赖查找时，IoC 容器存在多个 Bean 实例   BeanFactory#getBean(Class)\nBeanInstantiationException        当 Bean 所对应的类型非具体类时           BeanFactory#getBean\nBeanCreationException             当 Bean 初始化过程中                Bean 初始化方法执行异常时\nBeanDefinitionStoreException      当 BeanDefinition 配置元信息非法时    XML 配置资源无法打开时\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 依赖查找\n\n依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准 api 实现。\n\nioc 依赖查找大致可以分为以下几类：\n\n * 根据 bean 名称查找\n * 根据 bean 类型查找\n * 根据 bean 名称 + 类型查找\n * 根据 java 注解查找\n\n此外，根据查找的 bean 对象是单一或集合对象，是否需要延迟查找等特定常见，有相应不同的 api。\n\n\n# 单一类型依赖查找\n\n单一类型依赖查找接口- beanfactory\n\n * 根据 bean 名称查找\n   * getbean(string)\n   * spring 2.5 覆盖默认参数：getbean(string,object...)\n * 根据 bean 类型查找\n   * bean 实时查找\n     * spring 3.0 getbean(class)\n     * spring 4.1 覆盖默认参数：getbean(class,object...)\n   * spring 5.1 bean 延迟查找\n     * getbeanprovider(class)\n     * getbeanprovider(resolvabletype)\n * 根据 bean 名称 + 类型查找：getbean(string,class)\n\n\n# 集合类型依赖查找\n\n集合类型依赖查找接口- listablebeanfactory\n\n * 根据 bean 类型查找\n   \n   * 获取同类型 bean 名称列表\n     * getbeannamesfortype(class)\n     * spring 4.2 getbeannamesfortype(resolvabletype)\n   * 获取同类型 bean 实例列表\n     * getbeansoftype(class) 以及重载方法\n\n * 通过注解类型查找\n   \n   * spring 3.0 获取标注类型 bean 名称列表\n     \n     * getbeannamesforannotation(class<? extends annotation>)\n   \n   * spring 3.0 获取标注类型 bean 实例列表\n     \n     * getbeanswithannotation(class<? extends annotation>)\n   \n   * spring 3.0 获取指定名称+ 标注类型 bean 实例\n     \n     * findannotationonbean(string,class<? extends annotation>)\n\n\n# 层次性依赖查找\n\n层次性依赖查找接口- hierarchicalbeanfactory\n\n * 双亲 beanfactory：getparentbeanfactory()\n * 层次性查找\n   * 根据 bean 名称查找\n     * 基于 containslocalbean 方法实现\n   * 根据 bean 类型查找实例列表\n     * 单一类型：beanfactoryutils#beanoftype\n     * 集合类型：beanfactoryutils#beansoftypeincludingancestors\n   * 根据 java 注解查找名称列表\n     * beanfactoryutils#beannamesfortypeincludingancestors\n\n\n# 延迟依赖查找\n\nbean 延迟依赖查找接口\n\n * org.springframework.beans.factory.objectfactory\n * org.springframework.beans.factory.objectprovider（spring 5 对 java 8 特性扩展）\n * 函数式接口\n   * getifavailable(supplier)\n   * ifavailable(consumer)\n * stream 扩展- stream()\n\n\n# 安全依赖查找\n\n依赖查找类型   代表实现                                 是否安全\n单一类型查找   beanfactory#getbean                  否\n         objectfactory#getobject              否\n         objectprovider#getifavailable        是\n                                              \n集合类型查找   listablebeanfactory#getbeansoftype   是\n         objectprovider#stream                是\n\n注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的 beanfactory 接口\n\n\n# 内建可查找的依赖\n\nabstractapplicationcontext 内建可查找的依赖\n\nbean                          名称 bean                          实例使用场景\nenvironment                   environment 对象                   外部化配置以及 profiles\nsystemproperties              java.util.properties 对象          java 系统属性\nsystemenvironment             java.util.map 对象                 操作系统环境变量\nmessagesource                 messagesource 对象                 国际化文案\nlifecycleprocessor            lifecycleprocessor 对象            lifecycle bean 处理器\napplicationeventmulticaster   applicationeventmulticaster 对象   spring 事件广播器\n\n注解驱动 spring 应用上下文内建可查找的依赖（部分）\n\nbean 名称                                                                           bean 实例                                     使用场景\norg.springframework.context.annotation.internalconfigurationannotationprocessor   configurationclasspostprocessor 对象          处理 spring 配置类\norg.springframework.context.annotation.internalautowiredannotationprocessor       autowiredannotationbeanpostprocessor 对象     处理@autowired 以及@value 注解\norg.springframework.context.annotation.internalcommonannotationprocessor          commonannotationbeanpostprocessor 对象        （条件激活）处理 jsr-250 注解，如@postconstruct 等\norg.springframework.context.event.internaleventlistenerprocessor                  eventlistenermethodprocessor 对象             处理标注@eventlistener 的 spring 事件监听方法\norg.springframework.context.event.internaleventlistenerfactory                    defaulteventlistenerfactory 对象              @eventlistener 事件监听方法适配为 applicationlistener\norg.springframework.context.annotation.internalpersistenceannotationprocessor     persistenceannotationbeanpostprocessor 对象   （条件激活）处理 jpa 注解场景\n\n\n# 依赖查找中的经典异常\n\nbeansexception 子类型\n\n异常类型                              触发条件（举例）                     场景举例\nnosuchbeandefinitionexception     当查找 bean 不存在于 ioc 容器时        beanfactory#getbeanobjectfactory#getobject\nnouniquebeandefinitionexception   类型依赖查找时，ioc 容器存在多个 bean 实例   beanfactory#getbean(class)\nbeaninstantiationexception        当 bean 所对应的类型非具体类时           beanfactory#getbean\nbeancreationexception             当 bean 初始化过程中                bean 初始化方法执行异常时\nbeandefinitionstoreexception      当 beandefinition 配置元信息非法时    xml 配置资源无法打开时\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 依赖注入",frontmatter:{title:"Spring 依赖注入",date:"2020-08-30T16:06:10.000Z",order:4,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","IOC","依赖注入"],permalink:"/pages/f61a1c/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/04.Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/04.Spring依赖注入.md",key:"v-a011e00e",path:"/pages/f61a1c/",headers:[{level:2,title:"IoC 依赖注入 API",slug:"ioc-依赖注入-api",normalizedTitle:"ioc 依赖注入 api",charIndex:823},{level:2,title:"依赖注入模式",slug:"依赖注入模式",normalizedTitle:"依赖注入模式",charIndex:934},{level:3,title:"手动注入模式",slug:"手动注入模式",normalizedTitle:"手动注入模式",charIndex:952},{level:3,title:"自动注入模式",slug:"自动注入模式",normalizedTitle:"自动注入模式",charIndex:959},{level:4,title:"自动装配策略",slug:"自动装配策略",normalizedTitle:"自动装配策略",charIndex:1259},{level:4,title:"@Autowired 注入过程",slug:"autowired-注入过程",normalizedTitle:"@autowired 注入过程",charIndex:1658},{level:4,title:"自动装配的限制和不足",slug:"自动装配的限制和不足",normalizedTitle:"自动装配的限制和不足",charIndex:1710},{level:2,title:"依赖注入方式",slug:"依赖注入方式",normalizedTitle:"依赖注入方式",charIndex:2101},{level:3,title:"构造器注入",slug:"构造器注入",normalizedTitle:"构造器注入",charIndex:2196},{level:3,title:"Setter 方法注入",slug:"setter-方法注入",normalizedTitle:"setter 方法注入",charIndex:2143},{level:3,title:"字段注入",slug:"字段注入",normalizedTitle:"字段注入",charIndex:2257},{level:3,title:"方法注入",slug:"方法注入",normalizedTitle:"方法注入",charIndex:2150},{level:3,title:"接口回调注入",slug:"接口回调注入",normalizedTitle:"接口回调注入",charIndex:2354},{level:3,title:"依赖注入选型",slug:"依赖注入选型",normalizedTitle:"依赖注入选型",charIndex:6603},{level:2,title:"限定注入和延迟注入",slug:"限定注入和延迟注入",normalizedTitle:"限定注入和延迟注入",charIndex:6671},{level:3,title:"限定注入",slug:"限定注入",normalizedTitle:"限定注入",charIndex:6671},{level:3,title:"延迟注入",slug:"延迟注入",normalizedTitle:"延迟注入",charIndex:925},{level:2,title:"依赖注入数据类型",slug:"依赖注入数据类型",normalizedTitle:"依赖注入数据类型",charIndex:6868},{level:3,title:"基础类型",slug:"基础类型",normalizedTitle:"基础类型",charIndex:6881},{level:3,title:"集合类型",slug:"集合类型",normalizedTitle:"集合类型",charIndex:7123},{level:2,title:"依赖处理过程",slug:"依赖处理过程",normalizedTitle:"依赖处理过程",charIndex:7217},{level:2,title:"依赖查找 VS. 依赖注入",slug:"依赖查找-vs-依赖注入",normalizedTitle:"依赖查找 vs. 依赖注入",charIndex:7812},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7970}],headersStr:"IoC 依赖注入 API 依赖注入模式 手动注入模式 自动注入模式 自动装配策略 @Autowired 注入过程 自动装配的限制和不足 依赖注入方式 构造器注入 Setter 方法注入 字段注入 方法注入 接口回调注入 依赖注入选型 限定注入和延迟注入 限定注入 延迟注入 依赖注入数据类型 基础类型 集合类型 依赖处理过程 依赖查找 VS. 依赖注入 参考资料",content:'# Spring 依赖注入\n\nDI，是 Dependency Injection 的缩写，即依赖注入。依赖注入是 IoC 的最常见形式。依赖注入是手动或自动绑定的方式，无需依赖特定的容器或 API。\n\n依赖注入 (Dependency Injection，简称 DI) 是一个过程，其中对象仅通过构造函数参数、工厂方法的参数或对象实例在构造或从工厂方法返回。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此得名，控制反转），它通过使用类的直接构造或服务定位器模式自行控制其依赖项的实例化或位置。\n\n使用 DI，代码更干净，当对象具有依赖关系时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类别。结果，您的类变得更容易测试，特别是当依赖关系在接口或抽象基类上时，它们允许在单元测试中使用存根或模拟实现。\n\n容器全权负责组件的装配，它会把符合依赖关系的对象通过 JavaBean 属性或者构造函数传递给需要的对象。\n\nDI 是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：\n\n * **谁依赖于谁：**当然是应用程序依赖于 IoC 容器；\n * **为什么需要依赖：**应用程序需要 IoC 容器来提供对象需要的外部资源；\n * **谁注入谁：**很明显是 IoC 容器注入应用程序某个对象，应用程序依赖的对象；\n * 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\n\n# IoC 依赖注入 API\n\n * 根据 Bean 名称注入\n * 根据 Bean 类型注入\n * 注入容器内建 Bean 对象\n * 注入非 Bean 对象\n * 注入类型\n   * 实时注入\n   * 延迟注入\n\n\n# 依赖注入模式\n\n依赖注入模式可以分为手动注入模式和自动注入模式。\n\n\n# 手动注入模式\n\n手动注入模式：配置或者编程的方式，提前安排注入规则\n\n * XML 资源配置元信息\n * Java 注解配置元信息\n * API 配置元信息\n\n\n# 自动注入模式\n\n自动注入模式即自动装配。自动装配（Autowiring）是指 Spring 容器可以自动装配 Bean 之间的关系。Spring 可以通过检查 ApplicationContext 的内容，自动解析合作者（其他 Bean）。\n\n * 自动装配可以显著减少属性或构造函数参数的配置。\n * 随着对象的发展，自动装配可以更新配置。\n\n> 注：由于自动装配存在一些限制和不足，官方不推荐使用。\n\n# 自动装配策略\n\n当使用基于 XML 的配置元数据时，可以使用 <bean/> 元素的 autowire 属性为 Bean 指定自动装配模式。自动装配模式有以下类型：\n\n模式            说明\nno            默认值，未激活 Autowiring，需要手动指定依赖注入对象。\nbyName        根据被注入属性的名称作为 Bean 名称进行依赖查找，并将对象设置到该属性。\nbyType        根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性。\nconstructor   特殊 byType 类型，用于构造器参数。\n\norg.springframework.beans.factory.config.AutowireCapableBeanFactory 是 BeanFactory 的子接口，它是 Spring 中用于实现自动装配的容器。\n\n# @Autowired 注入过程\n\n * 元信息解析\n * 依赖查找\n * 依赖注入（字段、方法）\n\n# 自动装配的限制和不足\n\n自动装配有以下限制和不足：\n\n * 属性和构造函数参数设置中的显式依赖项会覆盖自动装配。您不能自动装配简单属性，例如基础数据类型、字符串和类（以及此类简单属性的数组）。\n * 自动装配不如显式装配精准。Spring 会尽量避免猜测可能存在歧义的结果。\n * Spring 容器生成文档的工具可能无法解析自动装配信息。\n * 如果同一类型存在多个 Bean 时，自动装配时会存在歧义。容器内的多个 Bean 定义可能与要自动装配的 Setter 方法或构造函数参数指定的类型匹配。对于数组、集合或 Map 实例，这不一定是问题。但是，对于期望单值的依赖项，如果没有唯一的 Bean 定义可用，则会引发异常。\n\n> 自动装配的限制和不足，详情可以参考官方文档：Limitations and Disadvantages of Autowiring 小节\n\n\n# 依赖注入方式\n\n依赖注入有如下方式：\n\n依赖注入方式        配置元数据举例\nSetter 方法注入   <proeprty name="user" ref="userBean"/>\n构造器注入         <constructor-arg name="user" ref="userBean" />\n字段注入          @Autowired User user;\n方法注入          @Autowired public void user(User user) { ... }\n接口回调注入        class MyBean implements BeanFactoryAware { ... }\n\n\n# 构造器注入\n\n * 手动模式\n   * xml 配置元信息\n   * 注解配置元信息\n   * Java 配置元信息\n * 自动模式\n   * constructor\n\n构造器注入是通过容器调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。调用带有特定参数的静态工厂方法来构造 bean 几乎是等价的，并且本次讨论对构造函数和静态工厂方法的参数进行了类似的处理。\n\n下面是一个构造器注入示例：\n\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on a MovieFinder\n    private final MovieFinder movieFinder;\n\n    // a constructor so that the Spring container can inject a MovieFinder\n    public SimpleMovieLister(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n\n\n构造函数参数解析匹配通过使用参数的类型进行。如果 bean 定义的构造函数参数中不存在潜在的歧义，则在 bean 定义中定义构造函数参数的顺序是在实例化 bean 时将这些参数提供给适当构造函数的顺序。\n\npackage x.y;\n\npublic class ThingOne {\n\n    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {\n        // ...\n    }\n}\n\n\n假设 ThingTwo 和 ThingThree 类没有继承关系，则不存在潜在的歧义。因此，以下配置工作正常，您无需在 <constructor-arg/> 元素中显式指定构造函数参数索引或类型。\n\n<beans>\n    <bean id="beanOne" class="x.y.ThingOne">\n        <constructor-arg ref="beanTwo"/>\n        <constructor-arg ref="beanThree"/>\n    </bean>\n\n    <bean id="beanTwo" class="x.y.ThingTwo"/>\n\n    <bean id="beanThree" class="x.y.ThingThree"/>\n</beans>\n\n\n当引用另一个 bean 时，类型是已知的，并且可以发生匹配（就像前面的示例一样）。当使用简单类型时，例如 <value>true</value> ，Spring 无法确定 value 的类型，因此无法在没有帮助的情况下按类型匹配。考虑以下类：\n\npackage examples;\n\npublic class ExampleBean {\n\n    // Number of years to calculate the Ultimate Answer\n    private final int years;\n\n    // The Answer to Life, the Universe, and Everything\n    private final String ultimateAnswer;\n\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}\n\n\n构造函数参数类型匹配\n\n在上述场景中，如果您使用 type 属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配，如以下示例所示：\n\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg type="int" value="7500000"/>\n    <constructor-arg type="java.lang.String" value="42"/>\n</bean>\n\n\n构造函数参数索引匹配\n\n可以使用 index 属性显式指定构造函数参数的索引，如以下示例所示\n\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg index="0" value="7500000"/>\n    <constructor-arg index="1" value="42"/>\n</bean>\n\n\n构造函数参数名称匹配\n\n<bean id="exampleBean" class="examples.ExampleBean">\n    <constructor-arg name="years" value="7500000"/>\n    <constructor-arg name="ultimateAnswer" value="42"/>\n</bean>\n\n\n可以使用 @ConstructorProperties 显式命名构造函数参数。\n\npackage examples;\n\npublic class ExampleBean {\n\n    // Fields omitted\n\n    @ConstructorProperties({"years", "ultimateAnswer"})\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}\n\n\n\n# Setter 方法注入\n\n * 手动模式\n   * xml 配置元信息\n   * 注解配置元信息\n   * Java 配置元信息\n * 自动模式\n   * byName\n   * byType\n\nSetter 方法注入是通过容器在调用无参数构造函数或无参数静态工厂方法来实例化 bean 后调用 bean 上的 setter 方法来完成的。\n\n以下示例显示了一个只能通过使用纯 setter 注入进行依赖注入的类。\n\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on the MovieFinder\n    private MovieFinder movieFinder;\n\n    // a setter method so that the Spring container can inject a MovieFinder\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n\n\n在 Spring 中，可以混合使用构造器注入和 setter 方法注入。建议将构造器注入用于强制依赖项；并将 setter 方法注入或配置方法用于可选依赖项。需要注意的是，在 setter 方法上使用 @Required 注解可用于使属性成为必需的依赖项；然而，更建议使用构造器注入来完成这项工作。\n\n\n# 字段注入\n\n手动模式（Java 注解配置元信息）\n\n * @Autowired\n * @Resource\n * @Inject（可选）\n\n\n# 方法注入\n\n手动模式（Java 注解配置元信息）\n\n * @Autowired\n * @Resource\n * @Inject（可选）\n * @Bean\n\n\n# 接口回调注入\n\nAware 系列接口回调\n\n內建接口                             说明\nBeanFactoryAware                 获取 IoC 容器- BeanFactory\nApplicationContextAware          获取 Spring 应用上下文- ApplicationContext 对象\nEnvironmentAware                 获取 Environment 对象\nResourceLoaderAware              获取资源加载器对象- ResourceLoader\nBeanClassLoaderAware             获取加载当前 Bean Class 的 ClassLoader\nBeanNameAware                    获取当前 Bean 的名称\nMessageSourceAware               获取 MessageSource 对象，用于 Spring 国际化\nApplicationEventPublisherAware   获取 ApplicationEventPublishAware 对象，用于 Spring 事件\nEmbeddedValueResolverAware       获取 StringValueResolver 对象，用于占位符处理\n\n\n# 依赖注入选型\n\n * 低依赖：构造器注入\n * 多依赖：Setter 方法注入\n * 便利性：字段注入\n * 声明类：方法注入\n\n\n# 限定注入和延迟注入\n\n\n# 限定注入\n\n * 使用 @Qualifier 注解限定\n   * 通过 Bean 名称限定\n   * 通过分组限定\n * 通过 @Qualifier 注解扩展限定\n   * 自定义注解：如 Spring Cloud 的 @LoadBalanced\n\n\n# 延迟注入\n\n * 使用 ObjectFactory\n * 使用 ObjectProvider（推荐）\n\n\n# 依赖注入数据类型\n\n\n# 基础类型\n\n * 基础数据类型：boolean、byte、char、short、int、float、long、double\n * 标量类型：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID\n * 常规类型：Object、String、TimeZone、Calendar、Optional 等\n * Spring 类型：Resource、InputSource、Formatter 等。\n\n\n# 集合类型\n\n数组类型：基础数据类型、标量类型、常规类型、String 类型的数组\n\n集合类型：\n\n * Collection：List、Set\n * Map：Properties\n\n\n# 依赖处理过程\n\n入口：DefaultListableBeanFactory#resolveDependency\n\n依赖描述符：DependencyDescriptor\n\n自定义绑定候选对象处理器：AutowireCandidateResolver\n\n@Autowired、@Value、@javax.inject.Inject 处理器：AutowiredAnnotationBeanPostProcessor\n\n通用注解处理器：CommonAnnotationBeanPostProcessor\n\n * 注入注解\n   * javax.xml.ws.WebServiceRef\n   * javax.ejb.EJB\n   * javax.annotation.Resources\n * 生命周期注解\n   * javax.annotation.PostConstruct\n   * javax.annotation.PreDestroy\n\n自定义依赖注入注解：\n\n * 生命周期处理\n   * InstantiationAwareBeanPostProcessor\n   * MergedBeanDefinitionPostProcessor\n * 元数据\n   * InjectionMetadata\n   * InjectionMetadata.InjectedElement\n\n\n# 依赖查找 VS. 依赖注入\n\n类型     依赖处理   实现复杂度   代码侵入性    API 依赖性     可读性\n依赖查找   主动     相对繁琐    侵入业务逻辑   依赖容器 API    良好\n依赖注入   被动     相对便利    低侵入性     不依赖容器 API   一般\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 依赖注入\n\ndi，是 dependency injection 的缩写，即依赖注入。依赖注入是 ioc 的最常见形式。依赖注入是手动或自动绑定的方式，无需依赖特定的容器或 api。\n\n依赖注入 (dependency injection，简称 di) 是一个过程，其中对象仅通过构造函数参数、工厂方法的参数或对象实例在构造或从工厂方法返回。然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此得名，控制反转），它通过使用类的直接构造或服务定位器模式自行控制其依赖项的实例化或位置。\n\n使用 di，代码更干净，当对象具有依赖关系时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类别。结果，您的类变得更容易测试，特别是当依赖关系在接口或抽象基类上时，它们允许在单元测试中使用存根或模拟实现。\n\n容器全权负责组件的装配，它会把符合依赖关系的对象通过 javabean 属性或者构造函数传递给需要的对象。\n\ndi 是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解 di 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：\n\n * **谁依赖于谁：**当然是应用程序依赖于 ioc 容器；\n * **为什么需要依赖：**应用程序需要 ioc 容器来提供对象需要的外部资源；\n * **谁注入谁：**很明显是 ioc 容器注入应用程序某个对象，应用程序依赖的对象；\n * 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\n\n# ioc 依赖注入 api\n\n * 根据 bean 名称注入\n * 根据 bean 类型注入\n * 注入容器内建 bean 对象\n * 注入非 bean 对象\n * 注入类型\n   * 实时注入\n   * 延迟注入\n\n\n# 依赖注入模式\n\n依赖注入模式可以分为手动注入模式和自动注入模式。\n\n\n# 手动注入模式\n\n手动注入模式：配置或者编程的方式，提前安排注入规则\n\n * xml 资源配置元信息\n * java 注解配置元信息\n * api 配置元信息\n\n\n# 自动注入模式\n\n自动注入模式即自动装配。自动装配（autowiring）是指 spring 容器可以自动装配 bean 之间的关系。spring 可以通过检查 applicationcontext 的内容，自动解析合作者（其他 bean）。\n\n * 自动装配可以显著减少属性或构造函数参数的配置。\n * 随着对象的发展，自动装配可以更新配置。\n\n> 注：由于自动装配存在一些限制和不足，官方不推荐使用。\n\n# 自动装配策略\n\n当使用基于 xml 的配置元数据时，可以使用 <bean/> 元素的 autowire 属性为 bean 指定自动装配模式。自动装配模式有以下类型：\n\n模式            说明\nno            默认值，未激活 autowiring，需要手动指定依赖注入对象。\nbyname        根据被注入属性的名称作为 bean 名称进行依赖查找，并将对象设置到该属性。\nbytype        根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性。\nconstructor   特殊 bytype 类型，用于构造器参数。\n\norg.springframework.beans.factory.config.autowirecapablebeanfactory 是 beanfactory 的子接口，它是 spring 中用于实现自动装配的容器。\n\n# @autowired 注入过程\n\n * 元信息解析\n * 依赖查找\n * 依赖注入（字段、方法）\n\n# 自动装配的限制和不足\n\n自动装配有以下限制和不足：\n\n * 属性和构造函数参数设置中的显式依赖项会覆盖自动装配。您不能自动装配简单属性，例如基础数据类型、字符串和类（以及此类简单属性的数组）。\n * 自动装配不如显式装配精准。spring 会尽量避免猜测可能存在歧义的结果。\n * spring 容器生成文档的工具可能无法解析自动装配信息。\n * 如果同一类型存在多个 bean 时，自动装配时会存在歧义。容器内的多个 bean 定义可能与要自动装配的 setter 方法或构造函数参数指定的类型匹配。对于数组、集合或 map 实例，这不一定是问题。但是，对于期望单值的依赖项，如果没有唯一的 bean 定义可用，则会引发异常。\n\n> 自动装配的限制和不足，详情可以参考官方文档：limitations and disadvantages of autowiring 小节\n\n\n# 依赖注入方式\n\n依赖注入有如下方式：\n\n依赖注入方式        配置元数据举例\nsetter 方法注入   <proeprty name="user" ref="userbean"/>\n构造器注入         <constructor-arg name="user" ref="userbean" />\n字段注入          @autowired user user;\n方法注入          @autowired public void user(user user) { ... }\n接口回调注入        class mybean implements beanfactoryaware { ... }\n\n\n# 构造器注入\n\n * 手动模式\n   * xml 配置元信息\n   * 注解配置元信息\n   * java 配置元信息\n * 自动模式\n   * constructor\n\n构造器注入是通过容器调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。调用带有特定参数的静态工厂方法来构造 bean 几乎是等价的，并且本次讨论对构造函数和静态工厂方法的参数进行了类似的处理。\n\n下面是一个构造器注入示例：\n\npublic class simplemovielister {\n\n    // the simplemovielister has a dependency on a moviefinder\n    private final moviefinder moviefinder;\n\n    // a constructor so that the spring container can inject a moviefinder\n    public simplemovielister(moviefinder moviefinder) {\n        this.moviefinder = moviefinder;\n    }\n\n    // business logic that actually uses the injected moviefinder is omitted...\n}\n\n\n构造函数参数解析匹配通过使用参数的类型进行。如果 bean 定义的构造函数参数中不存在潜在的歧义，则在 bean 定义中定义构造函数参数的顺序是在实例化 bean 时将这些参数提供给适当构造函数的顺序。\n\npackage x.y;\n\npublic class thingone {\n\n    public thingone(thingtwo thingtwo, thingthree thingthree) {\n        // ...\n    }\n}\n\n\n假设 thingtwo 和 thingthree 类没有继承关系，则不存在潜在的歧义。因此，以下配置工作正常，您无需在 <constructor-arg/> 元素中显式指定构造函数参数索引或类型。\n\n<beans>\n    <bean id="beanone" class="x.y.thingone">\n        <constructor-arg ref="beantwo"/>\n        <constructor-arg ref="beanthree"/>\n    </bean>\n\n    <bean id="beantwo" class="x.y.thingtwo"/>\n\n    <bean id="beanthree" class="x.y.thingthree"/>\n</beans>\n\n\n当引用另一个 bean 时，类型是已知的，并且可以发生匹配（就像前面的示例一样）。当使用简单类型时，例如 <value>true</value> ，spring 无法确定 value 的类型，因此无法在没有帮助的情况下按类型匹配。考虑以下类：\n\npackage examples;\n\npublic class examplebean {\n\n    // number of years to calculate the ultimate answer\n    private final int years;\n\n    // the answer to life, the universe, and everything\n    private final string ultimateanswer;\n\n    public examplebean(int years, string ultimateanswer) {\n        this.years = years;\n        this.ultimateanswer = ultimateanswer;\n    }\n}\n\n\n构造函数参数类型匹配\n\n在上述场景中，如果您使用 type 属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配，如以下示例所示：\n\n<bean id="examplebean" class="examples.examplebean">\n    <constructor-arg type="int" value="7500000"/>\n    <constructor-arg type="java.lang.string" value="42"/>\n</bean>\n\n\n构造函数参数索引匹配\n\n可以使用 index 属性显式指定构造函数参数的索引，如以下示例所示\n\n<bean id="examplebean" class="examples.examplebean">\n    <constructor-arg index="0" value="7500000"/>\n    <constructor-arg index="1" value="42"/>\n</bean>\n\n\n构造函数参数名称匹配\n\n<bean id="examplebean" class="examples.examplebean">\n    <constructor-arg name="years" value="7500000"/>\n    <constructor-arg name="ultimateanswer" value="42"/>\n</bean>\n\n\n可以使用 @constructorproperties 显式命名构造函数参数。\n\npackage examples;\n\npublic class examplebean {\n\n    // fields omitted\n\n    @constructorproperties({"years", "ultimateanswer"})\n    public examplebean(int years, string ultimateanswer) {\n        this.years = years;\n        this.ultimateanswer = ultimateanswer;\n    }\n}\n\n\n\n# setter 方法注入\n\n * 手动模式\n   * xml 配置元信息\n   * 注解配置元信息\n   * java 配置元信息\n * 自动模式\n   * byname\n   * bytype\n\nsetter 方法注入是通过容器在调用无参数构造函数或无参数静态工厂方法来实例化 bean 后调用 bean 上的 setter 方法来完成的。\n\n以下示例显示了一个只能通过使用纯 setter 注入进行依赖注入的类。\n\npublic class simplemovielister {\n\n    // the simplemovielister has a dependency on the moviefinder\n    private moviefinder moviefinder;\n\n    // a setter method so that the spring container can inject a moviefinder\n    public void setmoviefinder(moviefinder moviefinder) {\n        this.moviefinder = moviefinder;\n    }\n\n    // business logic that actually uses the injected moviefinder is omitted...\n}\n\n\n在 spring 中，可以混合使用构造器注入和 setter 方法注入。建议将构造器注入用于强制依赖项；并将 setter 方法注入或配置方法用于可选依赖项。需要注意的是，在 setter 方法上使用 @required 注解可用于使属性成为必需的依赖项；然而，更建议使用构造器注入来完成这项工作。\n\n\n# 字段注入\n\n手动模式（java 注解配置元信息）\n\n * @autowired\n * @resource\n * @inject（可选）\n\n\n# 方法注入\n\n手动模式（java 注解配置元信息）\n\n * @autowired\n * @resource\n * @inject（可选）\n * @bean\n\n\n# 接口回调注入\n\naware 系列接口回调\n\n內建接口                             说明\nbeanfactoryaware                 获取 ioc 容器- beanfactory\napplicationcontextaware          获取 spring 应用上下文- applicationcontext 对象\nenvironmentaware                 获取 environment 对象\nresourceloaderaware              获取资源加载器对象- resourceloader\nbeanclassloaderaware             获取加载当前 bean class 的 classloader\nbeannameaware                    获取当前 bean 的名称\nmessagesourceaware               获取 messagesource 对象，用于 spring 国际化\napplicationeventpublisheraware   获取 applicationeventpublishaware 对象，用于 spring 事件\nembeddedvalueresolveraware       获取 stringvalueresolver 对象，用于占位符处理\n\n\n# 依赖注入选型\n\n * 低依赖：构造器注入\n * 多依赖：setter 方法注入\n * 便利性：字段注入\n * 声明类：方法注入\n\n\n# 限定注入和延迟注入\n\n\n# 限定注入\n\n * 使用 @qualifier 注解限定\n   * 通过 bean 名称限定\n   * 通过分组限定\n * 通过 @qualifier 注解扩展限定\n   * 自定义注解：如 spring cloud 的 @loadbalanced\n\n\n# 延迟注入\n\n * 使用 objectfactory\n * 使用 objectprovider（推荐）\n\n\n# 依赖注入数据类型\n\n\n# 基础类型\n\n * 基础数据类型：boolean、byte、char、short、int、float、long、double\n * 标量类型：number、character、boolean、enum、locale、charset、currency、properties、uuid\n * 常规类型：object、string、timezone、calendar、optional 等\n * spring 类型：resource、inputsource、formatter 等。\n\n\n# 集合类型\n\n数组类型：基础数据类型、标量类型、常规类型、string 类型的数组\n\n集合类型：\n\n * collection：list、set\n * map：properties\n\n\n# 依赖处理过程\n\n入口：defaultlistablebeanfactory#resolvedependency\n\n依赖描述符：dependencydescriptor\n\n自定义绑定候选对象处理器：autowirecandidateresolver\n\n@autowired、@value、@javax.inject.inject 处理器：autowiredannotationbeanpostprocessor\n\n通用注解处理器：commonannotationbeanpostprocessor\n\n * 注入注解\n   * javax.xml.ws.webserviceref\n   * javax.ejb.ejb\n   * javax.annotation.resources\n * 生命周期注解\n   * javax.annotation.postconstruct\n   * javax.annotation.predestroy\n\n自定义依赖注入注解：\n\n * 生命周期处理\n   * instantiationawarebeanpostprocessor\n   * mergedbeandefinitionpostprocessor\n * 元数据\n   * injectionmetadata\n   * injectionmetadata.injectedelement\n\n\n# 依赖查找 vs. 依赖注入\n\n类型     依赖处理   实现复杂度   代码侵入性    api 依赖性     可读性\n依赖查找   主动     相对繁琐    侵入业务逻辑   依赖容器 api    良好\n依赖注入   被动     相对便利    低侵入性     不依赖容器 api   一般\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring IoC 依赖来源",frontmatter:{title:"Spring IoC 依赖来源",date:"2022-12-20T20:33:51.000Z",order:5,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","IOC","依赖注入"],permalink:"/pages/a5f257/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/05.SpringIoC%E4%BE%9D%E8%B5%96%E6%9D%A5%E6%BA%90.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/05.SpringIoC依赖来源.md",key:"v-b5170794",path:"/pages/a5f257/",headers:[{level:2,title:"依赖查找的来源",slug:"依赖查找的来源",normalizedTitle:"依赖查找的来源",charIndex:22},{level:2,title:"依赖注入的来源",slug:"依赖注入的来源",normalizedTitle:"依赖注入的来源",charIndex:1569},{level:2,title:"Spring 容器管理和游离对象",slug:"spring-容器管理和游离对象",normalizedTitle:"spring 容器管理和游离对象",charIndex:1832},{level:2,title:"Spring BeanDefinition 作为依赖来源",slug:"spring-beandefinition-作为依赖来源",normalizedTitle:"spring beandefinition 作为依赖来源",charIndex:2116},{level:2,title:"单例对象作为依赖来源",slug:"单例对象作为依赖来源",normalizedTitle:"单例对象作为依赖来源",charIndex:2261},{level:2,title:"非 Spring 对象容器管理对象作为依赖来源",slug:"非-spring-对象容器管理对象作为依赖来源",normalizedTitle:"非 spring 对象容器管理对象作为依赖来源",charIndex:2402},{level:2,title:"外部化配置作为依赖来源",slug:"外部化配置作为依赖来源",normalizedTitle:"外部化配置作为依赖来源",charIndex:2559},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2661},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3028}],headersStr:"依赖查找的来源 依赖注入的来源 Spring 容器管理和游离对象 Spring BeanDefinition 作为依赖来源 单例对象作为依赖来源 非 Spring 对象容器管理对象作为依赖来源 外部化配置作为依赖来源 问题 参考资料",content:'# Spring IoC 依赖来源\n\n\n# 依赖查找的来源\n\n查找来源\n\n来源                      配置元数据\nSpring BeanDefinition   <bean id ="user" class="xxx.xxx.User">\n                        @Bean public User user() {...}\n                        BeanDefinitionBuilder\n单例对象                    API 实现\n\nSpring 內建 BeanDefintion\n\nBEAN 名称                                                                           BEAN 实例                                   使用场景\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor   ConfigurationClassPostProcessor 对象        处理 Spring 配置类\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor       AutowiredAnnotationBeanPostProcessor 对象   处理 @Autowired 以及 @Value 注解\norg.springframework.context.annotation.internalCommonAnnotationProcessor          CommonAnnotationBeanPostProcessor 对象      （条件激活）处理 JSR-250 注解，如 @PostConstruct 等\norg.springframework.context.event.internalEventListenerProcessor                  EventListenerMethodProcessor 对象           处理标注 @EventListener 的 Spring 事件监听方法\n\nSpring 內建单例对象\n\nBEAN 名称                       BEAN 实例                          使用场景\nenvironment                   Environment 对象                   外部化配置以及 Profiles\nsystemProperties              java.util.Properties 对象          Java 系统属性\nsystemEnvironment             java.util.Map 对象                 操作系统环境变量\nmessageSource                 MessageSource 对象                 国际化文案\nlifecycleProcessor            LifecycleProcessor 对象            Lifecycle Bean 处理器\napplicationEventMulticaster   ApplicationEventMulticaster 对象   Spring 事件广播器\n\n\n# 依赖注入的来源\n\n来源                      配置元数据\nSpring BeanDefinition   <bean id ="user" class="xxx.xxx.User">\n                        @Bean public User user() {...}\n                        BeanDefinitionBuilder\n单例对象                    API 实现\n非 Spring 容器管理对象         \n\n\n# Spring 容器管理和游离对象\n\n来源                      SPRING BEAN 对象   生命周期管理   配置元信息   使用场景\nSpring BeanDefinition   是                是        有       依赖查找、依赖注入\n单体对象                    是                否        无       依赖查找、依赖注入\nResolvable Dependency   否                否        无       依赖注入\n\n\n# Spring BeanDefinition 作为依赖来源\n\n * 元数据：BeanDefinition\n * 注册：BeanDefinitionRegistry#registerBeanDefinition\n * 类型：延迟和非延迟\n * 顺序：Bean 生命周期顺序按照注册顺序\n\n\n# 单例对象作为依赖来源\n\n * 要素\n   * 来源：外部普通 Java 对象（不一定是 POJO）\n   * 注册：SingletonBeanRegistry#registerSingleton\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 Bean\n\n\n# 非 Spring 对象容器管理对象作为依赖来源\n\n * 要素\n   * 注册：ConfigurableListableBeanFactory#registerResolvableDependency\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 Bean\n   * 无法通过依赖查找\n\n\n# 外部化配置作为依赖来源\n\n * 要素\n   * 类型：非常规 Spring 对象依赖来源\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 Bean\n   * 无法通过依赖查找\n\n\n# 问题\n\n注入和查找的依赖来源是否相同？\n\n否，依赖查找的来源仅限于 Spring BeanDefinition 以及单例对象，而依赖注入的来源还包括 Resolvable Dependency 以及 @Value 所标注的外部化配置\n\n单例对象能在 IoC 容器启动后注册吗？\n\n可以的，单例对象的注册与 BeanDefinition 不同，BeanDefinition 会被 ConfigurableListableBeanFactory#freezeConfiguration() 方法影响，从而冻结注册，单例对象则没有这个限制。\n\nSpring 依赖注入的来源有哪些？\n\n * Spring BeanDefinition\n * 单例对象\n * Resolvable Dependency\n * @Value 外部化配置\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring ioc 依赖来源\n\n\n# 依赖查找的来源\n\n查找来源\n\n来源                      配置元数据\nspring beandefinition   <bean id ="user" class="xxx.xxx.user">\n                        @bean public user user() {...}\n                        beandefinitionbuilder\n单例对象                    api 实现\n\nspring 內建 beandefintion\n\nbean 名称                                                                           bean 实例                                   使用场景\norg.springframework.context.annotation.internalconfigurationannotationprocessor   configurationclasspostprocessor 对象        处理 spring 配置类\norg.springframework.context.annotation.internalautowiredannotationprocessor       autowiredannotationbeanpostprocessor 对象   处理 @autowired 以及 @value 注解\norg.springframework.context.annotation.internalcommonannotationprocessor          commonannotationbeanpostprocessor 对象      （条件激活）处理 jsr-250 注解，如 @postconstruct 等\norg.springframework.context.event.internaleventlistenerprocessor                  eventlistenermethodprocessor 对象           处理标注 @eventlistener 的 spring 事件监听方法\n\nspring 內建单例对象\n\nbean 名称                       bean 实例                          使用场景\nenvironment                   environment 对象                   外部化配置以及 profiles\nsystemproperties              java.util.properties 对象          java 系统属性\nsystemenvironment             java.util.map 对象                 操作系统环境变量\nmessagesource                 messagesource 对象                 国际化文案\nlifecycleprocessor            lifecycleprocessor 对象            lifecycle bean 处理器\napplicationeventmulticaster   applicationeventmulticaster 对象   spring 事件广播器\n\n\n# 依赖注入的来源\n\n来源                      配置元数据\nspring beandefinition   <bean id ="user" class="xxx.xxx.user">\n                        @bean public user user() {...}\n                        beandefinitionbuilder\n单例对象                    api 实现\n非 spring 容器管理对象         \n\n\n# spring 容器管理和游离对象\n\n来源                      spring bean 对象   生命周期管理   配置元信息   使用场景\nspring beandefinition   是                是        有       依赖查找、依赖注入\n单体对象                    是                否        无       依赖查找、依赖注入\nresolvable dependency   否                否        无       依赖注入\n\n\n# spring beandefinition 作为依赖来源\n\n * 元数据：beandefinition\n * 注册：beandefinitionregistry#registerbeandefinition\n * 类型：延迟和非延迟\n * 顺序：bean 生命周期顺序按照注册顺序\n\n\n# 单例对象作为依赖来源\n\n * 要素\n   * 来源：外部普通 java 对象（不一定是 pojo）\n   * 注册：singletonbeanregistry#registersingleton\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 bean\n\n\n# 非 spring 对象容器管理对象作为依赖来源\n\n * 要素\n   * 注册：configurablelistablebeanfactory#registerresolvabledependency\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 bean\n   * 无法通过依赖查找\n\n\n# 外部化配置作为依赖来源\n\n * 要素\n   * 类型：非常规 spring 对象依赖来源\n * 限制\n   * 无生命周期管理\n   * 无法实现延迟初始化 bean\n   * 无法通过依赖查找\n\n\n# 问题\n\n注入和查找的依赖来源是否相同？\n\n否，依赖查找的来源仅限于 spring beandefinition 以及单例对象，而依赖注入的来源还包括 resolvable dependency 以及 @value 所标注的外部化配置\n\n单例对象能在 ioc 容器启动后注册吗？\n\n可以的，单例对象的注册与 beandefinition 不同，beandefinition 会被 configurablelistablebeanfactory#freezeconfiguration() 方法影响，从而冻结注册，单例对象则没有这个限制。\n\nspring 依赖注入的来源有哪些？\n\n * spring beandefinition\n * 单例对象\n * resolvable dependency\n * @value 外部化配置\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring Bean 作用域",frontmatter:{title:"Spring Bean 作用域",date:"2022-12-21T11:42:00.000Z",order:6,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Bean"],permalink:"/pages/8289f5/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/06.SpringBean%E4%BD%9C%E7%94%A8%E5%9F%9F.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/06.SpringBean作用域.md",key:"v-359ace56",path:"/pages/8289f5/",headers:[{level:2,title:"Spring Bean 作用域",slug:"spring-bean-作用域-2",normalizedTitle:"spring bean 作用域",charIndex:2},{level:2,title:'"singleton" Bean 作用域',slug:"singleton-bean-作用域",normalizedTitle:"&quot;singleton&quot; bean 作用域",charIndex:null},{level:2,title:'"prototype" Bean 作用域',slug:"prototype-bean-作用域",normalizedTitle:"&quot;prototype&quot; bean 作用域",charIndex:null},{level:2,title:'"request" Bean 作用域',slug:"request-bean-作用域",normalizedTitle:"&quot;request&quot; bean 作用域",charIndex:null},{level:2,title:'"session" Bean 作用域',slug:"session-bean-作用域",normalizedTitle:"&quot;session&quot; bean 作用域",charIndex:null},{level:2,title:'"application" Bean 作用域',slug:"application-bean-作用域",normalizedTitle:"&quot;application&quot; bean 作用域",charIndex:null},{level:2,title:"自定义 Bean 作用域",slug:"自定义-bean-作用域",normalizedTitle:"自定义 bean 作用域",charIndex:1033},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:1452},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1716}],headersStr:'Spring Bean 作用域 "singleton" Bean 作用域 "prototype" Bean 作用域 "request" Bean 作用域 "session" Bean 作用域 "application" Bean 作用域 自定义 Bean 作用域 问题 参考资料',content:'# Spring Bean 作用域\n\n\n# Spring Bean 作用域\n\n来源            说明\nsingleton     默认 Spring Bean 作用域，一个 BeanFactory 有且仅有一个实例\nprototype     原型作用域，每次依赖查找和依赖注入生成新 Bean 对象\nrequest       将 Spring Bean 存储在 ServletRequest 上下文中\nsession       将 Spring Bean 存储在 HttpSession 中\napplication   将 Spring Bean 存储在 ServletContext 中\n\n\n# "singleton" Bean 作用域\n\n\n\n\n# "prototype" Bean 作用域\n\nSpring 容器没有办法管理 prototype Bean 的完整生命周期，也没有办法记录实例的存在。销毁回调方法将不会执行，可以利用 BeanPostProcessor 进行清扫工作。\n\n\n# "request" Bean 作用域\n\n * 配置\n   * XML - <bean class="..." scope = “request" />\n   * Java 注解 - @RequestScope 或 @Scope(WebApplicationContext.SCOPE_REQUEST)\n * 实现\n   * API - RequestScope\n\n\n# "session" Bean 作用域\n\n * 配置\n   * XML - <bean class="..." scope = “session" />\n   * Java 注解 - @SessionScope 或 @Scope(WebApplicationContext.SCOPE_SESSION)\n * 实现\n   * API - SessionScope\n\n\n# "application" Bean 作用域\n\n * 配置\n   * XML - <bean class="..." scope = “application" />\n   * Java 注解 - @ApplicationScope 或 @Scope(WebApplicationContext.SCOPE_APPLICATION)\n * 实现\n   * API - ServletContextScope\n\n\n# 自定义 Bean 作用域\n\n * 实现 Scope\n   \n   * org.springframework.beans.factory.config.Scope\n\n * 注册 Scope\n   \n   * API - org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope\n\n * 配置\n   \n   <bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">\n     <property name="scopes">\n       <map>\n         <entry key="...">\n         </entry>\n       </map>\n     </property>\n   </bean>\n   \n\n\n# 问题\n\nSpring 內建的 Bean 作用域有几种？\n\nsingleton、prototype、request、session、application 以及 websocket\n\nsingleton Bean 是否在一个应用是唯一的？\n\n否。singleton bean 仅在当前 Spring IoC 容器（BeanFactory）中是单例对象。\n\napplication Bean 是否可以被其他方案替代？\n\n可以的，实际上，“application” Bean 与“singleton” Bean 没有本质区别\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring bean 作用域\n\n\n# spring bean 作用域\n\n来源            说明\nsingleton     默认 spring bean 作用域，一个 beanfactory 有且仅有一个实例\nprototype     原型作用域，每次依赖查找和依赖注入生成新 bean 对象\nrequest       将 spring bean 存储在 servletrequest 上下文中\nsession       将 spring bean 存储在 httpsession 中\napplication   将 spring bean 存储在 servletcontext 中\n\n\n# "singleton" bean 作用域\n\n\n\n\n# "prototype" bean 作用域\n\nspring 容器没有办法管理 prototype bean 的完整生命周期，也没有办法记录实例的存在。销毁回调方法将不会执行，可以利用 beanpostprocessor 进行清扫工作。\n\n\n# "request" bean 作用域\n\n * 配置\n   * xml - <bean class="..." scope = “request" />\n   * java 注解 - @requestscope 或 @scope(webapplicationcontext.scope_request)\n * 实现\n   * api - requestscope\n\n\n# "session" bean 作用域\n\n * 配置\n   * xml - <bean class="..." scope = “session" />\n   * java 注解 - @sessionscope 或 @scope(webapplicationcontext.scope_session)\n * 实现\n   * api - sessionscope\n\n\n# "application" bean 作用域\n\n * 配置\n   * xml - <bean class="..." scope = “application" />\n   * java 注解 - @applicationscope 或 @scope(webapplicationcontext.scope_application)\n * 实现\n   * api - servletcontextscope\n\n\n# 自定义 bean 作用域\n\n * 实现 scope\n   \n   * org.springframework.beans.factory.config.scope\n\n * 注册 scope\n   \n   * api - org.springframework.beans.factory.config.configurablebeanfactory#registerscope\n\n * 配置\n   \n   <bean class="org.springframework.beans.factory.config.customscopeconfigurer">\n     <property name="scopes">\n       <map>\n         <entry key="...">\n         </entry>\n       </map>\n     </property>\n   </bean>\n   \n\n\n# 问题\n\nspring 內建的 bean 作用域有几种？\n\nsingleton、prototype、request、session、application 以及 websocket\n\nsingleton bean 是否在一个应用是唯一的？\n\n否。singleton bean 仅在当前 spring ioc 容器（beanfactory）中是单例对象。\n\napplication bean 是否可以被其他方案替代？\n\n可以的，实际上，“application” bean 与“singleton” bean 没有本质区别\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring Bean 生命周期",frontmatter:{title:"Spring Bean 生命周期",date:"2022-12-21T19:26:01.000Z",order:7,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Bean"],permalink:"/pages/4ab176/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/07.SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/07.SpringBean生命周期.md",key:"v-0ef44af3",path:"/pages/4ab176/",headers:[{level:2,title:"Spring Bean 元信息配置阶段",slug:"spring-bean-元信息配置阶段",normalizedTitle:"spring bean 元信息配置阶段",charIndex:23},{level:2,title:"Spring Bean 元信息解析阶段",slug:"spring-bean-元信息解析阶段",normalizedTitle:"spring bean 元信息解析阶段",charIndex:126},{level:2,title:"Spring Bean 注册阶段",slug:"spring-bean-注册阶段",normalizedTitle:"spring bean 注册阶段",charIndex:300},{level:2,title:"Spring BeanDefinition 合并阶段",slug:"spring-beandefinition-合并阶段",normalizedTitle:"spring beandefinition 合并阶段",charIndex:365},{level:2,title:"Spring Bean Class 加载阶段",slug:"spring-bean-class-加载阶段",normalizedTitle:"spring bean class 加载阶段",charIndex:481},{level:2,title:"Spring Bean 实例化前阶段",slug:"spring-bean-实例化前阶段",normalizedTitle:"spring bean 实例化前阶段",charIndex:592},{level:2,title:"Spring Bean 实例化阶段",slug:"spring-bean-实例化阶段",normalizedTitle:"spring bean 实例化阶段",charIndex:674},{level:2,title:"Spring Bean 实例化后阶段",slug:"spring-bean-实例化后阶段",normalizedTitle:"spring bean 实例化后阶段",charIndex:787},{level:2,title:"Spring Bean 属性赋值前阶段",slug:"spring-bean-属性赋值前阶段",normalizedTitle:"spring bean 属性赋值前阶段",charIndex:900},{level:2,title:"Spring Bean Aware 接口回调阶段",slug:"spring-bean-aware-接口回调阶段",normalizedTitle:"spring bean aware 接口回调阶段",charIndex:1134},{level:2,title:"Spring Bean 初始化前阶段",slug:"spring-bean-初始化前阶段",normalizedTitle:"spring bean 初始化前阶段",charIndex:1399},{level:2,title:"Spring Bean 初始化阶段",slug:"spring-bean-初始化阶段",normalizedTitle:"spring bean 初始化阶段",charIndex:1536},{level:2,title:"Spring Bean 初始化后阶段",slug:"spring-bean-初始化后阶段",normalizedTitle:"spring bean 初始化后阶段",charIndex:1671},{level:2,title:"Spring Bean 初始化完成阶段",slug:"spring-bean-初始化完成阶段",normalizedTitle:"spring bean 初始化完成阶段",charIndex:1749},{level:2,title:"Spring Bean 销毁前阶段",slug:"spring-bean-销毁前阶段",normalizedTitle:"spring bean 销毁前阶段",charIndex:1847},{level:2,title:"Spring Bean 销毁阶段",slug:"spring-bean-销毁阶段",normalizedTitle:"spring bean 销毁阶段",charIndex:1938},{level:2,title:"Spring Bean 垃圾收集",slug:"spring-bean-垃圾收集",normalizedTitle:"spring bean 垃圾收集",charIndex:2047},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2152},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3358}],headersStr:"Spring Bean 元信息配置阶段 Spring Bean 元信息解析阶段 Spring Bean 注册阶段 Spring BeanDefinition 合并阶段 Spring Bean Class 加载阶段 Spring Bean 实例化前阶段 Spring Bean 实例化阶段 Spring Bean 实例化后阶段 Spring Bean 属性赋值前阶段 Spring Bean Aware 接口回调阶段 Spring Bean 初始化前阶段 Spring Bean 初始化阶段 Spring Bean 初始化后阶段 Spring Bean 初始化完成阶段 Spring Bean 销毁前阶段 Spring Bean 销毁阶段 Spring Bean 垃圾收集 问题 参考资料",content:"# Spring Bean 生命周期\n\n\n# Spring Bean 元信息配置阶段\n\nBeanDefinition 配置\n\n * 面向资源\n   * XML 配置\n   * Properties 资源配置\n * 面向注解\n * 面向 API\n\n\n# Spring Bean 元信息解析阶段\n\n * 面向资源 BeanDefinition 解析\n   * BeanDefinitionReader\n   * XML 解析器 - BeanDefinitionParser\n * 面向注解 BeanDefinition 解析\n   * AnnotatedBeanDefinitionReader\n\n\n# Spring Bean 注册阶段\n\nBeanDefinition 注册接口：BeanDefinitionRegistry\n\n\n# Spring BeanDefinition 合并阶段\n\nBeanDefinition 合并\n\n父子 BeanDefinition 合并\n\n * 当前 BeanFactory 查找\n * 层次性 BeanFactory 查找\n\n\n# Spring Bean Class 加载阶段\n\n * ClassLoader 类加载\n * Java Security 安全控制\n * ConfigurableBeanFactory 临时 ClassLoader\n\n\n# Spring Bean 实例化前阶段\n\n实例化方式\n\n * 传统实例化方式：实例化策略（InstantiationStrategy）\n * 构造器依赖注入\n\n\n# Spring Bean 实例化阶段\n\n非主流生命周期 - Bean 实例化前阶段\n\nInstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n\n\n# Spring Bean 实例化后阶段\n\nBean 属性赋值（Populate）判断\n\nInstantiationAwareBeanPostProcessor#postProcessAfterInstantiation\n\n\n# Spring Bean 属性赋值前阶段\n\n * Bean 属性值元信息\n   * PropertyValues\n * Bean 属性赋值前回调\n   * Spring 1.2 - 5.0：InstantiationAwareBeanPostProcessor#postProcessPropertyValues\n   * Spring 5.1：InstantiationAwareBeanPostProcessor#postProcessProperties\n\n\n# Spring Bean Aware 接口回调阶段\n\nSpring Aware 接口：\n\n * BeanNameAware\n * BeanClassLoaderAware\n * BeanFactoryAware\n * EnvironmentAware\n * EmbeddedValueResolverAware\n * ResourceLoaderAware\n * ApplicationEventPublisherAware\n * MessageSourceAware\n * ApplicationContextAware\n\n\n# Spring Bean 初始化前阶段\n\n已完成：\n\n * Bean 实例化\n\n * Bean 属性赋值\n\n * Bean Aware 接口回调\n\n方法回调：\n\n * BeanPostProcessor#postProcessBeforeInitialization\n\n\n# Spring Bean 初始化阶段\n\nBean 初始化（Initialization）\n\n * @PostConstruct 标注方法\n * 实现 InitializingBean 接口的 afterPropertiesSet() 方法\n * 自定义初始化方法\n\n\n# Spring Bean 初始化后阶段\n\n方法回调：BeanPostProcessor#postProcessAfterInitialization\n\n\n# Spring Bean 初始化完成阶段\n\n方法回调：Spring 4.1 +：SmartInitializingSingleton#afterSingletonsInstantiated\n\n\n# Spring Bean 销毁前阶段\n\n方法回调：DestructionAwareBeanPostProcessor#postProcessBeforeDestruction\n\n\n# Spring Bean 销毁阶段\n\nBean 销毁（Destroy）\n\n * @PreDestroy 标注方法\n * 实现 DisposableBean 接口的 destroy() 方法\n * 自定义销毁方法\n\n\n# Spring Bean 垃圾收集\n\nBean 垃圾回收（GC）\n\n * 关闭 Spring 容器（应用上下文）\n * 执行 GC\n * Spring Bean 覆盖的 finalize() 方法被回调\n\n\n# 问题\n\nBeanPostProcessor 的使用场景有哪些？\n\nBeanPostProcessor 提供 Spring Bean 初始化前和初始化后的生命周期回调，分别对应 postProcessBeforeInitialization 以及 postProcessAfterInitialization 方法，允许对关心的 Bean 进行扩展，甚至是替换。\n\n加分项：其中，ApplicationContext 相关的 Aware 回调也是基于 BeanPostProcessor 实现，即 ApplicationContextAwareProcessor。\n\nBeanFactoryPostProcessor 与 BeanPostProcessor 的区别？\n\nBeanFactoryPostProcessor 是 Spring BeanFactory（实际为 ConfigurableListableBeanFactory） 的后置处理器，用于扩展 BeanFactory，或通过 BeanFactory 进行依赖查找和依赖注入。\n\nBeanFactoryPostProcessor 必须有 Spring ApplicationContext 执行，BeanFactory 无法与其直接交互。\n\n而 BeanPostProcessor 则直接与 BeanFactory 关联，属于 N 对 1 的关系。\n\nBeanFactory 是怎样处理 Bean 生命周期？\n\nBeanFactory 的默认实现为 DefaultListableBeanFactory，其中 Bean生命周期与方法映射如下：\n\n * BeanDefinition 注册阶段 - registerBeanDefinition\n * BeanDefinition 合并阶段 - getMergedBeanDefinition\n * Bean 实例化前阶段 - resolveBeforeInstantiation\n * Bean 实例化阶段 - createBeanInstance\n * Bean 初始化后阶段 - populateBean\n * Bean 属性赋值前阶段 - populateBean\n * Bean 属性赋值阶段 - populateBean\n * Bean Aware 接口回调阶段 - initializeBean\n * Bean 初始化前阶段 - initializeBean\n * Bean 初始化阶段 - initializeBean\n * Bean 初始化后阶段 - initializeBean\n * Bean 初始化完成阶段 - preInstantiateSingletons\n * Bean 销毁前阶段 - destroyBean\n * Bean 销毁阶段 - destroyBean\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring bean 生命周期\n\n\n# spring bean 元信息配置阶段\n\nbeandefinition 配置\n\n * 面向资源\n   * xml 配置\n   * properties 资源配置\n * 面向注解\n * 面向 api\n\n\n# spring bean 元信息解析阶段\n\n * 面向资源 beandefinition 解析\n   * beandefinitionreader\n   * xml 解析器 - beandefinitionparser\n * 面向注解 beandefinition 解析\n   * annotatedbeandefinitionreader\n\n\n# spring bean 注册阶段\n\nbeandefinition 注册接口：beandefinitionregistry\n\n\n# spring beandefinition 合并阶段\n\nbeandefinition 合并\n\n父子 beandefinition 合并\n\n * 当前 beanfactory 查找\n * 层次性 beanfactory 查找\n\n\n# spring bean class 加载阶段\n\n * classloader 类加载\n * java security 安全控制\n * configurablebeanfactory 临时 classloader\n\n\n# spring bean 实例化前阶段\n\n实例化方式\n\n * 传统实例化方式：实例化策略（instantiationstrategy）\n * 构造器依赖注入\n\n\n# spring bean 实例化阶段\n\n非主流生命周期 - bean 实例化前阶段\n\ninstantiationawarebeanpostprocessor#postprocessbeforeinstantiation\n\n\n# spring bean 实例化后阶段\n\nbean 属性赋值（populate）判断\n\ninstantiationawarebeanpostprocessor#postprocessafterinstantiation\n\n\n# spring bean 属性赋值前阶段\n\n * bean 属性值元信息\n   * propertyvalues\n * bean 属性赋值前回调\n   * spring 1.2 - 5.0：instantiationawarebeanpostprocessor#postprocesspropertyvalues\n   * spring 5.1：instantiationawarebeanpostprocessor#postprocessproperties\n\n\n# spring bean aware 接口回调阶段\n\nspring aware 接口：\n\n * beannameaware\n * beanclassloaderaware\n * beanfactoryaware\n * environmentaware\n * embeddedvalueresolveraware\n * resourceloaderaware\n * applicationeventpublisheraware\n * messagesourceaware\n * applicationcontextaware\n\n\n# spring bean 初始化前阶段\n\n已完成：\n\n * bean 实例化\n\n * bean 属性赋值\n\n * bean aware 接口回调\n\n方法回调：\n\n * beanpostprocessor#postprocessbeforeinitialization\n\n\n# spring bean 初始化阶段\n\nbean 初始化（initialization）\n\n * @postconstruct 标注方法\n * 实现 initializingbean 接口的 afterpropertiesset() 方法\n * 自定义初始化方法\n\n\n# spring bean 初始化后阶段\n\n方法回调：beanpostprocessor#postprocessafterinitialization\n\n\n# spring bean 初始化完成阶段\n\n方法回调：spring 4.1 +：smartinitializingsingleton#aftersingletonsinstantiated\n\n\n# spring bean 销毁前阶段\n\n方法回调：destructionawarebeanpostprocessor#postprocessbeforedestruction\n\n\n# spring bean 销毁阶段\n\nbean 销毁（destroy）\n\n * @predestroy 标注方法\n * 实现 disposablebean 接口的 destroy() 方法\n * 自定义销毁方法\n\n\n# spring bean 垃圾收集\n\nbean 垃圾回收（gc）\n\n * 关闭 spring 容器（应用上下文）\n * 执行 gc\n * spring bean 覆盖的 finalize() 方法被回调\n\n\n# 问题\n\nbeanpostprocessor 的使用场景有哪些？\n\nbeanpostprocessor 提供 spring bean 初始化前和初始化后的生命周期回调，分别对应 postprocessbeforeinitialization 以及 postprocessafterinitialization 方法，允许对关心的 bean 进行扩展，甚至是替换。\n\n加分项：其中，applicationcontext 相关的 aware 回调也是基于 beanpostprocessor 实现，即 applicationcontextawareprocessor。\n\nbeanfactorypostprocessor 与 beanpostprocessor 的区别？\n\nbeanfactorypostprocessor 是 spring beanfactory（实际为 configurablelistablebeanfactory） 的后置处理器，用于扩展 beanfactory，或通过 beanfactory 进行依赖查找和依赖注入。\n\nbeanfactorypostprocessor 必须有 spring applicationcontext 执行，beanfactory 无法与其直接交互。\n\n而 beanpostprocessor 则直接与 beanfactory 关联，属于 n 对 1 的关系。\n\nbeanfactory 是怎样处理 bean 生命周期？\n\nbeanfactory 的默认实现为 defaultlistablebeanfactory，其中 bean生命周期与方法映射如下：\n\n * beandefinition 注册阶段 - registerbeandefinition\n * beandefinition 合并阶段 - getmergedbeandefinition\n * bean 实例化前阶段 - resolvebeforeinstantiation\n * bean 实例化阶段 - createbeaninstance\n * bean 初始化后阶段 - populatebean\n * bean 属性赋值前阶段 - populatebean\n * bean 属性赋值阶段 - populatebean\n * bean aware 接口回调阶段 - initializebean\n * bean 初始化前阶段 - initializebean\n * bean 初始化阶段 - initializebean\n * bean 初始化后阶段 - initializebean\n * bean 初始化完成阶段 - preinstantiatesingletons\n * bean 销毁前阶段 - destroybean\n * bean 销毁阶段 - destroybean\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 配置元数据",frontmatter:{title:"Spring 配置元数据",date:"2022-12-21T19:49:48.000Z",order:"08",categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Bean"],permalink:"/pages/55f315/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/08.Spring%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/08.Spring配置元数据.md",key:"v-ec12120a",path:"/pages/55f315/",headers:[{level:2,title:"Spring 配置元信息",slug:"spring-配置元信息",normalizedTitle:"spring 配置元信息",charIndex:19},{level:2,title:"Spring Bean 配置元信息",slug:"spring-bean-配置元信息",normalizedTitle:"spring bean 配置元信息",charIndex:36},{level:2,title:"Spring Bean 属性元信息",slug:"spring-bean-属性元信息",normalizedTitle:"spring bean 属性元信息",charIndex:74},{level:2,title:"Spring 容器配置元信息",slug:"spring-容器配置元信息",normalizedTitle:"spring 容器配置元信息",charIndex:112},{level:2,title:"基于 XML 文件装载 Spring Bean 配置元信息",slug:"基于-xml-文件装载-spring-bean-配置元信息",normalizedTitle:"基于 xml 文件装载 spring bean 配置元信息",charIndex:1718},{level:2,title:"基于 Properties 文件装载 Spring Bean 配置元信息",slug:"基于-properties-文件装载-spring-bean-配置元信息",normalizedTitle:"基于 properties 文件装载 spring bean 配置元信息",charIndex:2008},{level:2,title:"基于 Java 注解装载 Spring Bean 配置元信息",slug:"基于-java-注解装载-spring-bean-配置元信息",normalizedTitle:"基于 java 注解装载 spring bean 配置元信息",charIndex:2351},{level:2,title:"Spring Bean 配置元信息底层实现",slug:"spring-bean-配置元信息底层实现",normalizedTitle:"spring bean 配置元信息底层实现",charIndex:3854},{level:3,title:"Spring XML 资源 BeanDefinition 解析与注册",slug:"spring-xml-资源-beandefinition-解析与注册",normalizedTitle:"spring xml 资源 beandefinition 解析与注册",charIndex:3880},{level:3,title:"Spring Properties 资源 BeanDefinition 解析与注册",slug:"spring-properties-资源-beandefinition-解析与注册",normalizedTitle:"spring properties 资源 beandefinition 解析与注册",charIndex:4145},{level:3,title:"Spring Java 注册 BeanDefinition 解析与注册",slug:"spring-java-注册-beandefinition-解析与注册",normalizedTitle:"spring java 注册 beandefinition 解析与注册",charIndex:4404},{level:2,title:"基于 XML 文件装载 Spring IoC 容器配置元信息",slug:"基于-xml-文件装载-spring-ioc-容器配置元信息",normalizedTitle:"基于 xml 文件装载 spring ioc 容器配置元信息",charIndex:4759},{level:2,title:"基于 Java 注解装载 Spring IoC 容器配置元信息",slug:"基于-java-注解装载-spring-ioc-容器配置元信息",normalizedTitle:"基于 java 注解装载 spring ioc 容器配置元信息",charIndex:5417},{level:2,title:"基于 Extensible XML authoring 扩展 SpringXML 元素",slug:"基于-extensible-xml-authoring-扩展-springxml-元素",normalizedTitle:"基于 extensible xml authoring 扩展 springxml 元素",charIndex:5865},{level:2,title:"Extensible XML authoring 扩展原理",slug:"extensible-xml-authoring-扩展原理",normalizedTitle:"extensible xml authoring 扩展原理",charIndex:6083},{level:3,title:"触发时机",slug:"触发时机",normalizedTitle:"触发时机",charIndex:6117},{level:3,title:"核心流程",slug:"核心流程",normalizedTitle:"核心流程",charIndex:6449},{level:2,title:"基于 Properties 文件装载外部化配置",slug:"基于-properties-文件装载外部化配置",normalizedTitle:"基于 properties 文件装载外部化配置",charIndex:6644},{level:2,title:"基于 YAML 文件装载外部化配置",slug:"基于-yaml-文件装载外部化配置",normalizedTitle:"基于 yaml 文件装载外部化配置",charIndex:6900},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:7126},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8247}],headersStr:"Spring 配置元信息 Spring Bean 配置元信息 Spring Bean 属性元信息 Spring 容器配置元信息 基于 XML 文件装载 Spring Bean 配置元信息 基于 Properties 文件装载 Spring Bean 配置元信息 基于 Java 注解装载 Spring Bean 配置元信息 Spring Bean 配置元信息底层实现 Spring XML 资源 BeanDefinition 解析与注册 Spring Properties 资源 BeanDefinition 解析与注册 Spring Java 注册 BeanDefinition 解析与注册 基于 XML 文件装载 Spring IoC 容器配置元信息 基于 Java 注解装载 Spring IoC 容器配置元信息 基于 Extensible XML authoring 扩展 SpringXML 元素 Extensible XML authoring 扩展原理 触发时机 核心流程 基于 Properties 文件装载外部化配置 基于 YAML 文件装载外部化配置 问题 参考资料",content:'# Spring 配置元数据\n\n\n# Spring 配置元信息\n\n * Spring Bean 配置元信息 - BeanDefinition\n * Spring Bean 属性元信息 - PropertyValues\n * Spring 容器配置元信息\n * Spring 外部化配置元信息 - PropertySource\n * Spring Profile 元信息 - @Profile\n\n\n# Spring Bean 配置元信息\n\nBean 配置元信息 - BeanDefinition\n\n * GenericBeanDefinition：通用型 BeanDefinition\n * RootBeanDefinition：无 Parent 的 BeanDefinition 或者合并后 BeanDefinition\n * AnnotatedBeanDefinition：注解标注的 BeanDefinition\n\n\n# Spring Bean 属性元信息\n\n * Bean 属性元信息 - PropertyValues\n   * 可修改实现 - MutablePropertyValues\n   * 元素成员 - PropertyValue\n * Bean 属性上下文存储 - AttributeAccessor\n * Bean 元信息元素 - BeanMetadataElement\n\n\n# Spring 容器配置元信息\n\nSpring XML 配置元信息 - beans 元素相关\n\nBEANS 元素属性                    默认值        使用场景\nprofile                       null（留空）   Spring Profiles 配置值\ndefault-lazy-init             default    当 outter beans “default-lazy-init” 属性存在时，继承该值，否则为“false”\ndefault-merge                 default    当 outter beans “default-merge” 属性存在时，继承该值，否则为“false”\ndefault-autowire              default    当 outter beans “default-autowire” 属性存在时，继承该值，否则为“no”\ndefault-autowire-candidates   null（留空）   默认 Spring Beans 名称 pattern\ndefault-init-method           null（留空）   默认 Spring Beans 自定义初始化方法\ndefault-destroy-method        null（留空）   默认 Spring Beans 自定义销毁方法\n\nSpring XML 配置元信息 - 应用上下文相关\n\nXML 元素                             使用场景\n<context:annotation-config />      激活 Spring 注解驱动\n<context:component-scan />         Spring @Component 以及自定义注解扫描\n<context:load-time-weaver />       激活 Spring LoadTimeWeaver\n<context:mbean-export />           暴露 Spring Beans 作为 JMX Beans\n<context:mbean-server />           将当前平台作为 MBeanServer\n<context:property-placeholder />   加载外部化配置资源作为 Spring 属性配\n<context:property-override />      利用外部化配置资源覆盖 Spring 属\n\n\n# 基于 XML 文件装载 Spring Bean 配置元信息\n\n底层实现 - XmlBeanDefinitionReader\n\nXML 元素             使用场景\n<beans:beans />    单 XML 资源下的多个 Spring Beans 配置\n<beans:bean />     单个 Spring Bean 定义（BeanDefinition）配置\n<beans:alias />    为 Spring Bean 定义（BeanDefinition）映射别名\n<beans:import />   加载外部 Spring XML 配置资源\n\n\n# 基于 Properties 文件装载 Spring Bean 配置元信息\n\n底层实现 - PropertiesBeanDefinitionReader\n\nPROPERTIES 属性名   使用场景\nclass            Bean 类全称限定名\nabstract         是否为抽象的 BeanDefinition\nparent           指定 parent BeanDefinition 名称\nlazy-init        是否为延迟初始化\nref              引用其他 Bean 的名称\nscope            设置 Bean 的 scope 属性\n${n}             n 表示第 n+1 个构造器参数\n\n\n# 基于 Java 注解装载 Spring Bean 配置元信息\n\nSpring 模式注解\n\nSPRING 注解        场景说明          起始版本\n@Repository      数据仓储模式注解      2.0\n@Component       通用组件模式注解      2.5\n@Service         服务模式注解        2.5\n@Controller      Web 控制器模式注解   2.5\n@Configuration   配置类模式注解       3.0\n\nSpring Bean 定义注解\n\nSPRING 注解    场景说明                                           起始版本\n@Bean        替换 XML 元素 <bean>                               3.0\n@DependsOn   替代 XML 属性 <bean depends-on="..."/>             3.0\n@Lazy        替代 XML 属性 <bean lazy-init="true | falses" />   3.0\n@Primary     替换 XML 元素 <bean primary="true | false" />      3.0\n@Role        替换 XML 元素 <bean role="..." />                  3.1\n@Lookup      替代 XML 属性 <bean lookup-method="...">           4.1\n\nSpring Bean 依赖注入注解\n\nSPRING 注解    场景说明                   起始版本\n@Autowired   Bean 依赖注入，支持多种依赖查找方式   2.5\n@Qualifier   细粒度的 @Autowired 依赖查找   2.5\n\nJAVA 注解     场景说明             起始版本\n@Resource   类似于 @Autowired   2.5\n@Inject     类似于 @Autowired   2.5\n\nSpring Bean 条件装配注解\n\nSPRING 注解      场景说明      起始版本\n@Profile       配置化条件装配   3.1\n@Conditional   编程条件装配    4.0\n\nSpring Bean 生命周期回调注解\n\nSPRING 注解        场景说明                           起始版本\n@PostConstruct   替换 XML 元素 或 InitializingBean   2.5\n@PreDestroy      替换 XML 元素 或 DisposableBean     2.5\n\nSpring BeanDefinition 解析与注册\n\nSPRING 注解       场景说明                             起始版本\nXML 资源          XmlBeanDefinitionReader          1.0\nProperties 资源   PropertiesBeanDefinitionReader   1.0\nJava 注解         AnnotatedBeanDefinitionReader    3.0\n\n\n# Spring Bean 配置元信息底层实现\n\n\n# Spring XML 资源 BeanDefinition 解析与注册\n\n核心 API - XmlBeanDefinitionReader\n\n * 资源 - Resource\n * 底层 - BeanDefinitionDocumentReader\n   * XML 解析 - Java DOM Level 3 API\n   * BeanDefinition 解析 - BeanDefinitionParserDelegate\n   * BeanDefinition 注册 - BeanDefinitionRegistry\n\n\n# Spring Properties 资源 BeanDefinition 解析与注册\n\n核心 API - PropertiesBeanDefinitionReader\n\n * 资源\n   * 字节流 - Resource\n   * 字符流 - EncodedResouce\n * 底层\n   * 存储 - java.util.Properties\n   * BeanDefinition 解析 - API 内部实现\n   * BeanDefinition 注册 - BeanDefinitionRegistry\n\n\n# Spring Java 注册 BeanDefinition 解析与注册\n\n核心 API - AnnotatedBeanDefinitionReader\n\n * 资源\n   * 类对象 - java.lang.Class\n * 底层\n   * 条件评估 - ConditionEvaluator\n   * Bean 范围解析 - ScopeMetadataResolver\n   * BeanDefinition 解析 - 内部 API 实现\n   * BeanDefinition 处理 - AnnotationConfigUtils.processCommonDefinitionAnnotations\n   * BeanDefinition 注册 - BeanDefinitionRegistry\n\n\n# 基于 XML 文件装载 Spring IoC 容器配置元信息\n\nSpring IoC 容器相关 XML 配置\n\n命名空间      所属模块             SCHEMA 资源 URL\nbeans     spring-beans     https://www.springframework.org/schema/beans/spring-beans.xsd\ncontext   spring-context   https://www.springframework.org/schema/context/spring-context.xsd\naop       spring-aop       https://www.springframework.org/schema/aop/spring-aop.xsd\ntx        spring-tx        https://www.springframework.org/schema/tx/spring-tx.xsd\nutil      spring-beans     beans\n                           https://www.springframework.org/schema/util/spring-util.xsd\ntool      spring-beans     https://www.springframework.org/schema/tool/spring-tool.xsd\n\n\n# 基于 Java 注解装载 Spring IoC 容器配置元信息\n\nSpring IoC 容器装配注解\n\nSPRING 注解         场景说明                             起始版本\n@ImportResource   替换 XML 元素 <import>               3.0\n@Import           导入 Configuration Class           3.0\n@ComponentScan    扫描指定 package 下标注 Spring 模式注解的类   3.1\n\nSpring IoC 配属属性注解\n\nSPRING 注解          场景说明                       起始版本\n@PropertySource    配置属性抽象 PropertySource 注解   3.1\n@PropertySources   @PropertySource 集合注解       4.0\n\n\n# 基于 Extensible XML authoring 扩展 SpringXML 元素\n\nSpring XML 扩展\n\n * 编写 XML Schema 文件：定义 XML 结构\n * 自定义 NamespaceHandler 实现：命名空间绑定\n * 自定义 BeanDefinitionParser 实现：XML 元素与 BeanDefinition 解析\n * 注册 XML 扩展：命名空间与 XML Schema 映射\n\n\n# Extensible XML authoring 扩展原理\n\n\n# 触发时机\n\n * AbstractApplicationContext#obtainFreshBeanFactory\n   * AbstractRefreshableApplicationContext#refreshBeanFactory\n     * AbstractXmlApplicationContext#loadBeanDefinitions\n       * ...\n         * XmlBeanDefinitionReader#doLoadBeanDefinitions\n           * ...\n             * BeanDefinitionParserDelegate#parseCustomElement\n\n\n# 核心流程\n\nBeanDefinitionParserDelegate#parseCustomElement(org.w3c.dom.Element, BeanDefinition)\n\n * 获取 namespace\n * 通过 namespace 解析 NamespaceHandler\n * 构造 ParserContext\n * 解析元素，获取 BeanDefinintion\n\n\n# 基于 Properties 文件装载外部化配置\n\n注解驱动\n\n * @org.springframework.context.annotation.PropertySource\n * @org.springframework.context.annotation.PropertySources\n\nAPI 编程\n\n * org.springframework.core.env.PropertySource\n * org.springframework.core.env.PropertySources\n\n\n# 基于 YAML 文件装载外部化配置\n\nAPI 编程\n\n * org.springframework.beans.factory.config.YamlProcessor\n   * org.springframework.beans.factory.config.YamlMapFactoryBean\n   * org.springframework.beans.factory.config.YamlPropertiesFactoryBean\n\n\n# 问题\n\nSpring 內建 XML Schema 常见有哪些？\n\n命名空间      所属模块             SCHEMA 资源 URL\nbeans     spring-beans     https://www.springframework.org/schema/beans/spring-beans.xsd\ncontext   spring-context   https://www.springframework.org/schema/context/spring-context.xsd\naop       spring-aop       https://www.springframework.org/schema/aop/spring-aop.xsd\ntx        spring-tx        https://www.springframework.org/schema/tx/spring-tx.xsd\nutil      spring-beans     beans\n                           https://www.springframework.org/schema/util/spring-util.xsd\ntool      spring-beans     https://www.springframework.org/schema/tool/spring-tool.xsd\n\nSpring 配置元信息具体有哪些？\n\n * Bean 配置元信息：通过媒介（如 XML、Proeprties 等），解析 BeanDefinition\n * IoC 容器配置元信息：通过媒介（如 XML、Proeprties 等），控制 IoC 容器行为，比如注解驱动、AOP 等\n * 外部化配置：通过资源抽象（如 Proeprties、YAML 等），控制 PropertySource\n * Spring Profile：通过外部化配置，提供条件分支流程\n\nExtensible XML authoring 的缺点？\n\n * 高复杂度：开发人员需要熟悉 XML Schema，spring.handlers，spring.schemas 以及 Spring API\n * 嵌套元素支持较弱：通常需要使用方法递归或者其嵌套解析的方式处理嵌套（子）元素\n * XML 处理性能较差：Spring XML 基于 DOM Level 3 API 实现，该 API 便于理解，然而性能较差\n * XML 框架移植性差：很难适配高性能和便利性的 XML 框架，如 JAXB\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 配置元数据\n\n\n# spring 配置元信息\n\n * spring bean 配置元信息 - beandefinition\n * spring bean 属性元信息 - propertyvalues\n * spring 容器配置元信息\n * spring 外部化配置元信息 - propertysource\n * spring profile 元信息 - @profile\n\n\n# spring bean 配置元信息\n\nbean 配置元信息 - beandefinition\n\n * genericbeandefinition：通用型 beandefinition\n * rootbeandefinition：无 parent 的 beandefinition 或者合并后 beandefinition\n * annotatedbeandefinition：注解标注的 beandefinition\n\n\n# spring bean 属性元信息\n\n * bean 属性元信息 - propertyvalues\n   * 可修改实现 - mutablepropertyvalues\n   * 元素成员 - propertyvalue\n * bean 属性上下文存储 - attributeaccessor\n * bean 元信息元素 - beanmetadataelement\n\n\n# spring 容器配置元信息\n\nspring xml 配置元信息 - beans 元素相关\n\nbeans 元素属性                    默认值        使用场景\nprofile                       null（留空）   spring profiles 配置值\ndefault-lazy-init             default    当 outter beans “default-lazy-init” 属性存在时，继承该值，否则为“false”\ndefault-merge                 default    当 outter beans “default-merge” 属性存在时，继承该值，否则为“false”\ndefault-autowire              default    当 outter beans “default-autowire” 属性存在时，继承该值，否则为“no”\ndefault-autowire-candidates   null（留空）   默认 spring beans 名称 pattern\ndefault-init-method           null（留空）   默认 spring beans 自定义初始化方法\ndefault-destroy-method        null（留空）   默认 spring beans 自定义销毁方法\n\nspring xml 配置元信息 - 应用上下文相关\n\nxml 元素                             使用场景\n<context:annotation-config />      激活 spring 注解驱动\n<context:component-scan />         spring @component 以及自定义注解扫描\n<context:load-time-weaver />       激活 spring loadtimeweaver\n<context:mbean-export />           暴露 spring beans 作为 jmx beans\n<context:mbean-server />           将当前平台作为 mbeanserver\n<context:property-placeholder />   加载外部化配置资源作为 spring 属性配\n<context:property-override />      利用外部化配置资源覆盖 spring 属\n\n\n# 基于 xml 文件装载 spring bean 配置元信息\n\n底层实现 - xmlbeandefinitionreader\n\nxml 元素             使用场景\n<beans:beans />    单 xml 资源下的多个 spring beans 配置\n<beans:bean />     单个 spring bean 定义（beandefinition）配置\n<beans:alias />    为 spring bean 定义（beandefinition）映射别名\n<beans:import />   加载外部 spring xml 配置资源\n\n\n# 基于 properties 文件装载 spring bean 配置元信息\n\n底层实现 - propertiesbeandefinitionreader\n\nproperties 属性名   使用场景\nclass            bean 类全称限定名\nabstract         是否为抽象的 beandefinition\nparent           指定 parent beandefinition 名称\nlazy-init        是否为延迟初始化\nref              引用其他 bean 的名称\nscope            设置 bean 的 scope 属性\n${n}             n 表示第 n+1 个构造器参数\n\n\n# 基于 java 注解装载 spring bean 配置元信息\n\nspring 模式注解\n\nspring 注解        场景说明          起始版本\n@repository      数据仓储模式注解      2.0\n@component       通用组件模式注解      2.5\n@service         服务模式注解        2.5\n@controller      web 控制器模式注解   2.5\n@configuration   配置类模式注解       3.0\n\nspring bean 定义注解\n\nspring 注解    场景说明                                           起始版本\n@bean        替换 xml 元素 <bean>                               3.0\n@dependson   替代 xml 属性 <bean depends-on="..."/>             3.0\n@lazy        替代 xml 属性 <bean lazy-init="true | falses" />   3.0\n@primary     替换 xml 元素 <bean primary="true | false" />      3.0\n@role        替换 xml 元素 <bean role="..." />                  3.1\n@lookup      替代 xml 属性 <bean lookup-method="...">           4.1\n\nspring bean 依赖注入注解\n\nspring 注解    场景说明                   起始版本\n@autowired   bean 依赖注入，支持多种依赖查找方式   2.5\n@qualifier   细粒度的 @autowired 依赖查找   2.5\n\njava 注解     场景说明             起始版本\n@resource   类似于 @autowired   2.5\n@inject     类似于 @autowired   2.5\n\nspring bean 条件装配注解\n\nspring 注解      场景说明      起始版本\n@profile       配置化条件装配   3.1\n@conditional   编程条件装配    4.0\n\nspring bean 生命周期回调注解\n\nspring 注解        场景说明                           起始版本\n@postconstruct   替换 xml 元素 或 initializingbean   2.5\n@predestroy      替换 xml 元素 或 disposablebean     2.5\n\nspring beandefinition 解析与注册\n\nspring 注解       场景说明                             起始版本\nxml 资源          xmlbeandefinitionreader          1.0\nproperties 资源   propertiesbeandefinitionreader   1.0\njava 注解         annotatedbeandefinitionreader    3.0\n\n\n# spring bean 配置元信息底层实现\n\n\n# spring xml 资源 beandefinition 解析与注册\n\n核心 api - xmlbeandefinitionreader\n\n * 资源 - resource\n * 底层 - beandefinitiondocumentreader\n   * xml 解析 - java dom level 3 api\n   * beandefinition 解析 - beandefinitionparserdelegate\n   * beandefinition 注册 - beandefinitionregistry\n\n\n# spring properties 资源 beandefinition 解析与注册\n\n核心 api - propertiesbeandefinitionreader\n\n * 资源\n   * 字节流 - resource\n   * 字符流 - encodedresouce\n * 底层\n   * 存储 - java.util.properties\n   * beandefinition 解析 - api 内部实现\n   * beandefinition 注册 - beandefinitionregistry\n\n\n# spring java 注册 beandefinition 解析与注册\n\n核心 api - annotatedbeandefinitionreader\n\n * 资源\n   * 类对象 - java.lang.class\n * 底层\n   * 条件评估 - conditionevaluator\n   * bean 范围解析 - scopemetadataresolver\n   * beandefinition 解析 - 内部 api 实现\n   * beandefinition 处理 - annotationconfigutils.processcommondefinitionannotations\n   * beandefinition 注册 - beandefinitionregistry\n\n\n# 基于 xml 文件装载 spring ioc 容器配置元信息\n\nspring ioc 容器相关 xml 配置\n\n命名空间      所属模块             schema 资源 url\nbeans     spring-beans     https://www.springframework.org/schema/beans/spring-beans.xsd\ncontext   spring-context   https://www.springframework.org/schema/context/spring-context.xsd\naop       spring-aop       https://www.springframework.org/schema/aop/spring-aop.xsd\ntx        spring-tx        https://www.springframework.org/schema/tx/spring-tx.xsd\nutil      spring-beans     beans\n                           https://www.springframework.org/schema/util/spring-util.xsd\ntool      spring-beans     https://www.springframework.org/schema/tool/spring-tool.xsd\n\n\n# 基于 java 注解装载 spring ioc 容器配置元信息\n\nspring ioc 容器装配注解\n\nspring 注解         场景说明                             起始版本\n@importresource   替换 xml 元素 <import>               3.0\n@import           导入 configuration class           3.0\n@componentscan    扫描指定 package 下标注 spring 模式注解的类   3.1\n\nspring ioc 配属属性注解\n\nspring 注解          场景说明                       起始版本\n@propertysource    配置属性抽象 propertysource 注解   3.1\n@propertysources   @propertysource 集合注解       4.0\n\n\n# 基于 extensible xml authoring 扩展 springxml 元素\n\nspring xml 扩展\n\n * 编写 xml schema 文件：定义 xml 结构\n * 自定义 namespacehandler 实现：命名空间绑定\n * 自定义 beandefinitionparser 实现：xml 元素与 beandefinition 解析\n * 注册 xml 扩展：命名空间与 xml schema 映射\n\n\n# extensible xml authoring 扩展原理\n\n\n# 触发时机\n\n * abstractapplicationcontext#obtainfreshbeanfactory\n   * abstractrefreshableapplicationcontext#refreshbeanfactory\n     * abstractxmlapplicationcontext#loadbeandefinitions\n       * ...\n         * xmlbeandefinitionreader#doloadbeandefinitions\n           * ...\n             * beandefinitionparserdelegate#parsecustomelement\n\n\n# 核心流程\n\nbeandefinitionparserdelegate#parsecustomelement(org.w3c.dom.element, beandefinition)\n\n * 获取 namespace\n * 通过 namespace 解析 namespacehandler\n * 构造 parsercontext\n * 解析元素，获取 beandefinintion\n\n\n# 基于 properties 文件装载外部化配置\n\n注解驱动\n\n * @org.springframework.context.annotation.propertysource\n * @org.springframework.context.annotation.propertysources\n\napi 编程\n\n * org.springframework.core.env.propertysource\n * org.springframework.core.env.propertysources\n\n\n# 基于 yaml 文件装载外部化配置\n\napi 编程\n\n * org.springframework.beans.factory.config.yamlprocessor\n   * org.springframework.beans.factory.config.yamlmapfactorybean\n   * org.springframework.beans.factory.config.yamlpropertiesfactorybean\n\n\n# 问题\n\nspring 內建 xml schema 常见有哪些？\n\n命名空间      所属模块             schema 资源 url\nbeans     spring-beans     https://www.springframework.org/schema/beans/spring-beans.xsd\ncontext   spring-context   https://www.springframework.org/schema/context/spring-context.xsd\naop       spring-aop       https://www.springframework.org/schema/aop/spring-aop.xsd\ntx        spring-tx        https://www.springframework.org/schema/tx/spring-tx.xsd\nutil      spring-beans     beans\n                           https://www.springframework.org/schema/util/spring-util.xsd\ntool      spring-beans     https://www.springframework.org/schema/tool/spring-tool.xsd\n\nspring 配置元信息具体有哪些？\n\n * bean 配置元信息：通过媒介（如 xml、proeprties 等），解析 beandefinition\n * ioc 容器配置元信息：通过媒介（如 xml、proeprties 等），控制 ioc 容器行为，比如注解驱动、aop 等\n * 外部化配置：通过资源抽象（如 proeprties、yaml 等），控制 propertysource\n * spring profile：通过外部化配置，提供条件分支流程\n\nextensible xml authoring 的缺点？\n\n * 高复杂度：开发人员需要熟悉 xml schema，spring.handlers，spring.schemas 以及 spring api\n * 嵌套元素支持较弱：通常需要使用方法递归或者其嵌套解析的方式处理嵌套（子）元素\n * xml 处理性能较差：spring xml 基于 dom level 3 api 实现，该 api 便于理解，然而性能较差\n * xml 框架移植性差：很难适配高性能和便利性的 xml 框架，如 jaxb\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring AOP",frontmatter:{title:"Spring AOP",date:"2020-02-26T23:47:47.000Z",order:10,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","AOP"],permalink:"/pages/53aedb/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/10.SpringAop.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/10.SpringAop.md",key:"v-a873abde",path:"/pages/53aedb/",headers:[{level:2,title:"AOP 概念",slug:"aop-概念",normalizedTitle:"aop 概念",charIndex:17},{level:3,title:"什么是 AOP",slug:"什么是-aop",normalizedTitle:"什么是 aop",charIndex:28},{level:3,title:"术语",slug:"术语",normalizedTitle:"术语",charIndex:208},{level:4,title:"Aspect(切面)",slug:"aspect-切面",normalizedTitle:"aspect(切面)",charIndex:193},{level:4,title:"advice(增强)",slug:"advice-增强",normalizedTitle:"advice(增强)",charIndex:480},{level:4,title:"连接点(join point)",slug:"连接点-join-point",normalizedTitle:"连接点(join point)",charIndex:832},{level:4,title:"切点(point cut)",slug:"切点-point-cut",normalizedTitle:"切点(point cut)",charIndex:1114},{level:4,title:"关于 join point 和 point cut 的区别",slug:"关于-join-point-和-point-cut-的区别",normalizedTitle:"关于 join point 和 point cut 的区别",charIndex:1424},{level:4,title:"introduction",slug:"introduction",normalizedTitle:"introduction",charIndex:1697},{level:4,title:"目标对象(Target)",slug:"目标对象-target",normalizedTitle:"目标对象(target)",charIndex:1839},{level:4,title:"AOP proxy",slug:"aop-proxy",normalizedTitle:"aop proxy",charIndex:2028},{level:4,title:"织入(Weaving)",slug:"织入-weaving",normalizedTitle:"织入(weaving)",charIndex:2144},{level:3,title:"advice 的类型",slug:"advice-的类型",normalizedTitle:"advice 的类型",charIndex:2365},{level:3,title:"关于 AOP Proxy",slug:"关于-aop-proxy",normalizedTitle:"关于 aop proxy",charIndex:2811},{level:3,title:"彻底理解 aspect, join point, point cut, advice",slug:"彻底理解-aspect-join-point-point-cut-advice",normalizedTitle:"彻底理解 aspect, join point, point cut, advice",charIndex:3113},{level:2,title:"@AspectJ 支持",slug:"aspectj-支持",normalizedTitle:"@aspectj 支持",charIndex:4839},{level:3,title:"使能 @AspectJ 支持",slug:"使能-aspectj-支持",normalizedTitle:"使能 @aspectj 支持",charIndex:4980},{level:4,title:"使用 Java Configuration 方式使能@AspectJ",slug:"使用-java-configuration-方式使能-aspectj",normalizedTitle:"使用 java configuration 方式使能@aspectj",charIndex:5093},{level:4,title:"使用 XML 方式使能@AspectJ",slug:"使用-xml-方式使能-aspectj",normalizedTitle:"使用 xml 方式使能@aspectj",charIndex:5199},{level:3,title:"定义 aspect(切面)",slug:"定义-aspect-切面",normalizedTitle:"定义 aspect(切面)",charIndex:5250},{level:3,title:"声明 pointcut",slug:"声明-pointcut",normalizedTitle:"声明 pointcut",charIndex:5576},{level:4,title:"切点标志符(designator)",slug:"切点标志符-designator",normalizedTitle:"切点标志符(designator)",charIndex:6017},{level:5,title:"execution",slug:"execution",normalizedTitle:"execution",charIndex:870},{level:5,title:"within",slug:"within",normalizedTitle:"within",charIndex:6276},{level:5,title:"this 与 target",slug:"this-与-target",normalizedTitle:"this 与 target",charIndex:6446},{level:5,title:"bean",slug:"bean",normalizedTitle:"bean",charIndex:1793},{level:5,title:"args",slug:"args",normalizedTitle:"args",charIndex:6760},{level:5,title:"@annotation",slug:"annotation",normalizedTitle:"@annotation",charIndex:7769},{level:4,title:"常见的切点表达式",slug:"常见的切点表达式",normalizedTitle:"常见的切点表达式",charIndex:7913},{level:5,title:"匹配方法签名",slug:"匹配方法签名",normalizedTitle:"匹配方法签名",charIndex:7925},{level:5,title:"匹配类型签名",slug:"匹配类型签名",normalizedTitle:"匹配类型签名",charIndex:8305},{level:5,title:"匹配 Bean 名字",slug:"匹配-bean-名字",normalizedTitle:"匹配 bean 名字",charIndex:8498},{level:5,title:"切点表达式组合",slug:"切点表达式组合",normalizedTitle:"切点表达式组合",charIndex:8555},{level:3,title:"声明 advice",slug:"声明-advice",normalizedTitle:"声明 advice",charIndex:8733},{level:4,title:"Before advice",slug:"before-advice",normalizedTitle:"before advice",charIndex:8918},{level:4,title:"around advice",slug:"around-advice",normalizedTitle:"around advice",charIndex:2732},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:10705}],headersStr:"AOP 概念 什么是 AOP 术语 Aspect(切面) advice(增强) 连接点(join point) 切点(point cut) 关于 join point 和 point cut 的区别 introduction 目标对象(Target) AOP proxy 织入(Weaving) advice 的类型 关于 AOP Proxy 彻底理解 aspect, join point, point cut, advice @AspectJ 支持 使能 @AspectJ 支持 使用 Java Configuration 方式使能@AspectJ 使用 XML 方式使能@AspectJ 定义 aspect(切面) 声明 pointcut 切点标志符(designator) execution within this 与 target bean args @annotation 常见的切点表达式 匹配方法签名 匹配类型签名 匹配 Bean 名字 切点表达式组合 声明 advice Before advice around advice 参考资料",content:'# Spring AOP\n\n\n# AOP 概念\n\n\n# 什么是 AOP\n\nAOP(Aspect-Oriented Programming，即 面向切面编程)与 OOP( Object-Oriented Programming，面向对象编程) 相辅相成，提供了与 OOP 不同的抽象软件结构的视角。\n\n在 OOP 中，我们以类(class)作为我们的基本单元，而 AOP 中的基本单元是 Aspect(切面)\n\n\n# 术语\n\n# Aspect(切面)\n\naspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中. AOP 的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:\n\n 1. 如何通过 pointcut 和 advice 定位到特定的 joinpoint 上\n 2. 如何在 advice 中编写切面代码.\n\n可以简单地认为, 使用 @Aspect 注解的类就是切面.\n\n# advice(增强)\n\n由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码. 许多 AOP 框架, 包括 Spring AOP, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截. 例如 HTTP 鉴权的实现, 我们可以为每个使用 RequestMapping 标注的方法织入 advice, 当 HTTP 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 HTTP 请求是否有相应的权限, 如果有, 则执行 Controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了.\n\n# 连接点(join point)\n\n> a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.\n\n程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理. 在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.\n\n# 切点(point cut)\n\n匹配 join point 的谓词(a predicate that matches join points). Advice 是和特定的 point cut 关联的, 并且在 point cut 相匹配的 join point 中执行. 在 Spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 Advice, 而 pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice.\n\n# 关于 join point 和 point cut 的区别\n\n在 Spring AOP 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西. advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice\n\n# introduction\n\n为一个类型添加额外的方法或字段. Spring AOP 允许我们为 目标对象 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 IsModified 接口, 并以此来简化 caching 的实现.\n\n# 目标对象(Target)\n\n织入 advice 的目标对象. 目标对象也被称为 advised object. 因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object) 注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.\n\n# AOP proxy\n\n一个类被 AOP 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类. 在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象.\n\n# 织入(Weaving)\n\n将 aspect 和其他对象连接起来, 并创建 adviced object 的过程. 根据不同的实现技术, AOP 织入有三种方式:\n\n * 编译器织入, 这要求有特殊的 Java 编译器.\n * 类装载期织入, 这需要有特殊的类装载器.\n * 动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式. Spring 采用动态代理织入, 而 AspectJ 采用编译器织入和类装载期织入.\n\n\n# advice 的类型\n\n * before advice, 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)\n * after return advice, 在一个 join point 正常返回后执行的 advice\n * after throwing advice, 当一个 join point 抛出异常后执行的 advice\n * after(final) advice, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.\n * around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.\n\n\n# 关于 AOP Proxy\n\nSpring AOP 默认使用标准的 JDK 动态代理(dynamic proxy)技术来实现 AOP 代理, 通过它, 我们可以为任意的接口实现代理. 如果需要为一个类实现代理, 那么可以使用 CGLIB 代理. 当一个业务逻辑对象没有实现接口时, 那么 Spring AOP 就默认使用 CGLIB 来作为 AOP 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 Spring AOP 会使用 CGLIB 来实现动态代理. 鉴于此, Spring AOP 建议基于接口编程, 对接口进行 AOP 而不是类.\n\n\n# 彻底理解 aspect, join point, point cut, advice\n\n看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 AOP 的概念还是很模糊, 对 AOP 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 AOP 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的. 下面我以一个简单的例子来比喻一下 AOP 中 aspect, jointpoint, pointcut 与 advice 之间的关系.\n\n让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.\n\n来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系. 首先我们知道, 在 Spring AOP 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 爪哇的小县城里的百姓, point cut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问. 为什么可以这样类比呢?\n\n * join point --\x3e 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 Spring AOP 中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.\n * point cut --\x3e 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配 joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.\n * advice --\x3e 抓过来审问, advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.\n * aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: "根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问" 这一整个动作可以被认为是一个 aspect.\n\n或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 定语, 被动句 之类的概念, 那么可以做一个不严谨的类比, 即 joinpoint 可以认为是一个 宾语, 而 pointcut 则可以类比为修饰 joinpoint 的定语, 那么整个 aspect 就可以描述为: 满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.\n\n\n# @AspectJ 支持\n\n@AspectJ 是一种使用 Java 注解来实现 AOP 的编码风格。\n\n@AspectJ 风格的 AOP 是 AspectJ Project 在 AspectJ 5 中引入的, 并且 Spring 也支持 @AspectJ 的 AOP 风格.\n\n\n# 使能 @AspectJ 支持\n\n@AspectJ 可以以 XML 的方式或以注解的方式来使能, 并且不论以哪种方式使能@ASpectJ, 我们都必须保证 aspectjweaver.jar 在 classpath 中.\n\n# 使用 Java Configuration 方式使能@AspectJ\n\n@Configuration\n@EnableAspectJAutoProxy\npublic class AppConfig {\n}\n\n\n# 使用 XML 方式使能@AspectJ\n\n<aop:aspectj-autoproxy/>\n\n\n\n# 定义 aspect(切面)\n\n当使用注解 @Aspect 标注一个 Bean 后, 那么 Spring 框架会自动收集这些 Bean, 并添加到 Spring AOP 中, 例如:\n\n@Component\n@Aspect\npublic class MyTest {\n}\n\n\n注意, 仅仅使用@Aspect 注解, 并不能将一个 Java 对象转换为 Bean, 因此我们还需要使用类似 @Component 之类的注解. 注意, 如果一个 类被@Aspect 标注, 则这个类就不能是其他 aspect 的 **advised object** 了, 因为使用 @Aspect 后, 这个类就会被排除在 auto-proxying 机制之外.\n\n\n# 声明 pointcut\n\n一个 pointcut 的声明由两部分组成:\n\n * 一个方法签名, 包括方法名和相关参数\n * 一个 pointcut 表达式, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice).\n\n在@AspectJ 风格的 AOP 中, 我们使用一个方法来描述 pointcut, 即:\n\n@Pointcut("execution(* com.xys.service.UserService.*(..))") // 切点表达式\nprivate void dataAccessOperation() {} // 切点前面\n\n\n这个方法必须无返回值. 这个方法本身就是 pointcut signature, pointcut 表达式使用@Pointcut 注解指定. 上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 com.xys.service.UserService 下的所有方法的执行.\n\n# 切点标志符(designator)\n\nAspectJ5 的切点表达式由标志符(designator)和操作参数组成. 如 "execution(* greetTo(..))" 的切点表达式, **execution** 就是 标志符, 而圆括号里的 *****greetTo(..) 就是操作参数\n\n# execution\n\n匹配 join point 的执行, 例如 "execution(* hello(..))" 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符.\n\n# within\n\n匹配特定包下的所有 join point, 例如 within(com.xys.*) 表示 com.xys 包中的所有连接点, 即包中的所有类的所有方法. 而within(com.xys.service.*Service) 表示在 com.xys.service 包中所有以 Service 结尾的类的所有的连接点.\n\n# this 与 target\n\nthis 的作用是匹配一个 bean, 这个 bean(Spring AOP proxy) 是一个给定类型的实例(instance of). 而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of).\n\n# bean\n\n匹配 bean 名字为指定值的 bean 下的所有方法, 例如:\n\nbean(*Service) // 匹配名字后缀为 Service 的 bean 下的所有方法\nbean(myService) // 匹配名字为 myService 的 bean 下的所有方法\n\n\n# args\n\n匹配参数满足要求的的方法. 例如:\n\n@Pointcut("within(com.xys.demo2.*)")\npublic void pointcut2() {\n}\n\n@Before(value = "pointcut2()  &&  args(name)")\npublic void doSomething(String name) {\n    logger.info("---page: {}---", name);\n}\n\n\n@Service\npublic class NormalService {\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    public void someMethod() {\n        logger.info("---NormalService: someMethod invoked---");\n    }\n\n    public String test(String name) {\n        logger.info("---NormalService: test invoked---");\n        return "服务一切正常";\n    }\n}\n\n\n当 NormalService.test 执行时, 则 advice doSomething 就会执行, test 方法的参数 name 就会传递到 doSomething 中.\n\n常用例子:\n\n// 匹配只有一个参数 name 的方法\n@Before(value = "aspectMethod()  &&  args(name)")\npublic void doSomething(String name) {\n}\n\n// 匹配第一个参数为 name 的方法\n@Before(value = "aspectMethod()  &&  args(name, ..)")\npublic void doSomething(String name) {\n}\n\n// 匹配第二个参数为 name 的方法\nBefore(value = "aspectMethod()  &&  args(*, name, ..)")\npublic void doSomething(String name) {\n}\n\n\n# @annotation\n\n匹配由指定注解所标注的方法, 例如:\n\n@Pointcut("@annotation(com.xys.demo1.AuthChecker)")\npublic void pointcut() {\n}\n\n\n则匹配由注解 AuthChecker 所标注的方法.\n\n# 常见的切点表达式\n\n# 匹配方法签名\n\n// 匹配指定包中的所有的方法\nexecution(* com.xys.service.*(..))\n\n// 匹配当前包中的指定类的所有方法\nexecution(* UserService.*(..))\n\n// 匹配指定包中的所有 public 方法\nexecution(public * com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法\nexecution(public int com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且第一个参数是 String, 返回值是 int 类型的方法\nexecution(public int com.xys.service.*(String name, ..))\n\n\n# 匹配类型签名\n\n// 匹配指定包中的所有的方法, 但不包括子包\nwithin(com.xys.service.*)\n\n// 匹配指定包中的所有的方法, 包括子包\nwithin(com.xys.service..*)\n\n// 匹配当前包中的指定类中的方法\nwithin(UserService)\n\n\n// 匹配一个接口的所有实现类中的实现的方法\nwithin(UserDao+)\n\n\n# 匹配 Bean 名字\n\n// 匹配以指定名字结尾的 Bean 中的所有方法\nbean(*Service)\n\n\n# 切点表达式组合\n\n// 匹配以 Service 或 ServiceImpl 结尾的 bean\nbean(*Service || *ServiceImpl)\n\n// 匹配名字以 Service 结尾, 并且在包 com.xys.service 中的 bean\nbean(*Service) && within(com.xys.service.*)\n\n\n\n# 声明 advice\n\nadvice 是和一个 pointcut 表达式关联在一起的, 并且会在匹配的 join point 的方法执行的前/后/周围 运行. pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式. 下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的.\n\n# Before advice\n\n/**\n * @author xiongyongshun\n * @version 1.0\n * @created 16/9/9 13:13\n */\n@Component\n@Aspect\npublic class BeforeAspectTest {\n    // 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.\n    @Pointcut("execution(* com.xys.service.UserService.*(..))")\n    public void dataAccessOperation() {\n    }\n}\n\n\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 定义 advise\n    @Before("com.xys.aspect.PointcutDefine.dataAccessOperation()")\n    public void doBeforeAccessCheck(JoinPoint joinPoint) {\n        System.out.println("*****Before advise, method: " + joinPoint.getSignature().toShortString() + " *****");\n    }\n}\n\n\n这里, @Before 引用了一个 pointcut, 即 "com.xys.aspect.PointcutDefine.dataAccessOperation()" 是一个 pointcut 的名字. 如果我们在 advice 在内置 pointcut, 则可以:\n\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 将 pointcut 和 advice 同时定义\n    @Before("within(com.xys.service..*)")\n    public void doAccessCheck(JoinPoint joinPoint) {\n        System.out.println("*****doAccessCheck, Before advise, method: " + joinPoint.getSignature().toShortString() + " *****");\n    }\n}\n\n\n# around advice\n\naround advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, 并且甚至可以决定何时, 如何, 是否调用匹配到的方法.\n\n@Component\n@Aspect\npublic class AdviseDefine {\n    // 定义 advise\n    @Around("com.xys.aspect.PointcutDefine.dataAccessOperation()")\n    public Object doAroundAccessCheck(ProceedingJoinPoint pjp) throws Throwable {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        // 开始\n        Object retVal = pjp.proceed();\n        stopWatch.stop();\n        // 结束\n        System.out.println("invoke method: " + pjp.getSignature().getName() + ", elapsed time: " + stopWatch.getTotalTimeMillis());\n        return retVal;\n    }\n}\n\n\naround advice 和前面的 before advice 差不多, 只是我们把注解 @Before 改为了 @Around 了.\n\n\n# 参考资料\n\n * 《 Spring 实战（第 4 版）》',normalizedContent:'# spring aop\n\n\n# aop 概念\n\n\n# 什么是 aop\n\naop(aspect-oriented programming，即 面向切面编程)与 oop( object-oriented programming，面向对象编程) 相辅相成，提供了与 oop 不同的抽象软件结构的视角。\n\n在 oop 中，我们以类(class)作为我们的基本单元，而 aop 中的基本单元是 aspect(切面)\n\n\n# 术语\n\n# aspect(切面)\n\naspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. spring aop 就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中. aop 的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:\n\n 1. 如何通过 pointcut 和 advice 定位到特定的 joinpoint 上\n 2. 如何在 advice 中编写切面代码.\n\n可以简单地认为, 使用 @aspect 注解的类就是切面.\n\n# advice(增强)\n\n由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码. 许多 aop 框架, 包括 spring aop, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截. 例如 http 鉴权的实现, 我们可以为每个使用 requestmapping 标注的方法织入 advice, 当 http 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 http 请求是否有相应的权限, 如果有, 则执行 controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了.\n\n# 连接点(join point)\n\n> a point during the execution of a program, such as the execution of a method or the handling of an exception. in spring aop, a join point always represents a method execution.\n\n程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理. 在 spring aop 中, join point 总是方法的执行点, 即只有方法连接点.\n\n# 切点(point cut)\n\n匹配 join point 的谓词(a predicate that matches join points). advice 是和特定的 point cut 关联的, 并且在 point cut 相匹配的 join point 中执行. 在 spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 advice, 而 pointcut 的作用就是提供一组规则(使用 aspectj pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 advice.\n\n# 关于 join point 和 point cut 的区别\n\n在 spring aop 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西. advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice\n\n# introduction\n\n为一个类型添加额外的方法或字段. spring aop 允许我们为 目标对象 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 ismodified 接口, 并以此来简化 caching 的实现.\n\n# 目标对象(target)\n\n织入 advice 的目标对象. 目标对象也被称为 advised object. 因为 spring aop 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object) 注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.\n\n# aop proxy\n\n一个类被 aop 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类. 在 spring aop 中, 一个 aop 代理是一个 jdk 动态代理对象或 cglib 代理对象.\n\n# 织入(weaving)\n\n将 aspect 和其他对象连接起来, 并创建 adviced object 的过程. 根据不同的实现技术, aop 织入有三种方式:\n\n * 编译器织入, 这要求有特殊的 java 编译器.\n * 类装载期织入, 这需要有特殊的类装载器.\n * 动态代理织入, 在运行期为目标类添加增强(advice)生成子类的方式. spring 采用动态代理织入, 而 aspectj 采用编译器织入和类装载期织入.\n\n\n# advice 的类型\n\n * before advice, 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)\n * after return advice, 在一个 join point 正常返回后执行的 advice\n * after throwing advice, 当一个 join point 抛出异常后执行的 advice\n * after(final) advice, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.\n * around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.\n\n\n# 关于 aop proxy\n\nspring aop 默认使用标准的 jdk 动态代理(dynamic proxy)技术来实现 aop 代理, 通过它, 我们可以为任意的接口实现代理. 如果需要为一个类实现代理, 那么可以使用 cglib 代理. 当一个业务逻辑对象没有实现接口时, 那么 spring aop 就默认使用 cglib 来作为 aop 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 spring aop 会使用 cglib 来实现动态代理. 鉴于此, spring aop 建议基于接口编程, 对接口进行 aop 而不是类.\n\n\n# 彻底理解 aspect, join point, point cut, advice\n\n看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 aop 的概念还是很模糊, 对 aop 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 aop 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的. 下面我以一个简单的例子来比喻一下 aop 中 aspect, jointpoint, pointcut 与 advice 之间的关系.\n\n让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.\n\n来让我们看一下上面的一个小故事和 aop 到底有什么对应关系. 首先我们知道, 在 spring aop 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 爪哇的小县城里的百姓, point cut 就相当于 老王所做的指控, 即凶手是个男性, 身高约七尺五寸, 而 advice 则是施加在符合老王所描述的嫌疑人的动作: 抓过来审问. 为什么可以这样类比呢?\n\n * join point --\x3e 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 spring aop 中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.\n * point cut --\x3e 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配 joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据凶手是个男性, 身高约七尺五寸, 把符合条件的人抓起来. 在这里凶手是个男性, 身高约七尺五寸 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.\n * advice --\x3e 抓过来审问, advice 是一个动作, 即一段 java 代码, 这段 java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, 抓过来审问 这个动作就是对作用于那些满足 男性, 身高约七尺五寸 的爪哇的小县城里的百姓.\n * aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: "根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问" 这一整个动作可以被认为是一个 aspect.\n\n或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 定语, 被动句 之类的概念, 那么可以做一个不严谨的类比, 即 joinpoint 可以认为是一个 宾语, 而 pointcut 则可以类比为修饰 joinpoint 的定语, 那么整个 aspect 就可以描述为: 满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.\n\n\n# @aspectj 支持\n\n@aspectj 是一种使用 java 注解来实现 aop 的编码风格。\n\n@aspectj 风格的 aop 是 aspectj project 在 aspectj 5 中引入的, 并且 spring 也支持 @aspectj 的 aop 风格.\n\n\n# 使能 @aspectj 支持\n\n@aspectj 可以以 xml 的方式或以注解的方式来使能, 并且不论以哪种方式使能@aspectj, 我们都必须保证 aspectjweaver.jar 在 classpath 中.\n\n# 使用 java configuration 方式使能@aspectj\n\n@configuration\n@enableaspectjautoproxy\npublic class appconfig {\n}\n\n\n# 使用 xml 方式使能@aspectj\n\n<aop:aspectj-autoproxy/>\n\n\n\n# 定义 aspect(切面)\n\n当使用注解 @aspect 标注一个 bean 后, 那么 spring 框架会自动收集这些 bean, 并添加到 spring aop 中, 例如:\n\n@component\n@aspect\npublic class mytest {\n}\n\n\n注意, 仅仅使用@aspect 注解, 并不能将一个 java 对象转换为 bean, 因此我们还需要使用类似 @component 之类的注解. 注意, 如果一个 类被@aspect 标注, 则这个类就不能是其他 aspect 的 **advised object** 了, 因为使用 @aspect 后, 这个类就会被排除在 auto-proxying 机制之外.\n\n\n# 声明 pointcut\n\n一个 pointcut 的声明由两部分组成:\n\n * 一个方法签名, 包括方法名和相关参数\n * 一个 pointcut 表达式, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice).\n\n在@aspectj 风格的 aop 中, 我们使用一个方法来描述 pointcut, 即:\n\n@pointcut("execution(* com.xys.service.userservice.*(..))") // 切点表达式\nprivate void dataaccessoperation() {} // 切点前面\n\n\n这个方法必须无返回值. 这个方法本身就是 pointcut signature, pointcut 表达式使用@pointcut 注解指定. 上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 com.xys.service.userservice 下的所有方法的执行.\n\n# 切点标志符(designator)\n\naspectj5 的切点表达式由标志符(designator)和操作参数组成. 如 "execution(* greetto(..))" 的切点表达式, **execution** 就是 标志符, 而圆括号里的 *****greetto(..) 就是操作参数\n\n# execution\n\n匹配 join point 的执行, 例如 "execution(* hello(..))" 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符.\n\n# within\n\n匹配特定包下的所有 join point, 例如 within(com.xys.*) 表示 com.xys 包中的所有连接点, 即包中的所有类的所有方法. 而within(com.xys.service.*service) 表示在 com.xys.service 包中所有以 service 结尾的类的所有的连接点.\n\n# this 与 target\n\nthis 的作用是匹配一个 bean, 这个 bean(spring aop proxy) 是一个给定类型的实例(instance of). 而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of).\n\n# bean\n\n匹配 bean 名字为指定值的 bean 下的所有方法, 例如:\n\nbean(*service) // 匹配名字后缀为 service 的 bean 下的所有方法\nbean(myservice) // 匹配名字为 myservice 的 bean 下的所有方法\n\n\n# args\n\n匹配参数满足要求的的方法. 例如:\n\n@pointcut("within(com.xys.demo2.*)")\npublic void pointcut2() {\n}\n\n@before(value = "pointcut2()  &&  args(name)")\npublic void dosomething(string name) {\n    logger.info("---page: {}---", name);\n}\n\n\n@service\npublic class normalservice {\n    private logger logger = loggerfactory.getlogger(getclass());\n\n    public void somemethod() {\n        logger.info("---normalservice: somemethod invoked---");\n    }\n\n    public string test(string name) {\n        logger.info("---normalservice: test invoked---");\n        return "服务一切正常";\n    }\n}\n\n\n当 normalservice.test 执行时, 则 advice dosomething 就会执行, test 方法的参数 name 就会传递到 dosomething 中.\n\n常用例子:\n\n// 匹配只有一个参数 name 的方法\n@before(value = "aspectmethod()  &&  args(name)")\npublic void dosomething(string name) {\n}\n\n// 匹配第一个参数为 name 的方法\n@before(value = "aspectmethod()  &&  args(name, ..)")\npublic void dosomething(string name) {\n}\n\n// 匹配第二个参数为 name 的方法\nbefore(value = "aspectmethod()  &&  args(*, name, ..)")\npublic void dosomething(string name) {\n}\n\n\n# @annotation\n\n匹配由指定注解所标注的方法, 例如:\n\n@pointcut("@annotation(com.xys.demo1.authchecker)")\npublic void pointcut() {\n}\n\n\n则匹配由注解 authchecker 所标注的方法.\n\n# 常见的切点表达式\n\n# 匹配方法签名\n\n// 匹配指定包中的所有的方法\nexecution(* com.xys.service.*(..))\n\n// 匹配当前包中的指定类的所有方法\nexecution(* userservice.*(..))\n\n// 匹配指定包中的所有 public 方法\nexecution(public * com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法\nexecution(public int com.xys.service.*(..))\n\n// 匹配指定包中的所有 public 方法, 并且第一个参数是 string, 返回值是 int 类型的方法\nexecution(public int com.xys.service.*(string name, ..))\n\n\n# 匹配类型签名\n\n// 匹配指定包中的所有的方法, 但不包括子包\nwithin(com.xys.service.*)\n\n// 匹配指定包中的所有的方法, 包括子包\nwithin(com.xys.service..*)\n\n// 匹配当前包中的指定类中的方法\nwithin(userservice)\n\n\n// 匹配一个接口的所有实现类中的实现的方法\nwithin(userdao+)\n\n\n# 匹配 bean 名字\n\n// 匹配以指定名字结尾的 bean 中的所有方法\nbean(*service)\n\n\n# 切点表达式组合\n\n// 匹配以 service 或 serviceimpl 结尾的 bean\nbean(*service || *serviceimpl)\n\n// 匹配名字以 service 结尾, 并且在包 com.xys.service 中的 bean\nbean(*service) && within(com.xys.service.*)\n\n\n\n# 声明 advice\n\nadvice 是和一个 pointcut 表达式关联在一起的, 并且会在匹配的 join point 的方法执行的前/后/周围 运行. pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式. 下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的.\n\n# before advice\n\n/**\n * @author xiongyongshun\n * @version 1.0\n * @created 16/9/9 13:13\n */\n@component\n@aspect\npublic class beforeaspecttest {\n    // 定义一个 pointcut, 使用 切点表达式函数 来描述对哪些 join point 使用 advise.\n    @pointcut("execution(* com.xys.service.userservice.*(..))")\n    public void dataaccessoperation() {\n    }\n}\n\n\n@component\n@aspect\npublic class advisedefine {\n    // 定义 advise\n    @before("com.xys.aspect.pointcutdefine.dataaccessoperation()")\n    public void dobeforeaccesscheck(joinpoint joinpoint) {\n        system.out.println("*****before advise, method: " + joinpoint.getsignature().toshortstring() + " *****");\n    }\n}\n\n\n这里, @before 引用了一个 pointcut, 即 "com.xys.aspect.pointcutdefine.dataaccessoperation()" 是一个 pointcut 的名字. 如果我们在 advice 在内置 pointcut, 则可以:\n\n@component\n@aspect\npublic class advisedefine {\n    // 将 pointcut 和 advice 同时定义\n    @before("within(com.xys.service..*)")\n    public void doaccesscheck(joinpoint joinpoint) {\n        system.out.println("*****doaccesscheck, before advise, method: " + joinpoint.getsignature().toshortstring() + " *****");\n    }\n}\n\n\n# around advice\n\naround advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, 并且甚至可以决定何时, 如何, 是否调用匹配到的方法.\n\n@component\n@aspect\npublic class advisedefine {\n    // 定义 advise\n    @around("com.xys.aspect.pointcutdefine.dataaccessoperation()")\n    public object doaroundaccesscheck(proceedingjoinpoint pjp) throws throwable {\n        stopwatch stopwatch = new stopwatch();\n        stopwatch.start();\n        // 开始\n        object retval = pjp.proceed();\n        stopwatch.stop();\n        // 结束\n        system.out.println("invoke method: " + pjp.getsignature().getname() + ", elapsed time: " + stopwatch.gettotaltimemillis());\n        return retval;\n    }\n}\n\n\naround advice 和前面的 before advice 差不多, 只是我们把注解 @before 改为了 @around 了.\n\n\n# 参考资料\n\n * 《 spring 实战（第 4 版）》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 应用上下文生命周期",frontmatter:{title:"Spring 应用上下文生命周期",date:"2022-12-23T09:58:09.000Z",order:"09",categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/ad472e/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/09.Spring%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/09.Spring应用上下文生命周期.md",key:"v-6447466a",path:"/pages/ad472e/",headers:[{level:2,title:"Spring 应用上下文启动准备阶段",slug:"spring-应用上下文启动准备阶段",normalizedTitle:"spring 应用上下文启动准备阶段",charIndex:23},{level:2,title:"BeanFactory 创建阶段",slug:"beanfactory-创建阶段",normalizedTitle:"beanfactory 创建阶段",charIndex:260},{level:2,title:"BeanFactory 准备阶段",slug:"beanfactory-准备阶段",normalizedTitle:"beanfactory 准备阶段",charIndex:813},{level:2,title:"BeanFactory 后置处理阶段",slug:"beanfactory-后置处理阶段",normalizedTitle:"beanfactory 后置处理阶段",charIndex:1351},{level:2,title:"BeanFactory 注册 BeanPostProcessor 阶段",slug:"beanfactory-注册-beanpostprocessor-阶段",normalizedTitle:"beanfactory 注册 beanpostprocessor 阶段",charIndex:1680},{level:2,title:"初始化內建 Bean：MessageSource",slug:"初始化內建-bean-messagesource",normalizedTitle:"初始化內建 bean：messagesource",charIndex:2019},{level:2,title:"初始化內建 Bean：Spring 事件广播器",slug:"初始化內建-bean-spring-事件广播器",normalizedTitle:"初始化內建 bean：spring 事件广播器",charIndex:2099},{level:2,title:"Spring 应用上下文刷新阶段",slug:"spring-应用上下文刷新阶段",normalizedTitle:"spring 应用上下文刷新阶段",charIndex:2192},{level:2,title:"Spring 事件监听器注册阶段",slug:"spring-事件监听器注册阶段",normalizedTitle:"spring 事件监听器注册阶段",charIndex:2721},{level:2,title:"BeanFactory 初始化完成阶段",slug:"beanfactory-初始化完成阶段",normalizedTitle:"beanfactory 初始化完成阶段",charIndex:2904},{level:2,title:"Spring 应用上下刷新完成阶段",slug:"spring-应用上下刷新完成阶段",normalizedTitle:"spring 应用上下刷新完成阶段",charIndex:3221},{level:2,title:"Spring 应用上下文启动阶段",slug:"spring-应用上下文启动阶段",normalizedTitle:"spring 应用上下文启动阶段",charIndex:3525},{level:2,title:"Spring 应用上下文停止阶段",slug:"spring-应用上下文停止阶段",normalizedTitle:"spring 应用上下文停止阶段",charIndex:3707},{level:2,title:"Spring 应用上下文关闭阶段",slug:"spring-应用上下文关闭阶段",normalizedTitle:"spring 应用上下文关闭阶段",charIndex:3888},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:4290},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4519}],headersStr:"Spring 应用上下文启动准备阶段 BeanFactory 创建阶段 BeanFactory 准备阶段 BeanFactory 后置处理阶段 BeanFactory 注册 BeanPostProcessor 阶段 初始化內建 Bean：MessageSource 初始化內建 Bean：Spring 事件广播器 Spring 应用上下文刷新阶段 Spring 事件监听器注册阶段 BeanFactory 初始化完成阶段 Spring 应用上下刷新完成阶段 Spring 应用上下文启动阶段 Spring 应用上下文停止阶段 Spring 应用上下文关闭阶段 问题 参考资料",content:"# Spring 应用上下文生命周期\n\n\n# Spring 应用上下文启动准备阶段\n\nAbstractApplicationContext#prepareRefresh() 方法\n\n * 启动时间 - startupDate\n * 状态标识 - closed(false)、active(true)\n * 初始化 PropertySources - initPropertySources()\n * 检验 Environment 中必须属性\n * 初始化事件监听器集合\n * 初始化早期 Spring 事件集合\n\n\n# BeanFactory 创建阶段\n\nAbstractApplicationContext#obtainFreshBeanFactory() 方法\n\n * 刷新 Spring 应用上下文底层 BeanFactory - refreshBeanFactory()\n   * 销毁或关闭 BeanFactory，如果已存在的话\n   * 创建 BeanFactory - createBeanFactory()\n   * 设置 BeanFactory Id\n   * 设置“是否允许 BeanDefinition 重复定义” - customizeBeanFactory(DefaultListableBeanFactory)\n   * 设置“是否允许循环引用（依赖）” - customizeBeanFactory(DefaultListableBeanFactory)\n   * 加载 BeanDefinition - loadBeanDefinitions(DefaultListableBeanFactory) 方法\n   * 关联新建 BeanFactory 到 Spring 应用上下文\n * 返回 Spring 应用上下文底层 BeanFactory - getBeanFactory()\n\n\n# BeanFactory 准备阶段\n\nAbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory) 方法\n\n * 关联 ClassLoader\n * 设置 Bean 表达式处理器\n * 添加 PropertyEditorRegistrar 实现 - ResourceEditorRegistrar\n * 添加 Aware 回调接口 BeanPostProcessor 实现 - ApplicationContextAwareProcessor\n * 忽略 Aware 回调接口作为依赖注入接口\n * 注册 ResolvableDependency 对象 - BeanFactory、ResourceLoader、ApplicationEventPublisher 以及 ApplicationContext\n * 注册 ApplicationListenerDetector 对象\n * 注册 LoadTimeWeaverAwareProcessor 对象\n * 注册单例对象 - Environment、Java System Properties 以及 OS 环境变量\n\n\n# BeanFactory 后置处理阶段\n\n * AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory) 方法\n   * 由子类覆盖该方法\n * AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory 方法\n   * 调用 BeanFactoryPostProcessor 或 BeanDefinitionRegistry 后置处理方法\n   * 注册 LoadTimeWeaverAwareProcessor 对象\n\n\n# BeanFactory 注册 BeanPostProcessor 阶段\n\nAbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory) 方法\n\n * 注册 PriorityOrdered 类型的 BeanPostProcessor Beans\n * 注册 Ordered 类型的 BeanPostProcessor Beans\n * 注册普通 BeanPostProcessor Beans\n * 注册 MergedBeanDefinitionPostProcessor Beans\n * 注册 ApplicationListenerDetector 对象\n\n\n# 初始化內建 Bean：MessageSource\n\nAbstractApplicationContext#initMessageSource() 方法\n\n\n# 初始化內建 Bean：Spring 事件广播器\n\nAbstractApplicationContext#initApplicationEventMulticaster() 方法\n\n\n# Spring 应用上下文刷新阶段\n\nAbstractApplicationContext#onRefresh() 方法\n\n子类覆盖该方法\n\n * org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh()\n * org.springframework.web.context.support.GenericWebApplicationContext#onRefresh()\n * org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh()\n * org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh()\n * org.springframework.web.context.support.StaticWebApplicationContext#onRefresh()\n\n\n# Spring 事件监听器注册阶段\n\nAbstractApplicationContext#registerListeners() 方法\n\n * 添加当前应用上下文所关联的 ApplicationListener 对象（集合）\n * 添加 BeanFactory 所注册 ApplicationListener Beans\n * 广播早期 Spring 事件\n\n\n# BeanFactory 初始化完成阶段\n\nAbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory) 方法\n\n * BeanFactory 关联 ConversionService Bean，如果存在\n * 添加 StringValueResolver 对象\n * 依赖查找 LoadTimeWeaverAware Bean\n * BeanFactory 临时 ClassLoader 置为 null\n * BeanFactory 冻结配置\n * BeanFactory 初始化非延迟单例 Beans\n\n\n# Spring 应用上下刷新完成阶段\n\nAbstractApplicationContext#finishRefresh() 方法\n\n * 清除 ResourceLoader 缓存 - clearResourceCaches() @since 5.0\n * 初始化 LifecycleProcessor 对象 - initLifecycleProcessor()\n * 调用 LifecycleProcessor#onRefresh() 方法\n * 发布 Spring 应用上下文已刷新事件 - ContextRefreshedEvent\n * 向 MBeanServer 托管 Live Beans\n\n\n# Spring 应用上下文启动阶段\n\nAbstractApplicationContext#start() 方法\n\n * 启动 LifecycleProcessor\n   * 依赖查找 Lifecycle Beans\n   * 启动 Lifecycle Beans\n * 发布 Spring 应用上下文已启动事件 - ContextStartedEvent\n\n\n# Spring 应用上下文停止阶段\n\nAbstractApplicationContext#stop() 方法\n\n * 停止 LifecycleProcessor\n   * 依赖查找 Lifecycle Beans\n   * 停止 Lifecycle Beans\n * 发布 Spring 应用上下文已停止事件 - ContextStoppedEvent\n\n\n# Spring 应用上下文关闭阶段\n\nAbstractApplicationContext#close() 方法\n\n * 状态标识：active(false)、closed(true)\n * Live Beans JMX 撤销托管\n   * LiveBeansView.unregisterApplicationContext(ConfigurableApplicationContext)\n * 发布 Spring 应用上下文已关闭事件 - ContextClosedEvent\n * 关闭 LifecycleProcessor\n   * 依赖查找 Lifecycle Beans\n   * 停止 Lifecycle Beans\n * 销毁 Spring Beans\n * 关闭 BeanFactory\n * 回调 onClose()\n * 注册 Shutdown Hook 线程（如果曾注册）\n\n\n# 问题\n\nSpring 应用上下文生命周期有哪些阶段？\n\n * 刷新阶段 - ConfigurableApplicationContext#refresh()\n * 启动阶段 - ConfigurableApplicationContext#start()\n * 停止阶段 - ConfigurableApplicationContext#stop()\n * 关闭阶段 - ConfigurableApplicationContext#close()\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 应用上下文生命周期\n\n\n# spring 应用上下文启动准备阶段\n\nabstractapplicationcontext#preparerefresh() 方法\n\n * 启动时间 - startupdate\n * 状态标识 - closed(false)、active(true)\n * 初始化 propertysources - initpropertysources()\n * 检验 environment 中必须属性\n * 初始化事件监听器集合\n * 初始化早期 spring 事件集合\n\n\n# beanfactory 创建阶段\n\nabstractapplicationcontext#obtainfreshbeanfactory() 方法\n\n * 刷新 spring 应用上下文底层 beanfactory - refreshbeanfactory()\n   * 销毁或关闭 beanfactory，如果已存在的话\n   * 创建 beanfactory - createbeanfactory()\n   * 设置 beanfactory id\n   * 设置“是否允许 beandefinition 重复定义” - customizebeanfactory(defaultlistablebeanfactory)\n   * 设置“是否允许循环引用（依赖）” - customizebeanfactory(defaultlistablebeanfactory)\n   * 加载 beandefinition - loadbeandefinitions(defaultlistablebeanfactory) 方法\n   * 关联新建 beanfactory 到 spring 应用上下文\n * 返回 spring 应用上下文底层 beanfactory - getbeanfactory()\n\n\n# beanfactory 准备阶段\n\nabstractapplicationcontext#preparebeanfactory(configurablelistablebeanfactory) 方法\n\n * 关联 classloader\n * 设置 bean 表达式处理器\n * 添加 propertyeditorregistrar 实现 - resourceeditorregistrar\n * 添加 aware 回调接口 beanpostprocessor 实现 - applicationcontextawareprocessor\n * 忽略 aware 回调接口作为依赖注入接口\n * 注册 resolvabledependency 对象 - beanfactory、resourceloader、applicationeventpublisher 以及 applicationcontext\n * 注册 applicationlistenerdetector 对象\n * 注册 loadtimeweaverawareprocessor 对象\n * 注册单例对象 - environment、java system properties 以及 os 环境变量\n\n\n# beanfactory 后置处理阶段\n\n * abstractapplicationcontext#postprocessbeanfactory(configurablelistablebeanfactory) 方法\n   * 由子类覆盖该方法\n * abstractapplicationcontext#invokebeanfactorypostprocessors(configurablelistablebeanfactory 方法\n   * 调用 beanfactorypostprocessor 或 beandefinitionregistry 后置处理方法\n   * 注册 loadtimeweaverawareprocessor 对象\n\n\n# beanfactory 注册 beanpostprocessor 阶段\n\nabstractapplicationcontext#registerbeanpostprocessors(configurablelistablebeanfactory) 方法\n\n * 注册 priorityordered 类型的 beanpostprocessor beans\n * 注册 ordered 类型的 beanpostprocessor beans\n * 注册普通 beanpostprocessor beans\n * 注册 mergedbeandefinitionpostprocessor beans\n * 注册 applicationlistenerdetector 对象\n\n\n# 初始化內建 bean：messagesource\n\nabstractapplicationcontext#initmessagesource() 方法\n\n\n# 初始化內建 bean：spring 事件广播器\n\nabstractapplicationcontext#initapplicationeventmulticaster() 方法\n\n\n# spring 应用上下文刷新阶段\n\nabstractapplicationcontext#onrefresh() 方法\n\n子类覆盖该方法\n\n * org.springframework.web.context.support.abstractrefreshablewebapplicationcontext#onrefresh()\n * org.springframework.web.context.support.genericwebapplicationcontext#onrefresh()\n * org.springframework.boot.web.reactive.context.reactivewebserverapplicationcontext#onrefresh()\n * org.springframework.boot.web.servlet.context.servletwebserverapplicationcontext#onrefresh()\n * org.springframework.web.context.support.staticwebapplicationcontext#onrefresh()\n\n\n# spring 事件监听器注册阶段\n\nabstractapplicationcontext#registerlisteners() 方法\n\n * 添加当前应用上下文所关联的 applicationlistener 对象（集合）\n * 添加 beanfactory 所注册 applicationlistener beans\n * 广播早期 spring 事件\n\n\n# beanfactory 初始化完成阶段\n\nabstractapplicationcontext#finishbeanfactoryinitialization(configurablelistablebeanfactory) 方法\n\n * beanfactory 关联 conversionservice bean，如果存在\n * 添加 stringvalueresolver 对象\n * 依赖查找 loadtimeweaveraware bean\n * beanfactory 临时 classloader 置为 null\n * beanfactory 冻结配置\n * beanfactory 初始化非延迟单例 beans\n\n\n# spring 应用上下刷新完成阶段\n\nabstractapplicationcontext#finishrefresh() 方法\n\n * 清除 resourceloader 缓存 - clearresourcecaches() @since 5.0\n * 初始化 lifecycleprocessor 对象 - initlifecycleprocessor()\n * 调用 lifecycleprocessor#onrefresh() 方法\n * 发布 spring 应用上下文已刷新事件 - contextrefreshedevent\n * 向 mbeanserver 托管 live beans\n\n\n# spring 应用上下文启动阶段\n\nabstractapplicationcontext#start() 方法\n\n * 启动 lifecycleprocessor\n   * 依赖查找 lifecycle beans\n   * 启动 lifecycle beans\n * 发布 spring 应用上下文已启动事件 - contextstartedevent\n\n\n# spring 应用上下文停止阶段\n\nabstractapplicationcontext#stop() 方法\n\n * 停止 lifecycleprocessor\n   * 依赖查找 lifecycle beans\n   * 停止 lifecycle beans\n * 发布 spring 应用上下文已停止事件 - contextstoppedevent\n\n\n# spring 应用上下文关闭阶段\n\nabstractapplicationcontext#close() 方法\n\n * 状态标识：active(false)、closed(true)\n * live beans jmx 撤销托管\n   * livebeansview.unregisterapplicationcontext(configurableapplicationcontext)\n * 发布 spring 应用上下文已关闭事件 - contextclosedevent\n * 关闭 lifecycleprocessor\n   * 依赖查找 lifecycle beans\n   * 停止 lifecycle beans\n * 销毁 spring beans\n * 关闭 beanfactory\n * 回调 onclose()\n * 注册 shutdown hook 线程（如果曾注册）\n\n\n# 问题\n\nspring 应用上下文生命周期有哪些阶段？\n\n * 刷新阶段 - configurableapplicationcontext#refresh()\n * 启动阶段 - configurableapplicationcontext#start()\n * 停止阶段 - configurableapplicationcontext#stop()\n * 关闭阶段 - configurableapplicationcontext#close()\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 资源管理",frontmatter:{title:"Spring 资源管理",date:"2019-09-04T19:46:41.000Z",order:20,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","Resource"],permalink:"/pages/a1549f/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/20.Spring%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/20.Spring资源管理.md",key:"v-bc19b5fc",path:"/pages/a1549f/",headers:[{level:2,title:"Resource 接口",slug:"resource-接口",normalizedTitle:"resource 接口",charIndex:35},{level:2,title:"内置的 Resource 实现",slug:"内置的-resource-实现",normalizedTitle:"内置的 resource 实现",charIndex:1403},{level:2,title:"ResourceLoader 接口",slug:"resourceloader-接口",normalizedTitle:"resourceloader 接口",charIndex:2964},{level:2,title:"ResourcePatternResolver 接口",slug:"resourcepatternresolver-接口",normalizedTitle:"resourcepatternresolver 接口",charIndex:4099},{level:2,title:"ResourceLoaderAware 接口",slug:"resourceloaderaware-接口",normalizedTitle:"resourceloaderaware 接口",charIndex:4743},{level:2,title:"资源依赖",slug:"资源依赖",normalizedTitle:"资源依赖",charIndex:5654},{level:2,title:"应用上下文和资源路径",slug:"应用上下文和资源路径",normalizedTitle:"应用上下文和资源路径",charIndex:7137},{level:3,title:"构造应用上下文",slug:"构造应用上下文",normalizedTitle:"构造应用上下文",charIndex:7152},{level:3,title:"使用通配符构造应用上下文",slug:"使用通配符构造应用上下文",normalizedTitle:"使用通配符构造应用上下文",charIndex:7646},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:8078},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8146}],headersStr:"Resource 接口 内置的 Resource 实现 ResourceLoader 接口 ResourcePatternResolver 接口 ResourceLoaderAware 接口 资源依赖 应用上下文和资源路径 构造应用上下文 使用通配符构造应用上下文 问题 参考资料",content:'# Spring 资源管理\n\n> Version 6.0.3\n\n\n# Resource 接口\n\n相对标准 URL 访问机制，Spring 的 org.springframework.core.io.Resource 接口抽象了对底层资源的访问接口，提供了一套更好的访问方式。\n\npublic interface Resource extends InputStreamSource {\n\n    boolean exists();\n\n    boolean isReadable();\n\n    boolean isOpen();\n\n    boolean isFile();\n\n    URL getURL() throws IOException;\n\n    URI getURI() throws IOException;\n\n    File getFile() throws IOException;\n\n    ReadableByteChannel readableChannel() throws IOException;\n\n    long contentLength() throws IOException;\n\n    long lastModified() throws IOException;\n\n    Resource createRelative(String relativePath) throws IOException;\n\n    String getFilename();\n\n    String getDescription();\n}\n\n\n正如 Resource 接口的定义所示，它扩展了 InputStreamSource 接口。Resource 最核心的方法如下：\n\n * getInputStream() - 定位并且打开当前资源，返回当前资源的 InputStream。每次调用都会返回一个新的 InputStream。调用者需要负责关闭流。\n * exists() - 判断当前资源是否真的存在。\n * isOpen() - 判断当前资源是否是一个已打开的 InputStream。如果为 true，则 InputStream 不能被多次读取，必须只读取一次然后关闭以避免资源泄漏。对所有常用资源实现返回 false，InputStreamResource 除外。\n * getDescription() - 返回当前资源的描述，当处理资源出错时，资源的描述会用于错误信息的输出。一般来说，资源的描述是一个完全限定的文件名称，或者是当前资源的真实 URL。\n\n常见 Spring 资源接口：\n\n类型      接口\n输入流     org.springframework.core.io.InputStreamSource\n只读资源    org.springframework.core.io.Resource\n可写资源    org.springframework.core.io.WritableResource\n编码资源    org.springframework.core.io.support.EncodedResource\n上下文资源   org.springframework.core.io.ContextResource\n\n\n\n\n# 内置的 Resource 实现\n\nSpring 包括几个内置的 Resource 实现：\n\n资源来源                     前缀                    说明\nUrlResource              file:、https:、ftp: 等   UrlResource 封装了一个 java.net.URL 对象，用于访问可通过 URL\n                                               访问的任何对象，例如文件、HTTPS 目标、FTP 目标等。所有 URL\n                                               都可以通过标准化的字符串形式表示，因此可以使用适当的标准化前缀来指示一种 URL 类型与另一种 URL 类型的区别。\n                                               这包括：file：用于访问文件系统路径；https：用于通过 HTTPS 协议访问资源；ftp：用于通过 FTP\n                                               访问资源等等。\nClassPathResource        classpath:            ClassPathResource 从类路径上加载资源。它使用线程上下文加载器、给定的类加载器或指定的 class\n                                               类型中的任意一个来加载资源。\nFileSystemResource       file:                 FileSystemResource 是 java.io.File 的资源实现。它还支持\n                                               java.nio.file.Path ，应用 Spring\n                                               的标准对字符串路径进行转换。FileSystemResource 支持解析为文件和 URL。\nPathResource             无                     PathResource 是 java.nio.file.Path 的资源实现。\nServletContextResource   无                     ServletContextResource 是 ServletContext 的资源实现。它表示相应 Web\n                                               应用程序根目录中的相对路径。\nInputStreamResource      无                     InputStreamResource 是指定 InputStream 的资源实现。注意：如果该 InputStream\n                                               已被打开，则不可以多次读取该流。\nByteArrayResource        无                     ByteArrayResource 是指定的二进制数组的资源实现。它会为给定的字节数组创建一个\n                                               ByteArrayInputStream。\n\n\n# ResourceLoader 接口\n\nResourceLoader 接口用于加载 Resource 对象。其定义如下：\n\npublic interface ResourceLoader {\n\n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}\n\n\nSpring 中主要的 ResourceLoader 实现：\n\n\n\nSpring 中，所有的 ApplicationContext 都实现了 ResourceLoader 接口。因此，所有 ApplicationContext 都可以通过 getResource() 方法获取 Resource 实例。\n\n【示例】\n\n// 如果没有指定资源前缀，Spring 会尝试返回合适的资源\nResource template = ctx.getResource("some/resource/path/myTemplate.txt");\n// 如果指定 classpath: 前缀，Spring 会强制使用 ClassPathResource\nResource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");\n// 如果指定 file:、http 等 URL 前缀，Spring 会强制使用 UrlResource\nResource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");\nResource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt");\n\n\n下表列举了 Spring 根据各种位置路径加载资源的策略：\n\n前缀           样例                               说明\nclasspath:   classpath:com/myapp/config.xml   从类路径加载\nfile:        file:///data/config.xml          以 URL 形式从文件系统加载\nhttp:        http://myserver/logo.png         以 URL 形式加载\n无            /data/config.xml                 由底层的 ApplicationContext 实现决定\n\n\n# ResourcePatternResolver 接口\n\nResourcePatternResolver 接口是 ResourceLoader 接口的扩展，它的作用是定义策略，根据位置模式解析 Resource 对象。\n\npublic interface ResourcePatternResolver extends ResourceLoader {\n\n    String CLASSPATH_ALL_URL_PREFIX = "classpath*:";\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}\n\n\nPathMatchingResourcePatternResolver 是一个独立的实现，可以在 ApplicationContext 之外使用，也可以被 ResourceArrayPropertyEditor 用于填充 Resource[] bean 属性。PathMatchingResourcePatternResolver 能够将指定的资源位置路径解析为一个或多个匹配的 Resource 对象。\n\n> 注意：任何标准 ApplicationContext 中的默认 ResourceLoader 实际上是 PathMatchingResourcePatternResolver 的一个实例，它实现了 ResourcePatternResolver 接口。\n\n\n# ResourceLoaderAware 接口\n\nResourceLoaderAware 接口是一个特殊的回调接口，用来标记提供 ResourceLoader 引用的对象。ResourceLoaderAware 接口定义如下：\n\npublic interface ResourceLoaderAware {\n    void setResourceLoader(ResourceLoader resourceLoader);\n}\n\n\n当一个类实现 ResourceLoaderAware 并部署到应用程序上下文中（作为 Spring 管理的 bean）时，它会被应用程序上下文识别为 ResourceLoaderAware，然后，应用程序上下文会调用 setResourceLoader(ResourceLoader)，将自身作为参数提供（请记住，Spring 中的所有应用程序上下文都实现 ResourceLoader 接口）。\n\n由于 ApplicationContext 是一个 ResourceLoader，该 bean 还可以实现 ApplicationContextAware 接口并直接使用提供的应用程序上下文来加载资源。 但是，一般来说，如果您只需要这些，最好使用专门的 ResourceLoader 接口。 该代码将仅耦合到资源加载接口（可以被视为实用程序接口），而不耦合到整个 Spring ApplicationContext 接口。\n\n在应用程序中，还可以使用 ResourceLoader 的自动装配作为实现 ResourceLoaderAware 接口的替代方法。传统的构造函数和 byType 自动装配模式能够分别为构造函数参数或 setter 方法参数提供 ResourceLoader。 为了获得更大的灵活性（包括自动装配字段和多参数方法的能力），请考虑使用基于注解的自动装配功能。 在这种情况下，ResourceLoader 会自动连接到需要 ResourceLoader 类型的字段、构造函数参数或方法参数中，只要相关字段、构造函数或方法带有 @Autowired 注解即可。\n\n\n# 资源依赖\n\n如果 bean 本身要通过某种动态过程来确定和提供资源路径，那么 bean 可以使用 ResourceLoader 或 ResourcePatternResolver 接口来加载资源。 例如，考虑加载某种模板，其中所需的特定资源取决于用户的角色。 如果资源是静态的，完全消除 ResourceLoader 接口（或 ResourcePatternResolver 接口）的使用，让 bean 公开它需要的 Resource 属性，并期望将它们注入其中是有意义的。\n\n使注入这些属性变得简单的原因是所有应用程序上下文都注册并使用一个特殊的 JavaBeans PropertyEditor，它可以将 String 路径转换为 Resource 对象。 例如，下面的 MyBean 类有一个 Resource 类型的模板属性。\n\n【示例】\n\n<bean id="myBean" class="example.MyBean">\n    <property name="template" value="some/resource/path/myTemplate.txt"/>\n</bean>\n\n\n请注意，配置中引用的模板资源路径没有前缀，因为应用程序上下文本身将用作 ResourceLoader，资源本身将根据需要通过 ClassPathResource，FileSystemResource 或 ServletContextResource 加载，具体取决于上下文的确切类型。\n\n如果需要强制使用特定的资源类型，则可以使用前缀。 以下两个示例显示如何强制使用 ClassPathResource 和 UrlResource（后者用于访问文件系统文件）。\n\n<property name="template" value="classpath:some/resource/path/myTemplate.txt">\n<property name="template" value="file:///some/resource/path/myTemplate.txt"/>\n\n\n可以通过 @Value 注解加载资源文件 myTemplate.txt，示例如下：\n\n@Component\npublic class MyBean {\n\n    private final Resource template;\n\n    public MyBean(@Value("${template.path}") Resource template) {\n        this.template = template;\n    }\n\n    // ...\n}\n\n\nSpring 的 PropertyEditor 会根据资源文件的路径字符串，加载 Resource 对象，并将其注入到 MyBean 的构造方法。\n\n如果想要加载多个资源文件，可以使用 classpath*: 前缀，例如：classpath*:/config/templates/*.txt。\n\n@Component\npublic class MyBean {\n\n    private final Resource[] templates;\n\n    public MyBean(@Value("${templates.path}") Resource[] templates) {\n        this.templates = templates;\n    }\n\n    // ...\n}\n\n\n\n# 应用上下文和资源路径\n\n\n# 构造应用上下文\n\n应用上下文构造函数（针对特定的应用上下文类型）通常将字符串或字符串数组作为资源的位置路径，例如构成上下文定义的 XML 文件。\n\n【示例】\n\nApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");\nApplicationContext ctx = new FileSystemXmlApplicationContext("conf/appContext.xml");\nApplicationContext ctx = new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");\nApplicationContext ctx = new ClassPathXmlApplicationContext(\n                new String[] {"services.xml", "daos.xml"}, MessengerService.class);\n\n\n\n# 使用通配符构造应用上下文\n\nApplicationContext 构造器的中的资源路径可以是单一的路径（即一对一地映射到目标资源）；也可以是通配符形式——可包含 classpath*：也可以是前缀或 ant 风格的正则表达式（使用 spring 的 PathMatcher 来匹配）。\n\n示例：\n\nApplicationContext ctx = new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");\n\n\n使用 classpath* 表示类路径下所有匹配文件名称的资源都会被获取(本质上就是调用了 ClassLoader.getResources(…) 方法），接着将获取到的资源组装成最终的应用上下文。\n\n在位置路径的其余部分，classpath*: 前缀可以与 PathMatcher 结合使用，如：classpath*:META-INF/*-beans.xml。\n\n\n# 问题\n\nSpring 配置资源中有哪些常见类型？\n\n * XML 资源\n * Properties 资源\n * YAML 资源\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 资源管理\n\n> version 6.0.3\n\n\n# resource 接口\n\n相对标准 url 访问机制，spring 的 org.springframework.core.io.resource 接口抽象了对底层资源的访问接口，提供了一套更好的访问方式。\n\npublic interface resource extends inputstreamsource {\n\n    boolean exists();\n\n    boolean isreadable();\n\n    boolean isopen();\n\n    boolean isfile();\n\n    url geturl() throws ioexception;\n\n    uri geturi() throws ioexception;\n\n    file getfile() throws ioexception;\n\n    readablebytechannel readablechannel() throws ioexception;\n\n    long contentlength() throws ioexception;\n\n    long lastmodified() throws ioexception;\n\n    resource createrelative(string relativepath) throws ioexception;\n\n    string getfilename();\n\n    string getdescription();\n}\n\n\n正如 resource 接口的定义所示，它扩展了 inputstreamsource 接口。resource 最核心的方法如下：\n\n * getinputstream() - 定位并且打开当前资源，返回当前资源的 inputstream。每次调用都会返回一个新的 inputstream。调用者需要负责关闭流。\n * exists() - 判断当前资源是否真的存在。\n * isopen() - 判断当前资源是否是一个已打开的 inputstream。如果为 true，则 inputstream 不能被多次读取，必须只读取一次然后关闭以避免资源泄漏。对所有常用资源实现返回 false，inputstreamresource 除外。\n * getdescription() - 返回当前资源的描述，当处理资源出错时，资源的描述会用于错误信息的输出。一般来说，资源的描述是一个完全限定的文件名称，或者是当前资源的真实 url。\n\n常见 spring 资源接口：\n\n类型      接口\n输入流     org.springframework.core.io.inputstreamsource\n只读资源    org.springframework.core.io.resource\n可写资源    org.springframework.core.io.writableresource\n编码资源    org.springframework.core.io.support.encodedresource\n上下文资源   org.springframework.core.io.contextresource\n\n\n\n\n# 内置的 resource 实现\n\nspring 包括几个内置的 resource 实现：\n\n资源来源                     前缀                    说明\nurlresource              file:、https:、ftp: 等   urlresource 封装了一个 java.net.url 对象，用于访问可通过 url\n                                               访问的任何对象，例如文件、https 目标、ftp 目标等。所有 url\n                                               都可以通过标准化的字符串形式表示，因此可以使用适当的标准化前缀来指示一种 url 类型与另一种 url 类型的区别。\n                                               这包括：file：用于访问文件系统路径；https：用于通过 https 协议访问资源；ftp：用于通过 ftp\n                                               访问资源等等。\nclasspathresource        classpath:            classpathresource 从类路径上加载资源。它使用线程上下文加载器、给定的类加载器或指定的 class\n                                               类型中的任意一个来加载资源。\nfilesystemresource       file:                 filesystemresource 是 java.io.file 的资源实现。它还支持\n                                               java.nio.file.path ，应用 spring\n                                               的标准对字符串路径进行转换。filesystemresource 支持解析为文件和 url。\npathresource             无                     pathresource 是 java.nio.file.path 的资源实现。\nservletcontextresource   无                     servletcontextresource 是 servletcontext 的资源实现。它表示相应 web\n                                               应用程序根目录中的相对路径。\ninputstreamresource      无                     inputstreamresource 是指定 inputstream 的资源实现。注意：如果该 inputstream\n                                               已被打开，则不可以多次读取该流。\nbytearrayresource        无                     bytearrayresource 是指定的二进制数组的资源实现。它会为给定的字节数组创建一个\n                                               bytearrayinputstream。\n\n\n# resourceloader 接口\n\nresourceloader 接口用于加载 resource 对象。其定义如下：\n\npublic interface resourceloader {\n\n    resource getresource(string location);\n\n    classloader getclassloader();\n}\n\n\nspring 中主要的 resourceloader 实现：\n\n\n\nspring 中，所有的 applicationcontext 都实现了 resourceloader 接口。因此，所有 applicationcontext 都可以通过 getresource() 方法获取 resource 实例。\n\n【示例】\n\n// 如果没有指定资源前缀，spring 会尝试返回合适的资源\nresource template = ctx.getresource("some/resource/path/mytemplate.txt");\n// 如果指定 classpath: 前缀，spring 会强制使用 classpathresource\nresource template = ctx.getresource("classpath:some/resource/path/mytemplate.txt");\n// 如果指定 file:、http 等 url 前缀，spring 会强制使用 urlresource\nresource template = ctx.getresource("file:///some/resource/path/mytemplate.txt");\nresource template = ctx.getresource("http://myhost.com/resource/path/mytemplate.txt");\n\n\n下表列举了 spring 根据各种位置路径加载资源的策略：\n\n前缀           样例                               说明\nclasspath:   classpath:com/myapp/config.xml   从类路径加载\nfile:        file:///data/config.xml          以 url 形式从文件系统加载\nhttp:        http://myserver/logo.png         以 url 形式加载\n无            /data/config.xml                 由底层的 applicationcontext 实现决定\n\n\n# resourcepatternresolver 接口\n\nresourcepatternresolver 接口是 resourceloader 接口的扩展，它的作用是定义策略，根据位置模式解析 resource 对象。\n\npublic interface resourcepatternresolver extends resourceloader {\n\n    string classpath_all_url_prefix = "classpath*:";\n\n    resource[] getresources(string locationpattern) throws ioexception;\n}\n\n\npathmatchingresourcepatternresolver 是一个独立的实现，可以在 applicationcontext 之外使用，也可以被 resourcearraypropertyeditor 用于填充 resource[] bean 属性。pathmatchingresourcepatternresolver 能够将指定的资源位置路径解析为一个或多个匹配的 resource 对象。\n\n> 注意：任何标准 applicationcontext 中的默认 resourceloader 实际上是 pathmatchingresourcepatternresolver 的一个实例，它实现了 resourcepatternresolver 接口。\n\n\n# resourceloaderaware 接口\n\nresourceloaderaware 接口是一个特殊的回调接口，用来标记提供 resourceloader 引用的对象。resourceloaderaware 接口定义如下：\n\npublic interface resourceloaderaware {\n    void setresourceloader(resourceloader resourceloader);\n}\n\n\n当一个类实现 resourceloaderaware 并部署到应用程序上下文中（作为 spring 管理的 bean）时，它会被应用程序上下文识别为 resourceloaderaware，然后，应用程序上下文会调用 setresourceloader(resourceloader)，将自身作为参数提供（请记住，spring 中的所有应用程序上下文都实现 resourceloader 接口）。\n\n由于 applicationcontext 是一个 resourceloader，该 bean 还可以实现 applicationcontextaware 接口并直接使用提供的应用程序上下文来加载资源。 但是，一般来说，如果您只需要这些，最好使用专门的 resourceloader 接口。 该代码将仅耦合到资源加载接口（可以被视为实用程序接口），而不耦合到整个 spring applicationcontext 接口。\n\n在应用程序中，还可以使用 resourceloader 的自动装配作为实现 resourceloaderaware 接口的替代方法。传统的构造函数和 bytype 自动装配模式能够分别为构造函数参数或 setter 方法参数提供 resourceloader。 为了获得更大的灵活性（包括自动装配字段和多参数方法的能力），请考虑使用基于注解的自动装配功能。 在这种情况下，resourceloader 会自动连接到需要 resourceloader 类型的字段、构造函数参数或方法参数中，只要相关字段、构造函数或方法带有 @autowired 注解即可。\n\n\n# 资源依赖\n\n如果 bean 本身要通过某种动态过程来确定和提供资源路径，那么 bean 可以使用 resourceloader 或 resourcepatternresolver 接口来加载资源。 例如，考虑加载某种模板，其中所需的特定资源取决于用户的角色。 如果资源是静态的，完全消除 resourceloader 接口（或 resourcepatternresolver 接口）的使用，让 bean 公开它需要的 resource 属性，并期望将它们注入其中是有意义的。\n\n使注入这些属性变得简单的原因是所有应用程序上下文都注册并使用一个特殊的 javabeans propertyeditor，它可以将 string 路径转换为 resource 对象。 例如，下面的 mybean 类有一个 resource 类型的模板属性。\n\n【示例】\n\n<bean id="mybean" class="example.mybean">\n    <property name="template" value="some/resource/path/mytemplate.txt"/>\n</bean>\n\n\n请注意，配置中引用的模板资源路径没有前缀，因为应用程序上下文本身将用作 resourceloader，资源本身将根据需要通过 classpathresource，filesystemresource 或 servletcontextresource 加载，具体取决于上下文的确切类型。\n\n如果需要强制使用特定的资源类型，则可以使用前缀。 以下两个示例显示如何强制使用 classpathresource 和 urlresource（后者用于访问文件系统文件）。\n\n<property name="template" value="classpath:some/resource/path/mytemplate.txt">\n<property name="template" value="file:///some/resource/path/mytemplate.txt"/>\n\n\n可以通过 @value 注解加载资源文件 mytemplate.txt，示例如下：\n\n@component\npublic class mybean {\n\n    private final resource template;\n\n    public mybean(@value("${template.path}") resource template) {\n        this.template = template;\n    }\n\n    // ...\n}\n\n\nspring 的 propertyeditor 会根据资源文件的路径字符串，加载 resource 对象，并将其注入到 mybean 的构造方法。\n\n如果想要加载多个资源文件，可以使用 classpath*: 前缀，例如：classpath*:/config/templates/*.txt。\n\n@component\npublic class mybean {\n\n    private final resource[] templates;\n\n    public mybean(@value("${templates.path}") resource[] templates) {\n        this.templates = templates;\n    }\n\n    // ...\n}\n\n\n\n# 应用上下文和资源路径\n\n\n# 构造应用上下文\n\n应用上下文构造函数（针对特定的应用上下文类型）通常将字符串或字符串数组作为资源的位置路径，例如构成上下文定义的 xml 文件。\n\n【示例】\n\napplicationcontext ctx = new classpathxmlapplicationcontext("conf/appcontext.xml");\napplicationcontext ctx = new filesystemxmlapplicationcontext("conf/appcontext.xml");\napplicationcontext ctx = new filesystemxmlapplicationcontext("classpath:conf/appcontext.xml");\napplicationcontext ctx = new classpathxmlapplicationcontext(\n                new string[] {"services.xml", "daos.xml"}, messengerservice.class);\n\n\n\n# 使用通配符构造应用上下文\n\napplicationcontext 构造器的中的资源路径可以是单一的路径（即一对一地映射到目标资源）；也可以是通配符形式——可包含 classpath*：也可以是前缀或 ant 风格的正则表达式（使用 spring 的 pathmatcher 来匹配）。\n\n示例：\n\napplicationcontext ctx = new classpathxmlapplicationcontext("classpath*:conf/appcontext.xml");\n\n\n使用 classpath* 表示类路径下所有匹配文件名称的资源都会被获取(本质上就是调用了 classloader.getresources(…) 方法），接着将获取到的资源组装成最终的应用上下文。\n\n在位置路径的其余部分，classpath*: 前缀可以与 pathmatcher 结合使用，如：classpath*:meta-inf/*-beans.xml。\n\n\n# 问题\n\nspring 配置资源中有哪些常见类型？\n\n * xml 资源\n * properties 资源\n * yaml 资源\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 校验",frontmatter:{title:"Spring 校验",date:"2022-12-22T17:42:28.000Z",order:21,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/fe6aad/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/21.Spring%E6%A0%A1%E9%AA%8C.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/21.Spring校验.md",key:"v-464c8937",path:"/pages/fe6aad/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:193},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:202},{level:3,title:"校验示例",slug:"校验示例",normalizedTitle:"校验示例",charIndex:739},{level:3,title:"统一异常处理",slug:"统一异常处理",normalizedTitle:"统一异常处理",charIndex:2072},{level:2,title:"进阶使用",slug:"进阶使用",normalizedTitle:"进阶使用",charIndex:4053},{level:3,title:"分组校验",slug:"分组校验",normalizedTitle:"分组校验",charIndex:4062},{level:3,title:"嵌套校验",slug:"嵌套校验",normalizedTitle:"嵌套校验",charIndex:5506},{level:3,title:"自定义校验注解",slug:"自定义校验注解",normalizedTitle:"自定义校验注解",charIndex:6978},{level:3,title:"自定义校验",slug:"自定义校验",normalizedTitle:"自定义校验",charIndex:6978},{level:3,title:"快速失败(Fail Fast)",slug:"快速失败-fail-fast",normalizedTitle:"快速失败(fail fast)",charIndex:10519},{level:2,title:"Spring 校验原理",slug:"spring-校验原理",normalizedTitle:"spring 校验原理",charIndex:10904},{level:3,title:"Spring 校验使用场景",slug:"spring-校验使用场景",normalizedTitle:"spring 校验使用场景",charIndex:10920},{level:3,title:"Validator 接口设计",slug:"validator-接口设计",normalizedTitle:"validator 接口设计",charIndex:11060},{level:3,title:"Errors 接口设计",slug:"errors-接口设计",normalizedTitle:"errors 接口设计",charIndex:11343},{level:3,title:"Errors 文案来源",slug:"errors-文案来源",normalizedTitle:"errors 文案来源",charIndex:11615},{level:3,title:"spring web 校验原理",slug:"spring-web-校验原理",normalizedTitle:"spring web 校验原理",charIndex:11891},{level:4,title:"RequestBody 参数校验实现原理",slug:"requestbody-参数校验实现原理",normalizedTitle:"requestbody 参数校验实现原理",charIndex:11910},{level:4,title:"方法级别的参数校验实现原理",slug:"方法级别的参数校验实现原理",normalizedTitle:"方法级别的参数校验实现原理",charIndex:14619},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:4149},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:17299}],headersStr:"快速入门 引入依赖 校验示例 统一异常处理 进阶使用 分组校验 嵌套校验 自定义校验注解 自定义校验 快速失败(Fail Fast) Spring 校验原理 Spring 校验使用场景 Validator 接口设计 Errors 接口设计 Errors 文案来源 spring web 校验原理 RequestBody 参数校验实现原理 方法级别的参数校验实现原理 问题 参考资料",content:'# Spring 校验\n\nJava API 规范(JSR303)定义了Bean校验的标准validation-api，但没有提供实现。hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。\n\n\n# 快速入门\n\n\n# 引入依赖\n\n如果 spring-boot 版本小于 2.3.x，spring-boot-starter-web 会自动传入 hibernate-validator 依赖。如果 spring-boot 版本大于 2.3.x，则需要手动引入依赖：\n\n<dependency>\n  <groupId>org.hibernate.validator</groupId>\n  <artifactId>hibernate-validator-parent</artifactId>\n  <version>6.2.5.Final</version>\n</dependency>\n\n\n对于 web 服务来说，为防止非法参数对业务造成影响，在 Controller 层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：\n\n * POST、PUT 请求，使用 requestBody 传递参数；\n * GET 请求，使用 requestParam/PathVariable 传递参数。\n\n实际上，不管是 requestBody 参数校验还是方法级别的校验，最终都是调用 Hibernate Validator 执行校验，Spring Validation 只是做了一层封装。\n\n\n# 校验示例\n\n（1）在实体上标记校验注解\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    @NotNull\n    private Long id;\n\n    @NotBlank\n    @Size(min = 2, max = 10)\n    private String name;\n\n    @Min(value = 1)\n    @Max(value = 100)\n    private Integer age;\n\n}\n\n\n（2）在方法参数上声明校验注解\n\n@Slf4j\n@Validated\n@RestController\n@RequestMapping("validate1")\npublic class ValidatorController {\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "save")\n    public DataResult<Boolean> save(@Valid @RequestBody User entity) {\n        log.info("保存一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n    /**\n     * {@link RequestParam} 参数校验\n     */\n    @GetMapping(value = "queryByName")\n    public DataResult<User> queryByName(\n        @RequestParam("username")\n        @NotBlank\n        @Size(min = 2, max = 10)\n        String name\n    ) {\n        User user = new User(1L, name, 18);\n        return DataResult.ok(user);\n    }\n\n    /**\n     * {@link PathVariable} 参数校验\n     */\n    @GetMapping(value = "detail/{id}")\n    public DataResult<User> detail(@PathVariable("id") @Min(1L) Long id) {\n        User user = new User(id, "李四", 18);\n        return DataResult.ok(user);\n    }\n\n}\n\n\n（3）如果请求参数不满足校验规则，则会抛出 ConstraintViolationException 或 MethodArgumentNotValidException 异常。\n\n\n# 统一异常处理\n\n在实际项目开发中，通常会用统一异常处理来返回一个更友好的提示。\n\n@Slf4j\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    /**\n     * 处理所有不可知的异常\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.OK)\n    @ExceptionHandler(Throwable.class)\n    public Result handleException(Throwable e) {\n        log.error("未知异常", e);\n        return new Result(ResultStatus.HTTP_SERVER_ERROR.getCode(), e.getMessage());\n    }\n\n    /**\n     * 统一处理请求参数校验异常(普通传参)\n     *\n     * @param e ConstraintViolationException\n     * @return {@link DataResult}\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler({ ConstraintViolationException.class })\n    public Result handleConstraintViolationException(final ConstraintViolationException e) {\n        log.error("ConstraintViolationException", e);\n        List<String> errors = new ArrayList<>();\n        for (ConstraintViolation<?> violation : e.getConstraintViolations()) {\n            Path path = violation.getPropertyPath();\n            List<String> pathArr = StrUtil.split(path.toString(), \',\');\n            errors.add(pathArr.get(0) + " " + violation.getMessage());\n        }\n        return new Result(ResultStatus.REQUEST_ERROR.getCode(), CollectionUtil.join(errors, ","));\n    }\n\n    /**\n     * 处理参数校验异常\n     *\n     * @param e MethodArgumentNotValidException\n     * @return {@link DataResult}\n     */\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler({ MethodArgumentNotValidException.class })\n    private Result handleMethodArgumentNotValidException(final MethodArgumentNotValidException e) {\n        log.error("MethodArgumentNotValidException", e);\n        List<String> errors = new ArrayList<>();\n        for (ObjectError error : e.getBindingResult().getAllErrors()) {\n            errors.add(((FieldError) error).getField() + " " + error.getDefaultMessage());\n        }\n        return new Result(ResultStatus.REQUEST_ERROR.getCode(), CollectionUtil.join(errors, ","));\n    }\n\n}\n\n\n\n# 进阶使用\n\n\n# 分组校验\n\n在实际项目中，可能多个方法需要使用同一个 DTO 类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在 DTO 类的字段上加约束注解无法解决这个问题。因此，spring-validation 支持了分组校验的功能，专门用来解决这类问题。\n\n（1）定义分组\n\n@Target({ ElementType.FIELD, ElementType.PARAMETER })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AddCheck { }\n\n@Target({ ElementType.FIELD, ElementType.PARAMETER })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface EditCheck { }\n\n\n（2）在实体上标记校验注解\n\n@Data\npublic class User2 {\n\n    @NotNull(groups = EditCheck.class)\n    private Long id;\n\n    @NotNull(groups = { AddCheck.class, EditCheck.class })\n    @Size(min = 2, max = 10, groups = { AddCheck.class, EditCheck.class })\n    private String name;\n\n    @IsMobile(message = "不是有效手机号", groups = { AddCheck.class, EditCheck.class })\n    private String mobile;\n\n}\n\n\n（3）在方法上根据不同场景进行校验分组\n\n@Slf4j\n@Validated\n@RestController\n@RequestMapping("validate2")\npublic class ValidatorController2 {\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "add")\n    public DataResult<Boolean> add(@Validated(AddCheck.class) @RequestBody User2 entity) {\n        log.info("添加一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n    /**\n     * {@link RequestBody} 参数校验\n     */\n    @PostMapping(value = "edit")\n    public DataResult<Boolean> edit(@Validated(EditCheck.class) @RequestBody User2 entity) {\n        log.info("编辑一条记录：{}", JSONUtil.toJsonStr(entity));\n        return DataResult.ok(true);\n    }\n\n}\n\n\n\n# 嵌套校验\n\n前面的示例中，DTO 类里面的字段都是基本数据类型和 String 类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用嵌套校验。 post 比如，上面保存 User 信息的时候同时还带有 Job 信息。需要注意的是，此时 DTO 类的对应字段必须标记@Valid 注解。\n\n@Data\npublic class UserDTO {\n\n    @Min(value = 10000000000000000L, groups = Update.class)\n    private Long userId;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n    private String userName;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 6, max = 20, groups = {Save.class, Update.class})\n    private String account;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Length(min = 6, max = 20, groups = {Save.class, Update.class})\n    private String password;\n\n    @NotNull(groups = {Save.class, Update.class})\n    @Valid\n    private Job job;\n\n    @Data\n    public static class Job {\n\n        @Min(value = 1, groups = Update.class)\n        private Long jobId;\n\n        @NotNull(groups = {Save.class, Update.class})\n        @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n        private String jobName;\n\n        @NotNull(groups = {Save.class, Update.class})\n        @Length(min = 2, max = 10, groups = {Save.class, Update.class})\n        private String position;\n    }\n\n    /**\n     * 保存的时候校验分组\n     */\n    public interface Save {\n    }\n\n    /**\n     * 更新的时候校验分组\n     */\n    public interface Update {\n    }\n}\n复制代码\n\n\n嵌套校验可以结合分组校验一起使用。还有就是嵌套集合校验会对集合里面的每一项都进行校验，例如List<Job>字段会对这个 list 里面的每一个 Job 对象都进行校验\n\n\n# 自定义校验注解\n\n（1）自定义校验注解 @IsMobile\n\n@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })\n@Retention(RUNTIME)\n@Constraint(validatedBy = MobileValidator.class)\npublic @interface IsMobile {\n\n    String message();\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n}\n\n\n（2）实现 ConstraintValidator 接口，编写 @IsMobile 校验注解的解析器\n\nimport cn.hutool.core.util.StrUtil;\nimport io.github.dunwu.spring.core.validation.annotation.IsMobile;\nimport io.github.dunwu.tool.util.ValidatorUtil;\n\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n\npublic class MobileValidator implements ConstraintValidator<IsMobile, String> {\n\n    @Override\n    public void initialize(IsMobile isMobile) { }\n\n    @Override\n    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {\n        if (StrUtil.isBlank(s)) {\n            return false;\n        } else {\n            return ValidatorUtil.isMobile(s);\n        }\n    }\n\n}\n\n\n\n# 自定义校验\n\n可以通过实现 org.springframework.validation.Validator 接口来自定义校验。\n\n有以下要点\n\n * 实现 supports 方法\n * 实现 validate 方法\n   * 通过 Errors 对象收集错误\n     * ObjectError：对象（Bean）错误：\n     * FieldError：对象（Bean）属性（Property）错误\n   * 通过 ObjectError 和 FieldError 关联 MessageSource 实现获取最终的错误文案\n\npackage io.github.dunwu.spring.core.validation;\n\nimport io.github.dunwu.spring.core.validation.annotation.Valid;\nimport io.github.dunwu.spring.core.validation.config.CustomValidatorConfig;\nimport io.github.dunwu.spring.core.validation.entity.Person;\nimport org.springframework.stereotype.Component;\nimport org.springframework.validation.Errors;\nimport org.springframework.validation.ValidationUtils;\nimport org.springframework.validation.Validator;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n@Component\npublic class CustomValidator implements Validator {\n\n    private final CustomValidatorConfig validatorConfig;\n\n    public CustomValidator(CustomValidatorConfig validatorConfig) {\n        this.validatorConfig = validatorConfig;\n    }\n\n    /**\n     * 本校验器只针对 Person 对象进行校验\n     */\n    @Override\n    public boolean supports(Class<?> clazz) {\n        return Person.class.equals(clazz);\n    }\n\n    @Override\n    public void validate(Object target, Errors errors) {\n        ValidationUtils.rejectIfEmpty(errors, "name", "name.empty");\n\n        List<Field> fields = getFields(target.getClass());\n        for (Field field : fields) {\n            Annotation[] annotations = field.getAnnotations();\n            for (Annotation annotation : annotations) {\n                if (annotation.annotationType().getAnnotation(Valid.class) != null) {\n                    try {\n                        ValidatorRule validatorRule = validatorConfig.findRule(annotation);\n                        if (validatorRule != null) {\n                            validatorRule.valid(annotation, target, field, errors);\n                        }\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private List<Field> getFields(Class<?> clazz) {\n        // 声明Field数组\n        List<Field> fields = new ArrayList<>();\n        // 如果class类型不为空\n        while (clazz != null) {\n            // 添加属性到属性数组\n            Collections.addAll(fields, clazz.getDeclaredFields());\n            clazz = clazz.getSuperclass();\n        }\n        return fields;\n    }\n\n}\n\n\n\n# 快速失败(Fail Fast)\n\nSpring Validation 默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启 Fali Fast 模式，一旦校验失败就立即返回。\n\n@Bean\npublic Validator validator() {\n    ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)\n            .configure()\n            // 快速失败模式\n            .failFast(true)\n            .buildValidatorFactory();\n    return validatorFactory.getValidator();\n}\n\n\n\n# Spring 校验原理\n\n\n# Spring 校验使用场景\n\n * Spring 常规校验（Validator）\n * Spring 数据绑定（DataBinder）\n * Spring Web 参数绑定（WebDataBinder）\n * Spring WebMVC/WebFlux 处理方法参数校验\n\n\n# Validator 接口设计\n\n * 接口职责\n   * Spring 内部校验器接口，通过编程的方式校验目标对象\n * 核心方法\n   * supports(Class)：校验目标类能否校验\n   * validate(Object,Errors)：校验目标对象，并将校验失败的内容输出至 Errors 对象\n * 配套组件\n   * 错误收集器：org.springframework.validation.Errors\n   * Validator 工具类：org.springframework.validation.ValidationUtils\n\n\n# Errors 接口设计\n\n * 接口职责\n   * 数据绑定和校验错误收集接口，与 Java Bean 和其属性有强关联性\n * 核心方法\n   * reject 方法（重载）：收集错误文案\n   * rejectValue 方法（重载）：收集对象字段中的错误文案\n * 配套组件\n   * Java Bean 错误描述：org.springframework.validation.ObjectError\n   * Java Bean 属性错误描述：org.springframework.validation.FieldError\n\n\n# Errors 文案来源\n\nErrors 文案生成步骤\n\n * 选择 Errors 实现（如：org.springframework.validation.BeanPropertyBindingResult）\n * 调用 reject 或 rejectValue 方法\n * 获取 Errors 对象中 ObjectError 或 FieldError\n * 将 ObjectError 或 FieldError 中的 code 和 args，关联 MessageSource 实现（如：ResourceBundleMessageSource）\n\n\n# spring web 校验原理\n\n# RequestBody 参数校验实现原理\n\n在 spring-mvc 中，RequestResponseBodyMethodProcessor 是用于解析 @RequestBody 标注的参数以及处理@ResponseBody 标注方法的返回值的。其中，执行参数校验的逻辑肯定就在解析参数的方法 resolveArgument() 中：\n\n@Override\npublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n    NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n    parameter = parameter.nestedIfOptional();\n    Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());\n    String name = Conventions.getVariableNameForParameter(parameter);\n\n    if (binderFactory != null) {\n        WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);\n        if (arg != null) {\n            // 尝试进行参数校验\n            validateIfApplicable(binder, parameter);\n            if (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n                // 如果存在校验错误，则抛出 MethodArgumentNotValidException\n                throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n            }\n        }\n        if (mavContainer != null) {\n            mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n        }\n    }\n\n    return adaptArgumentIfNecessary(arg, parameter);\n}\n\n\n可以看到，resolveArgument()调用了 validateIfApplicable()进行参数校验。\n\nprotected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {\n    // 获取参数注解，如 @RequestBody、@Valid、@Validated\n    Annotation[] annotations = parameter.getParameterAnnotations();\n    for (Annotation ann : annotations) {\n        // 先尝试获取 @Validated 注解\n        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);\n        // 如果标注了 @Validated，直接开始校验。\n        // 如果没有，那么判断参数前是否有 Valid 开头的注解。\n        if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {\n            Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));\n            Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});\n            // 执行校验\n            binder.validate(validationHints);\n            break;\n        }\n    }\n}\n\n\n以上代码，就解释了 Spring 为什么能同时支持 @Validated、@Valid 两个注解。\n\n接下来，看一下 WebDataBinder.validate() 的实现：\n\n@Override\npublic void validate(Object target, Errors errors, Object... validationHints) {\n    if (this.targetValidator != null) {\n        processConstraintViolations(\n            // 此处调用 Hibernate Validator 执行真正的校验\n            this.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n    }\n}\n\n\n通过上面代码，可以看出 Spring 校验实际上是基于 Hibernate Validator 的封装。\n\n# 方法级别的参数校验实现原理\n\nSpring 支持根据方法去进行拦截、校验，原理就在于应用了 AOP 技术。具体来说，是通过 MethodValidationPostProcessor 动态注册 AOP 切面，然后使用 MethodValidationInterceptor 对切点方法织入增强。\n\npublic class MethodValidationPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessorimplements InitializingBean {\n    @Override\n    public void afterPropertiesSet() {\n        // 为所有 @Validated 标注的 Bean 创建切面\n        Pointcut pointcut = new AnnotationMatchingPointcut(this.validatedAnnotationType, true);\n        // 创建 Advisor 进行增强\n        this.advisor = new DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(this.validator));\n    }\n\n    // 创建 Advice，本质就是一个方法拦截器\n    protected Advice createMethodValidationAdvice(@Nullable Validator validator) {\n        return (validator != null ? new MethodValidationInterceptor(validator) : new MethodValidationInterceptor());\n    }\n}\n\n\n接着看一下 MethodValidationInterceptor：\n\npublic class MethodValidationInterceptor implements MethodInterceptor {\n    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        // 无需增强的方法，直接跳过\n        if (isFactoryBeanMetadataMethod(invocation.getMethod())) {\n            return invocation.proceed();\n        }\n        // 获取分组信息\n        Class<?>[] groups = determineValidationGroups(invocation);\n        ExecutableValidator execVal = this.validator.forExecutables();\n        Method methodToValidate = invocation.getMethod();\n        Set<ConstraintViolation<Object>> result;\n        try {\n            // 方法入参校验，最终还是委托给 Hibernate Validator 来校验\n            result = execVal.validateParameters(\n                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);\n        }\n        catch (IllegalArgumentException ex) {\n            ...\n        }\n        // 有异常直接抛出\n        if (!result.isEmpty()) {\n            throw new ConstraintViolationException(result);\n        }\n        // 真正的方法调用\n        Object returnValue = invocation.proceed();\n        // 对返回值做校验，最终还是委托给Hibernate Validator来校验\n        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);\n        // 有异常直接抛出\n        if (!result.isEmpty()) {\n            throw new ConstraintViolationException(result);\n        }\n        return returnValue;\n    }\n}\n\n\n实际上，不管是 requestBody 参数校验还是方法级别的校验，最终都是调用 Hibernate Validator 执行校验，Spring Validation 只是做了一层封装。\n\n\n# 问题\n\nSpring 有哪些校验核心组件？\n\n * 检验器：org.springframework.validation.Validator\n * 错误收集器：org.springframework.validation.Errors\n * Java Bean 错误描述：org.springframework.validation.ObjectError\n * Java Bean 属性错误描述：org.springframework.validation.FieldError\n * Bean Validation 适配：org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》\n * https://juejin.cn/post/6856541106626363399',normalizedContent:'# spring 校验\n\njava api 规范(jsr303)定义了bean校验的标准validation-api，但没有提供实现。hibernate validation是对这个规范的实现，并增加了校验注解如@email、@length等。spring validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。\n\n\n# 快速入门\n\n\n# 引入依赖\n\n如果 spring-boot 版本小于 2.3.x，spring-boot-starter-web 会自动传入 hibernate-validator 依赖。如果 spring-boot 版本大于 2.3.x，则需要手动引入依赖：\n\n<dependency>\n  <groupid>org.hibernate.validator</groupid>\n  <artifactid>hibernate-validator-parent</artifactid>\n  <version>6.2.5.final</version>\n</dependency>\n\n\n对于 web 服务来说，为防止非法参数对业务造成影响，在 controller 层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：\n\n * post、put 请求，使用 requestbody 传递参数；\n * get 请求，使用 requestparam/pathvariable 传递参数。\n\n实际上，不管是 requestbody 参数校验还是方法级别的校验，最终都是调用 hibernate validator 执行校验，spring validation 只是做了一层封装。\n\n\n# 校验示例\n\n（1）在实体上标记校验注解\n\n@data\n@noargsconstructor\n@allargsconstructor\npublic class user implements serializable {\n\n    @notnull\n    private long id;\n\n    @notblank\n    @size(min = 2, max = 10)\n    private string name;\n\n    @min(value = 1)\n    @max(value = 100)\n    private integer age;\n\n}\n\n\n（2）在方法参数上声明校验注解\n\n@slf4j\n@validated\n@restcontroller\n@requestmapping("validate1")\npublic class validatorcontroller {\n\n    /**\n     * {@link requestbody} 参数校验\n     */\n    @postmapping(value = "save")\n    public dataresult<boolean> save(@valid @requestbody user entity) {\n        log.info("保存一条记录：{}", jsonutil.tojsonstr(entity));\n        return dataresult.ok(true);\n    }\n\n    /**\n     * {@link requestparam} 参数校验\n     */\n    @getmapping(value = "querybyname")\n    public dataresult<user> querybyname(\n        @requestparam("username")\n        @notblank\n        @size(min = 2, max = 10)\n        string name\n    ) {\n        user user = new user(1l, name, 18);\n        return dataresult.ok(user);\n    }\n\n    /**\n     * {@link pathvariable} 参数校验\n     */\n    @getmapping(value = "detail/{id}")\n    public dataresult<user> detail(@pathvariable("id") @min(1l) long id) {\n        user user = new user(id, "李四", 18);\n        return dataresult.ok(user);\n    }\n\n}\n\n\n（3）如果请求参数不满足校验规则，则会抛出 constraintviolationexception 或 methodargumentnotvalidexception 异常。\n\n\n# 统一异常处理\n\n在实际项目开发中，通常会用统一异常处理来返回一个更友好的提示。\n\n@slf4j\n@controlleradvice\npublic class globalexceptionhandler {\n\n    /**\n     * 处理所有不可知的异常\n     */\n    @responsebody\n    @responsestatus(httpstatus.ok)\n    @exceptionhandler(throwable.class)\n    public result handleexception(throwable e) {\n        log.error("未知异常", e);\n        return new result(resultstatus.http_server_error.getcode(), e.getmessage());\n    }\n\n    /**\n     * 统一处理请求参数校验异常(普通传参)\n     *\n     * @param e constraintviolationexception\n     * @return {@link dataresult}\n     */\n    @responsebody\n    @responsestatus(httpstatus.bad_request)\n    @exceptionhandler({ constraintviolationexception.class })\n    public result handleconstraintviolationexception(final constraintviolationexception e) {\n        log.error("constraintviolationexception", e);\n        list<string> errors = new arraylist<>();\n        for (constraintviolation<?> violation : e.getconstraintviolations()) {\n            path path = violation.getpropertypath();\n            list<string> patharr = strutil.split(path.tostring(), \',\');\n            errors.add(patharr.get(0) + " " + violation.getmessage());\n        }\n        return new result(resultstatus.request_error.getcode(), collectionutil.join(errors, ","));\n    }\n\n    /**\n     * 处理参数校验异常\n     *\n     * @param e methodargumentnotvalidexception\n     * @return {@link dataresult}\n     */\n    @responsebody\n    @responsestatus(httpstatus.bad_request)\n    @exceptionhandler({ methodargumentnotvalidexception.class })\n    private result handlemethodargumentnotvalidexception(final methodargumentnotvalidexception e) {\n        log.error("methodargumentnotvalidexception", e);\n        list<string> errors = new arraylist<>();\n        for (objecterror error : e.getbindingresult().getallerrors()) {\n            errors.add(((fielderror) error).getfield() + " " + error.getdefaultmessage());\n        }\n        return new result(resultstatus.request_error.getcode(), collectionutil.join(errors, ","));\n    }\n\n}\n\n\n\n# 进阶使用\n\n\n# 分组校验\n\n在实际项目中，可能多个方法需要使用同一个 dto 类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在 dto 类的字段上加约束注解无法解决这个问题。因此，spring-validation 支持了分组校验的功能，专门用来解决这类问题。\n\n（1）定义分组\n\n@target({ elementtype.field, elementtype.parameter })\n@retention(retentionpolicy.runtime)\npublic @interface addcheck { }\n\n@target({ elementtype.field, elementtype.parameter })\n@retention(retentionpolicy.runtime)\npublic @interface editcheck { }\n\n\n（2）在实体上标记校验注解\n\n@data\npublic class user2 {\n\n    @notnull(groups = editcheck.class)\n    private long id;\n\n    @notnull(groups = { addcheck.class, editcheck.class })\n    @size(min = 2, max = 10, groups = { addcheck.class, editcheck.class })\n    private string name;\n\n    @ismobile(message = "不是有效手机号", groups = { addcheck.class, editcheck.class })\n    private string mobile;\n\n}\n\n\n（3）在方法上根据不同场景进行校验分组\n\n@slf4j\n@validated\n@restcontroller\n@requestmapping("validate2")\npublic class validatorcontroller2 {\n\n    /**\n     * {@link requestbody} 参数校验\n     */\n    @postmapping(value = "add")\n    public dataresult<boolean> add(@validated(addcheck.class) @requestbody user2 entity) {\n        log.info("添加一条记录：{}", jsonutil.tojsonstr(entity));\n        return dataresult.ok(true);\n    }\n\n    /**\n     * {@link requestbody} 参数校验\n     */\n    @postmapping(value = "edit")\n    public dataresult<boolean> edit(@validated(editcheck.class) @requestbody user2 entity) {\n        log.info("编辑一条记录：{}", jsonutil.tojsonstr(entity));\n        return dataresult.ok(true);\n    }\n\n}\n\n\n\n# 嵌套校验\n\n前面的示例中，dto 类里面的字段都是基本数据类型和 string 类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用嵌套校验。 post 比如，上面保存 user 信息的时候同时还带有 job 信息。需要注意的是，此时 dto 类的对应字段必须标记@valid 注解。\n\n@data\npublic class userdto {\n\n    @min(value = 10000000000000000l, groups = update.class)\n    private long userid;\n\n    @notnull(groups = {save.class, update.class})\n    @length(min = 2, max = 10, groups = {save.class, update.class})\n    private string username;\n\n    @notnull(groups = {save.class, update.class})\n    @length(min = 6, max = 20, groups = {save.class, update.class})\n    private string account;\n\n    @notnull(groups = {save.class, update.class})\n    @length(min = 6, max = 20, groups = {save.class, update.class})\n    private string password;\n\n    @notnull(groups = {save.class, update.class})\n    @valid\n    private job job;\n\n    @data\n    public static class job {\n\n        @min(value = 1, groups = update.class)\n        private long jobid;\n\n        @notnull(groups = {save.class, update.class})\n        @length(min = 2, max = 10, groups = {save.class, update.class})\n        private string jobname;\n\n        @notnull(groups = {save.class, update.class})\n        @length(min = 2, max = 10, groups = {save.class, update.class})\n        private string position;\n    }\n\n    /**\n     * 保存的时候校验分组\n     */\n    public interface save {\n    }\n\n    /**\n     * 更新的时候校验分组\n     */\n    public interface update {\n    }\n}\n复制代码\n\n\n嵌套校验可以结合分组校验一起使用。还有就是嵌套集合校验会对集合里面的每一项都进行校验，例如list<job>字段会对这个 list 里面的每一个 job 对象都进行校验\n\n\n# 自定义校验注解\n\n（1）自定义校验注解 @ismobile\n\n@target({ method, field, annotation_type, constructor, parameter, type_use })\n@retention(runtime)\n@constraint(validatedby = mobilevalidator.class)\npublic @interface ismobile {\n\n    string message();\n\n    class<?>[] groups() default {};\n\n    class<? extends payload>[] payload() default {};\n\n}\n\n\n（2）实现 constraintvalidator 接口，编写 @ismobile 校验注解的解析器\n\nimport cn.hutool.core.util.strutil;\nimport io.github.dunwu.spring.core.validation.annotation.ismobile;\nimport io.github.dunwu.tool.util.validatorutil;\n\nimport javax.validation.constraintvalidator;\nimport javax.validation.constraintvalidatorcontext;\n\npublic class mobilevalidator implements constraintvalidator<ismobile, string> {\n\n    @override\n    public void initialize(ismobile ismobile) { }\n\n    @override\n    public boolean isvalid(string s, constraintvalidatorcontext constraintvalidatorcontext) {\n        if (strutil.isblank(s)) {\n            return false;\n        } else {\n            return validatorutil.ismobile(s);\n        }\n    }\n\n}\n\n\n\n# 自定义校验\n\n可以通过实现 org.springframework.validation.validator 接口来自定义校验。\n\n有以下要点\n\n * 实现 supports 方法\n * 实现 validate 方法\n   * 通过 errors 对象收集错误\n     * objecterror：对象（bean）错误：\n     * fielderror：对象（bean）属性（property）错误\n   * 通过 objecterror 和 fielderror 关联 messagesource 实现获取最终的错误文案\n\npackage io.github.dunwu.spring.core.validation;\n\nimport io.github.dunwu.spring.core.validation.annotation.valid;\nimport io.github.dunwu.spring.core.validation.config.customvalidatorconfig;\nimport io.github.dunwu.spring.core.validation.entity.person;\nimport org.springframework.stereotype.component;\nimport org.springframework.validation.errors;\nimport org.springframework.validation.validationutils;\nimport org.springframework.validation.validator;\n\nimport java.lang.annotation.annotation;\nimport java.lang.reflect.field;\nimport java.util.arraylist;\nimport java.util.collections;\nimport java.util.list;\n\n@component\npublic class customvalidator implements validator {\n\n    private final customvalidatorconfig validatorconfig;\n\n    public customvalidator(customvalidatorconfig validatorconfig) {\n        this.validatorconfig = validatorconfig;\n    }\n\n    /**\n     * 本校验器只针对 person 对象进行校验\n     */\n    @override\n    public boolean supports(class<?> clazz) {\n        return person.class.equals(clazz);\n    }\n\n    @override\n    public void validate(object target, errors errors) {\n        validationutils.rejectifempty(errors, "name", "name.empty");\n\n        list<field> fields = getfields(target.getclass());\n        for (field field : fields) {\n            annotation[] annotations = field.getannotations();\n            for (annotation annotation : annotations) {\n                if (annotation.annotationtype().getannotation(valid.class) != null) {\n                    try {\n                        validatorrule validatorrule = validatorconfig.findrule(annotation);\n                        if (validatorrule != null) {\n                            validatorrule.valid(annotation, target, field, errors);\n                        }\n                    } catch (exception e) {\n                        e.printstacktrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private list<field> getfields(class<?> clazz) {\n        // 声明field数组\n        list<field> fields = new arraylist<>();\n        // 如果class类型不为空\n        while (clazz != null) {\n            // 添加属性到属性数组\n            collections.addall(fields, clazz.getdeclaredfields());\n            clazz = clazz.getsuperclass();\n        }\n        return fields;\n    }\n\n}\n\n\n\n# 快速失败(fail fast)\n\nspring validation 默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启 fali fast 模式，一旦校验失败就立即返回。\n\n@bean\npublic validator validator() {\n    validatorfactory validatorfactory = validation.byprovider(hibernatevalidator.class)\n            .configure()\n            // 快速失败模式\n            .failfast(true)\n            .buildvalidatorfactory();\n    return validatorfactory.getvalidator();\n}\n\n\n\n# spring 校验原理\n\n\n# spring 校验使用场景\n\n * spring 常规校验（validator）\n * spring 数据绑定（databinder）\n * spring web 参数绑定（webdatabinder）\n * spring webmvc/webflux 处理方法参数校验\n\n\n# validator 接口设计\n\n * 接口职责\n   * spring 内部校验器接口，通过编程的方式校验目标对象\n * 核心方法\n   * supports(class)：校验目标类能否校验\n   * validate(object,errors)：校验目标对象，并将校验失败的内容输出至 errors 对象\n * 配套组件\n   * 错误收集器：org.springframework.validation.errors\n   * validator 工具类：org.springframework.validation.validationutils\n\n\n# errors 接口设计\n\n * 接口职责\n   * 数据绑定和校验错误收集接口，与 java bean 和其属性有强关联性\n * 核心方法\n   * reject 方法（重载）：收集错误文案\n   * rejectvalue 方法（重载）：收集对象字段中的错误文案\n * 配套组件\n   * java bean 错误描述：org.springframework.validation.objecterror\n   * java bean 属性错误描述：org.springframework.validation.fielderror\n\n\n# errors 文案来源\n\nerrors 文案生成步骤\n\n * 选择 errors 实现（如：org.springframework.validation.beanpropertybindingresult）\n * 调用 reject 或 rejectvalue 方法\n * 获取 errors 对象中 objecterror 或 fielderror\n * 将 objecterror 或 fielderror 中的 code 和 args，关联 messagesource 实现（如：resourcebundlemessagesource）\n\n\n# spring web 校验原理\n\n# requestbody 参数校验实现原理\n\n在 spring-mvc 中，requestresponsebodymethodprocessor 是用于解析 @requestbody 标注的参数以及处理@responsebody 标注方法的返回值的。其中，执行参数校验的逻辑肯定就在解析参数的方法 resolveargument() 中：\n\n@override\npublic object resolveargument(methodparameter parameter, @nullable modelandviewcontainer mavcontainer,\n    nativewebrequest webrequest, @nullable webdatabinderfactory binderfactory) throws exception {\n\n    parameter = parameter.nestedifoptional();\n    object arg = readwithmessageconverters(webrequest, parameter, parameter.getnestedgenericparametertype());\n    string name = conventions.getvariablenameforparameter(parameter);\n\n    if (binderfactory != null) {\n        webdatabinder binder = binderfactory.createbinder(webrequest, arg, name);\n        if (arg != null) {\n            // 尝试进行参数校验\n            validateifapplicable(binder, parameter);\n            if (binder.getbindingresult().haserrors() && isbindexceptionrequired(binder, parameter)) {\n                // 如果存在校验错误，则抛出 methodargumentnotvalidexception\n                throw new methodargumentnotvalidexception(parameter, binder.getbindingresult());\n            }\n        }\n        if (mavcontainer != null) {\n            mavcontainer.addattribute(bindingresult.model_key_prefix + name, binder.getbindingresult());\n        }\n    }\n\n    return adaptargumentifnecessary(arg, parameter);\n}\n\n\n可以看到，resolveargument()调用了 validateifapplicable()进行参数校验。\n\nprotected void validateifapplicable(webdatabinder binder, methodparameter parameter) {\n    // 获取参数注解，如 @requestbody、@valid、@validated\n    annotation[] annotations = parameter.getparameterannotations();\n    for (annotation ann : annotations) {\n        // 先尝试获取 @validated 注解\n        validated validatedann = annotationutils.getannotation(ann, validated.class);\n        // 如果标注了 @validated，直接开始校验。\n        // 如果没有，那么判断参数前是否有 valid 开头的注解。\n        if (validatedann != null || ann.annotationtype().getsimplename().startswith("valid")) {\n            object hints = (validatedann != null ? validatedann.value() : annotationutils.getvalue(ann));\n            object[] validationhints = (hints instanceof object[] ? (object[]) hints : new object[] {hints});\n            // 执行校验\n            binder.validate(validationhints);\n            break;\n        }\n    }\n}\n\n\n以上代码，就解释了 spring 为什么能同时支持 @validated、@valid 两个注解。\n\n接下来，看一下 webdatabinder.validate() 的实现：\n\n@override\npublic void validate(object target, errors errors, object... validationhints) {\n    if (this.targetvalidator != null) {\n        processconstraintviolations(\n            // 此处调用 hibernate validator 执行真正的校验\n            this.targetvalidator.validate(target, asvalidationgroups(validationhints)), errors);\n    }\n}\n\n\n通过上面代码，可以看出 spring 校验实际上是基于 hibernate validator 的封装。\n\n# 方法级别的参数校验实现原理\n\nspring 支持根据方法去进行拦截、校验，原理就在于应用了 aop 技术。具体来说，是通过 methodvalidationpostprocessor 动态注册 aop 切面，然后使用 methodvalidationinterceptor 对切点方法织入增强。\n\npublic class methodvalidationpostprocessor extends abstractbeanfactoryawareadvisingpostprocessorimplements initializingbean {\n    @override\n    public void afterpropertiesset() {\n        // 为所有 @validated 标注的 bean 创建切面\n        pointcut pointcut = new annotationmatchingpointcut(this.validatedannotationtype, true);\n        // 创建 advisor 进行增强\n        this.advisor = new defaultpointcutadvisor(pointcut, createmethodvalidationadvice(this.validator));\n    }\n\n    // 创建 advice，本质就是一个方法拦截器\n    protected advice createmethodvalidationadvice(@nullable validator validator) {\n        return (validator != null ? new methodvalidationinterceptor(validator) : new methodvalidationinterceptor());\n    }\n}\n\n\n接着看一下 methodvalidationinterceptor：\n\npublic class methodvalidationinterceptor implements methodinterceptor {\n    @override\n    public object invoke(methodinvocation invocation) throws throwable {\n        // 无需增强的方法，直接跳过\n        if (isfactorybeanmetadatamethod(invocation.getmethod())) {\n            return invocation.proceed();\n        }\n        // 获取分组信息\n        class<?>[] groups = determinevalidationgroups(invocation);\n        executablevalidator execval = this.validator.forexecutables();\n        method methodtovalidate = invocation.getmethod();\n        set<constraintviolation<object>> result;\n        try {\n            // 方法入参校验，最终还是委托给 hibernate validator 来校验\n            result = execval.validateparameters(\n                invocation.getthis(), methodtovalidate, invocation.getarguments(), groups);\n        }\n        catch (illegalargumentexception ex) {\n            ...\n        }\n        // 有异常直接抛出\n        if (!result.isempty()) {\n            throw new constraintviolationexception(result);\n        }\n        // 真正的方法调用\n        object returnvalue = invocation.proceed();\n        // 对返回值做校验，最终还是委托给hibernate validator来校验\n        result = execval.validatereturnvalue(invocation.getthis(), methodtovalidate, returnvalue, groups);\n        // 有异常直接抛出\n        if (!result.isempty()) {\n            throw new constraintviolationexception(result);\n        }\n        return returnvalue;\n    }\n}\n\n\n实际上，不管是 requestbody 参数校验还是方法级别的校验，最终都是调用 hibernate validator 执行校验，spring validation 只是做了一层封装。\n\n\n# 问题\n\nspring 有哪些校验核心组件？\n\n * 检验器：org.springframework.validation.validator\n * 错误收集器：org.springframework.validation.errors\n * java bean 错误描述：org.springframework.validation.objecterror\n * java bean 属性错误描述：org.springframework.validation.fielderror\n * bean validation 适配：org.springframework.validation.beanvalidation.localvalidatorfactorybean\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》\n * https://juejin.cn/post/6856541106626363399',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 数据绑定",frontmatter:{title:"Spring 数据绑定",date:"2022-12-22T19:26:57.000Z",order:22,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","数据绑定"],permalink:"/pages/267b4c/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/22.Spring%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/22.Spring数据绑定.md",key:"v-12c0ceb0",path:"/pages/267b4c/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:201},{level:2,title:"Spring 数据绑定使用场景",slug:"spring-数据绑定使用场景",normalizedTitle:"spring 数据绑定使用场景",charIndex:848},{level:2,title:"DataBinder",slug:"databinder",normalizedTitle:"databinder",charIndex:120},{level:2,title:"Spring 数据绑定元数据",slug:"spring-数据绑定元数据",normalizedTitle:"spring 数据绑定元数据",charIndex:1607},{level:2,title:"Spring 数据绑定控制参数",slug:"spring-数据绑定控制参数",normalizedTitle:"spring 数据绑定控制参数",charIndex:1996},{level:3,title:"DataBinder 绑定控制参数",slug:"databinder-绑定控制参数",normalizedTitle:"databinder 绑定控制参数",charIndex:2303},{level:2,title:"BeanWrapper 的使用场景",slug:"beanwrapper-的使用场景",normalizedTitle:"beanwrapper 的使用场景",charIndex:2563},{level:2,title:"Spring 底层 Java Beans 替换实现",slug:"spring-底层-java-beans-替换实现",normalizedTitle:"spring 底层 java beans 替换实现",charIndex:2796},{level:2,title:"DataBinder 数据校验",slug:"databinder-数据校验",normalizedTitle:"databinder 数据校验",charIndex:3082},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:3212},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3573}],headersStr:"快速入门 Spring 数据绑定使用场景 DataBinder Spring 数据绑定元数据 Spring 数据绑定控制参数 DataBinder 绑定控制参数 BeanWrapper 的使用场景 Spring 底层 Java Beans 替换实现 DataBinder 数据校验 问题 参考资料",content:'# Spring 数据绑定\n\nSpring 数据绑定(Data Binding)的作用是将用户的输入动态绑定到 JavaBean。换句话说，Spring 数据绑定机制是将属性值设置到目标对象中。\n\n在 Spring 中，数据绑定功能主要由 DataBinder 类实现。此外，BeanWrapper 也具有类似的功能，但 DataBinder 额外支持字段验证、字段格式化和绑定结果分析。\n\n\n\n\n# 快速入门\n\n定义一个用于测试的 JavaBean\n\npublic class TestBean {\n\n    private int num;\n\n    public int getNum() {\n        return num;\n    }\n\n    public void setNum(int num) {\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return "TestBean{" + "num=" + num + \'}\';\n    }\n\n}\n\n\n数据绑定示例\n\npublic class DataBindingDemo {\n\n    public static void main(String[] args) {\n\n        MutablePropertyValues mpv = new MutablePropertyValues();\n        mpv.add("num", "10");\n\n        TestBean testBean = new TestBean();\n        DataBinder db = new DataBinder(testBean);\n\n        db.bind(mpv);\n        System.out.println(testBean);\n    }\n\n}\n\n\n\n# Spring 数据绑定使用场景\n\n * Spring BeanDefinition 到 Bean 实例创建\n * Spring 数据绑定（DataBinder）\n * Spring Web 参数绑定（WebDataBinder）\n\n\n# DataBinder\n\n在 Spring 中，DataBinder 类是数据绑定功能的基类。WebDataBinder 是 DataBinder 的子类，主要用于 Spring Web 数据绑定，此外，还有一些 WebDataBinder 的扩展子类，其类族如下图所示：\n\n\n\nDataBinder 核心属性：\n\n属性                     说明\ntarget                 关联目标 Bean\nobjectName             目标 Bean 名称\nbindingResult          属性绑定结果\ntypeConverter          类型转换器\nconversionService      类型转换服务\nmessageCodesResolver   校验错误文案 Code 处理器\nvalidators             关联的 Bean Validator 实例集合\n\nDataBinder 类的核心方法是 bind(PropertyValues)：将 PropertyValues Key-Value 内容映射到关联 Bean（target）中的属性上\n\n * 假设 PropertyValues 中包含 name=dunwu 的键值对时, 同时 Bean 对象 User 中存在 name 属性, 当 bind 方法执行时, User 对象中的 name 属性值将被绑定为 dunwu\n\n\n# Spring 数据绑定元数据\n\nDataBinder 元数据 - PropertyValues\n\n特征         说明\n数据来源       BeanDefinition，主要来源 XML 资源配置 BeanDefinition\n数据结构       由一个或多个 PropertyValue 组成\n成员结构       PropertyValue 包含属性名称，以及属性值（包括原始值、类型转换后的值）\n常见实现       MutablePropertyValues\nWeb 扩展实现   ServletConfigPropertyValues、ServletRequestParameterPropertyValues\n相关生命周期     InstantiationAwareBeanPostProcessor#postProcessProperties\n\n\n# Spring 数据绑定控制参数\n\nDataBinder 绑定特殊场景分析\n\n * 当 PropertyValues 中包含名称 x 的 PropertyValue，目标对象 B 不存在 x 属性，当 bind 方法执 行时，会发生什么？\n * 当 PropertyValues 中包含名称 x 的 PropertyValue，目标对象 B 中存在 x 属性，当 bind 方法执 行时，如何避免 B 属性 x 不被绑定？\n * 当 PropertyValues 中包含名称 x.y 的 PropertyValue，目标对象 B 中存在 x 属性（嵌套 y 属性） ，当 bind 方法执行时，会发生什么？\n\n\n# DataBinder 绑定控制参数\n\n参数名称                  说明\nignoreUnknownFields   是否忽略未知字段，默认值：true\nignoreInvalidFields   是否忽略非法字段，默认值：false\nautoGrowNestedPaths   是否自动增加嵌套路径，默认值：true\nallowedFields         绑定字段白名单\ndisallowedFields      绑定字段黑名单\nrequiredFields        必须绑定字段\n\n\n# BeanWrapper 的使用场景\n\n * Spring 底层 JavaBeans 基础设施的中心化接口\n * 通常不会直接使用，间接用于 BeanFactory 和 DataBinder\n * 提供标准 JavaBeans 分析和操作，能够单独或批量存储 Java Bean 的属性（properties）\n * 支持嵌套属性路径（nested path）\n * 实现类 org.springframework.beans.BeanWrapperImpl\n\n\n# Spring 底层 Java Beans 替换实现\n\nJavaBeans 核心实现 - java.beans.BeanInfo\n\n * 属性（Property）\n   * java.beans.PropertyEditor\n * 方法（Method）\n * 事件（Event）\n * 表达式（Expression）\n\nSpring 替代实现 - org.springframework.beans.BeanWrapper\n\n * 属性（Property）\n   * java.beans.PropertyEditor\n * 嵌套属性路径（nested path）\n\n\n# DataBinder 数据校验\n\nDataBinder 与 BeanWrapper\n\n * bind 方法生成 BeanPropertyBindingResult\n * BeanPropertyBindingResult 关联 BeanWrapper\n\n\n# 问题\n\n标准 JavaBeans 是如何操作属性的？\n\nAPI                             说明\njava.beans.Introspector         Java Beans 内省 API\njava.beans.BeanInfo             Java Bean 元信息 API\njava.beans.BeanDescriptor       Java Bean 信息描述符\njava.beans.PropertyDescriptor   Java Bean 属性描述符\njava.beans.MethodDescriptor     Java Bean 方法描述符\njava.beans.EventSetDescriptor   Java Bean 事件集合描述符\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 数据绑定\n\nspring 数据绑定(data binding)的作用是将用户的输入动态绑定到 javabean。换句话说，spring 数据绑定机制是将属性值设置到目标对象中。\n\n在 spring 中，数据绑定功能主要由 databinder 类实现。此外，beanwrapper 也具有类似的功能，但 databinder 额外支持字段验证、字段格式化和绑定结果分析。\n\n\n\n\n# 快速入门\n\n定义一个用于测试的 javabean\n\npublic class testbean {\n\n    private int num;\n\n    public int getnum() {\n        return num;\n    }\n\n    public void setnum(int num) {\n        this.num = num;\n    }\n\n    @override\n    public string tostring() {\n        return "testbean{" + "num=" + num + \'}\';\n    }\n\n}\n\n\n数据绑定示例\n\npublic class databindingdemo {\n\n    public static void main(string[] args) {\n\n        mutablepropertyvalues mpv = new mutablepropertyvalues();\n        mpv.add("num", "10");\n\n        testbean testbean = new testbean();\n        databinder db = new databinder(testbean);\n\n        db.bind(mpv);\n        system.out.println(testbean);\n    }\n\n}\n\n\n\n# spring 数据绑定使用场景\n\n * spring beandefinition 到 bean 实例创建\n * spring 数据绑定（databinder）\n * spring web 参数绑定（webdatabinder）\n\n\n# databinder\n\n在 spring 中，databinder 类是数据绑定功能的基类。webdatabinder 是 databinder 的子类，主要用于 spring web 数据绑定，此外，还有一些 webdatabinder 的扩展子类，其类族如下图所示：\n\n\n\ndatabinder 核心属性：\n\n属性                     说明\ntarget                 关联目标 bean\nobjectname             目标 bean 名称\nbindingresult          属性绑定结果\ntypeconverter          类型转换器\nconversionservice      类型转换服务\nmessagecodesresolver   校验错误文案 code 处理器\nvalidators             关联的 bean validator 实例集合\n\ndatabinder 类的核心方法是 bind(propertyvalues)：将 propertyvalues key-value 内容映射到关联 bean（target）中的属性上\n\n * 假设 propertyvalues 中包含 name=dunwu 的键值对时, 同时 bean 对象 user 中存在 name 属性, 当 bind 方法执行时, user 对象中的 name 属性值将被绑定为 dunwu\n\n\n# spring 数据绑定元数据\n\ndatabinder 元数据 - propertyvalues\n\n特征         说明\n数据来源       beandefinition，主要来源 xml 资源配置 beandefinition\n数据结构       由一个或多个 propertyvalue 组成\n成员结构       propertyvalue 包含属性名称，以及属性值（包括原始值、类型转换后的值）\n常见实现       mutablepropertyvalues\nweb 扩展实现   servletconfigpropertyvalues、servletrequestparameterpropertyvalues\n相关生命周期     instantiationawarebeanpostprocessor#postprocessproperties\n\n\n# spring 数据绑定控制参数\n\ndatabinder 绑定特殊场景分析\n\n * 当 propertyvalues 中包含名称 x 的 propertyvalue，目标对象 b 不存在 x 属性，当 bind 方法执 行时，会发生什么？\n * 当 propertyvalues 中包含名称 x 的 propertyvalue，目标对象 b 中存在 x 属性，当 bind 方法执 行时，如何避免 b 属性 x 不被绑定？\n * 当 propertyvalues 中包含名称 x.y 的 propertyvalue，目标对象 b 中存在 x 属性（嵌套 y 属性） ，当 bind 方法执行时，会发生什么？\n\n\n# databinder 绑定控制参数\n\n参数名称                  说明\nignoreunknownfields   是否忽略未知字段，默认值：true\nignoreinvalidfields   是否忽略非法字段，默认值：false\nautogrownestedpaths   是否自动增加嵌套路径，默认值：true\nallowedfields         绑定字段白名单\ndisallowedfields      绑定字段黑名单\nrequiredfields        必须绑定字段\n\n\n# beanwrapper 的使用场景\n\n * spring 底层 javabeans 基础设施的中心化接口\n * 通常不会直接使用，间接用于 beanfactory 和 databinder\n * 提供标准 javabeans 分析和操作，能够单独或批量存储 java bean 的属性（properties）\n * 支持嵌套属性路径（nested path）\n * 实现类 org.springframework.beans.beanwrapperimpl\n\n\n# spring 底层 java beans 替换实现\n\njavabeans 核心实现 - java.beans.beaninfo\n\n * 属性（property）\n   * java.beans.propertyeditor\n * 方法（method）\n * 事件（event）\n * 表达式（expression）\n\nspring 替代实现 - org.springframework.beans.beanwrapper\n\n * 属性（property）\n   * java.beans.propertyeditor\n * 嵌套属性路径（nested path）\n\n\n# databinder 数据校验\n\ndatabinder 与 beanwrapper\n\n * bind 方法生成 beanpropertybindingresult\n * beanpropertybindingresult 关联 beanwrapper\n\n\n# 问题\n\n标准 javabeans 是如何操作属性的？\n\napi                             说明\njava.beans.introspector         java beans 内省 api\njava.beans.beaninfo             java bean 元信息 api\njava.beans.beandescriptor       java bean 信息描述符\njava.beans.propertydescriptor   java bean 属性描述符\njava.beans.methoddescriptor     java bean 方法描述符\njava.beans.eventsetdescriptor   java bean 事件集合描述符\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring EL 表达式",frontmatter:{title:"Spring EL 表达式",date:"2023-01-12T20:26:46.000Z",order:24,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/1f743f/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/24.SpringEL.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/24.SpringEL.md",key:"v-32803cf9",path:"/pages/1f743f/",headers:[{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:20}],headersStr:"参考资料",content:"# Spring EL 表达式\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring el 表达式\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 类型转换",frontmatter:{title:"Spring 类型转换",date:"2022-12-22T19:43:59.000Z",order:23,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/6662dc/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/23.Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/23.Spring类型转换.md",key:"v-1a5daf91",path:"/pages/6662dc/",headers:[{level:2,title:"Spring 类型转换的实现",slug:"spring-类型转换的实现",normalizedTitle:"spring 类型转换的实现",charIndex:18},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:127},{level:2,title:"基于 JavaBeans 接口的类型转换",slug:"基于-javabeans-接口的类型转换",normalizedTitle:"基于 javabeans 接口的类型转换",charIndex:37},{level:2,title:"Spring 內建 PropertyEditor 扩展",slug:"spring-內建-propertyeditor-扩展",normalizedTitle:"spring 內建 propertyeditor 扩展",charIndex:711},{level:2,title:"自定义 PropertyEditor 扩展",slug:"自定义-propertyeditor-扩展",normalizedTitle:"自定义 propertyeditor 扩展",charIndex:1326},{level:2,title:"Spring PropertyEditor 的设计缺陷",slug:"spring-propertyeditor-的设计缺陷",normalizedTitle:"spring propertyeditor 的设计缺陷",charIndex:1792},{level:2,title:"Spring 3 通用类型转换接口",slug:"spring-3-通用类型转换接口",normalizedTitle:"spring 3 通用类型转换接口",charIndex:2044},{level:2,title:"Spring 內建类型转换器",slug:"spring-內建类型转换器",normalizedTitle:"spring 內建类型转换器",charIndex:2448},{level:2,title:"Converter 接口的局限性",slug:"converter-接口的局限性",normalizedTitle:"converter 接口的局限性",charIndex:2681},{level:2,title:"GenericConverter 接口",slug:"genericconverter-接口",normalizedTitle:"genericconverter 接口",charIndex:2930},{level:2,title:"优化 GenericConverter 接口",slug:"优化-genericconverter-接口",normalizedTitle:"优化 genericconverter 接口",charIndex:3309},{level:2,title:"扩展 Spring 类型转换器",slug:"扩展-spring-类型转换器",normalizedTitle:"扩展 spring 类型转换器",charIndex:3608},{level:2,title:"统一类型转换服务",slug:"统一类型转换服务",normalizedTitle:"统一类型转换服务",charIndex:3938},{level:2,title:"ConversionService 作为依赖",slug:"conversionservice-作为依赖",normalizedTitle:"conversionservice 作为依赖",charIndex:4480},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:5315},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5723}],headersStr:"Spring 类型转换的实现 使用场景 基于 JavaBeans 接口的类型转换 Spring 內建 PropertyEditor 扩展 自定义 PropertyEditor 扩展 Spring PropertyEditor 的设计缺陷 Spring 3 通用类型转换接口 Spring 內建类型转换器 Converter 接口的局限性 GenericConverter 接口 优化 GenericConverter 接口 扩展 Spring 类型转换器 统一类型转换服务 ConversionService 作为依赖 问题 参考资料",content:"# Spring 类型转换\n\n\n# Spring 类型转换的实现\n\n * 基于 JavaBeans 接口的类型转换实现\n   * 基于 java.beans.PropertyEditor 接口扩展\n * Spring 3.0+ 通用类型转换实现\n\n\n# 使用场景\n\n场景            基于 JAVABEANS 接口的类型转换实现   SPRING 3.0+ 通用类型转换实现\n数据绑定          YES                      YES\nBeanWrapper   YES                      YES\nBean 属性类型转换   YES                      YES\n外部化属性类型转换     NO                       YES\n\n\n# 基于 JavaBeans 接口的类型转换\n\n核心职责\n\n * 将 String 类型的内容转化为目标类型的对象\n\n扩展原理\n\n * Spring 框架将文本内容传递到 PropertyEditor 实现的 setAsText(String) 方法\n * PropertyEditor#setAsText(String) 方法实现将 String 类型转化为目标类型的对象\n * 将目标类型的对象传入 PropertyEditor#setValue(Object) 方法\n * PropertyEditor#setValue(Object) 方法实现需要临时存储传入对象\n * Spring 框架将通过 PropertyEditor#getValue() 获取类型转换后的对象\n\n\n# Spring 內建 PropertyEditor 扩展\n\n內建扩展（org.springframework.beans.propertyeditors 包下）\n\n转换场景                 实现类\nString -> Byte 数组    org.springframework.beans.propertyeditors.ByteArrayPropertyEditor\nString -> Char       org.springframework.beans.propertyeditors.CharacterEditor\nString -> Char 数组    org.springframework.beans.propertyeditors.CharArrayPropertyEditor\nString -> Charset    org.springframework.beans.propertyeditors.CharsetEditor\nString -> Class      org.springframework.beans.propertyeditors.ClassEditor\nString -> Currency   org.springframework.beans.propertyeditors.CurrencyEditor\n                     \n\n\n# 自定义 PropertyEditor 扩展\n\n扩展模式\n\n * 扩展 java.beans.PropertyEditorSupport 类\n\n实现 org.springframework.beans.PropertyEditorRegistrar\n\n * 实现 registerCustomEditors(org.springframework.beans.PropertyEditorRegistry) 方法\n * 将 PropertyEditorRegistrar 实现注册为 Spring Bean\n\n向 org.springframework.beans.PropertyEditorRegistry 注册自定义 PropertyEditor 实现\n\n * 通用类型实现 registerCustomEditor(Class<?>, PropertyEditor)\n * Java Bean 属性类型实现：registerCustomEditor(Class<?>, String, PropertyEditor)\n\n\n# Spring PropertyEditor 的设计缺陷\n\n违反职责单一原则\n\n * java.beans.PropertyEditor 接口职责太多，除了类型转换，还包括 Java Beans 事件和 Java GUI 交 互\n\njava.beans.PropertyEditor 实现类型局限\n\n * 来源类型只能为 java.lang.String 类型\n\njava.beans.PropertyEditor 实现缺少类型安全\n\n * 除了实现类命名可以表达语义，实现类无法感知目标转换类型\n\n\n# Spring 3 通用类型转换接口\n\n类型转换接口 - org.springframework.core.convert.converter.Converter<S,T>\n\n * 泛型参数 S：来源类型，参数 T：目标类型\n * 核心方法：T convert(S)\n\n通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter\n\n * 核心方法：convert(Object,TypeDescriptor,TypeDescriptor)\n * 配对类型：org.springframework.core.convert.converter.GenericConverter.ConvertiblePair\n * 类型描述：org.springframework.core.convert.TypeDescriptor\n\n\n# Spring 內建类型转换器\n\n內建扩展\n\n转换场景             实现类所在包名（PACKAGE）\n日期/时间相关          org.springframework.format.datetime\nJava 8 日期/时间相关   org.springframework.format.datetime.standard\n通用实现             org.springframework.core.convert.support\n\n\n# Converter 接口的局限性\n\n局限一：缺少 Source Type 和 Target Type 前置判断\n\n * 应对：增加 org.springframework.core.convert.converter.ConditionalConverter 实现\n\n局限二：仅能转换单一的 Source Type 和 Target Type\n\n * 应对：使用 org.springframework.core.convert.converter.GenericConverter 代替\n\n\n# GenericConverter 接口\n\norg.springframework.core.convert.converter.GenericConverter\n\n核心要素   说明\n使用场景   用于“复合”类型转换场景，比如 Collection、Map、数组等\n转换范围   Set<ConvertiblePair> getConvertibleTypes()\n配对类型   org.springframework.core.convert.converter.GenericConverter.ConvertiblePair\n转换方法   convert(Object,TypeDescriptor,TypeDescriptor)\n类型描述   org.springframework.core.convert.TypeDescriptor\n\n\n# 优化 GenericConverter 接口\n\nGenericConverter 局限性\n\n * 缺少 Source Type 和 Target Type 前置判断\n * 单一类型转换实现复杂\n\nGenericConverter 优化接口 - ConditionalGenericConverter\n\n * 复合类型转换：org.springframework.core.convert.converter.GenericConverter\n * 类型条件判断：org.springframework.core.convert.converter.ConditionalConverter\n\n\n# 扩展 Spring 类型转换器\n\n实现转换器接口\n\n * org.springframework.core.convert.converter.Converter\n * org.springframework.core.convert.converter.ConverterFactory\n * org.springframework.core.convert.converter.GenericConverter\n\n注册转换器实现\n\n * 通过 ConversionServiceFactoryBean Spring Bean\n * 通过 org.springframework.core.convert.ConversionService API\n\n\n# 统一类型转换服务\n\norg.springframework.core.convert.ConversionService\n\n实现类型                                 说明\nGenericConversionService             通用 ConversionService 模板实现，不内置转化器实现\nDefaultConversionService             基础 ConversionService 实现，内置常用转化器实现\nFormattingConversionService          通用 Formatter + GenericConversionService 实现，不内置转化器和 Formatter\n                                     实现\nDefaultFormattingConversionService   DefaultConversionService + 格式化 实现（如：JSR-354 Money &\n                                     Currency, JSR-310 Date-Time）\n\n\n# ConversionService 作为依赖\n\n类型转换器底层接口 - org.springframework.beans.TypeConverter\n\n * 起始版本：Spring 2.0\n * 核心方法 - convertIfNecessary 重载方法\n * 抽象实现 - org.springframework.beans.TypeConverterSupport\n * 简单实现 - org.springframework.beans.SimpleTypeConverter\n\n类型转换器底层抽象实现 - org.springframework.beans.TypeConverterSupport\n\n * 实现接口 - org.springframework.beans.TypeConverter\n * 扩展实现 - org.springframework.beans.PropertyEditorRegistrySupport\n * 委派实现 - org.springframework.beans.TypeConverterDelegate\n\n类型转换器底层委派实现 - org.springframework.beans.TypeConverterDelegate\n\n * 构造来源 - org.springframework.beans.AbstractNestablePropertyAccessor 实现\n   * org.springframework.beans.BeanWrapperImpl\n * 依赖 - java.beans.PropertyEditor 实现\n   * 默认內建实现 - PropertyEditorRegistrySupport#registerDefaultEditors\n * 可选依赖 - org.springframework.core.convert.ConversionService 实现\n\n\n# 问题\n\nSpring 类型转换实现有哪些？\n\n * 基于 JavaBeans PropertyEditor 接口实现\n * Spring 3.0+ 通用类型转换实现\n\nSpring 类型转换器接口有哪些？\n\n * 类型转换接口 - org.springframework.core.convert.converter.Converter\n * 通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter\n * 类型条件接口 - org.springframework.core.convert.converter.ConditionalConverter\n * 综合类型转换接口 - org.springframework.core.convert.converter.ConditionalGenericConverter\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 类型转换\n\n\n# spring 类型转换的实现\n\n * 基于 javabeans 接口的类型转换实现\n   * 基于 java.beans.propertyeditor 接口扩展\n * spring 3.0+ 通用类型转换实现\n\n\n# 使用场景\n\n场景            基于 javabeans 接口的类型转换实现   spring 3.0+ 通用类型转换实现\n数据绑定          yes                      yes\nbeanwrapper   yes                      yes\nbean 属性类型转换   yes                      yes\n外部化属性类型转换     no                       yes\n\n\n# 基于 javabeans 接口的类型转换\n\n核心职责\n\n * 将 string 类型的内容转化为目标类型的对象\n\n扩展原理\n\n * spring 框架将文本内容传递到 propertyeditor 实现的 setastext(string) 方法\n * propertyeditor#setastext(string) 方法实现将 string 类型转化为目标类型的对象\n * 将目标类型的对象传入 propertyeditor#setvalue(object) 方法\n * propertyeditor#setvalue(object) 方法实现需要临时存储传入对象\n * spring 框架将通过 propertyeditor#getvalue() 获取类型转换后的对象\n\n\n# spring 內建 propertyeditor 扩展\n\n內建扩展（org.springframework.beans.propertyeditors 包下）\n\n转换场景                 实现类\nstring -> byte 数组    org.springframework.beans.propertyeditors.bytearraypropertyeditor\nstring -> char       org.springframework.beans.propertyeditors.charactereditor\nstring -> char 数组    org.springframework.beans.propertyeditors.chararraypropertyeditor\nstring -> charset    org.springframework.beans.propertyeditors.charseteditor\nstring -> class      org.springframework.beans.propertyeditors.classeditor\nstring -> currency   org.springframework.beans.propertyeditors.currencyeditor\n                     \n\n\n# 自定义 propertyeditor 扩展\n\n扩展模式\n\n * 扩展 java.beans.propertyeditorsupport 类\n\n实现 org.springframework.beans.propertyeditorregistrar\n\n * 实现 registercustomeditors(org.springframework.beans.propertyeditorregistry) 方法\n * 将 propertyeditorregistrar 实现注册为 spring bean\n\n向 org.springframework.beans.propertyeditorregistry 注册自定义 propertyeditor 实现\n\n * 通用类型实现 registercustomeditor(class<?>, propertyeditor)\n * java bean 属性类型实现：registercustomeditor(class<?>, string, propertyeditor)\n\n\n# spring propertyeditor 的设计缺陷\n\n违反职责单一原则\n\n * java.beans.propertyeditor 接口职责太多，除了类型转换，还包括 java beans 事件和 java gui 交 互\n\njava.beans.propertyeditor 实现类型局限\n\n * 来源类型只能为 java.lang.string 类型\n\njava.beans.propertyeditor 实现缺少类型安全\n\n * 除了实现类命名可以表达语义，实现类无法感知目标转换类型\n\n\n# spring 3 通用类型转换接口\n\n类型转换接口 - org.springframework.core.convert.converter.converter<s,t>\n\n * 泛型参数 s：来源类型，参数 t：目标类型\n * 核心方法：t convert(s)\n\n通用类型转换接口 - org.springframework.core.convert.converter.genericconverter\n\n * 核心方法：convert(object,typedescriptor,typedescriptor)\n * 配对类型：org.springframework.core.convert.converter.genericconverter.convertiblepair\n * 类型描述：org.springframework.core.convert.typedescriptor\n\n\n# spring 內建类型转换器\n\n內建扩展\n\n转换场景             实现类所在包名（package）\n日期/时间相关          org.springframework.format.datetime\njava 8 日期/时间相关   org.springframework.format.datetime.standard\n通用实现             org.springframework.core.convert.support\n\n\n# converter 接口的局限性\n\n局限一：缺少 source type 和 target type 前置判断\n\n * 应对：增加 org.springframework.core.convert.converter.conditionalconverter 实现\n\n局限二：仅能转换单一的 source type 和 target type\n\n * 应对：使用 org.springframework.core.convert.converter.genericconverter 代替\n\n\n# genericconverter 接口\n\norg.springframework.core.convert.converter.genericconverter\n\n核心要素   说明\n使用场景   用于“复合”类型转换场景，比如 collection、map、数组等\n转换范围   set<convertiblepair> getconvertibletypes()\n配对类型   org.springframework.core.convert.converter.genericconverter.convertiblepair\n转换方法   convert(object,typedescriptor,typedescriptor)\n类型描述   org.springframework.core.convert.typedescriptor\n\n\n# 优化 genericconverter 接口\n\ngenericconverter 局限性\n\n * 缺少 source type 和 target type 前置判断\n * 单一类型转换实现复杂\n\ngenericconverter 优化接口 - conditionalgenericconverter\n\n * 复合类型转换：org.springframework.core.convert.converter.genericconverter\n * 类型条件判断：org.springframework.core.convert.converter.conditionalconverter\n\n\n# 扩展 spring 类型转换器\n\n实现转换器接口\n\n * org.springframework.core.convert.converter.converter\n * org.springframework.core.convert.converter.converterfactory\n * org.springframework.core.convert.converter.genericconverter\n\n注册转换器实现\n\n * 通过 conversionservicefactorybean spring bean\n * 通过 org.springframework.core.convert.conversionservice api\n\n\n# 统一类型转换服务\n\norg.springframework.core.convert.conversionservice\n\n实现类型                                 说明\ngenericconversionservice             通用 conversionservice 模板实现，不内置转化器实现\ndefaultconversionservice             基础 conversionservice 实现，内置常用转化器实现\nformattingconversionservice          通用 formatter + genericconversionservice 实现，不内置转化器和 formatter\n                                     实现\ndefaultformattingconversionservice   defaultconversionservice + 格式化 实现（如：jsr-354 money &\n                                     currency, jsr-310 date-time）\n\n\n# conversionservice 作为依赖\n\n类型转换器底层接口 - org.springframework.beans.typeconverter\n\n * 起始版本：spring 2.0\n * 核心方法 - convertifnecessary 重载方法\n * 抽象实现 - org.springframework.beans.typeconvertersupport\n * 简单实现 - org.springframework.beans.simpletypeconverter\n\n类型转换器底层抽象实现 - org.springframework.beans.typeconvertersupport\n\n * 实现接口 - org.springframework.beans.typeconverter\n * 扩展实现 - org.springframework.beans.propertyeditorregistrysupport\n * 委派实现 - org.springframework.beans.typeconverterdelegate\n\n类型转换器底层委派实现 - org.springframework.beans.typeconverterdelegate\n\n * 构造来源 - org.springframework.beans.abstractnestablepropertyaccessor 实现\n   * org.springframework.beans.beanwrapperimpl\n * 依赖 - java.beans.propertyeditor 实现\n   * 默认內建实现 - propertyeditorregistrysupport#registerdefaulteditors\n * 可选依赖 - org.springframework.core.convert.conversionservice 实现\n\n\n# 问题\n\nspring 类型转换实现有哪些？\n\n * 基于 javabeans propertyeditor 接口实现\n * spring 3.0+ 通用类型转换实现\n\nspring 类型转换器接口有哪些？\n\n * 类型转换接口 - org.springframework.core.convert.converter.converter\n * 通用类型转换接口 - org.springframework.core.convert.converter.genericconverter\n * 类型条件接口 - org.springframework.core.convert.converter.conditionalconverter\n * 综合类型转换接口 - org.springframework.core.convert.converter.conditionalgenericconverter\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 事件",frontmatter:{title:"Spring 事件",date:"2022-12-22T20:31:02.000Z",order:25,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/cca414/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/25.Spring%E4%BA%8B%E4%BB%B6.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/25.Spring事件.md",key:"v-26a96ffb",path:"/pages/cca414/",headers:[{level:2,title:"Java 事件/监听器编程模型",slug:"java-事件-监听器编程模型",normalizedTitle:"java 事件/监听器编程模型",charIndex:16},{level:2,title:"面向接口的事件/监听器设计模式",slug:"面向接口的事件-监听器设计模式",normalizedTitle:"面向接口的事件/监听器设计模式",charIndex:195},{level:2,title:"面向注解的事件/监听器设计模式",slug:"面向注解的事件-监听器设计模式",normalizedTitle:"面向注解的事件/监听器设计模式",charIndex:659},{level:2,title:"Spring 标准事件 - ApplicationEvent",slug:"spring-标准事件-applicationevent",normalizedTitle:"spring 标准事件 - applicationevent",charIndex:1030},{level:2,title:"基于接口的 Spring 事件监听器",slug:"基于接口的-spring-事件监听器",normalizedTitle:"基于接口的 spring 事件监听器",charIndex:1458},{level:2,title:"基于注解的 Spring 事件监听器",slug:"基于注解的-spring-事件监听器",normalizedTitle:"基于注解的 spring 事件监听器",charIndex:1696},{level:2,title:"注册 Spring ApplicationListener",slug:"注册-spring-applicationlistener",normalizedTitle:"注册 spring applicationlistener",charIndex:1921},{level:2,title:"Spring 事件发布器",slug:"spring-事件发布器",normalizedTitle:"spring 事件发布器",charIndex:2049},{level:2,title:"Spring 层次性上下文事件传播",slug:"spring-层次性上下文事件传播",normalizedTitle:"spring 层次性上下文事件传播",charIndex:2273},{level:2,title:"Spring 内建事件",slug:"spring-内建事件",normalizedTitle:"spring 内建事件",charIndex:2536},{level:2,title:"Spring 4.2 Payload 事件",slug:"spring-4-2-payload-事件",normalizedTitle:"spring 4.2 payload 事件",charIndex:2748},{level:2,title:"自定义 Spring 事件",slug:"自定义-spring-事件",normalizedTitle:"自定义 spring 事件",charIndex:2944},{level:2,title:"依赖注入 ApplicationEventPublisher",slug:"依赖注入-applicationeventpublisher",normalizedTitle:"依赖注入 applicationeventpublisher",charIndex:3122},{level:2,title:"依赖查找 ApplicationEventMulticaster",slug:"依赖查找-applicationeventmulticaster",normalizedTitle:"依赖查找 applicationeventmulticaster",charIndex:3243},{level:2,title:"ApplicationEventPublisher 底层实现",slug:"applicationeventpublisher-底层实现",normalizedTitle:"applicationeventpublisher 底层实现",charIndex:3401},{level:2,title:"同步和异步 Spring 事件广播",slug:"同步和异步-spring-事件广播",normalizedTitle:"同步和异步 spring 事件广播",charIndex:3657},{level:2,title:"Spring 4.1 事件异常处理",slug:"spring-4-1-事件异常处理",normalizedTitle:"spring 4.1 事件异常处理",charIndex:4063},{level:2,title:"Spring 事件/监听器实现原理",slug:"spring-事件-监听器实现原理",normalizedTitle:"spring 事件/监听器实现原理",charIndex:4396},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:4761},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6092}],headersStr:"Java 事件/监听器编程模型 面向接口的事件/监听器设计模式 面向注解的事件/监听器设计模式 Spring 标准事件 - ApplicationEvent 基于接口的 Spring 事件监听器 基于注解的 Spring 事件监听器 注册 Spring ApplicationListener Spring 事件发布器 Spring 层次性上下文事件传播 Spring 内建事件 Spring 4.2 Payload 事件 自定义 Spring 事件 依赖注入 ApplicationEventPublisher 依赖查找 ApplicationEventMulticaster ApplicationEventPublisher 底层实现 同步和异步 Spring 事件广播 Spring 4.1 事件异常处理 Spring 事件/监听器实现原理 问题 参考资料",content:'# Spring 事件\n\n\n# Java 事件/监听器编程模型\n\n设计模式 - 观察者模式扩展\n\n * 可观者对象（消息发送者） - java.util.Observable\n * 观察者 - java.util.Observer\n\n标准化接口\n\n * 事件对象 - java.util.EventObject\n * 事件监听器 - java.util.EventListener\n\n\n# 面向接口的事件/监听器设计模式\n\n事件/监听器场景举例\n\nJAVA 技术规范         事件接口                                    监听器接口\nJavaBeans         java.beans.PropertyChangeEvent          java.beans.PropertyChangeListener\nJava AWT          java.awt.event.MouseEvent               java.awt.event.MouseListener\nJava Swing        javax.swing.event.MenuEvent             javax.swing.event.MenuListener\nJava Preference   java.util.prefs.PreferenceChangeEvent   java.util.prefs.PreferenceChangeListener\n\n\n# 面向注解的事件/监听器设计模式\n\n事件/监听器注解场景举例\n\nJAVA 技术规范      事件注解                             监听器注解\nServlet 3.0+                                    @javax.servlet.annotation.WebListener\nJPA 1.0+       @javax.persistence.PostPersist   \nJava Common    @PostConstruct                   \nEJB 3.0+       @javax.ejb.PrePassivate          \nJSF 2.0+       @javax.faces.event.ListenerFor   \n\n\n# Spring 标准事件 - ApplicationEvent\n\nJava 标准事件 java.util.EventObject 扩展\n\n * 扩展特性：事件发生事件戳\n * Spring 应用上下文 ApplicationEvent 扩展 - ApplicationContextEvent\n * Spring 应用上下文（ApplicationContext）作为事件源\n\n具体实现：\n\n * org.springframework.context.event.ContextClosedEvent\n * org.springframework.context.event.ContextRefreshedEvent\n * org.springframework.context.event.ContextStartedEvent\n * org.springframework.context.event.ContextStoppedEvent\n\n\n# 基于接口的 Spring 事件监听器\n\nJava 标准事件监听器 java.util.EventListener 扩展\n\n * 扩展接口 - org.springframework.context.ApplicationListener\n * 设计特点：单一类型事件处理\n * 处理方法：onApplicationEvent(ApplicationEvent)\n * 事件类型：org.springframework.context.ApplicationEvent\n\n\n# 基于注解的 Spring 事件监听器\n\nSpring 注解 - @org.springframework.context.event.EventListener\n\n特性           说明\n设计特点         支持多 ApplicationEvent 类型，无需接口约束\n注解目标         方法\n是否支持异步执行     支持\n是否支持泛型类型事件   支持\n是指支持顺序控制     支持，配合 @Order 注解控制\n\n\n# 注册 Spring ApplicationListener\n\n * 方法一：ApplicationListener 作为 Spring Bean 注册\n * 方法二：通过 ConfigurableApplicationContext API 注册\n\n\n# Spring 事件发布器\n\n * 方法一：通过 ApplicationEventPublisher 发布 Spring 事件\n   * 获取 ApplicationEventPublisher\n     * 依赖注入\n * 方法二：通过 ApplicationEventMulticaster 发布 Spring 事件\n   * 获取 ApplicationEventMulticaster\n     * 依赖注入\n     * 依赖查找\n\n\n# Spring 层次性上下文事件传播\n\n * 发生说明\n * 当 Spring 应用出现多层次 Spring 应用上下文（ApplicationContext）时，如 Spring WebMVC、Spring Boot 或 Spring Cloud 场景下，由子 ApplicationContext 发起 Spring 事件可能会传递到其 Parent ApplicationContext（直到 Root）的过程\n * 如何避免\n * 定位 Spring 事件源（ApplicationContext）进行过滤处理\n\n\n# Spring 内建事件\n\nApplicationContextEvent 派生事件\n\n * ContextRefreshedEvent ：Spring 应用上下文就绪事件\n * ContextStartedEvent ：Spring 应用上下文启动事件\n * ContextStoppedEvent ：Spring 应用上下文停止事件\n * ContextClosedEvent ：Spring 应用上下文关闭事件\n\n\n# Spring 4.2 Payload 事件\n\nSpring Payload 事件 - org.springframework.context.PayloadApplicationEvent\n\n * 使用场景：简化 Spring 事件发送，关注事件源主体\n * 发送方法：ApplicationEventPublisher#publishEvent(java.lang.Object)\n\n\n# 自定义 Spring 事件\n\n * 扩展 org.springframework.context.ApplicationEvent\n * 实现 org.springframework.context.ApplicationListener\n * 注册 org.springframework.context.ApplicationListener\n\n\n# 依赖注入 ApplicationEventPublisher\n\n * 通过 ApplicationEventPublisherAware 回调接口\n * 通过 @Autowired ApplicationEventPublisher\n\n\n# 依赖查找 ApplicationEventMulticaster\n\n查找条件\n\n * Bean 名称："applicationEventMulticaster"\n * Bean 类型：org.springframework.context.event.ApplicationEventMulticaster\n\n\n# ApplicationEventPublisher 底层实现\n\n * 接口：org.springframework.context.event.ApplicationEventMulticaster\n * 抽象类：org.springframework.context.event.AbstractApplicationEventMulticaster\n * 实现类：org.springframework.context.event.SimpleApplicationEventMulticaster\n\n\n# 同步和异步 Spring 事件广播\n\n基于实现类 - org.springframework.context.event.SimpleApplicationEventMulticaster\n\n * 模式切换：setTaskExecutor(java.util.concurrent.Executor) 方法\n   * 默认模式：同步\n   * 异步模式：如 java.util.concurrent.ThreadPoolExecutor\n * 设计缺陷：非基于接口契约编程\n\n基于注解 - @org.springframework.context.event.EventListener\n\n * 模式切换\n   * 默认模式：同步\n   * 异步模式：标注 @org.springframework.scheduling.annotation.Async\n * 实现限制：无法直接实现同步/异步动态切换\n\n\n# Spring 4.1 事件异常处理\n\nSpring 3.0 错误处理接口 - org.springframework.util.ErrorHandler\n\n使用场景\n\n * Spring 事件（Events）\n   * SimpleApplicationEventMulticaster Spring 4.1 开始支持\n * Spring 本地调度（Scheduling）\n   * org.springframework.scheduling.concurrent.ConcurrentTaskScheduler\n   * org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler\n\n\n# Spring 事件/监听器实现原理\n\n核心类 - org.springframework.context.event.SimpleApplicationEventMulticaster\n\n * 设计模式：观察者模式扩展\n   * 被观察者 - org.springframework.context.ApplicationListener\n     * API 添加\n     * 依赖查找\n   * 通知对象 - org.springframework.context.ApplicationEvent\n * 执行模式：同步/异步\n * 异常处理：org.springframework.util.ErrorHandler\n * 泛型处理：org.springframework.core.ResolvableType\n\n\n# 问题\n\nSpring Boot 事件\n\n事件类型                                  发生时机\nApplicationStartingEvent              当 Spring Boot 应用已启动时\nApplicationStartedEvent               当 Spring Boot 应用已启动时\nApplicationEnvironmentPreparedEvent   当 Spring Boot Environment 实例已准备时\nApplicationPreparedEvent              当 Spring Boot 应用预备时\nApplicationReadyEvent                 当 Spring Boot 应用完全可用时\nApplicationFailedEvent                当 Spring Boot 应用启动失败时\n\nSpring Cloud 事件\n\n事件类型                         发生时机\nEnvironmentChangeEvent       当 Environment 示例配置属性发生变化时\nHeartbeatEvent               当 DiscoveryClient 客户端发送心跳时\nInstancePreRegisteredEvent   当服务实例注册前\nInstanceRegisteredEvent      当服务实例注册后\nRefreshEvent                 当 RefreshEndpoint 被调用时\nRefreshScopeRefreshedEvent   当 Refresh Scope Bean 刷新后\n\nSpring 事件核心接口/组件？\n\n * Spring 事件 - org.springframework.context.ApplicationEvent\n * Spring 事件监听器 - org.springframework.context.ApplicationListener\n * Spring 事件发布器 - org.springframework.context.ApplicationEventPublisher\n * Spring 事件广播器 - org.springframework.context.event.ApplicationEventMulticaster\n\nSpring 同步和异步事件处理的使用场景？\n\n * Spring 同步事件 - 绝大多数 Spring 使用场景，如 ContextRefreshedEvent\n * Spring 异步事件 - 主要 @EventListener 与 @Async 配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整 SimpleApplicationEventMulticaster 中关联的 taskExecutor 对象，除非使用者非常了解 Spring 事件机制，否则容易出现异常行为。\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》',normalizedContent:'# spring 事件\n\n\n# java 事件/监听器编程模型\n\n设计模式 - 观察者模式扩展\n\n * 可观者对象（消息发送者） - java.util.observable\n * 观察者 - java.util.observer\n\n标准化接口\n\n * 事件对象 - java.util.eventobject\n * 事件监听器 - java.util.eventlistener\n\n\n# 面向接口的事件/监听器设计模式\n\n事件/监听器场景举例\n\njava 技术规范         事件接口                                    监听器接口\njavabeans         java.beans.propertychangeevent          java.beans.propertychangelistener\njava awt          java.awt.event.mouseevent               java.awt.event.mouselistener\njava swing        javax.swing.event.menuevent             javax.swing.event.menulistener\njava preference   java.util.prefs.preferencechangeevent   java.util.prefs.preferencechangelistener\n\n\n# 面向注解的事件/监听器设计模式\n\n事件/监听器注解场景举例\n\njava 技术规范      事件注解                             监听器注解\nservlet 3.0+                                    @javax.servlet.annotation.weblistener\njpa 1.0+       @javax.persistence.postpersist   \njava common    @postconstruct                   \nejb 3.0+       @javax.ejb.prepassivate          \njsf 2.0+       @javax.faces.event.listenerfor   \n\n\n# spring 标准事件 - applicationevent\n\njava 标准事件 java.util.eventobject 扩展\n\n * 扩展特性：事件发生事件戳\n * spring 应用上下文 applicationevent 扩展 - applicationcontextevent\n * spring 应用上下文（applicationcontext）作为事件源\n\n具体实现：\n\n * org.springframework.context.event.contextclosedevent\n * org.springframework.context.event.contextrefreshedevent\n * org.springframework.context.event.contextstartedevent\n * org.springframework.context.event.contextstoppedevent\n\n\n# 基于接口的 spring 事件监听器\n\njava 标准事件监听器 java.util.eventlistener 扩展\n\n * 扩展接口 - org.springframework.context.applicationlistener\n * 设计特点：单一类型事件处理\n * 处理方法：onapplicationevent(applicationevent)\n * 事件类型：org.springframework.context.applicationevent\n\n\n# 基于注解的 spring 事件监听器\n\nspring 注解 - @org.springframework.context.event.eventlistener\n\n特性           说明\n设计特点         支持多 applicationevent 类型，无需接口约束\n注解目标         方法\n是否支持异步执行     支持\n是否支持泛型类型事件   支持\n是指支持顺序控制     支持，配合 @order 注解控制\n\n\n# 注册 spring applicationlistener\n\n * 方法一：applicationlistener 作为 spring bean 注册\n * 方法二：通过 configurableapplicationcontext api 注册\n\n\n# spring 事件发布器\n\n * 方法一：通过 applicationeventpublisher 发布 spring 事件\n   * 获取 applicationeventpublisher\n     * 依赖注入\n * 方法二：通过 applicationeventmulticaster 发布 spring 事件\n   * 获取 applicationeventmulticaster\n     * 依赖注入\n     * 依赖查找\n\n\n# spring 层次性上下文事件传播\n\n * 发生说明\n * 当 spring 应用出现多层次 spring 应用上下文（applicationcontext）时，如 spring webmvc、spring boot 或 spring cloud 场景下，由子 applicationcontext 发起 spring 事件可能会传递到其 parent applicationcontext（直到 root）的过程\n * 如何避免\n * 定位 spring 事件源（applicationcontext）进行过滤处理\n\n\n# spring 内建事件\n\napplicationcontextevent 派生事件\n\n * contextrefreshedevent ：spring 应用上下文就绪事件\n * contextstartedevent ：spring 应用上下文启动事件\n * contextstoppedevent ：spring 应用上下文停止事件\n * contextclosedevent ：spring 应用上下文关闭事件\n\n\n# spring 4.2 payload 事件\n\nspring payload 事件 - org.springframework.context.payloadapplicationevent\n\n * 使用场景：简化 spring 事件发送，关注事件源主体\n * 发送方法：applicationeventpublisher#publishevent(java.lang.object)\n\n\n# 自定义 spring 事件\n\n * 扩展 org.springframework.context.applicationevent\n * 实现 org.springframework.context.applicationlistener\n * 注册 org.springframework.context.applicationlistener\n\n\n# 依赖注入 applicationeventpublisher\n\n * 通过 applicationeventpublisheraware 回调接口\n * 通过 @autowired applicationeventpublisher\n\n\n# 依赖查找 applicationeventmulticaster\n\n查找条件\n\n * bean 名称："applicationeventmulticaster"\n * bean 类型：org.springframework.context.event.applicationeventmulticaster\n\n\n# applicationeventpublisher 底层实现\n\n * 接口：org.springframework.context.event.applicationeventmulticaster\n * 抽象类：org.springframework.context.event.abstractapplicationeventmulticaster\n * 实现类：org.springframework.context.event.simpleapplicationeventmulticaster\n\n\n# 同步和异步 spring 事件广播\n\n基于实现类 - org.springframework.context.event.simpleapplicationeventmulticaster\n\n * 模式切换：settaskexecutor(java.util.concurrent.executor) 方法\n   * 默认模式：同步\n   * 异步模式：如 java.util.concurrent.threadpoolexecutor\n * 设计缺陷：非基于接口契约编程\n\n基于注解 - @org.springframework.context.event.eventlistener\n\n * 模式切换\n   * 默认模式：同步\n   * 异步模式：标注 @org.springframework.scheduling.annotation.async\n * 实现限制：无法直接实现同步/异步动态切换\n\n\n# spring 4.1 事件异常处理\n\nspring 3.0 错误处理接口 - org.springframework.util.errorhandler\n\n使用场景\n\n * spring 事件（events）\n   * simpleapplicationeventmulticaster spring 4.1 开始支持\n * spring 本地调度（scheduling）\n   * org.springframework.scheduling.concurrent.concurrenttaskscheduler\n   * org.springframework.scheduling.concurrent.threadpooltaskscheduler\n\n\n# spring 事件/监听器实现原理\n\n核心类 - org.springframework.context.event.simpleapplicationeventmulticaster\n\n * 设计模式：观察者模式扩展\n   * 被观察者 - org.springframework.context.applicationlistener\n     * api 添加\n     * 依赖查找\n   * 通知对象 - org.springframework.context.applicationevent\n * 执行模式：同步/异步\n * 异常处理：org.springframework.util.errorhandler\n * 泛型处理：org.springframework.core.resolvabletype\n\n\n# 问题\n\nspring boot 事件\n\n事件类型                                  发生时机\napplicationstartingevent              当 spring boot 应用已启动时\napplicationstartedevent               当 spring boot 应用已启动时\napplicationenvironmentpreparedevent   当 spring boot environment 实例已准备时\napplicationpreparedevent              当 spring boot 应用预备时\napplicationreadyevent                 当 spring boot 应用完全可用时\napplicationfailedevent                当 spring boot 应用启动失败时\n\nspring cloud 事件\n\n事件类型                         发生时机\nenvironmentchangeevent       当 environment 示例配置属性发生变化时\nheartbeatevent               当 discoveryclient 客户端发送心跳时\ninstancepreregisteredevent   当服务实例注册前\ninstanceregisteredevent      当服务实例注册后\nrefreshevent                 当 refreshendpoint 被调用时\nrefreshscoperefreshedevent   当 refresh scope bean 刷新后\n\nspring 事件核心接口/组件？\n\n * spring 事件 - org.springframework.context.applicationevent\n * spring 事件监听器 - org.springframework.context.applicationlistener\n * spring 事件发布器 - org.springframework.context.applicationeventpublisher\n * spring 事件广播器 - org.springframework.context.event.applicationeventmulticaster\n\nspring 同步和异步事件处理的使用场景？\n\n * spring 同步事件 - 绝大多数 spring 使用场景，如 contextrefreshedevent\n * spring 异步事件 - 主要 @eventlistener 与 @async 配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整 simpleapplicationeventmulticaster 中关联的 taskexecutor 对象，除非使用者非常了解 spring 事件机制，否则容易出现异常行为。\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 国际化",frontmatter:{title:"Spring 国际化",date:"2022-12-22T11:44:54.000Z",order:26,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/b5b8ad/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/26.Spring%E5%9B%BD%E9%99%85%E5%8C%96.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/26.Spring国际化.md",key:"v-77b7c09e",path:"/pages/b5b8ad/",headers:[{level:2,title:"Spring 国际化使用场景",slug:"spring-国际化使用场景",normalizedTitle:"spring 国际化使用场景",charIndex:17},{level:2,title:"Spring 国际化接口",slug:"spring-国际化接口",normalizedTitle:"spring 国际化接口",charIndex:107},{level:2,title:"层次性 MessageSource",slug:"层次性-messagesource",normalizedTitle:"层次性 messagesource",charIndex:235},{level:2,title:"Java 国际化标准实现",slug:"java-国际化标准实现",normalizedTitle:"java 国际化标准实现",charIndex:530},{level:2,title:"Java 文本格式化",slug:"java-文本格式化",normalizedTitle:"java 文本格式化",charIndex:871},{level:2,title:"MessageSource 开箱即用实现",slug:"messagesource-开箱即用实现",normalizedTitle:"messagesource 开箱即用实现",charIndex:1288},{level:2,title:"MessageSource 內建依赖",slug:"messagesource-內建依赖",normalizedTitle:"messagesource 內建依赖",charIndex:1569},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:1740},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2541}],headersStr:"Spring 国际化使用场景 Spring 国际化接口 层次性 MessageSource Java 国际化标准实现 Java 文本格式化 MessageSource 开箱即用实现 MessageSource 內建依赖 问题 参考资料",content:"# Spring 国际化\n\n\n# Spring 国际化使用场景\n\n * 普通国际化文案\n * Bean Validation 校验国际化文案\n * Web 站点页面渲染\n * Web MVC 错误消息提示\n\n\n# Spring 国际化接口\n\n * 核心接口：org.springframework.context.MessageSource\n * 主要概念\n   * 文案模板编码（code）\n   * 文案模板参数（args）\n   * 区域（Locale）\n\n\n# 层次性 MessageSource\n\n * Spring 层次性接口回顾\n   * org.springframework.beans.factory.HierarchicalBeanFactory\n   * org.springframework.context.ApplicationContext\n   * org.springframework.beans.factory.config.BeanDefinition\n * Spring 层次性国际化接口\n   * org.springframework.context.HierarchicalMessageSource\n\n\n# Java 国际化标准实现\n\n核心接口：\n\n * 抽象实现 - java.util.ResourceBundle\n * Properties 资源实现 - java.util.PropertyResourceBundle\n * 例举实现 - java.util.ListResourceBundle\n\nResourceBundle 核心特性\n\n * Key-Value 设计\n * 层次性设计\n * 缓存设计\n * 字符编码控制 - java.util.ResourceBundle.Control（@since 1.6）\n * Control SPI 扩展 - java.util.spi.ResourceBundleControlProvider（@since 1.8）\n\n\n# Java 文本格式化\n\n * 核心接口\n   * java.text.MessageFormat\n * 基本用法\n   * 设置消息格式模式- new MessageFormat(...)\n   * 格式化 - format(new Object[]{...})\n * 消息格式模式\n   * 格式元素：{ArgumentIndex (,FormatType,(FormatStyle))}\n   * FormatType：消息格式类型，可选项，每种类型在 number、date、time 和 choice 类型选其一\n   * FormatStyle：消息格式风格，可选项，包括：short、medium、long、full、integer、currency、 percent\n * 高级特性\n   * 重置消息格式模式\n   * 重置 java.util.Locale\n   * 重置 java.text.Format\n\n\n# MessageSource 开箱即用实现\n\n * 基于 ResourceBundle + MessageFormat 组合 MessageSource 实现\n * org.springframework.context.support.ResourceBundleMessageSource\n * 可重载 Properties + MessageFormat 组合 MessageSource 实现\n * org.springframework.context.support.ReloadableResourceBundleMessageSource\n\n\n# MessageSource 內建依赖\n\n * MessageSource 內建 Bean 可能来源\n * 预注册 Bean 名称为：“messageSource”，类型为：MessageSource Bean\n * 默认內建实现 - DelegatingMessageSource\n * 层次性查找 MessageSource 对象\n\n\n# 问题\n\nSpring Boot 为什么要新建 MessageSource Bean？\n\n * AbstractApplicationContext 的实现决定了 MessageSource 內建实现\n * Spring Boot 通过外部化配置简化 MessageSource Bean 构建\n * Spring Boot 基于 Bean Validation 校验非常普遍\n\nSpring 国际化接口有哪些？\n\n * 核心接口 - MessageSource\n * 层次性接口 - org.springframework.context.HierarchicalMessageSource\n\nSpring 有哪些 MessageSource 內建实现？\n\n * org.springframework.context.support.ResourceBundleMessageSource\n * org.springframework.context.support.ReloadableResourceBundleMessageSource\n * org.springframework.context.support.StaticMessageSource\n * org.springframework.context.support.DelegatingMessageSource\n\n如何实现配置自动更新 MessageSource？\n\n主要技术\n\n * Java NIO 2：java.nio.file.WatchService\n * Java Concurrency : java.util.concurrent.ExecutorService\n * Spring：org.springframework.context.support.AbstractMessageSource\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 国际化\n\n\n# spring 国际化使用场景\n\n * 普通国际化文案\n * bean validation 校验国际化文案\n * web 站点页面渲染\n * web mvc 错误消息提示\n\n\n# spring 国际化接口\n\n * 核心接口：org.springframework.context.messagesource\n * 主要概念\n   * 文案模板编码（code）\n   * 文案模板参数（args）\n   * 区域（locale）\n\n\n# 层次性 messagesource\n\n * spring 层次性接口回顾\n   * org.springframework.beans.factory.hierarchicalbeanfactory\n   * org.springframework.context.applicationcontext\n   * org.springframework.beans.factory.config.beandefinition\n * spring 层次性国际化接口\n   * org.springframework.context.hierarchicalmessagesource\n\n\n# java 国际化标准实现\n\n核心接口：\n\n * 抽象实现 - java.util.resourcebundle\n * properties 资源实现 - java.util.propertyresourcebundle\n * 例举实现 - java.util.listresourcebundle\n\nresourcebundle 核心特性\n\n * key-value 设计\n * 层次性设计\n * 缓存设计\n * 字符编码控制 - java.util.resourcebundle.control（@since 1.6）\n * control spi 扩展 - java.util.spi.resourcebundlecontrolprovider（@since 1.8）\n\n\n# java 文本格式化\n\n * 核心接口\n   * java.text.messageformat\n * 基本用法\n   * 设置消息格式模式- new messageformat(...)\n   * 格式化 - format(new object[]{...})\n * 消息格式模式\n   * 格式元素：{argumentindex (,formattype,(formatstyle))}\n   * formattype：消息格式类型，可选项，每种类型在 number、date、time 和 choice 类型选其一\n   * formatstyle：消息格式风格，可选项，包括：short、medium、long、full、integer、currency、 percent\n * 高级特性\n   * 重置消息格式模式\n   * 重置 java.util.locale\n   * 重置 java.text.format\n\n\n# messagesource 开箱即用实现\n\n * 基于 resourcebundle + messageformat 组合 messagesource 实现\n * org.springframework.context.support.resourcebundlemessagesource\n * 可重载 properties + messageformat 组合 messagesource 实现\n * org.springframework.context.support.reloadableresourcebundlemessagesource\n\n\n# messagesource 內建依赖\n\n * messagesource 內建 bean 可能来源\n * 预注册 bean 名称为：“messagesource”，类型为：messagesource bean\n * 默认內建实现 - delegatingmessagesource\n * 层次性查找 messagesource 对象\n\n\n# 问题\n\nspring boot 为什么要新建 messagesource bean？\n\n * abstractapplicationcontext 的实现决定了 messagesource 內建实现\n * spring boot 通过外部化配置简化 messagesource bean 构建\n * spring boot 基于 bean validation 校验非常普遍\n\nspring 国际化接口有哪些？\n\n * 核心接口 - messagesource\n * 层次性接口 - org.springframework.context.hierarchicalmessagesource\n\nspring 有哪些 messagesource 內建实现？\n\n * org.springframework.context.support.resourcebundlemessagesource\n * org.springframework.context.support.reloadableresourcebundlemessagesource\n * org.springframework.context.support.staticmessagesource\n * org.springframework.context.support.delegatingmessagesource\n\n如何实现配置自动更新 messagesource？\n\n主要技术\n\n * java nio 2：java.nio.file.watchservice\n * java concurrency : java.util.concurrent.executorservice\n * spring：org.springframework.context.support.abstractmessagesource\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 泛型处理",frontmatter:{title:"Spring 泛型处理",date:"2022-12-22T20:11:52.000Z",order:27,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/175cbd/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/27.Spring%E6%B3%9B%E5%9E%8B%E5%A4%84%E7%90%86.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/27.Spring泛型处理.md",key:"v-60d8b9e6",path:"/pages/175cbd/",headers:[{level:2,title:"Java 泛型基础",slug:"java-泛型基础",normalizedTitle:"java 泛型基础",charIndex:18},{level:2,title:"Java 5 类型接口",slug:"java-5-类型接口",normalizedTitle:"java 5 类型接口",charIndex:332},{level:2,title:"Spring 泛型类型辅助类",slug:"spring-泛型类型辅助类",normalizedTitle:"spring 泛型类型辅助类",charIndex:1075},{level:2,title:"Spring 泛型集合类型辅助类",slug:"spring-泛型集合类型辅助类",normalizedTitle:"spring 泛型集合类型辅助类",charIndex:1400},{level:2,title:"Spring 方法参数封装 - MethodParameter",slug:"spring-方法参数封装-methodparameter",normalizedTitle:"spring 方法参数封装 - methodparameter",charIndex:1654},{level:2,title:"Spring 4.0 泛型优化实现 - ResolvableType",slug:"spring-4-0-泛型优化实现-resolvabletype",normalizedTitle:"spring 4.0 泛型优化实现 - resolvabletype",charIndex:1980},{level:2,title:"ResolvableType 的局限性",slug:"resolvabletype-的局限性",normalizedTitle:"resolvabletype 的局限性",charIndex:2202},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2308},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2682}],headersStr:"Java 泛型基础 Java 5 类型接口 Spring 泛型类型辅助类 Spring 泛型集合类型辅助类 Spring 方法参数封装 - MethodParameter Spring 4.0 泛型优化实现 - ResolvableType ResolvableType 的局限性 问题 参考资料",content:"# Spring 泛型处理\n\n\n# Java 泛型基础\n\n泛型类型\n\n * 泛型类型是在类型上参数化的泛型类或接口\n\n泛型使用场景\n\n * 编译时强类型检查\n * 避免类型强转\n * 实现通用算法\n\n泛型类型擦写\n\n * 泛型被引入到 Java 语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会 为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：\n   * 将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为 “Object”。因此，生成的字节码只包含普通类、接口和方法\n   * 必要时插入类型转换以保持类型安全\n   * 生成桥方法以保留扩展泛型类型中的多态性\n\n\n# Java 5 类型接口\n\nJava 5 类型接口 - java.lang.reflect.Type\n\n派生类或接口                                说明\njava.lang.Class                       Java 类 API，如 java.lang.String\njava.lang.reflect.GenericArrayType    泛型数组类型\njava.lang.reflect.ParameterizedType   泛型参数类型\njava.lang.reflect.TypeVariable        泛型类型变量，如 Collection<E> 中的 E\njava.lang.reflect.WildcardType        泛型通配类型\n\nJava 泛型反射 API\n\n类型                           API\n泛型信息（Generics Info）          java.lang.Class#getGenericInfo()\n泛型参数（Parameters）             java.lang.reflect.ParameterizedType\n泛型父类（Super Classes）          java.lang.Class#getGenericSuperclass()\n泛型接口（Interfaces）             java.lang.Class#getGenericInterfaces()\n泛型声明（Generics Declaration）   java.lang.reflect.GenericDeclaration\n\n\n# Spring 泛型类型辅助类\n\n核心 API - org.springframework.core.GenericTypeResolver\n\n * 版本支持：[2.5.2 , )\n * 处理类型相关（Type）相关方法\n   * resolveReturnType\n   * resolveType\n * 处理泛型参数类型（ParameterizedType）相关方法\n   * resolveReturnTypeArgument\n   * resolveTypeArgument\n   * resolveTypeArguments\n * 处理泛型类型变量（TypeVariable）相关方法\n   * getTypeVariableMap\n\n\n# Spring 泛型集合类型辅助类\n\n核心 API - org.springframework.core.GenericCollectionTypeResolver\n\n * 版本支持：[2.0 , 4.3]\n * 替换实现：org.springframework.core.ResolvableType\n * 处理 Collection 相关\n   * getCollection*Type\n * 处理 Map 相关\n   * getMapKey*Type\n   * getMapValue*Type\n\n\n# Spring 方法参数封装 - MethodParameter\n\n核心 API - org.springframework.core.MethodParameter\n\n * 起始版本：[2.0 , )\n * 元信息\n   * 关联的方法 - Method\n   * 关联的构造器 - Constructor\n   * 构造器或方法参数索引 - parameterIndex\n   * 构造器或方法参数类型 - parameterType\n   * 构造器或方法参数泛型类型 - genericParameterType\n   * 构造器或方法参数参数名称 - parameterName\n   * 所在的类 - containingClass\n\n\n# Spring 4.0 泛型优化实现 - ResolvableType\n\n核心 API - org.springframework.core.ResolvableType\n\n * 起始版本：[4.0 , )\n * 扮演角色：GenericTypeResolver 和 GenericCollectionTypeResolver 替代者\n * 工厂方法：for* 方法\n * 转换方法：as* 方法\n * 处理方法：resolve* 方法\n\n\n# ResolvableType 的局限性\n\n * 局限一：ResolvableType 无法处理泛型擦写\n * 局限二：ResolvableType 无法处理非具体化的 ParameterizedType\n\n\n# 问题\n\nJava 泛型擦写发生在编译时还是运行时？\n\n运行时\n\n请介绍 Java 5 Type 类型的派生类或接口\n\n * java.lang.Class\n * java.lang.reflect.GenericArrayType\n * java.lang.reflect.ParameterizedType\n * java.lang.reflect.TypeVariable\n * java.lang.reflect.WildcardType\n\n请说明 ResolvableType 的设计优势？\n\n * 简化 Java 5 Type API 开发，屏蔽复杂 API 的运用，如 ParameterizedType\n * 不变性设计（Immutability）\n * Fluent API 设计（Builder 模式），链式（流式）编程\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 泛型处理\n\n\n# java 泛型基础\n\n泛型类型\n\n * 泛型类型是在类型上参数化的泛型类或接口\n\n泛型使用场景\n\n * 编译时强类型检查\n * 避免类型强转\n * 实现通用算法\n\n泛型类型擦写\n\n * 泛型被引入到 java 语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会 为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：\n   * 将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为 “object”。因此，生成的字节码只包含普通类、接口和方法\n   * 必要时插入类型转换以保持类型安全\n   * 生成桥方法以保留扩展泛型类型中的多态性\n\n\n# java 5 类型接口\n\njava 5 类型接口 - java.lang.reflect.type\n\n派生类或接口                                说明\njava.lang.class                       java 类 api，如 java.lang.string\njava.lang.reflect.genericarraytype    泛型数组类型\njava.lang.reflect.parameterizedtype   泛型参数类型\njava.lang.reflect.typevariable        泛型类型变量，如 collection<e> 中的 e\njava.lang.reflect.wildcardtype        泛型通配类型\n\njava 泛型反射 api\n\n类型                           api\n泛型信息（generics info）          java.lang.class#getgenericinfo()\n泛型参数（parameters）             java.lang.reflect.parameterizedtype\n泛型父类（super classes）          java.lang.class#getgenericsuperclass()\n泛型接口（interfaces）             java.lang.class#getgenericinterfaces()\n泛型声明（generics declaration）   java.lang.reflect.genericdeclaration\n\n\n# spring 泛型类型辅助类\n\n核心 api - org.springframework.core.generictyperesolver\n\n * 版本支持：[2.5.2 , )\n * 处理类型相关（type）相关方法\n   * resolvereturntype\n   * resolvetype\n * 处理泛型参数类型（parameterizedtype）相关方法\n   * resolvereturntypeargument\n   * resolvetypeargument\n   * resolvetypearguments\n * 处理泛型类型变量（typevariable）相关方法\n   * gettypevariablemap\n\n\n# spring 泛型集合类型辅助类\n\n核心 api - org.springframework.core.genericcollectiontyperesolver\n\n * 版本支持：[2.0 , 4.3]\n * 替换实现：org.springframework.core.resolvabletype\n * 处理 collection 相关\n   * getcollection*type\n * 处理 map 相关\n   * getmapkey*type\n   * getmapvalue*type\n\n\n# spring 方法参数封装 - methodparameter\n\n核心 api - org.springframework.core.methodparameter\n\n * 起始版本：[2.0 , )\n * 元信息\n   * 关联的方法 - method\n   * 关联的构造器 - constructor\n   * 构造器或方法参数索引 - parameterindex\n   * 构造器或方法参数类型 - parametertype\n   * 构造器或方法参数泛型类型 - genericparametertype\n   * 构造器或方法参数参数名称 - parametername\n   * 所在的类 - containingclass\n\n\n# spring 4.0 泛型优化实现 - resolvabletype\n\n核心 api - org.springframework.core.resolvabletype\n\n * 起始版本：[4.0 , )\n * 扮演角色：generictyperesolver 和 genericcollectiontyperesolver 替代者\n * 工厂方法：for* 方法\n * 转换方法：as* 方法\n * 处理方法：resolve* 方法\n\n\n# resolvabletype 的局限性\n\n * 局限一：resolvabletype 无法处理泛型擦写\n * 局限二：resolvabletype 无法处理非具体化的 parameterizedtype\n\n\n# 问题\n\njava 泛型擦写发生在编译时还是运行时？\n\n运行时\n\n请介绍 java 5 type 类型的派生类或接口\n\n * java.lang.class\n * java.lang.reflect.genericarraytype\n * java.lang.reflect.parameterizedtype\n * java.lang.reflect.typevariable\n * java.lang.reflect.wildcardtype\n\n请说明 resolvabletype 的设计优势？\n\n * 简化 java 5 type api 开发，屏蔽复杂 api 的运用，如 parameterizedtype\n * 不变性设计（immutability）\n * fluent api 设计（builder 模式），链式（流式）编程\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring Environment 抽象",frontmatter:{title:"Spring Environment 抽象",date:"2022-12-23T09:27:44.000Z",order:29,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/03d838/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/29.SpringEnvironment%E6%8A%BD%E8%B1%A1.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/29.SpringEnvironment抽象.md",key:"v-8f04575e",path:"/pages/03d838/",headers:[{level:2,title:"理解 Spring Environment 抽象",slug:"理解-spring-environment-抽象",normalizedTitle:"理解 spring environment 抽象",charIndex:28},{level:2,title:"Spring Environment 接口使用场景",slug:"spring-environment-接口使用场景",normalizedTitle:"spring environment 接口使用场景",charIndex:295},{level:2,title:"Environment 占位符处理",slug:"environment-占位符处理",normalizedTitle:"environment 占位符处理",charIndex:419},{level:2,title:"理解条件配置 Spring Profiles",slug:"理解条件配置-spring-profiles",normalizedTitle:"理解条件配置 spring profiles",charIndex:758},{level:2,title:"Spring 4 重构 @Profile",slug:"spring-4-重构-profile",normalizedTitle:"spring 4 重构 @profile",charIndex:1120},{level:2,title:"依赖注入 Environment",slug:"依赖注入-environment",normalizedTitle:"依赖注入 environment",charIndex:1269},{level:2,title:"依赖查找 Environment",slug:"依赖查找-environment",normalizedTitle:"依赖查找 environment",charIndex:1442},{level:2,title:"依赖注入 @Value",slug:"依赖注入-value",normalizedTitle:"依赖注入 @value",charIndex:1648},{level:2,title:"Spring 类型转换在 Environment 中的运用",slug:"spring-类型转换在-environment-中的运用",normalizedTitle:"spring 类型转换在 environment 中的运用",charIndex:1765},{level:2,title:"Spring 类型转换在 @Value 中的运用",slug:"spring-类型转换在-value-中的运用",normalizedTitle:"spring 类型转换在 @value 中的运用",charIndex:2074},{level:2,title:"Spring 配置属性源 PropertySource",slug:"spring-配置属性源-propertysource",normalizedTitle:"spring 配置属性源 propertysource",charIndex:2504},{level:2,title:"Spring 內建的配置属性源",slug:"spring-內建的配置属性源",normalizedTitle:"spring 內建的配置属性源",charIndex:2962},{level:2,title:"基于注解扩展 Spring 配置属性源",slug:"基于注解扩展-spring-配置属性源",normalizedTitle:"基于注解扩展 spring 配置属性源",charIndex:3584},{level:2,title:"基于 API 扩展 Spring 配置属性源",slug:"基于-api-扩展-spring-配置属性源",normalizedTitle:"基于 api 扩展 spring 配置属性源",charIndex:4024},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:4124},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4376}],headersStr:"理解 Spring Environment 抽象 Spring Environment 接口使用场景 Environment 占位符处理 理解条件配置 Spring Profiles Spring 4 重构 @Profile 依赖注入 Environment 依赖查找 Environment 依赖注入 @Value Spring 类型转换在 Environment 中的运用 Spring 类型转换在 @Value 中的运用 Spring 配置属性源 PropertySource Spring 內建的配置属性源 基于注解扩展 Spring 配置属性源 基于 API 扩展 Spring 配置属性源 问题 参考资料",content:"# Spring Environment 抽象\n\n\n# 理解 Spring Environment 抽象\n\n统一的 Spring 配置属性管理\n\nSpring Framework 3.1 开始引入 Environment 抽象，它统一 Spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 PropertyPlaceholderConfigurer，而且还支持更丰富的配置属性源（PropertySource）\n\n条件化 Spring Bean 装配管理\n\n通过 Environment Profiles 信息，帮助 Spring 容器提供条件化地装配 Bean\n\n\n# Spring Environment 接口使用场景\n\n * ⽤于属性占位符处理\n * 用于转换 Spring 配置属性类型\n * 用于存储 Spring 配置属性源（PropertySource）\n * 用于 Profiles 状态的维护\n\n\n# Environment 占位符处理\n\nSpring 3.1 前占位符处理\n\n * 组件：org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\n * 接口：org.springframework.util.StringValueResolver\n\nSpring 3.1 + 占位符处理\n\n * 组件：org.springframework.context.support.PropertySourcesPlaceholderConfigurer\n * 接口：org.springframework.beans.factory.config.EmbeddedValueResolver\n\n\n# 理解条件配置 Spring Profiles\n\nSpring 3.1 条件配置\n\n * API：org.springframework.core.env.ConfigurableEnvironment\n * 修改：addActiveProfile(String)、setActiveProfiles(String...) 和 setDefaultProfiles(String...)\n * 获取：getActiveProfiles() 和 getDefaultProfiles()\n * 匹配：#acceptsProfiles(String...) 和 acceptsProfiles(Profiles)\n * 注解：@org.springframework.context.annotation.Profile\n\n\n# Spring 4 重构 @Profile\n\n基于 Spring 4 org.springframework.context.annotation.Condition 接口实现\n\norg.springframework.context.annotation.ProfileCondition\n\n\n# 依赖注入 Environment\n\n直接依赖注入\n\n * 通过 EnvironmentAware 接口回调\n * 通过 @Autowired 注入 Environment\n\n间接依赖注入\n\n * 通过 ApplicationContextAware 接口回调\n * 通过 @Autowired 注入 ApplicationContext\n\n\n# 依赖查找 Environment\n\n直接依赖查找\n\n * 通过 org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME\n\n间接依赖查找\n\n * 通过 org.springframework.context.ConfigurableApplicationContext#getEnvironment\n\n\n# 依赖注入 @Value\n\n通过注入 @Value\n\n实现 - org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\n\n\n# Spring 类型转换在 Environment 中的运用\n\nEnvironment 底层实现\n\n * 底层实现 - org.springframework.core.env.PropertySourcesPropertyResolver\n * 核心方法 - convertValueIfNecessary(Object,Class)\n * 底层服务 - org.springframework.core.convert.ConversionService\n * 默认实现 - org.springframework.core.convert.support.DefaultConversionService\n\n\n# Spring 类型转换在 @Value 中的运用\n\n@Value 底层实现\n\n * 底层实现 - org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\n   * org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency\n * 底层服务 - org.springframework.beans.TypeConverter\n   * 默认实现 - org.springframework.beans.TypeConverterDelegate\n     * java.beans.PropertyEditor\n     * org.springframework.core.convert.ConversionService\n\n\n# Spring 配置属性源 PropertySource\n\n * API\n   * 单配置属性源 - org.springframework.core.env.PropertySource\n   * 多配置属性源 - org.springframework.core.env.PropertySources\n * 注解\n   * 单配置属性源 - @org.springframework.context.annotation.PropertySource\n   * 多配置属性源 - @org.springframework.context.annotation.PropertySources\n * 关联\n   * 存储对象 - org.springframework.core.env.MutablePropertySources\n   * 关联方法 - org.springframework.core.env.ConfigurableEnvironment#getPropertySources()\n\n\n# Spring 內建的配置属性源\n\n內建 PropertySource\n\nPROPERTYSOURCE 类型                                                      说明\norg.springframework.core.env.CommandLinePropertySource                 命令行配置属性源\norg.springframework.jndi.JndiPropertySource                            JDNI 配置属性源\norg.springframework.core.env.PropertiesPropertySource                  Properties 配置属性源\norg.springframework.web.context.support.ServletConfigPropertySource    Servlet 配置属性源\norg.springframework.web.context.support.ServletContextPropertySource   ServletContext 配置属性源\norg.springframework.core.env.SystemEnvironmentPropertySource           环境变量配置属性源\n\n\n# 基于注解扩展 Spring 配置属性源\n\n@org.springframework.context.annotation.PropertySource 实现原理\n\n * 入口 - org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass\n   * org.springframework.context.annotation.ConfigurationClassParser#processPropertySource\n * 4.3 新增语义\n   * 配置属性字符编码 - encoding\n   * org.springframework.core.io.support.PropertySourceFactory\n * 适配对象 - org.springframework.core.env.CompositePropertySource\n\n\n# 基于 API 扩展 Spring 配置属性源\n\n * Spring 应用上下文启动前装配 PropertySource\n * Spring 应用上下文启动后装配 PropertySource\n\n\n# 问题\n\n简单介绍 Spring Environment 接口？\n\n * 核心接口 - org.springframework.core.env.Environment\n * 父接口 - org.springframework.core.env.PropertyResolver\n * 可配置接口 - org.springframework.core.env.ConfigurableEnvironment\n * 职责：\n   * 管理 Spring 配置属性源\n   * 管理 Profiles\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring environment 抽象\n\n\n# 理解 spring environment 抽象\n\n统一的 spring 配置属性管理\n\nspring framework 3.1 开始引入 environment 抽象，它统一 spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 propertyplaceholderconfigurer，而且还支持更丰富的配置属性源（propertysource）\n\n条件化 spring bean 装配管理\n\n通过 environment profiles 信息，帮助 spring 容器提供条件化地装配 bean\n\n\n# spring environment 接口使用场景\n\n * ⽤于属性占位符处理\n * 用于转换 spring 配置属性类型\n * 用于存储 spring 配置属性源（propertysource）\n * 用于 profiles 状态的维护\n\n\n# environment 占位符处理\n\nspring 3.1 前占位符处理\n\n * 组件：org.springframework.beans.factory.config.propertyplaceholderconfigurer\n * 接口：org.springframework.util.stringvalueresolver\n\nspring 3.1 + 占位符处理\n\n * 组件：org.springframework.context.support.propertysourcesplaceholderconfigurer\n * 接口：org.springframework.beans.factory.config.embeddedvalueresolver\n\n\n# 理解条件配置 spring profiles\n\nspring 3.1 条件配置\n\n * api：org.springframework.core.env.configurableenvironment\n * 修改：addactiveprofile(string)、setactiveprofiles(string...) 和 setdefaultprofiles(string...)\n * 获取：getactiveprofiles() 和 getdefaultprofiles()\n * 匹配：#acceptsprofiles(string...) 和 acceptsprofiles(profiles)\n * 注解：@org.springframework.context.annotation.profile\n\n\n# spring 4 重构 @profile\n\n基于 spring 4 org.springframework.context.annotation.condition 接口实现\n\norg.springframework.context.annotation.profilecondition\n\n\n# 依赖注入 environment\n\n直接依赖注入\n\n * 通过 environmentaware 接口回调\n * 通过 @autowired 注入 environment\n\n间接依赖注入\n\n * 通过 applicationcontextaware 接口回调\n * 通过 @autowired 注入 applicationcontext\n\n\n# 依赖查找 environment\n\n直接依赖查找\n\n * 通过 org.springframework.context.configurableapplicationcontext#environment_bean_name\n\n间接依赖查找\n\n * 通过 org.springframework.context.configurableapplicationcontext#getenvironment\n\n\n# 依赖注入 @value\n\n通过注入 @value\n\n实现 - org.springframework.beans.factory.annotation.autowiredannotationbeanpostprocessor\n\n\n# spring 类型转换在 environment 中的运用\n\nenvironment 底层实现\n\n * 底层实现 - org.springframework.core.env.propertysourcespropertyresolver\n * 核心方法 - convertvalueifnecessary(object,class)\n * 底层服务 - org.springframework.core.convert.conversionservice\n * 默认实现 - org.springframework.core.convert.support.defaultconversionservice\n\n\n# spring 类型转换在 @value 中的运用\n\n@value 底层实现\n\n * 底层实现 - org.springframework.beans.factory.annotation.autowiredannotationbeanpostprocessor\n   * org.springframework.beans.factory.support.defaultlistablebeanfactory#doresolvedependency\n * 底层服务 - org.springframework.beans.typeconverter\n   * 默认实现 - org.springframework.beans.typeconverterdelegate\n     * java.beans.propertyeditor\n     * org.springframework.core.convert.conversionservice\n\n\n# spring 配置属性源 propertysource\n\n * api\n   * 单配置属性源 - org.springframework.core.env.propertysource\n   * 多配置属性源 - org.springframework.core.env.propertysources\n * 注解\n   * 单配置属性源 - @org.springframework.context.annotation.propertysource\n   * 多配置属性源 - @org.springframework.context.annotation.propertysources\n * 关联\n   * 存储对象 - org.springframework.core.env.mutablepropertysources\n   * 关联方法 - org.springframework.core.env.configurableenvironment#getpropertysources()\n\n\n# spring 內建的配置属性源\n\n內建 propertysource\n\npropertysource 类型                                                      说明\norg.springframework.core.env.commandlinepropertysource                 命令行配置属性源\norg.springframework.jndi.jndipropertysource                            jdni 配置属性源\norg.springframework.core.env.propertiespropertysource                  properties 配置属性源\norg.springframework.web.context.support.servletconfigpropertysource    servlet 配置属性源\norg.springframework.web.context.support.servletcontextpropertysource   servletcontext 配置属性源\norg.springframework.core.env.systemenvironmentpropertysource           环境变量配置属性源\n\n\n# 基于注解扩展 spring 配置属性源\n\n@org.springframework.context.annotation.propertysource 实现原理\n\n * 入口 - org.springframework.context.annotation.configurationclassparser#doprocessconfigurationclass\n   * org.springframework.context.annotation.configurationclassparser#processpropertysource\n * 4.3 新增语义\n   * 配置属性字符编码 - encoding\n   * org.springframework.core.io.support.propertysourcefactory\n * 适配对象 - org.springframework.core.env.compositepropertysource\n\n\n# 基于 api 扩展 spring 配置属性源\n\n * spring 应用上下文启动前装配 propertysource\n * spring 应用上下文启动后装配 propertysource\n\n\n# 问题\n\n简单介绍 spring environment 接口？\n\n * 核心接口 - org.springframework.core.env.environment\n * 父接口 - org.springframework.core.env.propertyresolver\n * 可配置接口 - org.springframework.core.env.configurableenvironment\n * 职责：\n   * 管理 spring 配置属性源\n   * 管理 profiles\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 注解",frontmatter:{title:"Spring 注解",date:"2022-12-23T09:08:15.000Z",order:28,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring"],permalink:"/pages/b6556f/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/28.Spring%E6%B3%A8%E8%A7%A3.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/28.Spring注解.md",key:"v-6cd7991c",path:"/pages/b6556f/",headers:[{level:2,title:"Spring 注解驱动编程发展历程",slug:"spring-注解驱动编程发展历程",normalizedTitle:"spring 注解驱动编程发展历程",charIndex:16},{level:2,title:"Spring 核心注解场景分类",slug:"spring-核心注解场景分类",normalizedTitle:"spring 核心注解场景分类",charIndex:204},{level:2,title:"Spring 注解编程模型",slug:"spring-注解编程模型",normalizedTitle:"spring 注解编程模型",charIndex:807},{level:2,title:"Spring 元注解（Meta-Annotations）",slug:"spring-元注解-meta-annotations",normalizedTitle:"spring 元注解（meta-annotations）",charIndex:980},{level:2,title:"Spring 模式注解（Stereotype Annotations）",slug:"spring-模式注解-stereotype-annotations",normalizedTitle:"spring 模式注解（stereotype annotations）",charIndex:850},{level:2,title:"Spring 组合注解（Composed Annotations）",slug:"spring-组合注解-composed-annotations",normalizedTitle:"spring 组合注解（composed annotations）",charIndex:889},{level:2,title:"Spring 注解属性别名（Attribute Aliases）",slug:"spring-注解属性别名-attribute-aliases",normalizedTitle:"spring 注解属性别名（attribute aliases）",charIndex:2312},{level:2,title:"Spring 注解属性覆盖（Attribute Overrides）",slug:"spring-注解属性覆盖-attribute-overrides",normalizedTitle:"spring 注解属性覆盖（attribute overrides）",charIndex:2349},{level:2,title:"Spring @Enable 模块驱动",slug:"spring-enable-模块驱动",normalizedTitle:"spring @enable 模块驱动",charIndex:2388},{level:2,title:"Spring 条件注解",slug:"spring-条件注解",normalizedTitle:"spring 条件注解",charIndex:2844},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3564}],headersStr:"Spring 注解驱动编程发展历程 Spring 核心注解场景分类 Spring 注解编程模型 Spring 元注解（Meta-Annotations） Spring 模式注解（Stereotype Annotations） Spring 组合注解（Composed Annotations） Spring 注解属性别名（Attribute Aliases） Spring 注解属性覆盖（Attribute Overrides） Spring @Enable 模块驱动 Spring 条件注解 参考资料",content:"# Spring 注解\n\n\n# Spring 注解驱动编程发展历程\n\n * 注解驱动启蒙时代：Spring Framework 1.x\n * 注解驱动过渡时代：Spring Framework 2.x\n * 注解驱动黄金时代：Spring Framework 3.x\n * 注解驱动完善时代：Spring Framework 4.x\n * 注解驱动当下时代：Spring Framework 5.x\n\n\n# Spring 核心注解场景分类\n\nSpring 模式注解\n\nSPRING 注解        场景说明          起始版本\n@Repository      数据仓储模式注解      2.0\n@Component       通用组件模式注解      2.5\n@Service         服务模式注解        2.5\n@Controller      Web 控制器模式注解   2.5\n@Configuration   配置类模式注解       3.0\n\n装配注解\n\nSPRING 注解         场景说明                             起始版本\n@ImportResource   替换 XML 元素 <import>               2.5\n@Import           导入 Configuration 类               2.5\n@ComponentScan    扫描指定 package 下标注 Spring 模式注解的类   3.1\n\n依赖注入注解\n\nSPRING 注解    场景说明                   起始版本\n@Autowired   Bean 依赖注入，支持多种依赖查找方式   2.5\n@Qualifier   细粒度的 @Autowired 依赖查找   2.5\n\n\n# Spring 注解编程模型\n\n * 元注解（Meta-Annotations）\n * Spring 模式注解（Stereotype Annotations）\n * Spring 组合注解（Composed Annotations）\n * Spring 注解属性别名和覆盖（Attribute Aliases and Overrides）\n\n\n# Spring 元注解（Meta-Annotations）\n\n * java.lang.annotation.Documented\n * java.lang.annotation.Inherited\n * java.lang.annotation.Repeatable\n\n\n# Spring 模式注解（Stereotype Annotations）\n\n理解 @Component “派⽣性”：元标注 @Component 的注解在 XML 元素 context:component-scan 或注解 @ComponentScan 扫描中“派生”了 @Component 的特性，并且从 Spring Framework 4.0 开始支持多层次“派⽣性”。\n\n举例说明：\n\n * @Repository\n * @Service\n * @Controller\n * @Configuration\n * @SpringBootConfiguration（Spring Boot）\n\n@Component “派⽣性”原理\n\n * 核心组件 - org.springframework.context.annotation.ClassPathBeanDefinitionScanner\n * org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider\n * 资源处理 - org.springframework.core.io.support.ResourcePatternResolver\n * 资源-类元信息\n * org.springframework.core.type.classreading.MetadataReaderFactory\n * 类元信息 - org.springframework.core.type.ClassMetadata\n * ASM 实现 - org.springframework.core.type.classreading.ClassMetadataReadingVisitor\n * 反射实现 - org.springframework.core.type.StandardAnnotationMetadata\n * 注解元信息 - org.springframework.core.type.AnnotationMetadata\n * ASM 实现 - org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor\n * 反射实现 - org.springframework.core.type.StandardAnnotationMetadata\n\n\n# Spring 组合注解（Composed Annotations）\n\nSpring 组合注解（Composed Annotations）中的元注允许是 Spring 模式注解（Stereotype Annotation）与其他 Spring 功能性注解的任意组合。\n\n\n# Spring 注解属性别名（Attribute Aliases）\n\n\n# Spring 注解属性覆盖（Attribute Overrides）\n\n\n# Spring @Enable 模块驱动\n\n@Enable 模块驱动\n\n@Enable 模块驱动是以 @Enable 为前缀的注解驱动编程模型。所谓“模块”是指具备相同领域的功能组件集合，组合所形成⼀个独⽴的单元。⽐如 Web MVC 模块、AspectJ 代理模块、Caching（缓存）模块、JMX（Java 管理扩展）模块、Async（异步处理）模块等。\n\n举例说明\n\n * @EnableWebMvc\n * @EnableTransactionManagement\n * @EnableCaching\n * @EnableMBeanExport\n * @EnableAsync\n\n@Enable 模块驱动编程模式\n\n * 驱动注解：@EnableXXX\n * 导入注解：@Import 具体实现\n * 具体实现\n * 基于 Configuration Class\n * 基于 ImportSelector 接口实现\n * 基于 ImportBeanDefinitionRegistrar 接口实现\n\n\n# Spring 条件注解\n\n基于配置条件注解 - @org.springframework.context.annotation.Profile\n\n * 关联对象 - org.springframework.core.env.Environment 中的 Profiles\n * 实现变化：从 Spring 4.0 开始，@Profile 基于 @Conditional 实现\n\n基于编程条件注解 - @org.springframework.context.annotation.Conditional\n\n * 关联对象 - org.springframework.context.annotation.Condition 具体实现\n\n@Conditional 实现原理\n\n * 上下文对象 - org.springframework.context.annotation.ConditionContext\n * 条件判断 - org.springframework.context.annotation.ConditionEvaluator\n * 配置阶段 - org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase\n * 判断入口\n   * org.springframework.context.annotation.ConfigurationClassPostProcessor\n   * org.springframework.context.annotation.ConfigurationClassParser\n\n\n# 参考资料\n\n * Spring 官方文档之 Core Technologies\n * 《小马哥讲 Spring 核心编程思想》",normalizedContent:"# spring 注解\n\n\n# spring 注解驱动编程发展历程\n\n * 注解驱动启蒙时代：spring framework 1.x\n * 注解驱动过渡时代：spring framework 2.x\n * 注解驱动黄金时代：spring framework 3.x\n * 注解驱动完善时代：spring framework 4.x\n * 注解驱动当下时代：spring framework 5.x\n\n\n# spring 核心注解场景分类\n\nspring 模式注解\n\nspring 注解        场景说明          起始版本\n@repository      数据仓储模式注解      2.0\n@component       通用组件模式注解      2.5\n@service         服务模式注解        2.5\n@controller      web 控制器模式注解   2.5\n@configuration   配置类模式注解       3.0\n\n装配注解\n\nspring 注解         场景说明                             起始版本\n@importresource   替换 xml 元素 <import>               2.5\n@import           导入 configuration 类               2.5\n@componentscan    扫描指定 package 下标注 spring 模式注解的类   3.1\n\n依赖注入注解\n\nspring 注解    场景说明                   起始版本\n@autowired   bean 依赖注入，支持多种依赖查找方式   2.5\n@qualifier   细粒度的 @autowired 依赖查找   2.5\n\n\n# spring 注解编程模型\n\n * 元注解（meta-annotations）\n * spring 模式注解（stereotype annotations）\n * spring 组合注解（composed annotations）\n * spring 注解属性别名和覆盖（attribute aliases and overrides）\n\n\n# spring 元注解（meta-annotations）\n\n * java.lang.annotation.documented\n * java.lang.annotation.inherited\n * java.lang.annotation.repeatable\n\n\n# spring 模式注解（stereotype annotations）\n\n理解 @component “派⽣性”：元标注 @component 的注解在 xml 元素 context:component-scan 或注解 @componentscan 扫描中“派生”了 @component 的特性，并且从 spring framework 4.0 开始支持多层次“派⽣性”。\n\n举例说明：\n\n * @repository\n * @service\n * @controller\n * @configuration\n * @springbootconfiguration（spring boot）\n\n@component “派⽣性”原理\n\n * 核心组件 - org.springframework.context.annotation.classpathbeandefinitionscanner\n * org.springframework.context.annotation.classpathscanningcandidatecomponentprovider\n * 资源处理 - org.springframework.core.io.support.resourcepatternresolver\n * 资源-类元信息\n * org.springframework.core.type.classreading.metadatareaderfactory\n * 类元信息 - org.springframework.core.type.classmetadata\n * asm 实现 - org.springframework.core.type.classreading.classmetadatareadingvisitor\n * 反射实现 - org.springframework.core.type.standardannotationmetadata\n * 注解元信息 - org.springframework.core.type.annotationmetadata\n * asm 实现 - org.springframework.core.type.classreading.annotationmetadatareadingvisitor\n * 反射实现 - org.springframework.core.type.standardannotationmetadata\n\n\n# spring 组合注解（composed annotations）\n\nspring 组合注解（composed annotations）中的元注允许是 spring 模式注解（stereotype annotation）与其他 spring 功能性注解的任意组合。\n\n\n# spring 注解属性别名（attribute aliases）\n\n\n# spring 注解属性覆盖（attribute overrides）\n\n\n# spring @enable 模块驱动\n\n@enable 模块驱动\n\n@enable 模块驱动是以 @enable 为前缀的注解驱动编程模型。所谓“模块”是指具备相同领域的功能组件集合，组合所形成⼀个独⽴的单元。⽐如 web mvc 模块、aspectj 代理模块、caching（缓存）模块、jmx（java 管理扩展）模块、async（异步处理）模块等。\n\n举例说明\n\n * @enablewebmvc\n * @enabletransactionmanagement\n * @enablecaching\n * @enablembeanexport\n * @enableasync\n\n@enable 模块驱动编程模式\n\n * 驱动注解：@enablexxx\n * 导入注解：@import 具体实现\n * 具体实现\n * 基于 configuration class\n * 基于 importselector 接口实现\n * 基于 importbeandefinitionregistrar 接口实现\n\n\n# spring 条件注解\n\n基于配置条件注解 - @org.springframework.context.annotation.profile\n\n * 关联对象 - org.springframework.core.env.environment 中的 profiles\n * 实现变化：从 spring 4.0 开始，@profile 基于 @conditional 实现\n\n基于编程条件注解 - @org.springframework.context.annotation.conditional\n\n * 关联对象 - org.springframework.context.annotation.condition 具体实现\n\n@conditional 实现原理\n\n * 上下文对象 - org.springframework.context.annotation.conditioncontext\n * 条件判断 - org.springframework.context.annotation.conditionevaluator\n * 配置阶段 - org.springframework.context.annotation.configurationcondition.configurationphase\n * 判断入口\n   * org.springframework.context.annotation.configurationclasspostprocessor\n   * org.springframework.context.annotation.configurationclassparser\n\n\n# 参考资料\n\n * spring 官方文档之 core technologies\n * 《小马哥讲 spring 核心编程思想》",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 之快速入门",frontmatter:{title:"SpringBoot 之快速入门",date:"2021-12-10T18:22:26.000Z",order:31,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/950e4d/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/31.SpringBoot%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/31.SpringBoot之快速入门.md",key:"v-11054c30",path:"/pages/950e4d/",headers:[{level:2,title:"Spring Boot 简介",slug:"spring-boot-简介",normalizedTitle:"spring boot 简介",charIndex:23},{level:2,title:"Spring Boot 系统要求",slug:"spring-boot-系统要求",normalizedTitle:"spring boot 系统要求",charIndex:211},{level:2,title:"部署第一个 Spring Boot 项目",slug:"部署第一个-spring-boot-项目",normalizedTitle:"部署第一个 spring boot 项目",charIndex:466},{level:3,title:"环境检查",slug:"环境检查",normalizedTitle:"环境检查",charIndex:589},{level:3,title:"创建 pom",slug:"创建-pom",normalizedTitle:"创建 pom",charIndex:1043},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:1779},{level:3,title:"编写代码",slug:"编写代码",normalizedTitle:"编写代码",charIndex:2522},{level:3,title:"运行示例",slug:"运行示例",normalizedTitle:"运行示例",charIndex:3485},{level:3,title:"创建可执行 jar",slug:"创建可执行-jar",normalizedTitle:"创建可执行 jar",charIndex:4145},{level:2,title:"通过 SPRING INITIALIZR 创建 Spring Boot 项目",slug:"通过-spring-initializr-创建-spring-boot-项目",normalizedTitle:"通过 spring initializr 创建 spring boot 项目",charIndex:5952},{level:3,title:"创建项目",slug:"创建项目",normalizedTitle:"创建项目",charIndex:5995},{level:3,title:"项目说明",slug:"项目说明",normalizedTitle:"项目说明",charIndex:6250},{level:3,title:"编写 REST 服务",slug:"编写-rest-服务",normalizedTitle:"编写 rest 服务",charIndex:7790},{level:3,title:"编写单元测试用例",slug:"编写单元测试用例",normalizedTitle:"编写单元测试用例",charIndex:8129},{level:3,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:9205},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9249}],headersStr:"Spring Boot 简介 Spring Boot 系统要求 部署第一个 Spring Boot 项目 环境检查 创建 pom 添加依赖 编写代码 运行示例 创建可执行 jar 通过 SPRING INITIALIZR 创建 Spring Boot 项目 创建项目 项目说明 编写 REST 服务 编写单元测试用例 示例源码 参考资料",content:'# SpringBoot 之快速入门\n\n\n# Spring Boot 简介\n\nSpring Boot 可以让使用者非常方便的创建 Spring 应用。\n\nSpring Boot 的目标是：\n\n * 为所有 Spring 开发者提供更快且可广泛访问的入门体验。\n * 开箱即用\n * 提供一系列通用的非功能特性（例如嵌入式服务、安全、指标、健康检查和外部化配置）\n * 完全不需要代码生成，也不需要 XML 配置。\n\n\n# Spring Boot 系统要求\n\nSpring Boot 的构建工具要求：\n\nBUILD TOOL   VERSION\nMaven        3.5+\nGradle       6.8.x, 6.9.x, and 7.x\n\nSpring Boot 支持的 Servlet 容器：\n\nNAME           SERVLET VERSION\nTomcat 9.0     4.0\nJetty 9.4      3.1\nJetty 10.0     4.0\nUndertow 2.0   4.0\n\n\n# 部署第一个 Spring Boot 项目\n\n> 本节介绍如何开发一个小的“Hello World!” web 应用示例，来展示 Spring Boot 的一些关键功能。我们使用 Maven 来构建这个项目，因为大多数 IDE 都支持它。\n\n\n# 环境检查\n\nSpring Boot 项目依赖于 Java 环境和 Mave，开始项目之前需要先检查一下环境。\n\n本地是否已安装 Java：\n\n$ java -version\njava version "1.8.0_102"\nJava(TM) SE Runtime Environment (build 1.8.0_102-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)\n\n\n本地是否已安装 Maven：\n\n$ mvn -v\nApache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00)\nMaven home: /usr/local/Cellar/maven/3.3.9/libexec\nJava version: 1.8.0_102, vendor: Oracle Corporation\n\n\n\n# 创建 pom\n\n我们需要从创建 Maven pom.xml 文件开始。 pom.xml 是 Maven 用于构建项目的配置文件。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>myproject</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.6.1</version>\n    </parent>\n\n    \x3c!-- Additional lines to be added here... --\x3e\n\n</project>\n\n\n使用者可以通过运行 mvn package 来测试它\n\n\n# 添加依赖\n\nSpring Boot 提供了许多启动器（Starters）以应对不同的使用场景。使用者可将 jars 添加到类路径中。我们的示例程序在 POM 的 parent 使用 spring-boot-starter-parent。 spring-boot-starter-parent 是一个特殊的启动器，提供有用的 Maven 默认值。它还提供了一个依赖项的版本管理，可以让使用者使用时不必显示指定版本。\n\n其他启动器（Starters）提供了各种针对不同使用场景的功能。比如，我们需要开发一个 Web 应用程序，就可以添加了一个 spring-boot-starter-web 依赖项。在此之前，我们可以通过运行以下命令来查看我们当前拥有的 maven 依赖：\n\n$ mvn dependency:tree\n\n[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT\n\n\nmvn dependency:tree 命令打印项目依赖项的层级结构。可以看到 spring-boot-starter-parent 本身没有提供任何依赖。要添加必要的依赖，需要编辑 pom.xml 并在 <dependencies> 部分添加 spring-boot-starter-web 依赖项：\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n\n\n\n# 编写代码\n\n要运行应用程序，我们需要创建一个启动类。默认情况下，Maven 从 src/main/java 编译源代码，因此您需要创建该目录结构，然后添加一个名为 src/main/java/MyApplication.java 的文件以包含以下代码：\n\n@RestController\n@EnableAutoConfiguration\npublic class MyApplication {\n\n    @RequestMapping("/")\n    String home() {\n        return "Hello World!";\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n\n}\n\n\n说明：\n\n@RestController 注解告诉 Spring，这个类是用来处理 Rest 请求的。\n\n@RequestMapping 注解提供了“路由”信息。它告诉 Spring 任何带有 / 路径的 HTTP 请求都应该映射到 home 方法。 @RestController 注解告诉 Spring 将结果字符串直接呈现给调用者。\n\n@EnableAutoConfiguration 注解告诉 Spring Boot 根据你添加的 jar 依赖去自动装配 Spring。\n\n> 自动配置旨在与“Starters”配合使用，但这两个概念并没有直接联系。您可以自由选择 starters 之外的 jar 依赖项。 Spring Boot 仍然尽力自动配置您的应用程序。\n\nSpring Boot 的 main 方法通过调用 run 委托给 Spring Boot 的 SpringApplication 类。 SpringApplication 引导我们的应用程序，启动 Spring，进而启动自动配置的 Tomcat Web 服务器。我们需要将 MyApplication.class 作为参数传递给 run 方法，以告诉 SpringApplication 哪个是入口类。还传递 args 数组以公开任何命令行参数。\n\n\n# 运行示例\n\n此时，您的应用程序应该可以工作了。由于您使用了 spring-boot-starter-parent POM，因此您有一个有用的运行目标，可用于启动应用程序。从项目根目录键入 mvn spring-boot:run 以启动应用程序。您应该会看到类似于以下内容的输出：\n\n$ mvn spring-boot:run\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ Started MyApplication in 2.222 seconds (JVM running for 6.514)\n\n\n如果您打开 Web 浏览器访问 localhost:8080，您应该会看到以下输出：\n\nHello World!\n\n\n要正常退出应用程序，请按 ctrl-c。\n\n\n# 创建可执行 jar\n\n要创建一个可执行的 jar，我们需要将 spring-boot-maven-plugin 添加到我们的 pom.xml 中。为此，请在依赖项部分下方插入以下行：\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n\n\n保存 pom.xml 并从命令行运行 mvn package，如下所示：\n\n$ mvn package\n\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building myproject 0.0.1-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] .... ..\n[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---\n[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar\n[INFO]\n[INFO] --- spring-boot-maven-plugin:2.6.1:repackage (default) @ myproject ---\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n\n\n如果您查看 target 目录，应该会看到 myproject-0.0.1-SNAPSHOT.jar。该文件的大小应约为 10 MB。如果想看里面，可以使用 jar tvf，如下：\n\n$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar\n\n\n您还应该在目标目录中看到一个更小的名为 myproject-0.0.1-SNAPSHOT.jar.original 的文件。这是 Maven 在 Spring Boot 重新打包之前创建的原始 jar 文件。\n\n要运行该应用程序，请使用 java -jar 命令，如下所示：\n\n$ java -jar target/myproject-0.0.1-SNAPSHOT.jar\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ Started MyApplication in 2.536 seconds (JVM running for 2.864)\n\n\n和以前一样，要退出应用程序，请按 ctrl-c。\n\n\n# 通过 SPRING INITIALIZR 创建 Spring Boot 项目\n\n\n# 创建项目\n\n通过 SPRING INITIALIZR 工具产生基础项目\n\n 1. 访问：http://start.spring.io/\n 2. 选择构建工具Maven Project、Spring Boot 版本 1.5.10 以及一些工程基本信息，可参考下图所示：\n\n\n\n 3. 点击Generate Project下载项目压缩包\n 4. 解压压缩包，包中已是一个完整的项目。\n\n如果你使用 Intellij 作为 IDE，那么你可以直接使用 SPRING INITIALIZR，参考下图操作：\n\n\n\n\n# 项目说明\n\n重要文件\n\n * src/main/java 路径下的 Chapter1Application 类 ：程序入口\n * src/main/resources 路径下的 application.properties ：项目配置文件\n * src/test/java 路径下的 Chapter01ApplicationTests ：程序测试入口\n\npom.xml\n\npom 中指定 parent 为以下内容，表示此项目继承了 spring-boot-starter-parent 的 maven 配置（主要是指定了常用依赖、插件的版本）。\n\n<parent>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-parent</artifactId>\n <version>1.5.10.RELEASE</version>\n <relativePath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n\n\n此外，pom 中默认引入两个依赖包，和一个插件。\n\n<dependencies>\n <dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n </dependency>\n\n <dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-test</artifactId>\n  <scope>test</scope>\n </dependency>\n</dependencies>\n\n<build>\n <plugins>\n  <plugin>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-maven-plugin</artifactId>\n  </plugin>\n </plugins>\n</build>\n\n\n * spring-boot-starter-web：核心模块，包括自动配置支持、日志和 YAML。\n * spring-boot-starter-test：测试模块，包括 JUnit、Hamcrest、Mockito。\n * spring-boot-maven-plugin：spring boot 插件， 提供了一系列 spring boot 相关的 maven 操作。\n   * spring-boot:build-info，生成 Actuator 使用的构建信息文件 build-info.properties\n   * spring-boot:repackage，默认 goal。在 mvn package 之后，再次打包可执行的 jar/war，同时保留 mvn package 生成的 jar/war 为.origin\n   * spring-boot:run，运行 Spring Boot 应用\n   * spring-boot:start，在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理\n   * spring-boot:stop，在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理\n\n\n# 编写 REST 服务\n\n * 创建 package ，名为 io.github.zp.springboot.chapter1.web（根据项目情况修改）\n * 创建 HelloController 类，内容如下：\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping("/hello")\n    public String index() {\n        return "Hello World";\n    }\n\n}\n\n\n * 启动主程序 XXXApplication，打开浏览器访问http://localhost:8080/hello ，可以看到页面输出Hello World\n\n\n# 编写单元测试用例\n\n在 XXXApplicationTests 类中编写一个简单的单元测试来模拟 HTTP 请求，具体如下：\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(classes = MockServletContext.class)\n@WebAppConfiguration\npublic class SpringBootHelloWorldApplicationTest {\n\n\tprivate MockMvc mvc;\n\n\t@Before\n\tpublic void setUp() {\n\t\tmvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n\t}\n\n\t@Test\n\tpublic void getHello() throws Exception {\n\t\tmvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON))\n\t\t\t\t.andExpect(status().isOk())\n\t\t\t\t.andExpect(content().string(equalTo("Hello World")));\n\t}\n\n}\n\n\n使用MockServletContext来构建一个空的WebApplicationContext，这样我们创建的HelloController就可以在@Before函数中创建并传递到MockMvcBuilders.standaloneSetup（）函数中。\n\n * 注意引入下面内容，让status、content、equalTo函数可用\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n\n至此已完成目标，通过 Maven 构建了一个空白 Spring Boot 项目，再通过引入 web 模块实现了一个简单的请求处理。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-web-helloworld\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 Getting Started',normalizedContent:'# springboot 之快速入门\n\n\n# spring boot 简介\n\nspring boot 可以让使用者非常方便的创建 spring 应用。\n\nspring boot 的目标是：\n\n * 为所有 spring 开发者提供更快且可广泛访问的入门体验。\n * 开箱即用\n * 提供一系列通用的非功能特性（例如嵌入式服务、安全、指标、健康检查和外部化配置）\n * 完全不需要代码生成，也不需要 xml 配置。\n\n\n# spring boot 系统要求\n\nspring boot 的构建工具要求：\n\nbuild tool   version\nmaven        3.5+\ngradle       6.8.x, 6.9.x, and 7.x\n\nspring boot 支持的 servlet 容器：\n\nname           servlet version\ntomcat 9.0     4.0\njetty 9.4      3.1\njetty 10.0     4.0\nundertow 2.0   4.0\n\n\n# 部署第一个 spring boot 项目\n\n> 本节介绍如何开发一个小的“hello world!” web 应用示例，来展示 spring boot 的一些关键功能。我们使用 maven 来构建这个项目，因为大多数 ide 都支持它。\n\n\n# 环境检查\n\nspring boot 项目依赖于 java 环境和 mave，开始项目之前需要先检查一下环境。\n\n本地是否已安装 java：\n\n$ java -version\njava version "1.8.0_102"\njava(tm) se runtime environment (build 1.8.0_102-b14)\njava hotspot(tm) 64-bit server vm (build 25.102-b14, mixed mode)\n\n\n本地是否已安装 maven：\n\n$ mvn -v\napache maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17t14:33:14-04:00)\nmaven home: /usr/local/cellar/maven/3.3.9/libexec\njava version: 1.8.0_102, vendor: oracle corporation\n\n\n\n# 创建 pom\n\n我们需要从创建 maven pom.xml 文件开始。 pom.xml 是 maven 用于构建项目的配置文件。\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xsi:schemalocation="http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelversion>4.0.0</modelversion>\n\n    <groupid>com.example</groupid>\n    <artifactid>myproject</artifactid>\n    <version>0.0.1-snapshot</version>\n\n    <parent>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-parent</artifactid>\n        <version>2.6.1</version>\n    </parent>\n\n    \x3c!-- additional lines to be added here... --\x3e\n\n</project>\n\n\n使用者可以通过运行 mvn package 来测试它\n\n\n# 添加依赖\n\nspring boot 提供了许多启动器（starters）以应对不同的使用场景。使用者可将 jars 添加到类路径中。我们的示例程序在 pom 的 parent 使用 spring-boot-starter-parent。 spring-boot-starter-parent 是一个特殊的启动器，提供有用的 maven 默认值。它还提供了一个依赖项的版本管理，可以让使用者使用时不必显示指定版本。\n\n其他启动器（starters）提供了各种针对不同使用场景的功能。比如，我们需要开发一个 web 应用程序，就可以添加了一个 spring-boot-starter-web 依赖项。在此之前，我们可以通过运行以下命令来查看我们当前拥有的 maven 依赖：\n\n$ mvn dependency:tree\n\n[info] com.example:myproject:jar:0.0.1-snapshot\n\n\nmvn dependency:tree 命令打印项目依赖项的层级结构。可以看到 spring-boot-starter-parent 本身没有提供任何依赖。要添加必要的依赖，需要编辑 pom.xml 并在 <dependencies> 部分添加 spring-boot-starter-web 依赖项：\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n</dependencies>\n\n\n\n# 编写代码\n\n要运行应用程序，我们需要创建一个启动类。默认情况下，maven 从 src/main/java 编译源代码，因此您需要创建该目录结构，然后添加一个名为 src/main/java/myapplication.java 的文件以包含以下代码：\n\n@restcontroller\n@enableautoconfiguration\npublic class myapplication {\n\n    @requestmapping("/")\n    string home() {\n        return "hello world!";\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(myapplication.class, args);\n    }\n\n}\n\n\n说明：\n\n@restcontroller 注解告诉 spring，这个类是用来处理 rest 请求的。\n\n@requestmapping 注解提供了“路由”信息。它告诉 spring 任何带有 / 路径的 http 请求都应该映射到 home 方法。 @restcontroller 注解告诉 spring 将结果字符串直接呈现给调用者。\n\n@enableautoconfiguration 注解告诉 spring boot 根据你添加的 jar 依赖去自动装配 spring。\n\n> 自动配置旨在与“starters”配合使用，但这两个概念并没有直接联系。您可以自由选择 starters 之外的 jar 依赖项。 spring boot 仍然尽力自动配置您的应用程序。\n\nspring boot 的 main 方法通过调用 run 委托给 spring boot 的 springapplication 类。 springapplication 引导我们的应用程序，启动 spring，进而启动自动配置的 tomcat web 服务器。我们需要将 myapplication.class 作为参数传递给 run 方法，以告诉 springapplication 哪个是入口类。还传递 args 数组以公开任何命令行参数。\n\n\n# 运行示例\n\n此时，您的应用程序应该可以工作了。由于您使用了 spring-boot-starter-parent pom，因此您有一个有用的运行目标，可用于启动应用程序。从项目根目录键入 mvn spring-boot:run 以启动应用程序。您应该会看到类似于以下内容的输出：\n\n$ mvn spring-boot:run\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ started myapplication in 2.222 seconds (jvm running for 6.514)\n\n\n如果您打开 web 浏览器访问 localhost:8080，您应该会看到以下输出：\n\nhello world!\n\n\n要正常退出应用程序，请按 ctrl-c。\n\n\n# 创建可执行 jar\n\n要创建一个可执行的 jar，我们需要将 spring-boot-maven-plugin 添加到我们的 pom.xml 中。为此，请在依赖项部分下方插入以下行：\n\n<build>\n    <plugins>\n        <plugin>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-maven-plugin</artifactid>\n        </plugin>\n    </plugins>\n</build>\n\n\n保存 pom.xml 并从命令行运行 mvn package，如下所示：\n\n$ mvn package\n\n[info] scanning for projects...\n[info]\n[info] ------------------------------------------------------------------------\n[info] building myproject 0.0.1-snapshot\n[info] ------------------------------------------------------------------------\n[info] .... ..\n[info] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---\n[info] building jar: /users/developer/example/spring-boot-example/target/myproject-0.0.1-snapshot.jar\n[info]\n[info] --- spring-boot-maven-plugin:2.6.1:repackage (default) @ myproject ---\n[info] ------------------------------------------------------------------------\n[info] build success\n[info] ------------------------------------------------------------------------\n\n\n如果您查看 target 目录，应该会看到 myproject-0.0.1-snapshot.jar。该文件的大小应约为 10 mb。如果想看里面，可以使用 jar tvf，如下：\n\n$ jar tvf target/myproject-0.0.1-snapshot.jar\n\n\n您还应该在目标目录中看到一个更小的名为 myproject-0.0.1-snapshot.jar.original 的文件。这是 maven 在 spring boot 重新打包之前创建的原始 jar 文件。\n\n要运行该应用程序，请使用 java -jar 命令，如下所示：\n\n$ java -jar target/myproject-0.0.1-snapshot.jar\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::  (v2.6.1)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ started myapplication in 2.536 seconds (jvm running for 2.864)\n\n\n和以前一样，要退出应用程序，请按 ctrl-c。\n\n\n# 通过 spring initializr 创建 spring boot 项目\n\n\n# 创建项目\n\n通过 spring initializr 工具产生基础项目\n\n 1. 访问：http://start.spring.io/\n 2. 选择构建工具maven project、spring boot 版本 1.5.10 以及一些工程基本信息，可参考下图所示：\n\n\n\n 3. 点击generate project下载项目压缩包\n 4. 解压压缩包，包中已是一个完整的项目。\n\n如果你使用 intellij 作为 ide，那么你可以直接使用 spring initializr，参考下图操作：\n\n\n\n\n# 项目说明\n\n重要文件\n\n * src/main/java 路径下的 chapter1application 类 ：程序入口\n * src/main/resources 路径下的 application.properties ：项目配置文件\n * src/test/java 路径下的 chapter01applicationtests ：程序测试入口\n\npom.xml\n\npom 中指定 parent 为以下内容，表示此项目继承了 spring-boot-starter-parent 的 maven 配置（主要是指定了常用依赖、插件的版本）。\n\n<parent>\n <groupid>org.springframework.boot</groupid>\n <artifactid>spring-boot-starter-parent</artifactid>\n <version>1.5.10.release</version>\n <relativepath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n\n\n此外，pom 中默认引入两个依赖包，和一个插件。\n\n<dependencies>\n <dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-web</artifactid>\n </dependency>\n\n <dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-test</artifactid>\n  <scope>test</scope>\n </dependency>\n</dependencies>\n\n<build>\n <plugins>\n  <plugin>\n   <groupid>org.springframework.boot</groupid>\n   <artifactid>spring-boot-maven-plugin</artifactid>\n  </plugin>\n </plugins>\n</build>\n\n\n * spring-boot-starter-web：核心模块，包括自动配置支持、日志和 yaml。\n * spring-boot-starter-test：测试模块，包括 junit、hamcrest、mockito。\n * spring-boot-maven-plugin：spring boot 插件， 提供了一系列 spring boot 相关的 maven 操作。\n   * spring-boot:build-info，生成 actuator 使用的构建信息文件 build-info.properties\n   * spring-boot:repackage，默认 goal。在 mvn package 之后，再次打包可执行的 jar/war，同时保留 mvn package 生成的 jar/war 为.origin\n   * spring-boot:run，运行 spring boot 应用\n   * spring-boot:start，在 mvn integration-test 阶段，进行 spring boot 应用生命周期的管理\n   * spring-boot:stop，在 mvn integration-test 阶段，进行 spring boot 应用生命周期的管理\n\n\n# 编写 rest 服务\n\n * 创建 package ，名为 io.github.zp.springboot.chapter1.web（根据项目情况修改）\n * 创建 hellocontroller 类，内容如下：\n\n@restcontroller\npublic class hellocontroller {\n\n    @requestmapping("/hello")\n    public string index() {\n        return "hello world";\n    }\n\n}\n\n\n * 启动主程序 xxxapplication，打开浏览器访问http://localhost:8080/hello ，可以看到页面输出hello world\n\n\n# 编写单元测试用例\n\n在 xxxapplicationtests 类中编写一个简单的单元测试来模拟 http 请求，具体如下：\n\n@runwith(springjunit4classrunner.class)\n@springapplicationconfiguration(classes = mockservletcontext.class)\n@webappconfiguration\npublic class springboothelloworldapplicationtest {\n\n\tprivate mockmvc mvc;\n\n\t@before\n\tpublic void setup() {\n\t\tmvc = mockmvcbuilders.standalonesetup(new hellocontroller()).build();\n\t}\n\n\t@test\n\tpublic void gethello() throws exception {\n\t\tmvc.perform(mockmvcrequestbuilders.get("/hello").accept(mediatype.application_json))\n\t\t\t\t.andexpect(status().isok())\n\t\t\t\t.andexpect(content().string(equalto("hello world")));\n\t}\n\n}\n\n\n使用mockservletcontext来构建一个空的webapplicationcontext，这样我们创建的hellocontroller就可以在@before函数中创建并传递到mockmvcbuilders.standalonesetup（）函数中。\n\n * 注意引入下面内容，让status、content、equalto函数可用\n\nimport static org.hamcrest.matchers.equalto;\nimport static org.springframework.test.web.servlet.result.mockmvcresultmatchers.content;\nimport static org.springframework.test.web.servlet.result.mockmvcresultmatchers.status;\n\n\n至此已完成目标，通过 maven 构建了一个空白 spring boot 项目，再通过引入 web 模块实现了一个简单的请求处理。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-web-helloworld\n\n\n# 参考资料\n\n * spring boot 官方文档之 getting started',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 之属性加载详解",frontmatter:{title:"SpringBoot 之属性加载详解",date:"2019-01-10T11:55:54.000Z",order:32,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/0fb992/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/32.SpringBoot%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/32.SpringBoot之属性加载.md",key:"v-5bd37d3c",path:"/pages/0fb992/",headers:[{level:2,title:"加载 property 顺序",slug:"加载-property-顺序",normalizedTitle:"加载 property 顺序",charIndex:25},{level:2,title:"随机属性",slug:"随机属性",normalizedTitle:"随机属性",charIndex:839},{level:2,title:"命令行属性",slug:"命令行属性",normalizedTitle:"命令行属性",charIndex:1080},{level:2,title:"Application 属性文件",slug:"application-属性文件",normalizedTitle:"application 属性文件",charIndex:1267},{level:2,title:"Profile 特定属性",slug:"profile-特定属性",normalizedTitle:"profile 特定属性",charIndex:1837},{level:2,title:"属性中的占位符",slug:"属性中的占位符",normalizedTitle:"属性中的占位符",charIndex:2026},{level:2,title:"YAML 属性",slug:"yaml-属性",normalizedTitle:"yaml 属性",charIndex:2262},{level:3,title:"访问属性",slug:"访问属性",normalizedTitle:"访问属性",charIndex:2889},{level:3,title:"多 profile 配置",slug:"多-profile-配置",normalizedTitle:"多 profile 配置",charIndex:3036},{level:3,title:"YAML 的缺点",slug:"yaml-的缺点",normalizedTitle:"yaml 的缺点",charIndex:3234},{level:2,title:"属性前缀",slug:"属性前缀",normalizedTitle:"属性前缀",charIndex:3323},{level:2,title:"属性松散绑定规则",slug:"属性松散绑定规则",normalizedTitle:"属性松散绑定规则",charIndex:4709},{level:2,title:"属性转换",slug:"属性转换",normalizedTitle:"属性转换",charIndex:4969},{level:3,title:"时间单位转换",slug:"时间单位转换",normalizedTitle:"时间单位转换",charIndex:5158},{level:3,title:"数据大小转换",slug:"数据大小转换",normalizedTitle:"数据大小转换",charIndex:5978},{level:2,title:"校验属性",slug:"校验属性",normalizedTitle:"校验属性",charIndex:6650},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:7071},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7109}],headersStr:"加载 property 顺序 随机属性 命令行属性 Application 属性文件 Profile 特定属性 属性中的占位符 YAML 属性 访问属性 多 profile 配置 YAML 的缺点 属性前缀 属性松散绑定规则 属性转换 时间单位转换 数据大小转换 校验属性 示例源码 参考资料",content:'# SpringBoot 之属性加载详解\n\n\n# 加载 property 顺序\n\nSpring Boot 加载 property 顺序如下：\n\n 1.  Devtools 全局配置 (当 devtools 被激活 ~/.spring-boot-devtools.properties).\n 2.  测试环境中的 @TestPropertySource 注解配置\n 3.  测试环境中的属性 properties：@SpringBootTest 和 测试注解.\n 4.  命令行参数\n 5.  SPRING_APPLICATION_JSON 属性\n 6.  ServletConfig 初始化参数\n 7.  ServletContext 初始化参数\n 8.  JNDI attributes from 通过 java:comp/env 配置的 JNDI 属性\n 9.  Java 系统属性 (System.getProperties())\n 10. 操作系统环境比那里\n 11. RandomValuePropertySource 加载 random.* 形式的属性\n 12. jar 包外的 application-{profile}.properties 或 application-{profile}.yml 配置\n 13. jar 包内的 application-{profile}.properties 或 application-{profile}.yml 配置\n 14. jar 包外的 application.properties 或 application.yml 配置\n 15. jar 包内的 application.properties 或 application.yml 配置\n 16. @PropertySource 绑定的配置\n 17. 默认属性 (通过 SpringApplication.setDefaultProperties 指定)\n\n\n# 随机属性\n\nRandomValuePropertySource 类用于配置随机值。\n\n示例：\n\nmy.secret=${random.value}\nmy.number=${random.int}\nmy.bignumber=${random.long}\nmy.uuid=${random.uuid}\nmy.number.less.than.ten=${random.int(10)}\nmy.number.in.range=${random.int[1024,65536]}\n\n\n\n# 命令行属性\n\n默认情况下， SpringApplication 会获取 -- 参数（例如 --server.port=9000 ），并将这个 property 添加到 Spring 的 Environment 中。\n\n如果不想加载命令行属性，可以通过 SpringApplication.setAddCommandLineProperties(false) 禁用。\n\n\n# Application 属性文件\n\nSpringApplication 会自动加载以下路径下的 application.properties 配置文件，将其中的属性读到 Spring 的 Environment 中。\n\n 1. 当前目录的 /config 子目录\n 2. 当前目录\n 3. classpath 路径下的 /config package\n 4. classpath 根路径\n\n> 注：\n> \n> 以上列表的配置文件会根据顺序，后序的配置会覆盖前序的配置。\n> \n> 你可以选择 YAML(yml) 配置文件替换 properties 配置文件。\n\n如果不喜欢 application.properties 作为配置文件名，可以使用 spring.config.name 环境变量替换：\n\n$ java -jar myproject.jar --spring.config.name=myproject\n\n\n可以使用 spring.config.location 环境变量指定配置文件路径：\n\n$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties\n\n\n\n# Profile 特定属性\n\n如果定义 application-{profile}.properties 形式的配置文件，将被视为 profile 环境下的特定配置。\n\n可以通过 spring.profiles.active 参数来激活 profile，如果没有激活的 profile,默认会加载 application-default.properties 中的配置。\n\n\n# 属性中的占位符\n\napplication.properties 中的值会被 Environment 过滤，所以，可以引用之前定义的属性。\n\napp.name=MyApp\napp.description=${app.name} is a Spring Boot application\n\n\n> 注：你可以使用此技术来创建 Spring Boot 属性变量。请参考： Section 77.4, “Use ‘Short’ Command Line Arguments\n\n\n# YAML 属性\n\nSpring 框架有两个类支持加载 YAML 文件。\n\n * YamlPropertiesFactoryBean 将 YAML 文件的配置加载为 Properties 。\n * YamlMapFactoryBean 将 YAML 文件的配置加载为 Map 。\n\n示例 1\n\nenvironments:\n\tdev:\n\t\turl: http://dev.example.com\n\t\tname: Developer Setup\n\tprod:\n\t\turl: http://another.example.com\n\t\tname: My Cool App\n\n\n等价于：\n\nenvironments.dev.url=http://dev.example.com\nenvironments.dev.name=Developer Setup\nenvironments.prod.url=http://another.example.com\nenvironments.prod.name=My Cool App\n\n\nYAML 支持列表形式，等价于 property 中的 [index] ：\n\nmy:\nservers:\n\t- dev.example.com\n\t- another.example.com\n\n\n等价于\n\nmy.servers[0]=dev.example.com\nmy.servers[1]=another.example.com\n\n\n\n# 访问属性\n\nYamlPropertySourceLoader 类会将 YAML 配置转化为 Spring Environment 类中的 PropertySource 。然后，你可以如同 properties 文件中的属性一样，使用 @Value 注解来访问 YAML 中配置的属性。\n\n\n# 多 profile 配置\n\nserver:\n  address: 192.168.1.100\n---\nspring:\n  profiles: development\nserver:\n  address: 127.0.0.1\n---\nspring:\n  profiles: production & eu-central\nserver:\n  address: 192.168.1.120\n\n\n\n# YAML 的缺点\n\n注：YAML 注解中的属性不能通过 @PropertySource 注解来访问。所以，如果你的项目中使用了一些自定义属性文件，建议不要用 YAML。\n\n\n# 属性前缀\n\npackage com.example;\n\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix="acme")\npublic class AcmeProperties {\n\n\tprivate boolean enabled;\n\n\tprivate InetAddress remoteAddress;\n\n\tprivate final Security security = new Security();\n\n\tpublic boolean isEnabled() { ... }\n\n\tpublic void setEnabled(boolean enabled) { ... }\n\n\tpublic InetAddress getRemoteAddress() { ... }\n\n\tpublic void setRemoteAddress(InetAddress remoteAddress) { ... }\n\n\tpublic Security getSecurity() { ... }\n\n\tpublic static class Security {\n\n\t\tprivate String username;\n\n\t\tprivate String password;\n\n\t\tprivate List<String> roles = new ArrayList<>(Collections.singleton("USER"));\n\n\t\tpublic String getUsername() { ... }\n\n\t\tpublic void setUsername(String username) { ... }\n\n\t\tpublic String getPassword() { ... }\n\n\t\tpublic void setPassword(String password) { ... }\n\n\t\tpublic List<String> getRoles() { ... }\n\n\t\tpublic void setRoles(List<String> roles) { ... }\n\n\t}\n}\n\n\n相当于支持配置以下属性：\n\n * acme.enabled\n * acme.remote-address\n * acme.security.username\n * acme.security.password\n * acme.security.roles\n\n然后，你需要使用 @EnableConfigurationProperties 注解将属性类注入配置类中。\n\n@Configuration\n@EnableConfigurationProperties(AcmeProperties.class)\npublic class MyConfiguration {\n}\n\n\n\n# 属性松散绑定规则\n\nSpring Boot 属性名绑定比较松散。\n\n以下属性 key 都是等价的：\n\nPROPERTY                            NOTE\nacme.my-project.person.first-name   - 分隔\nacme.myProject.person.firstName     驼峰命名\nacme.my_project.person.first_name   _ 分隔\nACME_MYPROJECT_PERSON_FIRSTNAME     大写字母\n\n\n# 属性转换\n\n如果需要类型转换，你可以提供一个 ConversionService bean (一个名叫 conversionService 的 bean) 或自定义属性配置 (一个 CustomEditorConfigurer bean) 或自定义的 Converters (被 @ConfigurationPropertiesBinding 注解修饰的 bena)。\n\n\n# 时间单位转换\n\nSpring 使用 java.time.Duration 类代表时间大小，以下场景适用：\n\n * 除非指定 @DurationUnit ，否则一个 long 代表的时间为毫秒。\n * ISO-8601 标准格式（ java.time.Duration 的实现就是参照此标准）\n * 你也可以使用以下支持的单位：\n   * ns - 纳秒\n   * us - 微秒\n   * ms - 毫秒\n   * s - 秒\n   * m - 分\n   * h - 时\n   * d - 天\n\n示例：\n\n@ConfigurationProperties("app.system")\npublic class AppSystemProperties {\n\n\t@DurationUnit(ChronoUnit.SECONDS)\n\tprivate Duration sessionTimeout = Duration.ofSeconds(30);\n\n\tprivate Duration readTimeout = Duration.ofMillis(1000);\n\n\tpublic Duration getSessionTimeout() {\n\t\treturn this.sessionTimeout;\n\t}\n\n\tpublic void setSessionTimeout(Duration sessionTimeout) {\n\t\tthis.sessionTimeout = sessionTimeout;\n\t}\n\n\tpublic Duration getReadTimeout() {\n\t\treturn this.readTimeout;\n\t}\n\n\tpublic void setReadTimeout(Duration readTimeout) {\n\t\tthis.readTimeout = readTimeout;\n\t}\n\n}\n\n\n\n# 数据大小转换\n\nSpring 使用 DataSize 类代表数据大小，以下场景适用：\n\n * long 值（默认视为 byte）\n * 你也可以使用以下支持的单位：\n   * B\n   * KB\n   * MB\n   * GB\n   * TB\n\n示例：\n\n@ConfigurationProperties("app.io")\npublic class AppIoProperties {\n\n\t@DataSizeUnit(DataUnit.MEGABYTES)\n\tprivate DataSize bufferSize = DataSize.ofMegabytes(2);\n\n\tprivate DataSize sizeThreshold = DataSize.ofBytes(512);\n\n\tpublic DataSize getBufferSize() {\n\t\treturn this.bufferSize;\n\t}\n\n\tpublic void setBufferSize(DataSize bufferSize) {\n\t\tthis.bufferSize = bufferSize;\n\t}\n\n\tpublic DataSize getSizeThreshold() {\n\t\treturn this.sizeThreshold;\n\t}\n\n\tpublic void setSizeThreshold(DataSize sizeThreshold) {\n\t\tthis.sizeThreshold = sizeThreshold;\n\t}\n\n}\n\n\n\n# 校验属性\n\n@ConfigurationProperties(prefix="acme")\n@Validated\npublic class AcmeProperties {\n\n\t@NotNull\n\tprivate InetAddress remoteAddress;\n\n\t@Valid\n\tprivate final Security security = new Security();\n\n\t// ... getters and setters\n\n\tpublic static class Security {\n\n\t\t@NotEmpty\n\t\tpublic String username;\n\n\t\t// ... getters and setters\n\n\t}\n\n}\n\n\n你也可以自定义一个名为 configurationPropertiesValidator 的校验器 Bean。获取这个 @Bean 的方法必须声明为 static。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-property\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 boot-features-external-config',normalizedContent:'# springboot 之属性加载详解\n\n\n# 加载 property 顺序\n\nspring boot 加载 property 顺序如下：\n\n 1.  devtools 全局配置 (当 devtools 被激活 ~/.spring-boot-devtools.properties).\n 2.  测试环境中的 @testpropertysource 注解配置\n 3.  测试环境中的属性 properties：@springboottest 和 测试注解.\n 4.  命令行参数\n 5.  spring_application_json 属性\n 6.  servletconfig 初始化参数\n 7.  servletcontext 初始化参数\n 8.  jndi attributes from 通过 java:comp/env 配置的 jndi 属性\n 9.  java 系统属性 (system.getproperties())\n 10. 操作系统环境比那里\n 11. randomvaluepropertysource 加载 random.* 形式的属性\n 12. jar 包外的 application-{profile}.properties 或 application-{profile}.yml 配置\n 13. jar 包内的 application-{profile}.properties 或 application-{profile}.yml 配置\n 14. jar 包外的 application.properties 或 application.yml 配置\n 15. jar 包内的 application.properties 或 application.yml 配置\n 16. @propertysource 绑定的配置\n 17. 默认属性 (通过 springapplication.setdefaultproperties 指定)\n\n\n# 随机属性\n\nrandomvaluepropertysource 类用于配置随机值。\n\n示例：\n\nmy.secret=${random.value}\nmy.number=${random.int}\nmy.bignumber=${random.long}\nmy.uuid=${random.uuid}\nmy.number.less.than.ten=${random.int(10)}\nmy.number.in.range=${random.int[1024,65536]}\n\n\n\n# 命令行属性\n\n默认情况下， springapplication 会获取 -- 参数（例如 --server.port=9000 ），并将这个 property 添加到 spring 的 environment 中。\n\n如果不想加载命令行属性，可以通过 springapplication.setaddcommandlineproperties(false) 禁用。\n\n\n# application 属性文件\n\nspringapplication 会自动加载以下路径下的 application.properties 配置文件，将其中的属性读到 spring 的 environment 中。\n\n 1. 当前目录的 /config 子目录\n 2. 当前目录\n 3. classpath 路径下的 /config package\n 4. classpath 根路径\n\n> 注：\n> \n> 以上列表的配置文件会根据顺序，后序的配置会覆盖前序的配置。\n> \n> 你可以选择 yaml(yml) 配置文件替换 properties 配置文件。\n\n如果不喜欢 application.properties 作为配置文件名，可以使用 spring.config.name 环境变量替换：\n\n$ java -jar myproject.jar --spring.config.name=myproject\n\n\n可以使用 spring.config.location 环境变量指定配置文件路径：\n\n$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties\n\n\n\n# profile 特定属性\n\n如果定义 application-{profile}.properties 形式的配置文件，将被视为 profile 环境下的特定配置。\n\n可以通过 spring.profiles.active 参数来激活 profile，如果没有激活的 profile,默认会加载 application-default.properties 中的配置。\n\n\n# 属性中的占位符\n\napplication.properties 中的值会被 environment 过滤，所以，可以引用之前定义的属性。\n\napp.name=myapp\napp.description=${app.name} is a spring boot application\n\n\n> 注：你可以使用此技术来创建 spring boot 属性变量。请参考： section 77.4, “use ‘short’ command line arguments\n\n\n# yaml 属性\n\nspring 框架有两个类支持加载 yaml 文件。\n\n * yamlpropertiesfactorybean 将 yaml 文件的配置加载为 properties 。\n * yamlmapfactorybean 将 yaml 文件的配置加载为 map 。\n\n示例 1\n\nenvironments:\n\tdev:\n\t\turl: http://dev.example.com\n\t\tname: developer setup\n\tprod:\n\t\turl: http://another.example.com\n\t\tname: my cool app\n\n\n等价于：\n\nenvironments.dev.url=http://dev.example.com\nenvironments.dev.name=developer setup\nenvironments.prod.url=http://another.example.com\nenvironments.prod.name=my cool app\n\n\nyaml 支持列表形式，等价于 property 中的 [index] ：\n\nmy:\nservers:\n\t- dev.example.com\n\t- another.example.com\n\n\n等价于\n\nmy.servers[0]=dev.example.com\nmy.servers[1]=another.example.com\n\n\n\n# 访问属性\n\nyamlpropertysourceloader 类会将 yaml 配置转化为 spring environment 类中的 propertysource 。然后，你可以如同 properties 文件中的属性一样，使用 @value 注解来访问 yaml 中配置的属性。\n\n\n# 多 profile 配置\n\nserver:\n  address: 192.168.1.100\n---\nspring:\n  profiles: development\nserver:\n  address: 127.0.0.1\n---\nspring:\n  profiles: production & eu-central\nserver:\n  address: 192.168.1.120\n\n\n\n# yaml 的缺点\n\n注：yaml 注解中的属性不能通过 @propertysource 注解来访问。所以，如果你的项目中使用了一些自定义属性文件，建议不要用 yaml。\n\n\n# 属性前缀\n\npackage com.example;\n\nimport java.net.inetaddress;\nimport java.util.arraylist;\nimport java.util.collections;\nimport java.util.list;\n\nimport org.springframework.boot.context.properties.configurationproperties;\n\n@configurationproperties(prefix="acme")\npublic class acmeproperties {\n\n\tprivate boolean enabled;\n\n\tprivate inetaddress remoteaddress;\n\n\tprivate final security security = new security();\n\n\tpublic boolean isenabled() { ... }\n\n\tpublic void setenabled(boolean enabled) { ... }\n\n\tpublic inetaddress getremoteaddress() { ... }\n\n\tpublic void setremoteaddress(inetaddress remoteaddress) { ... }\n\n\tpublic security getsecurity() { ... }\n\n\tpublic static class security {\n\n\t\tprivate string username;\n\n\t\tprivate string password;\n\n\t\tprivate list<string> roles = new arraylist<>(collections.singleton("user"));\n\n\t\tpublic string getusername() { ... }\n\n\t\tpublic void setusername(string username) { ... }\n\n\t\tpublic string getpassword() { ... }\n\n\t\tpublic void setpassword(string password) { ... }\n\n\t\tpublic list<string> getroles() { ... }\n\n\t\tpublic void setroles(list<string> roles) { ... }\n\n\t}\n}\n\n\n相当于支持配置以下属性：\n\n * acme.enabled\n * acme.remote-address\n * acme.security.username\n * acme.security.password\n * acme.security.roles\n\n然后，你需要使用 @enableconfigurationproperties 注解将属性类注入配置类中。\n\n@configuration\n@enableconfigurationproperties(acmeproperties.class)\npublic class myconfiguration {\n}\n\n\n\n# 属性松散绑定规则\n\nspring boot 属性名绑定比较松散。\n\n以下属性 key 都是等价的：\n\nproperty                            note\nacme.my-project.person.first-name   - 分隔\nacme.myproject.person.firstname     驼峰命名\nacme.my_project.person.first_name   _ 分隔\nacme_myproject_person_firstname     大写字母\n\n\n# 属性转换\n\n如果需要类型转换，你可以提供一个 conversionservice bean (一个名叫 conversionservice 的 bean) 或自定义属性配置 (一个 customeditorconfigurer bean) 或自定义的 converters (被 @configurationpropertiesbinding 注解修饰的 bena)。\n\n\n# 时间单位转换\n\nspring 使用 java.time.duration 类代表时间大小，以下场景适用：\n\n * 除非指定 @durationunit ，否则一个 long 代表的时间为毫秒。\n * iso-8601 标准格式（ java.time.duration 的实现就是参照此标准）\n * 你也可以使用以下支持的单位：\n   * ns - 纳秒\n   * us - 微秒\n   * ms - 毫秒\n   * s - 秒\n   * m - 分\n   * h - 时\n   * d - 天\n\n示例：\n\n@configurationproperties("app.system")\npublic class appsystemproperties {\n\n\t@durationunit(chronounit.seconds)\n\tprivate duration sessiontimeout = duration.ofseconds(30);\n\n\tprivate duration readtimeout = duration.ofmillis(1000);\n\n\tpublic duration getsessiontimeout() {\n\t\treturn this.sessiontimeout;\n\t}\n\n\tpublic void setsessiontimeout(duration sessiontimeout) {\n\t\tthis.sessiontimeout = sessiontimeout;\n\t}\n\n\tpublic duration getreadtimeout() {\n\t\treturn this.readtimeout;\n\t}\n\n\tpublic void setreadtimeout(duration readtimeout) {\n\t\tthis.readtimeout = readtimeout;\n\t}\n\n}\n\n\n\n# 数据大小转换\n\nspring 使用 datasize 类代表数据大小，以下场景适用：\n\n * long 值（默认视为 byte）\n * 你也可以使用以下支持的单位：\n   * b\n   * kb\n   * mb\n   * gb\n   * tb\n\n示例：\n\n@configurationproperties("app.io")\npublic class appioproperties {\n\n\t@datasizeunit(dataunit.megabytes)\n\tprivate datasize buffersize = datasize.ofmegabytes(2);\n\n\tprivate datasize sizethreshold = datasize.ofbytes(512);\n\n\tpublic datasize getbuffersize() {\n\t\treturn this.buffersize;\n\t}\n\n\tpublic void setbuffersize(datasize buffersize) {\n\t\tthis.buffersize = buffersize;\n\t}\n\n\tpublic datasize getsizethreshold() {\n\t\treturn this.sizethreshold;\n\t}\n\n\tpublic void setsizethreshold(datasize sizethreshold) {\n\t\tthis.sizethreshold = sizethreshold;\n\t}\n\n}\n\n\n\n# 校验属性\n\n@configurationproperties(prefix="acme")\n@validated\npublic class acmeproperties {\n\n\t@notnull\n\tprivate inetaddress remoteaddress;\n\n\t@valid\n\tprivate final security security = new security();\n\n\t// ... getters and setters\n\n\tpublic static class security {\n\n\t\t@notempty\n\t\tpublic string username;\n\n\t\t// ... getters and setters\n\n\t}\n\n}\n\n\n你也可以自定义一个名为 configurationpropertiesvalidator 的校验器 bean。获取这个 @bean 的方法必须声明为 static。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-property\n\n\n# 参考资料\n\n * spring boot 官方文档之 boot-features-external-config',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 之 Profile",frontmatter:{title:"SpringBoot 之 Profile",date:"2019-11-18T14:55:01.000Z",order:33,categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/cb598e/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/33.SpringBoot%E4%B9%8BProfile.html",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/33.SpringBoot之Profile.md",key:"v-ca7af3d6",path:"/pages/cb598e/",headers:[{level:2,title:"区分环境的配置",slug:"区分环境的配置",normalizedTitle:"区分环境的配置",charIndex:129},{level:3,title:"properties 配置",slug:"properties-配置",normalizedTitle:"properties 配置",charIndex:141},{level:3,title:"yml 配置",slug:"yml-配置",normalizedTitle:"yml 配置",charIndex:441},{level:2,title:"区分环境的代码",slug:"区分环境的代码",normalizedTitle:"区分环境的代码",charIndex:1110},{level:3,title:"修饰类",slug:"修饰类",normalizedTitle:"修饰类",charIndex:1164},{level:3,title:"修饰注解",slug:"修饰注解",normalizedTitle:"修饰注解",charIndex:1450},{level:3,title:"修饰方法",slug:"修饰方法",normalizedTitle:"修饰方法",charIndex:1579},{level:2,title:"激活 profile",slug:"激活-profile",normalizedTitle:"激活 profile",charIndex:393},{level:3,title:"插件激活 profile",slug:"插件激活-profile",normalizedTitle:"插件激活 profile",charIndex:2238},{level:3,title:"main 方法激活 profile",slug:"main-方法激活-profile",normalizedTitle:"main 方法激活 profile",charIndex:2293},{level:3,title:"jar 激活 profile",slug:"jar-激活-profile",normalizedTitle:"jar 激活 profile",charIndex:2347},{level:3,title:"在 Java 代码中激活 profile",slug:"在-java-代码中激活-profile",normalizedTitle:"在 java 代码中激活 profile",charIndex:2414},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:2779},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2816}],headersStr:"区分环境的配置 properties 配置 yml 配置 区分环境的代码 修饰类 修饰注解 修饰方法 激活 profile 插件激活 profile main 方法激活 profile jar 激活 profile 在 Java 代码中激活 profile 示例源码 参考资料",content:'# SpringBoot 之 Profile\n\n> 一个应用为了在不同的环境下工作，常常会有不同的配置，代码逻辑处理。Spring Boot 对此提供了简便的支持。\n> \n> 关键词： @Profile、spring.profiles.active\n\n\n# 区分环境的配置\n\n\n# properties 配置\n\n假设，一个应用的工作环境有：dev、test、prod\n\n那么，我们可以添加 4 个配置文件：\n\n * applcation.properties - 公共配置\n * application-dev.properties - 开发环境配置\n * application-test.properties - 测试环境配置\n * application-prod.properties - 生产环境配置\n\n在 applcation.properties 文件中可以通过以下配置来激活 profile：\n\nspring.profiles.active = test\n\n\n\n# yml 配置\n\n与 properties 文件类似，我们也可以添加 4 个配置文件：\n\n * applcation.yml - 公共配置\n * application-dev.yml - 开发环境配置\n * application-test.yml - 测试环境配置\n * application-prod.yml - 生产环境配置\n\n在 applcation.yml 文件中可以通过以下配置来激活 profile：\n\nspring:\n  profiles:\n    active: prod\n\n\n此外，yml 文件也可以在一个文件中完成所有 profile 的配置：\n\n# 激活 prod\nspring:\n  profiles:\n    active: prod\n# 也可以同时激活多个 profile\n# spring.profiles.active: prod,proddb,prodlog\n---\n# dev 配置\nspring:\n  profiles: dev\n\n# 略去配置\n\n---\nspring:\n  profiles: test\n\n# 略去配置\n\n---\nspring.profiles: prod\nspring.profiles.include:\n  - proddb\n  - prodlog\n\n---\nspring:\n  profiles: proddb\n\n# 略去配置\n\n---\nspring:\n  profiles: prodlog\n# 略去配置\n\n\n注意：不同 profile 之间通过 --- 分割\n\n\n# 区分环境的代码\n\n使用 @Profile 注解可以指定类或方法在特定的 Profile 环境生效。\n\n\n# 修饰类\n\n@Configuration\n@Profile("production")\npublic class JndiDataConfig {\n\n    @Bean(destroyMethod="")\n    public DataSource dataSource() throws Exception {\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n\n\n\n# 修饰注解\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Profile("production")\npublic @interface Production {\n}\n\n\n\n# 修饰方法\n\n@Configuration\npublic class AppConfig {\n\n    @Bean("dataSource")\n    @Profile("development")\n    public DataSource standaloneDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript("classpath:com/bank/config/sql/schema.sql")\n            .addScript("classpath:com/bank/config/sql/test-data.sql")\n            .build();\n    }\n\n    @Bean("dataSource")\n    @Profile("production")\n    public DataSource jndiDataSource() throws Exception {\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n\n\n\n# 激活 profile\n\n\n# 插件激活 profile\n\nspring-boot:run -Drun.profiles=prod\n\n\n\n# main 方法激活 profile\n\n--spring.profiles.active=prod\n\n\n\n# jar 激活 profile\n\njava -jar -Dspring.profiles.active=prod *.jar\n\n\n\n# 在 Java 代码中激活 profile\n\n直接指定环境变量来激活 profile：\n\nSystem.setProperty("spring.profiles.active", "test");\n\n\n在 Spring 容器中激活 profile：\n\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\nctx.getEnvironment().setActiveProfiles("development");\nctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\nctx.refresh();\n\n\n\n# 示例源码\n\n> 示例源码：spring-boot-profile\n\n\n# 参考资料\n\n * Spring 官方文档之 Bean Definition Profiles\n * Spring Boot 官方文档之 boot-features-profiles',normalizedContent:'# springboot 之 profile\n\n> 一个应用为了在不同的环境下工作，常常会有不同的配置，代码逻辑处理。spring boot 对此提供了简便的支持。\n> \n> 关键词： @profile、spring.profiles.active\n\n\n# 区分环境的配置\n\n\n# properties 配置\n\n假设，一个应用的工作环境有：dev、test、prod\n\n那么，我们可以添加 4 个配置文件：\n\n * applcation.properties - 公共配置\n * application-dev.properties - 开发环境配置\n * application-test.properties - 测试环境配置\n * application-prod.properties - 生产环境配置\n\n在 applcation.properties 文件中可以通过以下配置来激活 profile：\n\nspring.profiles.active = test\n\n\n\n# yml 配置\n\n与 properties 文件类似，我们也可以添加 4 个配置文件：\n\n * applcation.yml - 公共配置\n * application-dev.yml - 开发环境配置\n * application-test.yml - 测试环境配置\n * application-prod.yml - 生产环境配置\n\n在 applcation.yml 文件中可以通过以下配置来激活 profile：\n\nspring:\n  profiles:\n    active: prod\n\n\n此外，yml 文件也可以在一个文件中完成所有 profile 的配置：\n\n# 激活 prod\nspring:\n  profiles:\n    active: prod\n# 也可以同时激活多个 profile\n# spring.profiles.active: prod,proddb,prodlog\n---\n# dev 配置\nspring:\n  profiles: dev\n\n# 略去配置\n\n---\nspring:\n  profiles: test\n\n# 略去配置\n\n---\nspring.profiles: prod\nspring.profiles.include:\n  - proddb\n  - prodlog\n\n---\nspring:\n  profiles: proddb\n\n# 略去配置\n\n---\nspring:\n  profiles: prodlog\n# 略去配置\n\n\n注意：不同 profile 之间通过 --- 分割\n\n\n# 区分环境的代码\n\n使用 @profile 注解可以指定类或方法在特定的 profile 环境生效。\n\n\n# 修饰类\n\n@configuration\n@profile("production")\npublic class jndidataconfig {\n\n    @bean(destroymethod="")\n    public datasource datasource() throws exception {\n        context ctx = new initialcontext();\n        return (datasource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n\n\n\n# 修饰注解\n\n@target(elementtype.type)\n@retention(retentionpolicy.runtime)\n@profile("production")\npublic @interface production {\n}\n\n\n\n# 修饰方法\n\n@configuration\npublic class appconfig {\n\n    @bean("datasource")\n    @profile("development")\n    public datasource standalonedatasource() {\n        return new embeddeddatabasebuilder()\n            .settype(embeddeddatabasetype.hsql)\n            .addscript("classpath:com/bank/config/sql/schema.sql")\n            .addscript("classpath:com/bank/config/sql/test-data.sql")\n            .build();\n    }\n\n    @bean("datasource")\n    @profile("production")\n    public datasource jndidatasource() throws exception {\n        context ctx = new initialcontext();\n        return (datasource) ctx.lookup("java:comp/env/jdbc/datasource");\n    }\n}\n\n\n\n# 激活 profile\n\n\n# 插件激活 profile\n\nspring-boot:run -drun.profiles=prod\n\n\n\n# main 方法激活 profile\n\n--spring.profiles.active=prod\n\n\n\n# jar 激活 profile\n\njava -jar -dspring.profiles.active=prod *.jar\n\n\n\n# 在 java 代码中激活 profile\n\n直接指定环境变量来激活 profile：\n\nsystem.setproperty("spring.profiles.active", "test");\n\n\n在 spring 容器中激活 profile：\n\nannotationconfigapplicationcontext ctx = new annotationconfigapplicationcontext();\nctx.getenvironment().setactiveprofiles("development");\nctx.register(someconfig.class, standalonedataconfig.class, jndidataconfig.class);\nctx.refresh();\n\n\n\n# 示例源码\n\n> 示例源码：spring-boot-profile\n\n\n# 参考资料\n\n * spring 官方文档之 bean definition profiles\n * spring boot 官方文档之 boot-features-profiles',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 核心",frontmatter:{title:"Spring 核心",date:"2020-02-26T23:47:47.000Z",categories:["Java","框架","Spring","Spring核心"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/5e7c20/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%E6%A0%B8%E5%BF%83/",relativePath:"01.Java/13.框架/01.Spring/01.Spring核心/README.md",key:"v-4d1c67ea",path:"/pages/5e7c20/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:99},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:453},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:632}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring 核心\n\n> 章节主要针对：Spring & Spring Boot 框架的核心技术。如；Spring Bean、IoC、依赖查找、依赖注入、AOP、数据绑定、资源管理等。\n\n\n# 📖 内容\n\n * Spring Bean\n * Spring IoC\n * Spring 依赖查找\n * Spring 依赖注入\n * Spring IoC 依赖来源\n * Spring Bean 作用域\n * Spring Bean 生命周期\n * Spring 配置元数据\n * Spring AOP\n * Spring 资源管理\n * Spring 校验\n * Spring 数据绑定\n * Spring 类型转换\n * Spring EL 表达式\n * Spring 事件\n * Spring 国际化\n * Spring 泛型处理\n * Spring 注解\n * SpringBoot 教程之快速入门\n * SpringBoot 之属性加载\n * SpringBoot 之 Profile\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring 核心\n\n> 章节主要针对：spring & spring boot 框架的核心技术。如；spring bean、ioc、依赖查找、依赖注入、aop、数据绑定、资源管理等。\n\n\n# 📖 内容\n\n * spring bean\n * spring ioc\n * spring 依赖查找\n * spring 依赖注入\n * spring ioc 依赖来源\n * spring bean 作用域\n * spring bean 生命周期\n * spring 配置元数据\n * spring aop\n * spring 资源管理\n * spring 校验\n * spring 数据绑定\n * spring 类型转换\n * spring el 表达式\n * spring 事件\n * spring 国际化\n * spring 泛型处理\n * spring 注解\n * springboot 教程之快速入门\n * springboot 之属性加载\n * springboot 之 profile\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 之 JDBC",frontmatter:{title:"Spring 之 JDBC",date:"2019-02-18T14:33:55.000Z",order:2,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","JDBC","JdbcTemplate"],permalink:"/pages/cf19fd/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/02.Spring%E4%B9%8BJDBC.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/02.Spring之JDBC.md",key:"v-9a6a8e22",path:"/pages/cf19fd/",headers:[{level:2,title:"JDBC 入门示例",slug:"jdbc-入门示例",normalizedTitle:"jdbc 入门示例",charIndex:78},{level:3,title:"定义实体",slug:"定义实体",normalizedTitle:"定义实体",charIndex:996},{level:3,title:"定义 DAO 接口",slug:"定义-dao-接口",normalizedTitle:"定义 dao 接口",charIndex:1348},{level:3,title:"定义 DAO 实现类",slug:"定义-dao-实现类",normalizedTitle:"定义 dao 实现类",charIndex:2078},{level:3,title:"测试类",slug:"测试类",normalizedTitle:"测试类",charIndex:5742},{level:2,title:"Spring Boot JDBC",slug:"spring-boot-jdbc",normalizedTitle:"spring boot jdbc",charIndex:8153},{level:3,title:"引入 Spring Boot 依赖",slug:"引入-spring-boot-依赖",normalizedTitle:"引入 spring boot 依赖",charIndex:8204},{level:3,title:"配置数据源",slug:"配置数据源",normalizedTitle:"配置数据源",charIndex:8783},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:5742},{level:2,title:"Spring JDBC",slug:"spring-jdbc",normalizedTitle:"spring jdbc",charIndex:10623},{level:3,title:"引入 Spring 依赖",slug:"引入-spring-依赖",normalizedTitle:"引入 spring 依赖",charIndex:10739},{level:3,title:"基于 JDBC 驱动的数据源配置",slug:"基于-jdbc-驱动的数据源配置",normalizedTitle:"基于 jdbc 驱动的数据源配置",charIndex:11536},{level:3,title:"测试",slug:"测试-2",normalizedTitle:"测试",charIndex:5742},{level:2,title:"JdbcTemplate API",slug:"jdbctemplate-api",normalizedTitle:"jdbctemplate api",charIndex:14871},{level:3,title:"execute 方法",slug:"execute-方法",normalizedTitle:"execute 方法",charIndex:15360},{level:3,title:"update 方法",slug:"update-方法",normalizedTitle:"update 方法",charIndex:15405},{level:3,title:"query 方法",slug:"query-方法",normalizedTitle:"query 方法",charIndex:15486},{level:2,title:"SpringBoot JDBC 配置",slug:"springboot-jdbc-配置",normalizedTitle:"springboot jdbc 配置",charIndex:17896},{level:3,title:"JdbcTemplateAutoConfiguration 类",slug:"jdbctemplateautoconfiguration-类",normalizedTitle:"jdbctemplateautoconfiguration 类",charIndex:17919},{level:3,title:"JdbcTemplateConfiguration 类",slug:"jdbctemplateconfiguration-类",normalizedTitle:"jdbctemplateconfiguration 类",charIndex:18947},{level:3,title:"NamedParameterJdbcTemplateConfiguration 类",slug:"namedparameterjdbctemplateconfiguration-类",normalizedTitle:"namedparameterjdbctemplateconfiguration 类",charIndex:19729},{level:2,title:"spring-data-jdbc",slug:"spring-data-jdbc",normalizedTitle:"spring-data-jdbc",charIndex:10643},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:20696}],headersStr:"JDBC 入门示例 定义实体 定义 DAO 接口 定义 DAO 实现类 测试类 Spring Boot JDBC 引入 Spring Boot 依赖 配置数据源 测试 Spring JDBC 引入 Spring 依赖 基于 JDBC 驱动的数据源配置 测试 JdbcTemplate API execute 方法 update 方法 query 方法 SpringBoot JDBC 配置 JdbcTemplateAutoConfiguration 类 JdbcTemplateConfiguration 类 NamedParameterJdbcTemplateConfiguration 类 spring-data-jdbc 参考资料",content:'# Spring 之 JDBC\n\nJDBC 是 Java 语言中用来规范客户端程序如何访问数据库的应用程序接口，提供了增、删、改、查数据库的方法。\n\n\n# JDBC 入门示例\n\nJDBC 的工作步骤大致如下：\n\n 1. 创建实体类。\n 2. 声明数据库读写接口的 DAO 接口。定义 DAO 的好处在于对于数据层上层的业务，调用 DAO 时仅关注对外暴露的读写方法，而不考虑底层的具体持久化方式。这样，便于替换持久化方式。\n 3. 创建一个 DAO 接口的实现类，使用 Spring 的 JDBC 模板去实现接口。\n 4. 最后，定义一个 DAO 接口的实现类的 JavaBean，并将数据源注入进去。\n\n假设，我们要通过 Spring + JDBC 访问一张 Mysql 数据表 user，user 表的数据结构如下：\n\n-- 创建用户表\nCREATE TABLE `user` (\n    `id`      BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \'ID\',\n    `name`    VARCHAR(255)        NOT NULL DEFAULT \'\' COMMENT \'用户名\',\n    `age`     INT(3)              NOT NULL DEFAULT 0 COMMENT \'年龄\',\n    `address` VARCHAR(255)        NOT NULL DEFAULT \'\' COMMENT \'地址\',\n    `email`   VARCHAR(255)        NOT NULL DEFAULT \'\' COMMENT \'邮件\',\n    PRIMARY KEY (`id`),\n    UNIQUE (`name`)\n) COMMENT = \'用户表\';\n\nINSERT INTO `user` (`name`, `age`, `address`, `email`)\nVALUES (\'张三\', 18, \'北京\', \'xxx@163.com\');\nINSERT INTO `user` (`name`, `age`, `address`, `email`)\nVALUES (\'李四\', 19, \'上海\', \'xxx@163.com\');\n\n\n\n# 定义实体\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.util.Objects;\n\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String email;\n}\n\n\n\n# 定义 DAO 接口\n\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * user 表 Dao 接口\n *\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2019-11-18\n */\npublic interface UserDao {\n\n    // DML\n    // -------------------------------------------------------------------\n    void insert(User user);\n\n    void batchInsert(List<User> users);\n\n    void deleteByName(String name);\n\n    void deleteAll();\n\n    void update(User user);\n\n    Integer count();\n\n    List<User> list();\n\n    User queryByName(String name);\n\n    JdbcTemplate getJdbcTemplate();\n\n    // DDL\n    // -------------------------------------------------------------------\n    void truncate();\n\n    void recreateTable();\n\n}\n\n\n\n# 定义 DAO 实现类\n\n通过 JdbcTemplate 执行对应数据源符合语法的 SQL，即可完成各种数据库访问。\n\npackage io.github.dunwu.springboot.core.data.jdbc;\n\nimport org.springframework.dao.EmptyResultDataAccessException;\nimport org.springframework.jdbc.core.BeanPropertyRowMapper;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * user 表 Dao 接口实现类\n *\n * @author <a href="mailto:forbreak@163.com">Zhang Peng</a>\n * @since 2019-11-18\n */\n@Repository\npublic class UserDaoImpl implements UserDao {\n\n    private JdbcTemplate jdbcTemplate;\n\n    public UserDaoImpl(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Override\n    public void insert(User user) {\n        jdbcTemplate.update("INSERT INTO user(name, age, address, email) VALUES(?, ?, ?, ?)",\n            user.getName(), user.getAge(), user.getAddress(), user.getEmail());\n    }\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void batchInsert(List<User> users) {\n        String sql = "INSERT INTO user(name, age, address, email) VALUES(?, ?, ?, ?)";\n\n        List<Object[]> params = new ArrayList<>();\n\n        users.forEach(user -> {\n            params.add(new Object[] { user.getName(), user.getAge(), user.getAddress(), user.getEmail() });\n        });\n        jdbcTemplate.batchUpdate(sql, params);\n    }\n\n    @Override\n    public void deleteByName(String name) {\n        jdbcTemplate.update("DELETE FROM user WHERE name = ?", name);\n    }\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void deleteAll() {\n        jdbcTemplate.execute("DELETE FROM user");\n    }\n\n    @Override\n    public void update(User user) {\n        jdbcTemplate.update("UPDATE user SET name=?, age=?, address=?, email=? WHERE id=?",\n            user.getName(), user.getAge(), user.getAddress(), user.getEmail(), user.getId());\n    }\n\n    @Override\n    public Integer count() {\n        try {\n            return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM user", Integer.class);\n        } catch (EmptyResultDataAccessException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public List<User> list() {\n        return jdbcTemplate.query("SELECT * FROM user", new BeanPropertyRowMapper<>(User.class));\n    }\n\n    @Override\n    public User queryByName(String name) {\n        try {\n            return jdbcTemplate.queryForObject("SELECT * FROM user WHERE name = ?",\n                new BeanPropertyRowMapper<>(User.class), name);\n        } catch (EmptyResultDataAccessException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public JdbcTemplate getJdbcTemplate() {\n        return jdbcTemplate;\n    }\n\n    @Override\n    public void truncate() {\n        jdbcTemplate.execute("TRUNCATE TABLE user");\n    }\n\n    @Override\n    public void recreateTable() {\n        jdbcTemplate.execute("DROP TABLE IF EXISTS user");\n\n        String sqlStatement =\n            "CREATE TABLE IF NOT EXISTS user (\\n"\n                + "    id      BIGINT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \'Id\',\\n"\n                + "    name    VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'用户名\',\\n"\n                + "    age     INT(3)              NOT NULL DEFAULT 0 COMMENT \'年龄\',\\n"\n                + "    address VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'地址\',\\n"\n                + "    email   VARCHAR(255)         NOT NULL DEFAULT \'\' COMMENT \'邮件\',\\n"\n                + "    PRIMARY KEY (id)\\n"\n                + ") COMMENT = \'用户表\';";\n        jdbcTemplate.execute(sqlStatement);\n    }\n\n}\n\n\n\n# 测试类\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.annotation.Rollback;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@Slf4j\n@Rollback\n@SpringBootTest(classes = { SpringBootDataJdbcApplication.class })\npublic class DataJdbcMysqlDataSourceTest {\n\n    @Autowired\n    private UserDao userDAO;\n\n    @BeforeEach\n    public void before() {\n        userDAO.truncate();\n    }\n\n    @Test\n    public void insert() {\n        userDAO.insert(new User("张三", 18, "北京", "user1@163.com"));\n        User linda = userDAO.queryByName("张三");\n        assertThat(linda).isNotNull();\n    }\n\n    @Test\n    public void batchInsert() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n\n        userDAO.batchInsert(users);\n        int count = userDAO.count();\n        assertThat(count).isEqualTo(4);\n\n        List<User> list = userDAO.list();\n        assertThat(list).isNotEmpty().hasSize(4);\n        list.forEach(user -> {\n            log.info(user.toString());\n        });\n    }\n\n    @Test\n    public void delete() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        userDAO.batchInsert(users);\n\n        userDAO.deleteByName("张三");\n        User user = userDAO.queryByName("张三");\n        assertThat(user).isNull();\n\n        userDAO.deleteAll();\n        List<User> list = userDAO.list();\n        assertThat(list).isEmpty();\n    }\n\n    @Test\n    public void update() {\n        userDAO.insert(new User("张三", 18, "北京", "user1@163.com"));\n        User oldUser = userDAO.queryByName("张三");\n        oldUser.setName("张三丰");\n        userDAO.update(oldUser);\n        User newUser = userDAO.queryByName("张三丰");\n        assertThat(newUser).isNotNull();\n    }\n\n}\n\n\n\n# Spring Boot JDBC\n\n> 完整示例：spring-boot-data-jdbc\n\n\n# 引入 Spring Boot 依赖\n\n你可以通过 Spring Boot 官方的初始化器（Spring Initializr）选择需要的组件来创建一个 Spring Boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.7.7</version>\n  </parent>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jdbc</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n  </dependencies>\n\n\n\n# 配置数据源\n\n引入依赖后，需要在 application.properties 或 application.yml 文件中指定数据源配置。\n\n下面是一个最基本的数据源配置示例：\n\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.username = root\nspring.datasource.password = root\n\n\n需要根据实际情况，替换 url、username、password。\n\n\n# 测试\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport javax.sql.DataSource;\n\n@Slf4j\n@SpringBootApplication\npublic class SpringBootDataJdbcApplication implements CommandLineRunner {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public SpringBootDataJdbcApplication(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n20:50:18.449 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcApplication.run - 数据源 Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n\n\n\n# Spring JDBC\n\n> 完整示例：spring-data-jdbc\n\nspring-boot-starter-data-jdbc 引入了 spring-jdbc ，其 JDBC 特性就是基于 spring-jdbc。\n\n\n# 引入 Spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n# 基于 JDBC 驱动的数据源配置\n\n下面是一个 mysql 的 JDBC 数据源配置实例：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xmlns:jdbc="http://www.springframework.org/schema/jdbc"\n    xmlns="http://www.springframework.org/schema/beans"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans.xsd\n            http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context.xsd\n            http://www.springframework.org/schema/jdbc\n            http://www.springframework.org/schema/jdbc/spring-jdbc.xsd">\n\n    \x3c!-- 引入配置文件 --\x3e\n    <context:property-placeholder location="classpath:properties/mysql.properties" />\n\n    \x3c!-- 使用JDBC驱动的数据源 --\x3e\n    \x3c!-- (1)在每个连接请求时都会返回一个新建的连接。性能不高 --\x3e\n    <bean id="dataSource1" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- (2)在每个连接请求时都会返回同一个连接。不适用于多线程 --\x3e\n    <bean id="dataSource2" class="org.springframework.jdbc.datasource.SingleConnectionDataSource">\n        <property name="driverClassName" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- JDBC模板 --\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        <constructor-arg ref="dataSource1" />\n    </bean>\n    <bean id="userDao" class="io.github.dunwu.springboot.data.jdbc.UserDaoImpl">\n        <constructor-arg ref="jdbcTemplate" />\n    </bean>\n\n    \x3c!-- 初始化数据表结构 --\x3e\n    <jdbc:initialize-database data-source="dataSource1" ignore-failures="ALL">\n        <jdbc:script location="classpath:sql/schema.sql" />\n        <jdbc:script location="classpath:sql/data.sql" />\n    </jdbc:initialize-database>\n</beans>\n\n\n\n# 测试\n\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.io.IOException;\nimport java.sql.SQLException;\n\n@SuppressWarnings("all")\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = { "classpath:data/spring-mysql.xml" })\npublic class MysqlJdbcTest {\n\n    @Autowired\n    private ApplicationContext ctx;\n\n    @Before\n    public void before() {\n        ctx = JdbcDemo.getMysqlApplicationContext();\n    }\n\n    @Test\n    public void testExecJdbcOper() throws SQLException, IOException {\n        UserDao userDao = (UserDaoImpl) ctx.getBean("userDao");\n        JdbcDemo.execJdbcOper(userDao);\n    }\n\n    @After\n    public void after() {\n        ((ClassPathXmlApplicationContext) ctx).close();\n    }\n\n}\n\n\n\n# JdbcTemplate API\n\nSpring 将数据访问的样板式代码提取到模板类中。Spring 提供了 3 个 JDBC 模板类：\n\n * JdbcTemplate：最基本的 Spring JDBC 模板，这个模板支持最简单的 JDBC 数据库访问功能以及简单的索引参数查询。\n * SimpleJdbcTemplate：改模板类利用 Java 5 的一些特性，如自动装箱、泛型以及可变参数列表来简化 JDBC 模板的使用。\n * NamedParameterJdbcTemplate：使用该模板类执行查询时，可以将查询值以命名参数的形式绑定到 SQL 中，而不是使用简单的索引参数。\n\nspring-jdbc 最核心的 API 无疑就是 JdbcTemplate，可以说所有的 JDBC 数据访问，几乎都是围绕着这个类去工作的。Spring 对数据库的操作在 Jdbc 层面做了深层次的封装，利用依赖注入，把数据源配置装配到 JdbcTemplate 中，再由 JdbcTemplate 负责具体的数据访问。\n\nJdbcTemplate 主要提供以下几类方法：\n\n * execute 方法：可以用于执行任何 SQL 语句，一般用于执行 DDL 语句；\n * update 方法及 batchUpdate 方法：update 方法用于执行新增、修改、删除等语句；batchUpdate 方法用于执行批处理相关语句；\n * query 方法及 queryForXXX 方法：用于执行查询相关语句；\n * call 方法：用于执行存储过程、函数相关语句。\n\n为了方便演示，以下增删改查操作都围绕一个名为 user 的表（该表的主键 id 是自增序列）进行，该表的数据实体如下：\n\npublic class User {\n    private Integer id;\n    private String name;\n    private Integer age;\n\n    // 省略 getter/setter\n}\n\n\n数据实体只要是一个纯粹的 Java Bean 即可，无需任何注解修饰。\n\n\n# execute 方法\n\n使用 execute 执行 DDL 语句，创建一个名为 test 的数据库，并在此数据库下新建一个名为 user 的表。\n\npublic void recreateTable() {\n    jdbcTemplate.execute("DROP DATABASE IF EXISTS test");\n    jdbcTemplate.execute("CREATE DATABASE test");\n    jdbcTemplate.execute("USE test");\n    jdbcTemplate.execute("DROP TABLE if EXISTS user");\n    jdbcTemplate.execute("DROP TABLE if EXISTS user");\n    // @formatter:off\n    StringBuilder sb = new StringBuilder();\n    sb.append("CREATE TABLE user (id int (10) unsigned NOT NULL AUTO_INCREMENT,\\n")\n        .append("name varchar (64) NOT NULL DEFAULT \'\',\\n")\n        .append("age tinyint (3) NOT NULL DEFAULT 0,\\n")\n        .append("PRIMARY KEY (ID));\\n");\n    // @formatter:on\n    jdbcTemplate.execute(sb.toString());\n}\n\n\n\n# update 方法\n\n新增数据\n\npublic void insert(String name, Integer age) {\n    jdbcTemplate.update("INSERT INTO user(name, age) VALUES(?, ?)", name, age);\n}\n\n\n删除数据\n\npublic void delete(String name) {\n    jdbcTemplate.update("DELETE FROM user WHERE name = ?", name);\n}\n\n\n修改数据\n\npublic void update(User user) {\n    jdbcTemplate.update("UPDATE USER SET name=?, age=? WHERE id=?", user.getName(), user.getAge(), user.getId());\n}\n\n\n批处理\n\npublic void batchInsert(List<User> users) {\n    String sql = "INSERT INTO user(name, age) VALUES(?, ?)";\n\n    List<Object[]> params = new ArrayList<>();\n\n    users.forEach(item -> {\n        params.add(new Object[] {item.getName(), item.getAge()});\n    });\n    jdbcTemplate.batchUpdate(sql, params);\n}\n\n\n\n# query 方法\n\n查单个对象\n\npublic User queryByName(String name) {\n    try {\n        return jdbcTemplate\n            .queryForObject("SELECT * FROM user WHERE name = ?", new BeanPropertyRowMapper<>(User.class), name);\n    } catch (EmptyResultDataAccessException e) {\n        return null;\n    }\n}\n\n\n查多个对象\n\npublic List<User> list() {\n    return jdbcTemplate.query("select * from USER", new BeanPropertyRowMapper(User.class));\n}\n\n\n获取某个记录某列或者 count、avg、sum 等函数返回唯一值\n\npublic Integer count() {\n    try {\n        return jdbcTemplate.queryForObject("SELECT COUNT(*) FROM user", Integer.class);\n    } catch (EmptyResultDataAccessException e) {\n        return null;\n    }\n}\n\n\n\n# SpringBoot JDBC 配置\n\n\n# JdbcTemplateAutoConfiguration 类\n\nJdbcTemplateAutoConfiguration 是 JdbcTemplate 自动配置类，它负责实例化 JdbcTemplate。\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })\n@ConditionalOnSingleCandidate(DataSource.class)\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\n@EnableConfigurationProperties(JdbcProperties.class)\n@Import({ JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class })\npublic class JdbcTemplateAutoConfiguration {\n\n}\n\n\nJdbcTemplateAutoConfiguration 类的源码解读：\n\n * @AutoConfigureAfter(DataSourceAutoConfiguration.class) 表明 JdbcTemplateAutoConfiguration 必须在 DataSourceAutoConfiguration 执行完之后才开始工作，这意味着：JdbcTemplate 的初始化必须在 DataSource 初始化之后。\n * JdbcProperties 是 JdbcTemplateAutoConfiguration 的配置选项类，允许使用者通过设置选项控制 JdbcTemplate 初始化行为。\n * @Import({ JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class }) 表明引入 JdbcTemplateConfiguration、NamedParameterJdbcTemplateConfiguration 两个配置类，具体的实例化 JdbcTemplate 的工作也是放在这两个配置中完成。\n\n\n# JdbcTemplateConfiguration 类\n\nJdbcTemplateConfiguration 源码如下：\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnMissingBean(JdbcOperations.class)\nclass JdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tJdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {\n\t\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\t\tJdbcProperties.Template template = properties.getTemplate();\n\t\tjdbcTemplate.setFetchSize(template.getFetchSize());\n\t\tjdbcTemplate.setMaxRows(template.getMaxRows());\n\t\tif (template.getQueryTimeout() != null) {\n\t\t\tjdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());\n\t\t}\n\t\treturn jdbcTemplate;\n\t}\n\n}\n\n\nJdbcTemplateConfiguration 源码解读：JdbcTemplateConfiguration 中根据 DataSource 和 JdbcProperties 实例化了一个 JdbcTemplate。\n\n\n# NamedParameterJdbcTemplateConfiguration 类\n\nNamedParameterJdbcTemplateConfiguration 源码如下：\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnSingleCandidate(JdbcTemplate.class)\n@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)\nclass NamedParameterJdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tNamedParameterJdbcTemplate namedParameterJdbcTemplate(JdbcTemplate jdbcTemplate) {\n\t\treturn new NamedParameterJdbcTemplate(jdbcTemplate);\n\t}\n\n}\n\n\nNamedParameterJdbcTemplateConfiguration 源码解读：NamedParameterJdbcTemplateConfiguration 中根据 JdbcTemplate 实例化了一个 NamedParameterJdbcTemplate。\n\n\n# spring-data-jdbc\n\nSpring Data 项目包含了对 JDBC 的存储库支持，并将自动为 CrudRepository 上的方法生成 SQL。对于更高级的查询，提供了 @Query 注解。\n\n当 classpath 上存在必要的依赖项时，Spring Boot 将自动配置 Spring Data 的 JDBC 存储库。它们可以通过 spring-boot-starter-data-jdbc 的单一依赖项添加到项目中。如有必要，可以通过将 @EnableJdbcRepositories 批注或 JdbcConfiguration 子类添加到应用程序来控制 Spring Data JDBC 的配置。\n\n> 更多 Spring Data JDBC 细节，可以参考 Spring Data JDBC 官方文档。\n\n\n# 参考资料\n\n * Spring 官网\n * Spring Framework 官方文档\n * Spring Boot 官方文档',normalizedContent:'# spring 之 jdbc\n\njdbc 是 java 语言中用来规范客户端程序如何访问数据库的应用程序接口，提供了增、删、改、查数据库的方法。\n\n\n# jdbc 入门示例\n\njdbc 的工作步骤大致如下：\n\n 1. 创建实体类。\n 2. 声明数据库读写接口的 dao 接口。定义 dao 的好处在于对于数据层上层的业务，调用 dao 时仅关注对外暴露的读写方法，而不考虑底层的具体持久化方式。这样，便于替换持久化方式。\n 3. 创建一个 dao 接口的实现类，使用 spring 的 jdbc 模板去实现接口。\n 4. 最后，定义一个 dao 接口的实现类的 javabean，并将数据源注入进去。\n\n假设，我们要通过 spring + jdbc 访问一张 mysql 数据表 user，user 表的数据结构如下：\n\n-- 创建用户表\ncreate table `user` (\n    `id`      bigint(20) unsigned not null auto_increment comment \'id\',\n    `name`    varchar(255)        not null default \'\' comment \'用户名\',\n    `age`     int(3)              not null default 0 comment \'年龄\',\n    `address` varchar(255)        not null default \'\' comment \'地址\',\n    `email`   varchar(255)        not null default \'\' comment \'邮件\',\n    primary key (`id`),\n    unique (`name`)\n) comment = \'用户表\';\n\ninsert into `user` (`name`, `age`, `address`, `email`)\nvalues (\'张三\', 18, \'北京\', \'xxx@163.com\');\ninsert into `user` (`name`, `age`, `address`, `email`)\nvalues (\'李四\', 19, \'上海\', \'xxx@163.com\');\n\n\n\n# 定义实体\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport lombok.tostring;\n\nimport java.util.objects;\n\n@data\n@tostring\n@noargsconstructor\n@allargsconstructor\npublic class user {\n    private long id;\n    private string name;\n    private integer age;\n    private string address;\n    private string email;\n}\n\n\n\n# 定义 dao 接口\n\nimport org.springframework.jdbc.core.jdbctemplate;\n\nimport java.util.list;\n\n/**\n * user 表 dao 接口\n *\n * @author <a href="mailto:forbreak@163.com">zhang peng</a>\n * @since 2019-11-18\n */\npublic interface userdao {\n\n    // dml\n    // -------------------------------------------------------------------\n    void insert(user user);\n\n    void batchinsert(list<user> users);\n\n    void deletebyname(string name);\n\n    void deleteall();\n\n    void update(user user);\n\n    integer count();\n\n    list<user> list();\n\n    user querybyname(string name);\n\n    jdbctemplate getjdbctemplate();\n\n    // ddl\n    // -------------------------------------------------------------------\n    void truncate();\n\n    void recreatetable();\n\n}\n\n\n\n# 定义 dao 实现类\n\n通过 jdbctemplate 执行对应数据源符合语法的 sql，即可完成各种数据库访问。\n\npackage io.github.dunwu.springboot.core.data.jdbc;\n\nimport org.springframework.dao.emptyresultdataaccessexception;\nimport org.springframework.jdbc.core.beanpropertyrowmapper;\nimport org.springframework.jdbc.core.jdbctemplate;\nimport org.springframework.stereotype.repository;\nimport org.springframework.transaction.annotation.transactional;\n\nimport java.util.arraylist;\nimport java.util.list;\n\n/**\n * user 表 dao 接口实现类\n *\n * @author <a href="mailto:forbreak@163.com">zhang peng</a>\n * @since 2019-11-18\n */\n@repository\npublic class userdaoimpl implements userdao {\n\n    private jdbctemplate jdbctemplate;\n\n    public userdaoimpl(jdbctemplate jdbctemplate) {\n        this.jdbctemplate = jdbctemplate;\n    }\n\n    @override\n    public void insert(user user) {\n        jdbctemplate.update("insert into user(name, age, address, email) values(?, ?, ?, ?)",\n            user.getname(), user.getage(), user.getaddress(), user.getemail());\n    }\n\n    @override\n    @transactional(rollbackfor = exception.class)\n    public void batchinsert(list<user> users) {\n        string sql = "insert into user(name, age, address, email) values(?, ?, ?, ?)";\n\n        list<object[]> params = new arraylist<>();\n\n        users.foreach(user -> {\n            params.add(new object[] { user.getname(), user.getage(), user.getaddress(), user.getemail() });\n        });\n        jdbctemplate.batchupdate(sql, params);\n    }\n\n    @override\n    public void deletebyname(string name) {\n        jdbctemplate.update("delete from user where name = ?", name);\n    }\n\n    @override\n    @transactional(rollbackfor = exception.class)\n    public void deleteall() {\n        jdbctemplate.execute("delete from user");\n    }\n\n    @override\n    public void update(user user) {\n        jdbctemplate.update("update user set name=?, age=?, address=?, email=? where id=?",\n            user.getname(), user.getage(), user.getaddress(), user.getemail(), user.getid());\n    }\n\n    @override\n    public integer count() {\n        try {\n            return jdbctemplate.queryforobject("select count(*) from user", integer.class);\n        } catch (emptyresultdataaccessexception e) {\n            return null;\n        }\n    }\n\n    @override\n    public list<user> list() {\n        return jdbctemplate.query("select * from user", new beanpropertyrowmapper<>(user.class));\n    }\n\n    @override\n    public user querybyname(string name) {\n        try {\n            return jdbctemplate.queryforobject("select * from user where name = ?",\n                new beanpropertyrowmapper<>(user.class), name);\n        } catch (emptyresultdataaccessexception e) {\n            return null;\n        }\n    }\n\n    @override\n    public jdbctemplate getjdbctemplate() {\n        return jdbctemplate;\n    }\n\n    @override\n    public void truncate() {\n        jdbctemplate.execute("truncate table user");\n    }\n\n    @override\n    public void recreatetable() {\n        jdbctemplate.execute("drop table if exists user");\n\n        string sqlstatement =\n            "create table if not exists user (\\n"\n                + "    id      bigint(10) unsigned not null auto_increment comment \'id\',\\n"\n                + "    name    varchar(255)         not null default \'\' comment \'用户名\',\\n"\n                + "    age     int(3)              not null default 0 comment \'年龄\',\\n"\n                + "    address varchar(255)         not null default \'\' comment \'地址\',\\n"\n                + "    email   varchar(255)         not null default \'\' comment \'邮件\',\\n"\n                + "    primary key (id)\\n"\n                + ") comment = \'用户表\';";\n        jdbctemplate.execute(sqlstatement);\n    }\n\n}\n\n\n\n# 测试类\n\nimport lombok.extern.slf4j.slf4j;\nimport org.junit.jupiter.api.beforeeach;\nimport org.junit.jupiter.api.test;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.test.context.springboottest;\nimport org.springframework.test.annotation.rollback;\n\nimport java.util.arraylist;\nimport java.util.list;\n\nimport static org.assertj.core.api.assertions.assertthat;\n\n@slf4j\n@rollback\n@springboottest(classes = { springbootdatajdbcapplication.class })\npublic class datajdbcmysqldatasourcetest {\n\n    @autowired\n    private userdao userdao;\n\n    @beforeeach\n    public void before() {\n        userdao.truncate();\n    }\n\n    @test\n    public void insert() {\n        userdao.insert(new user("张三", 18, "北京", "user1@163.com"));\n        user linda = userdao.querybyname("张三");\n        assertthat(linda).isnotnull();\n    }\n\n    @test\n    public void batchinsert() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n\n        userdao.batchinsert(users);\n        int count = userdao.count();\n        assertthat(count).isequalto(4);\n\n        list<user> list = userdao.list();\n        assertthat(list).isnotempty().hassize(4);\n        list.foreach(user -> {\n            log.info(user.tostring());\n        });\n    }\n\n    @test\n    public void delete() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n        userdao.batchinsert(users);\n\n        userdao.deletebyname("张三");\n        user user = userdao.querybyname("张三");\n        assertthat(user).isnull();\n\n        userdao.deleteall();\n        list<user> list = userdao.list();\n        assertthat(list).isempty();\n    }\n\n    @test\n    public void update() {\n        userdao.insert(new user("张三", 18, "北京", "user1@163.com"));\n        user olduser = userdao.querybyname("张三");\n        olduser.setname("张三丰");\n        userdao.update(olduser);\n        user newuser = userdao.querybyname("张三丰");\n        assertthat(newuser).isnotnull();\n    }\n\n}\n\n\n\n# spring boot jdbc\n\n> 完整示例：spring-boot-data-jdbc\n\n\n# 引入 spring boot 依赖\n\n你可以通过 spring boot 官方的初始化器（spring initializr）选择需要的组件来创建一个 spring boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n  <parent>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-parent</artifactid>\n    <version>2.7.7</version>\n  </parent>\n\n  <dependencies>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-data-jdbc</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>mysql</groupid>\n      <artifactid>mysql-connector-java</artifactid>\n    </dependency>\n  </dependencies>\n\n\n\n# 配置数据源\n\n引入依赖后，需要在 application.properties 或 application.yml 文件中指定数据源配置。\n\n下面是一个最基本的数据源配置示例：\n\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.driver\nspring.datasource.username = root\nspring.datasource.password = root\n\n\n需要根据实际情况，替换 url、username、password。\n\n\n# 测试\n\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.boot.commandlinerunner;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.jdbc.core.jdbctemplate;\n\nimport java.sql.connection;\nimport javax.sql.datasource;\n\n@slf4j\n@springbootapplication\npublic class springbootdatajdbcapplication implements commandlinerunner {\n\n    private final jdbctemplate jdbctemplate;\n\n    public springbootdatajdbcapplication(jdbctemplate jdbctemplate) {\n        this.jdbctemplate = jdbctemplate;\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(springbootdatajdbcapplication.class, args);\n    }\n\n    @override\n    public void run(string... args) throws exception {\n        datasource datasource = jdbctemplate.getdatasource();\n\n        connection connection;\n        if (datasource != null) {\n            connection = datasource.getconnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 url: {}", connection.getmetadata().geturl());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n20:50:18.449 [main] [info ] i.g.d.s.d.springbootdatajdbcapplication.run - 数据源 url: jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\n\n\n\n# spring jdbc\n\n> 完整示例：spring-data-jdbc\n\nspring-boot-starter-data-jdbc 引入了 spring-jdbc ，其 jdbc 特性就是基于 spring-jdbc。\n\n\n# 引入 spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n    <dependencies>\n        <dependency>\n            <groupid>com.alibaba</groupid>\n            <artifactid>druid</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-context-support</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-jdbc</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-tx</artifactid>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n# 基于 jdbc 驱动的数据源配置\n\n下面是一个 mysql 的 jdbc 数据源配置实例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xmlns:jdbc="http://www.springframework.org/schema/jdbc"\n    xmlns="http://www.springframework.org/schema/beans"\n    xsi:schemalocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans.xsd\n            http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context.xsd\n            http://www.springframework.org/schema/jdbc\n            http://www.springframework.org/schema/jdbc/spring-jdbc.xsd">\n\n    \x3c!-- 引入配置文件 --\x3e\n    <context:property-placeholder location="classpath:properties/mysql.properties" />\n\n    \x3c!-- 使用jdbc驱动的数据源 --\x3e\n    \x3c!-- (1)在每个连接请求时都会返回一个新建的连接。性能不高 --\x3e\n    <bean id="datasource1" class="org.springframework.jdbc.datasource.drivermanagerdatasource">\n        <property name="driverclassname" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- (2)在每个连接请求时都会返回同一个连接。不适用于多线程 --\x3e\n    <bean id="datasource2" class="org.springframework.jdbc.datasource.singleconnectiondatasource">\n        <property name="driverclassname" value="${jdbc.driver}" />\n        <property name="url" value="${jdbc.url}" />\n        <property name="username" value="${jdbc.username}" />\n        <property name="password" value="${jdbc.password}" />\n    </bean>\n\n    \x3c!-- jdbc模板 --\x3e\n    <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n        <constructor-arg ref="datasource1" />\n    </bean>\n    <bean id="userdao" class="io.github.dunwu.springboot.data.jdbc.userdaoimpl">\n        <constructor-arg ref="jdbctemplate" />\n    </bean>\n\n    \x3c!-- 初始化数据表结构 --\x3e\n    <jdbc:initialize-database data-source="datasource1" ignore-failures="all">\n        <jdbc:script location="classpath:sql/schema.sql" />\n        <jdbc:script location="classpath:sql/data.sql" />\n    </jdbc:initialize-database>\n</beans>\n\n\n\n# 测试\n\n\nimport org.junit.after;\nimport org.junit.before;\nimport org.junit.test;\nimport org.junit.runner.runwith;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.support.classpathxmlapplicationcontext;\nimport org.springframework.test.context.contextconfiguration;\nimport org.springframework.test.context.junit4.springjunit4classrunner;\n\nimport java.io.ioexception;\nimport java.sql.sqlexception;\n\n@suppresswarnings("all")\n@runwith(springjunit4classrunner.class)\n@contextconfiguration(locations = { "classpath:data/spring-mysql.xml" })\npublic class mysqljdbctest {\n\n    @autowired\n    private applicationcontext ctx;\n\n    @before\n    public void before() {\n        ctx = jdbcdemo.getmysqlapplicationcontext();\n    }\n\n    @test\n    public void testexecjdbcoper() throws sqlexception, ioexception {\n        userdao userdao = (userdaoimpl) ctx.getbean("userdao");\n        jdbcdemo.execjdbcoper(userdao);\n    }\n\n    @after\n    public void after() {\n        ((classpathxmlapplicationcontext) ctx).close();\n    }\n\n}\n\n\n\n# jdbctemplate api\n\nspring 将数据访问的样板式代码提取到模板类中。spring 提供了 3 个 jdbc 模板类：\n\n * jdbctemplate：最基本的 spring jdbc 模板，这个模板支持最简单的 jdbc 数据库访问功能以及简单的索引参数查询。\n * simplejdbctemplate：改模板类利用 java 5 的一些特性，如自动装箱、泛型以及可变参数列表来简化 jdbc 模板的使用。\n * namedparameterjdbctemplate：使用该模板类执行查询时，可以将查询值以命名参数的形式绑定到 sql 中，而不是使用简单的索引参数。\n\nspring-jdbc 最核心的 api 无疑就是 jdbctemplate，可以说所有的 jdbc 数据访问，几乎都是围绕着这个类去工作的。spring 对数据库的操作在 jdbc 层面做了深层次的封装，利用依赖注入，把数据源配置装配到 jdbctemplate 中，再由 jdbctemplate 负责具体的数据访问。\n\njdbctemplate 主要提供以下几类方法：\n\n * execute 方法：可以用于执行任何 sql 语句，一般用于执行 ddl 语句；\n * update 方法及 batchupdate 方法：update 方法用于执行新增、修改、删除等语句；batchupdate 方法用于执行批处理相关语句；\n * query 方法及 queryforxxx 方法：用于执行查询相关语句；\n * call 方法：用于执行存储过程、函数相关语句。\n\n为了方便演示，以下增删改查操作都围绕一个名为 user 的表（该表的主键 id 是自增序列）进行，该表的数据实体如下：\n\npublic class user {\n    private integer id;\n    private string name;\n    private integer age;\n\n    // 省略 getter/setter\n}\n\n\n数据实体只要是一个纯粹的 java bean 即可，无需任何注解修饰。\n\n\n# execute 方法\n\n使用 execute 执行 ddl 语句，创建一个名为 test 的数据库，并在此数据库下新建一个名为 user 的表。\n\npublic void recreatetable() {\n    jdbctemplate.execute("drop database if exists test");\n    jdbctemplate.execute("create database test");\n    jdbctemplate.execute("use test");\n    jdbctemplate.execute("drop table if exists user");\n    jdbctemplate.execute("drop table if exists user");\n    // @formatter:off\n    stringbuilder sb = new stringbuilder();\n    sb.append("create table user (id int (10) unsigned not null auto_increment,\\n")\n        .append("name varchar (64) not null default \'\',\\n")\n        .append("age tinyint (3) not null default 0,\\n")\n        .append("primary key (id));\\n");\n    // @formatter:on\n    jdbctemplate.execute(sb.tostring());\n}\n\n\n\n# update 方法\n\n新增数据\n\npublic void insert(string name, integer age) {\n    jdbctemplate.update("insert into user(name, age) values(?, ?)", name, age);\n}\n\n\n删除数据\n\npublic void delete(string name) {\n    jdbctemplate.update("delete from user where name = ?", name);\n}\n\n\n修改数据\n\npublic void update(user user) {\n    jdbctemplate.update("update user set name=?, age=? where id=?", user.getname(), user.getage(), user.getid());\n}\n\n\n批处理\n\npublic void batchinsert(list<user> users) {\n    string sql = "insert into user(name, age) values(?, ?)";\n\n    list<object[]> params = new arraylist<>();\n\n    users.foreach(item -> {\n        params.add(new object[] {item.getname(), item.getage()});\n    });\n    jdbctemplate.batchupdate(sql, params);\n}\n\n\n\n# query 方法\n\n查单个对象\n\npublic user querybyname(string name) {\n    try {\n        return jdbctemplate\n            .queryforobject("select * from user where name = ?", new beanpropertyrowmapper<>(user.class), name);\n    } catch (emptyresultdataaccessexception e) {\n        return null;\n    }\n}\n\n\n查多个对象\n\npublic list<user> list() {\n    return jdbctemplate.query("select * from user", new beanpropertyrowmapper(user.class));\n}\n\n\n获取某个记录某列或者 count、avg、sum 等函数返回唯一值\n\npublic integer count() {\n    try {\n        return jdbctemplate.queryforobject("select count(*) from user", integer.class);\n    } catch (emptyresultdataaccessexception e) {\n        return null;\n    }\n}\n\n\n\n# springboot jdbc 配置\n\n\n# jdbctemplateautoconfiguration 类\n\njdbctemplateautoconfiguration 是 jdbctemplate 自动配置类，它负责实例化 jdbctemplate。\n\n@configuration(proxybeanmethods = false)\n@conditionalonclass({ datasource.class, jdbctemplate.class })\n@conditionalonsinglecandidate(datasource.class)\n@autoconfigureafter(datasourceautoconfiguration.class)\n@enableconfigurationproperties(jdbcproperties.class)\n@import({ jdbctemplateconfiguration.class, namedparameterjdbctemplateconfiguration.class })\npublic class jdbctemplateautoconfiguration {\n\n}\n\n\njdbctemplateautoconfiguration 类的源码解读：\n\n * @autoconfigureafter(datasourceautoconfiguration.class) 表明 jdbctemplateautoconfiguration 必须在 datasourceautoconfiguration 执行完之后才开始工作，这意味着：jdbctemplate 的初始化必须在 datasource 初始化之后。\n * jdbcproperties 是 jdbctemplateautoconfiguration 的配置选项类，允许使用者通过设置选项控制 jdbctemplate 初始化行为。\n * @import({ jdbctemplateconfiguration.class, namedparameterjdbctemplateconfiguration.class }) 表明引入 jdbctemplateconfiguration、namedparameterjdbctemplateconfiguration 两个配置类，具体的实例化 jdbctemplate 的工作也是放在这两个配置中完成。\n\n\n# jdbctemplateconfiguration 类\n\njdbctemplateconfiguration 源码如下：\n\n@configuration(proxybeanmethods = false)\n@conditionalonmissingbean(jdbcoperations.class)\nclass jdbctemplateconfiguration {\n\n\t@bean\n\t@primary\n\tjdbctemplate jdbctemplate(datasource datasource, jdbcproperties properties) {\n\t\tjdbctemplate jdbctemplate = new jdbctemplate(datasource);\n\t\tjdbcproperties.template template = properties.gettemplate();\n\t\tjdbctemplate.setfetchsize(template.getfetchsize());\n\t\tjdbctemplate.setmaxrows(template.getmaxrows());\n\t\tif (template.getquerytimeout() != null) {\n\t\t\tjdbctemplate.setquerytimeout((int) template.getquerytimeout().getseconds());\n\t\t}\n\t\treturn jdbctemplate;\n\t}\n\n}\n\n\njdbctemplateconfiguration 源码解读：jdbctemplateconfiguration 中根据 datasource 和 jdbcproperties 实例化了一个 jdbctemplate。\n\n\n# namedparameterjdbctemplateconfiguration 类\n\nnamedparameterjdbctemplateconfiguration 源码如下：\n\n@configuration(proxybeanmethods = false)\n@conditionalonsinglecandidate(jdbctemplate.class)\n@conditionalonmissingbean(namedparameterjdbcoperations.class)\nclass namedparameterjdbctemplateconfiguration {\n\n\t@bean\n\t@primary\n\tnamedparameterjdbctemplate namedparameterjdbctemplate(jdbctemplate jdbctemplate) {\n\t\treturn new namedparameterjdbctemplate(jdbctemplate);\n\t}\n\n}\n\n\nnamedparameterjdbctemplateconfiguration 源码解读：namedparameterjdbctemplateconfiguration 中根据 jdbctemplate 实例化了一个 namedparameterjdbctemplate。\n\n\n# spring-data-jdbc\n\nspring data 项目包含了对 jdbc 的存储库支持，并将自动为 crudrepository 上的方法生成 sql。对于更高级的查询，提供了 @query 注解。\n\n当 classpath 上存在必要的依赖项时，spring boot 将自动配置 spring data 的 jdbc 存储库。它们可以通过 spring-boot-starter-data-jdbc 的单一依赖项添加到项目中。如有必要，可以通过将 @enablejdbcrepositories 批注或 jdbcconfiguration 子类添加到应用程序来控制 spring data jdbc 的配置。\n\n> 更多 spring data jdbc 细节，可以参考 spring data jdbc 官方文档。\n\n\n# 参考资料\n\n * spring 官网\n * spring framework 官方文档\n * spring boot 官方文档',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 之数据源",frontmatter:{title:"Spring 之数据源",date:"2017-10-20T09:27:55.000Z",order:1,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","数据库","DataSource"],permalink:"/pages/1b774c/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/01.Spring%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%BA%90.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/01.Spring之数据源.md",key:"v-b009604a",path:"/pages/1b774c/",headers:[{level:2,title:"Spring Boot 数据源基本配置",slug:"spring-boot-数据源基本配置",normalizedTitle:"spring boot 数据源基本配置",charIndex:48},{level:2,title:"Spring Boot 连接嵌入式数据源",slug:"spring-boot-连接嵌入式数据源",normalizedTitle:"spring boot 连接嵌入式数据源",charIndex:601},{level:2,title:"Spring Boot 连接池化数据源",slug:"spring-boot-连接池化数据源",normalizedTitle:"spring boot 连接池化数据源",charIndex:1467},{level:3,title:"引入 Spring Boot 依赖",slug:"引入-spring-boot-依赖",normalizedTitle:"引入 spring boot 依赖",charIndex:2883},{level:3,title:"测试单数据源连接",slug:"测试单数据源连接",normalizedTitle:"测试单数据源连接",charIndex:3238},{level:2,title:"Spring Boot 连接多数据源",slug:"spring-boot-连接多数据源",normalizedTitle:"spring boot 连接多数据源",charIndex:4696},{level:3,title:"多数据源配置",slug:"多数据源配置",normalizedTitle:"多数据源配置",charIndex:4986},{level:3,title:"测试多数据源连接",slug:"测试多数据源连接",normalizedTitle:"测试多数据源连接",charIndex:6930},{level:2,title:"Spring 之数据源",slug:"spring-之数据源-2",normalizedTitle:"spring 之数据源",charIndex:2},{level:3,title:"引入 Spring 依赖",slug:"引入-spring-依赖",normalizedTitle:"引入 spring 依赖",charIndex:10151},{level:3,title:"Spring 配置数据源",slug:"spring-配置数据源",normalizedTitle:"spring 配置数据源",charIndex:10948},{level:4,title:"使用 JNDI 数据源",slug:"使用-jndi-数据源",normalizedTitle:"使用 jndi 数据源",charIndex:10991},{level:4,title:"使用数据库连接池",slug:"使用数据库连接池",normalizedTitle:"使用数据库连接池",charIndex:11868},{level:4,title:"基于 JDBC 驱动的数据源",slug:"基于-jdbc-驱动的数据源",normalizedTitle:"基于 jdbc 驱动的数据源",charIndex:13361},{level:2,title:"SpringBoot 数据源配置",slug:"springboot-数据源配置",normalizedTitle:"springboot 数据源配置",charIndex:13696},{level:2,title:"DataSourceAutoConfiguration 类",slug:"datasourceautoconfiguration-类",normalizedTitle:"datasourceautoconfiguration 类",charIndex:4934},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:17118}],headersStr:"Spring Boot 数据源基本配置 Spring Boot 连接嵌入式数据源 Spring Boot 连接池化数据源 引入 Spring Boot 依赖 测试单数据源连接 Spring Boot 连接多数据源 多数据源配置 测试多数据源连接 Spring 之数据源 引入 Spring 依赖 Spring 配置数据源 使用 JNDI 数据源 使用数据库连接池 基于 JDBC 驱动的数据源 SpringBoot 数据源配置 DataSourceAutoConfiguration 类 参考资料",content:'# Spring 之数据源\n\n> 本文基于 Spring Boot 2.7.3 版本。\n\n\n# Spring Boot 数据源基本配置\n\nSpring Boot 提供了一系列 spring.datasource.* 配置来控制 DataSource 的配置。用户可以在 application.properties 或 application.yml 文件中指定数据源配置。这些配置项维护在 DataSourceProperties 。\n\n下面是一个最基本的 mysql 数据源配置示例（都是必填项）：\n\n# 数据库访问地址\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n# 数据库驱动类，必须保证驱动类是可加载的\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\n# 数据库账号\nspring.datasource.username = root\n# 数据库账号密码\nspring.datasource.password = root\n\n\n需要根据实际情况，替换 url、username、password。\n\n\n# Spring Boot 连接嵌入式数据源\n\n使用内存嵌入式数据库开发应用程序通常很方便。显然，内存数据库不提供持久存储。使用者需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。\n\nSpring Boot 可以自动配置嵌入式数据库 H2、HSQL 和 Derby。使用者无需提供任何连接 URL，只需要包含对要使用的嵌入式数据库的构建依赖项。如果类路径上有多个嵌入式数据库，需要设置 spring.datasource.embedded-database-connection 配置属性来控制使用哪一个。将该属性设置为 none 会禁用嵌入式数据库的自动配置。\n\n> 注意：如果在测试中使用此功能，无论使用多少应用程序上下文，整个测试套件都会重用同一个数据库。如果要确保每个上下文都有一个单独的嵌入式数据库，则应将 spring.datasource.generate-unique-name 设置为 true。\n\n下面，通过一个实例展示如何连接 H2 嵌入式数据库。\n\n（1）在 pom.xml 中引入所需要的依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jdbc</artifactId>\n</dependency>\n<dependency>\n  <groupId>com.h2database</groupId>\n  <artifactId>h2</artifactId>\n</dependency>\n\n\n（2）数据源配置\n\nspring.datasource.jdbc-url = jdbc:h2:mem:test\nspring.datasource.driver-class-name = org.h2.Driver\nspring.datasource.username = sa\nspring.datasource.password =\n\n\n\n# Spring Boot 连接池化数据源\n\n> 完整示例：spring-boot-data-jdbc\n\n在生产环境中，出于性能考虑，一般会通过数据库连接池连接数据源。\n\n除了 DataSourceProperties 中的数据源通用配置以外，Spring Boot 还支持通过使用类似spring.datasource.hikari.*、spring.datasource.tomcat.*、spring.datasource.dbcp2.* 和 spring.datasource.oracleucp.* 的前缀来配置指定的数据库连接池属性。\n\n下面，就是一份 hikari 的连接池配置示例：\n\n# 连接池名称\nspring.datasource.hikari.pool-name = SpringTutorialHikariPool\n# 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值\nspring.datasource.hikari.maximum-pool-size = 10\n# 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size\nspring.datasource.hikari.minimum-idle = 10\n# 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒\nspring.datasource.hikari.connection-timeout = 60000\n# 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime>0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒\n# 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放\nspring.datasource.hikari.idle-timeout = 600000\n# 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短\nspring.datasource.hikari.max-lifetime = 540000\n\n\nSpring Boot 会按以下顺序检测连接池是否可用，如果可用就选择对应的池化 DataSource：\n\nHikariCP -> Tomcat pooling DataSource -> DBCP2 -> Oracle UCP\n\n用户也可以通过 spring.datasource.type 来指定数据源类型。\n\n此外，也可以使用 DataSourceBuilder 手动配置其他连接池。如果自定义 DataSource bean，则不会发生自动配置。 DataSourceBuilder 支持以下连接池：\n\n * HikariCP\n * Tomcat pooling Datasource\n * Commons DBCP2\n * Oracle UCP & OracleDataSource\n * Spring Framework’s SimpleDriverDataSource\n * H2 JdbcDataSource\n * PostgreSQL PGSimpleDataSource\n * C3P0\n\n\n# 引入 Spring Boot 依赖\n\n你可以通过 Spring Boot 官方的初始化器（Spring Initializr）选择需要的组件来创建一个 Spring Boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-jdbc</artifactId>\n</dependency>\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n</dependency>\n\n\n\n# 测试单数据源连接\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport javax.sql.DataSource;\n\n@Slf4j\n@SpringBootApplication\npublic class SpringBootDataJdbcApplication implements CommandLineRunner {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public SpringBootDataJdbcApplication(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n20:50:18.449 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcApplication.run - 数据源 Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\n\n\n\n# Spring Boot 连接多数据源\n\n> 完整示例：spring-boot-data-jdbc-multi-datasource\n\nSpring Boot 连接多数据源所需要的依赖并无不同，主要差异在于数据源的配置。Spring Boot 默认的数据源配置类为 org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration。使用者只要指定一些必要的 spring.datasource 配置，DataSourceAutoConfiguration 类就会自动完成剩下的数据源实例化工作。\n\n\n# 多数据源配置\n\n下面的示例中，自定义了一个数据源配置类，通过读取不同的 spring.datasource.xxx 来完成对于不同数据源的实例化工作。对于 JDBC 来说，最重要的，就是实例化 DataSource 和 JdbcTemplate。\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\n@Configuration\npublic class DataSourceConfig {\n\n    @Primary\n    @Bean("mysqlDataSource")\n    @ConfigurationProperties(prefix = "spring.datasource.mysql")\n    public DataSource mysqlDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Primary\n    @Bean("mysqlJdbcTemplate")\n    public JdbcTemplate mysqlJdbcTemplate(@Qualifier("mysqlDataSource") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n    @Bean("h2DataSource")\n    @ConfigurationProperties(prefix = "spring.datasource.h2")\n    public DataSource h2DataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Bean(name = "h2JdbcTemplate")\n    public JdbcTemplate h2JdbcTemplate(@Qualifier("h2DataSource") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n}\n\n\napplication.properties 或 application.yml 配置文件中也必须以 @ConfigurationProperties 所指定的配置前缀进行配置：\n\n# 数据源一：Mysql\nspring.datasource.mysql.jdbc-url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\nspring.datasource.mysql.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.mysql.username = root\nspring.datasource.mysql.password = root\n# 数据源一：H2\nspring.datasource.h2.jdbc-url = jdbc:h2:mem:test\nspring.datasource.h2.driver-class-name = org.h2.Driver\nspring.datasource.h2.username = sa\nspring.datasource.h2.password =\n\n\n\n# 测试多数据源连接\n\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport javax.sql.DataSource;\n\n@SpringBootApplication\npublic class SpringBootDataJdbcMultiDataSourceApplication implements CommandLineRunner {\n\n    private static final Logger log = LoggerFactory.getLogger(SpringBootDataJdbcMultiDataSourceApplication.class);\n\n    private final UserDao mysqlUserDao;\n\n    private final UserDao h2UserDao;\n\n    public SpringBootDataJdbcMultiDataSourceApplication(@Qualifier("mysqlUserDao") UserDao mysqlUserDao,\n        @Qualifier("h2UserDao") UserDao h2UserDao) {\n        this.mysqlUserDao = mysqlUserDao;\n        this.h2UserDao = h2UserDao;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDataJdbcMultiDataSourceApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n\n        if (mysqlUserDao != null && mysqlUserDao.getJdbcTemplate() != null) {\n            printDataSourceInfo(mysqlUserDao.getJdbcTemplate());\n            log.info("Connect to mysql datasource success.");\n        } else {\n            log.error("Connect to mysql datasource failed!");\n            return;\n        }\n\n        if (h2UserDao != null) {\n            printDataSourceInfo(h2UserDao.getJdbcTemplate());\n            log.info("Connect to h2 datasource success.");\n        } else {\n            log.error("Connect to h2 datasource failed!");\n            return;\n        }\n\n        // 主数据源执行 JDBC SQL\n        mysqlUserDao.recreateTable();\n\n        // 次数据源执行 JDBC SQL\n        h2UserDao.recreateTable();\n    }\n\n    private void printDataSourceInfo(JdbcTemplate jdbcTemplate) throws SQLException {\n\n        DataSource dataSource = jdbcTemplate.getDataSource();\n\n        Connection connection;\n        if (dataSource != null) {\n            connection = dataSource.getConnection();\n        } else {\n            log.error("Get dataSource failed!");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("DataSource Url: {}", connection.getMetaData().getURL());\n        } else {\n            log.error("Connect to datasource failed!");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n21:16:44.654 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.printDataSourceInfo - DataSource Url: jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&useSSL=false\n21:16:44.654 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.run - Connect to mysql datasource success.\n\n21:16:44.726 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.printDataSourceInfo - DataSource Url: jdbc:h2:mem:test\n21:16:44.726 [main] [INFO ] i.g.d.s.d.SpringBootDataJdbcMultiDataSourceApplication.run - Connect to h2 datasource success.\n\n\n\n# Spring 之数据源\n\n如果你的项目是传统的 Spring 项目，当然也可以轻松建立数据源连接，只是需要自行设置的配置更多一些。\n\n\n# 引入 Spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n# Spring 配置数据源\n\nSpring 配置数据源有多种方式，下面一一列举：\n\n# 使用 JNDI 数据源\n\n如果 Spring 应用部署在支持 JNDI 的 WEB 服务器上（如 WebSphere、JBoss、Tomcat 等），就可以使用 JNDI 获取数据源。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n  xmlns:jee="http://www.springframework.org/schema/jee"\n  xsi:schemaLocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\nhttp://www.springframework.org/schema/jee\nhttp://www.springframework.org/schema/jee/spring-jee-3.2.xsd">\n\n  \x3c!-- 1.使用bean配置jndi数据源 --\x3e\n  <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">\n    <property name="jndiName" value="java:comp/env/jdbc/orclight" />\n  </bean>\n\n  \x3c!-- 2.使用jee标签配置jndi数据源，与1等价，但是需要引入命名空间 --\x3e\n  <jee:jndi-lookup id="dataSource" jndi-name=" java:comp/env/jdbc/orclight" />\n</beans>\n\n\n# 使用数据库连接池\n\nSpring 本身并没有提供数据库连接池的实现，需要自行选择合适的数据库连接池。下面是一个使用 Druid 作为数据库连接池的示例：\n\n<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"\n        init-method="init" destroy-method="close">\n    <property name="driverClassName" value="${jdbc.driver}"/>\n    <property name="url" value="${jdbc.url}"/>\n    <property name="username" value="${jdbc.username}"/>\n    <property name="password" value="${jdbc.password}"/>\n\n    \x3c!-- 配置初始化大小、最小、最大 --\x3e\n    <property name="initialSize" value="1"/>\n    <property name="minIdle" value="1"/>\n    <property name="maxActive" value="10"/>\n\n    \x3c!-- 配置获取连接等待超时的时间 --\x3e\n    <property name="maxWait" value="10000"/>\n\n    \x3c!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --\x3e\n    <property name="timeBetweenEvictionRunsMillis" value="60000"/>\n\n    \x3c!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --\x3e\n    <property name="minEvictableIdleTimeMillis" value="300000"/>\n\n    <property name="testWhileIdle" value="true"/>\n\n    \x3c!-- 这里建议配置为TRUE，防止取到的连接不可用 --\x3e\n    <property name="testOnBorrow" value="true"/>\n    <property name="testOnReturn" value="false"/>\n\n    \x3c!-- 打开PSCache，并且指定每个连接上PSCache的大小 --\x3e\n    <property name="poolPreparedStatements" value="true"/>\n    <property name="maxPoolPreparedStatementPerConnectionSize"\n              value="20"/>\n\n    \x3c!-- 这里配置提交方式，默认就是TRUE，可以不用配置 --\x3e\n\n    <property name="defaultAutoCommit" value="true"/>\n\n    \x3c!-- 验证连接有效与否的SQL，不同的数据配置不同 --\x3e\n    <property name="validationQuery" value="select 1 "/>\n    <property name="filters" value="stat"/>\n  </bean>\n\n\n# 基于 JDBC 驱动的数据源\n\n<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n  <property name="driverClassName" value="${jdbc.driver}"/>\n  <property name="url" value="${jdbc.url}"/>\n  <property name="username" value="${jdbc.username}"/>\n  <property name="password" value="${jdbc.password}"/>\n</bean>\n\n\n\n# SpringBoot 数据源配置\n\n> Spring Boot 数据库配置官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/data.html#data.sql\n\n通过前面的实战，我们已经知道了 Spring、Spring Boot 是如何连接数据源，并通过 JDBC 方式访问数据库。\n\nSpringBoot 数据源的配置方式是在 application.properties 或 application.yml 文件中指定 spring.datasource.* 的配置。\n\n（1）数据源基本配置方式是指定 url、用户名、密码\n\nspring.datasource.url=jdbc:mysql://localhost/test\nspring.datasource.username=dbuser\nspring.datasource.password=dbpass\n\n\n（2）配置 JNDI\n\n如果想要通过 JNDI 方式连接数据源，可以采用如下方式：\n\nspring.datasource.jndi-name=java:jboss/datasources/customers\n\n\n\n# DataSourceAutoConfiguration 类\n\n显而易见，Spring Boot 的配置更加简化，那么， Spring Boot 做了哪些工作，使得接入更加便捷呢？奥秘就在于 spring-boot-autoconfigure jar 包，其中定义了大量的 Spring Boot 自动配置类。其中，与数据库访问相关的比较核心的配置类有：\n\n * DataSourceAutoConfiguration：数据源自动配置类\n * JdbcTemplateAutoConfiguration：JdbcTemplate 自动配置类\n * DataSourceTransactionManagerAutoConfiguration：数据源事务管理自动配置类\n * JndiDataSourceAutoConfiguration：JNDI 数据源自动配置类\n * EmbeddedDataSourceConfiguration：嵌入式数据库数据源自动配置类\n * 等等\n\n这些自动配置类会根据各种条件控制核心类的实例化。\n\nDataSourceAutoConfiguration 是数据源自动配置类，它负责实例化 DataSource。\n\nDataSourceAutoConfiguration 的源码如下（省略部分代码）：\n\n@AutoConfiguration(before = SqlInitializationAutoConfiguration.class)\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import(DataSourcePoolMetadataProvidersConfiguration.class)\npublic class DataSourceAutoConfiguration {\n\n\t@Configuration(proxyBeanMethods = false)\n\t@Conditional(EmbeddedDatabaseCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import(EmbeddedDataSourceConfiguration.class)\n\tprotected static class EmbeddedDatabaseConfiguration {\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@Conditional(PooledDataSourceCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,\n\t\t\tDataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,\n\t\t\tDataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class })\n\tprotected static class PooledDataSourceConfiguration {\n  }\n\n\tstatic class PooledDataSourceCondition extends AnyNestedCondition {\n    // 略\n\t}\n\n\tstatic class PooledDataSourceAvailableCondition extends SpringBootCondition {\n    // 略\n\t}\n\n\tstatic class EmbeddedDatabaseCondition extends SpringBootCondition {\n    // 略\n\t}\n}\n\n\nDataSourceAutoConfiguration 类的源码解读：\n\n * DataSourceProperties 是 DataSourceAutoConfiguration 的配置选项类，允许使用者通过设置选项控制 DataSource 初始化行为。\n * DataSourceAutoConfiguration 通过 @Import 注解引入 DataSourcePoolMetadataProvidersConfiguration 类。\n * DataSourceAutoConfiguration 中定义了两个内部类：嵌入式数据源配置类 EmbeddedDatabaseConfiguration 和 池化数据源配置类 PooledDataSourceConfiguration，分别标记了不同的实例化条件。\n   * 当满足 EmbeddedDatabaseConfiguration 的示例化条件时，将引入 EmbeddedDataSourceConfiguration 类初始化数据源，这个类实际上是加载嵌入式数据源驱动的 ClassLoader 去进行初始化。\n   * 当满足 PooledDataSourceConfiguration 的示例化条件时，将引入 DataSourceConfiguration.Hikari.class、DataSourceConfiguration.Tomcat.class、DataSourceConfiguration.Dbcp2.class、DataSourceConfiguration.OracleUcp.class、DataSourceConfiguration.Generic.class、DataSourceJmxConfiguration.class 这些配置类，分别对应不同的数据库连接池方式。具体选用哪种数据库连接池，可以通过 spring.datasource.type 配置指定。其中，Hikari 是 Spring Boot 默认的数据库连接池，spring-boot-starter-data-jdbc 中内置了 Hikari 连接池驱动包。如果想要替换其他数据库连接池，前提是必须先手动引入对应的连接池驱动包。\n\n\n# 参考资料\n\n * Spring 官网\n * Spring Framework 官方文档\n * Spring Boot 官方文档',normalizedContent:'# spring 之数据源\n\n> 本文基于 spring boot 2.7.3 版本。\n\n\n# spring boot 数据源基本配置\n\nspring boot 提供了一系列 spring.datasource.* 配置来控制 datasource 的配置。用户可以在 application.properties 或 application.yml 文件中指定数据源配置。这些配置项维护在 datasourceproperties 。\n\n下面是一个最基本的 mysql 数据源配置示例（都是必填项）：\n\n# 数据库访问地址\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\n# 数据库驱动类，必须保证驱动类是可加载的\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.driver\n# 数据库账号\nspring.datasource.username = root\n# 数据库账号密码\nspring.datasource.password = root\n\n\n需要根据实际情况，替换 url、username、password。\n\n\n# spring boot 连接嵌入式数据源\n\n使用内存嵌入式数据库开发应用程序通常很方便。显然，内存数据库不提供持久存储。使用者需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。\n\nspring boot 可以自动配置嵌入式数据库 h2、hsql 和 derby。使用者无需提供任何连接 url，只需要包含对要使用的嵌入式数据库的构建依赖项。如果类路径上有多个嵌入式数据库，需要设置 spring.datasource.embedded-database-connection 配置属性来控制使用哪一个。将该属性设置为 none 会禁用嵌入式数据库的自动配置。\n\n> 注意：如果在测试中使用此功能，无论使用多少应用程序上下文，整个测试套件都会重用同一个数据库。如果要确保每个上下文都有一个单独的嵌入式数据库，则应将 spring.datasource.generate-unique-name 设置为 true。\n\n下面，通过一个实例展示如何连接 h2 嵌入式数据库。\n\n（1）在 pom.xml 中引入所需要的依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-jdbc</artifactid>\n</dependency>\n<dependency>\n  <groupid>com.h2database</groupid>\n  <artifactid>h2</artifactid>\n</dependency>\n\n\n（2）数据源配置\n\nspring.datasource.jdbc-url = jdbc:h2:mem:test\nspring.datasource.driver-class-name = org.h2.driver\nspring.datasource.username = sa\nspring.datasource.password =\n\n\n\n# spring boot 连接池化数据源\n\n> 完整示例：spring-boot-data-jdbc\n\n在生产环境中，出于性能考虑，一般会通过数据库连接池连接数据源。\n\n除了 datasourceproperties 中的数据源通用配置以外，spring boot 还支持通过使用类似spring.datasource.hikari.*、spring.datasource.tomcat.*、spring.datasource.dbcp2.* 和 spring.datasource.oracleucp.* 的前缀来配置指定的数据库连接池属性。\n\n下面，就是一份 hikari 的连接池配置示例：\n\n# 连接池名称\nspring.datasource.hikari.pool-name = springtutorialhikaripool\n# 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值\nspring.datasource.hikari.maximum-pool-size = 10\n# 最小空闲连接，默认值10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size\nspring.datasource.hikari.minimum-idle = 10\n# 连接超时时间（单位：毫秒），小于 250 毫秒，会被重置为默认值 30 秒\nspring.datasource.hikari.connection-timeout = 60000\n# 空闲连接超时时间，默认值 600000（10分钟），大于等于 max-lifetime 且 max-lifetime>0，会被重置为0；不等于 0 且小于 10 秒，会被重置为 10 秒\n# 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放\nspring.datasource.hikari.idle-timeout = 600000\n# 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟。该值应该比数据库所设置的超时时间短\nspring.datasource.hikari.max-lifetime = 540000\n\n\nspring boot 会按以下顺序检测连接池是否可用，如果可用就选择对应的池化 datasource：\n\nhikaricp -> tomcat pooling datasource -> dbcp2 -> oracle ucp\n\n用户也可以通过 spring.datasource.type 来指定数据源类型。\n\n此外，也可以使用 datasourcebuilder 手动配置其他连接池。如果自定义 datasource bean，则不会发生自动配置。 datasourcebuilder 支持以下连接池：\n\n * hikaricp\n * tomcat pooling datasource\n * commons dbcp2\n * oracle ucp & oracledatasource\n * spring framework’s simpledriverdatasource\n * h2 jdbcdatasource\n * postgresql pgsimpledatasource\n * c3p0\n\n\n# 引入 spring boot 依赖\n\n你可以通过 spring boot 官方的初始化器（spring initializr）选择需要的组件来创建一个 spring boot 工程。或者，直接在 pom.xml 中引入所需要的依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-jdbc</artifactid>\n</dependency>\n<dependency>\n  <groupid>mysql</groupid>\n  <artifactid>mysql-connector-java</artifactid>\n</dependency>\n\n\n\n# 测试单数据源连接\n\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.boot.commandlinerunner;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.jdbc.core.jdbctemplate;\n\nimport java.sql.connection;\nimport javax.sql.datasource;\n\n@slf4j\n@springbootapplication\npublic class springbootdatajdbcapplication implements commandlinerunner {\n\n    private final jdbctemplate jdbctemplate;\n\n    public springbootdatajdbcapplication(jdbctemplate jdbctemplate) {\n        this.jdbctemplate = jdbctemplate;\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(springbootdatajdbcapplication.class, args);\n    }\n\n    @override\n    public void run(string... args) throws exception {\n        datasource datasource = jdbctemplate.getdatasource();\n\n        connection connection;\n        if (datasource != null) {\n            connection = datasource.getconnection();\n        } else {\n            log.error("连接数据源失败！");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("数据源 url: {}", connection.getmetadata().geturl());\n        } else {\n            log.error("连接数据源失败！");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n20:50:18.449 [main] [info ] i.g.d.s.d.springbootdatajdbcapplication.run - 数据源 url: jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\n\n\n\n# spring boot 连接多数据源\n\n> 完整示例：spring-boot-data-jdbc-multi-datasource\n\nspring boot 连接多数据源所需要的依赖并无不同，主要差异在于数据源的配置。spring boot 默认的数据源配置类为 org.springframework.boot.autoconfigure.jdbc.datasourceautoconfiguration。使用者只要指定一些必要的 spring.datasource 配置，datasourceautoconfiguration 类就会自动完成剩下的数据源实例化工作。\n\n\n# 多数据源配置\n\n下面的示例中，自定义了一个数据源配置类，通过读取不同的 spring.datasource.xxx 来完成对于不同数据源的实例化工作。对于 jdbc 来说，最重要的，就是实例化 datasource 和 jdbctemplate。\n\nimport org.springframework.beans.factory.annotation.qualifier;\nimport org.springframework.boot.context.properties.configurationproperties;\nimport org.springframework.boot.jdbc.datasourcebuilder;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.context.annotation.primary;\nimport org.springframework.jdbc.core.jdbctemplate;\n\n@configuration\npublic class datasourceconfig {\n\n    @primary\n    @bean("mysqldatasource")\n    @configurationproperties(prefix = "spring.datasource.mysql")\n    public datasource mysqldatasource() {\n        return datasourcebuilder.create().build();\n    }\n\n    @primary\n    @bean("mysqljdbctemplate")\n    public jdbctemplate mysqljdbctemplate(@qualifier("mysqldatasource") datasource datasource) {\n        return new jdbctemplate(datasource);\n    }\n\n    @bean("h2datasource")\n    @configurationproperties(prefix = "spring.datasource.h2")\n    public datasource h2datasource() {\n        return datasourcebuilder.create().build();\n    }\n\n    @bean(name = "h2jdbctemplate")\n    public jdbctemplate h2jdbctemplate(@qualifier("h2datasource") datasource datasource) {\n        return new jdbctemplate(datasource);\n    }\n\n}\n\n\napplication.properties 或 application.yml 配置文件中也必须以 @configurationproperties 所指定的配置前缀进行配置：\n\n# 数据源一：mysql\nspring.datasource.mysql.jdbc-url = jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8&usessl=false\nspring.datasource.mysql.driver-class-name = com.mysql.cj.jdbc.driver\nspring.datasource.mysql.username = root\nspring.datasource.mysql.password = root\n# 数据源一：h2\nspring.datasource.h2.jdbc-url = jdbc:h2:mem:test\nspring.datasource.h2.driver-class-name = org.h2.driver\nspring.datasource.h2.username = sa\nspring.datasource.h2.password =\n\n\n\n# 测试多数据源连接\n\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.beans.factory.annotation.qualifier;\nimport org.springframework.boot.commandlinerunner;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.jdbc.core.jdbctemplate;\n\nimport java.sql.connection;\nimport java.sql.sqlexception;\nimport javax.sql.datasource;\n\n@springbootapplication\npublic class springbootdatajdbcmultidatasourceapplication implements commandlinerunner {\n\n    private static final logger log = loggerfactory.getlogger(springbootdatajdbcmultidatasourceapplication.class);\n\n    private final userdao mysqluserdao;\n\n    private final userdao h2userdao;\n\n    public springbootdatajdbcmultidatasourceapplication(@qualifier("mysqluserdao") userdao mysqluserdao,\n        @qualifier("h2userdao") userdao h2userdao) {\n        this.mysqluserdao = mysqluserdao;\n        this.h2userdao = h2userdao;\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(springbootdatajdbcmultidatasourceapplication.class, args);\n    }\n\n    @override\n    public void run(string... args) throws exception {\n\n        if (mysqluserdao != null && mysqluserdao.getjdbctemplate() != null) {\n            printdatasourceinfo(mysqluserdao.getjdbctemplate());\n            log.info("connect to mysql datasource success.");\n        } else {\n            log.error("connect to mysql datasource failed!");\n            return;\n        }\n\n        if (h2userdao != null) {\n            printdatasourceinfo(h2userdao.getjdbctemplate());\n            log.info("connect to h2 datasource success.");\n        } else {\n            log.error("connect to h2 datasource failed!");\n            return;\n        }\n\n        // 主数据源执行 jdbc sql\n        mysqluserdao.recreatetable();\n\n        // 次数据源执行 jdbc sql\n        h2userdao.recreatetable();\n    }\n\n    private void printdatasourceinfo(jdbctemplate jdbctemplate) throws sqlexception {\n\n        datasource datasource = jdbctemplate.getdatasource();\n\n        connection connection;\n        if (datasource != null) {\n            connection = datasource.getconnection();\n        } else {\n            log.error("get datasource failed!");\n            return;\n        }\n\n        if (connection != null) {\n            log.info("datasource url: {}", connection.getmetadata().geturl());\n        } else {\n            log.error("connect to datasource failed!");\n        }\n    }\n\n}\n\n\n运行 main 方法后，控制台会输出以下内容，表示数据源连接成功：\n\n21:16:44.654 [main] [info ] i.g.d.s.d.springbootdatajdbcmultidatasourceapplication.printdatasourceinfo - datasource url: jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8&usessl=false\n21:16:44.654 [main] [info ] i.g.d.s.d.springbootdatajdbcmultidatasourceapplication.run - connect to mysql datasource success.\n\n21:16:44.726 [main] [info ] i.g.d.s.d.springbootdatajdbcmultidatasourceapplication.printdatasourceinfo - datasource url: jdbc:h2:mem:test\n21:16:44.726 [main] [info ] i.g.d.s.d.springbootdatajdbcmultidatasourceapplication.run - connect to h2 datasource success.\n\n\n\n# spring 之数据源\n\n如果你的项目是传统的 spring 项目，当然也可以轻松建立数据源连接，只是需要自行设置的配置更多一些。\n\n\n# 引入 spring 依赖\n\n在 pom.xml 中引入所需要的依赖：\n\n    <dependencies>\n        <dependency>\n            <groupid>com.alibaba</groupid>\n            <artifactid>druid</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n        </dependency>\n\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-context-support</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-jdbc</artifactid>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-tx</artifactid>\n        </dependency>\n    </dependencies>\n</project>\n\n\n\n# spring 配置数据源\n\nspring 配置数据源有多种方式，下面一一列举：\n\n# 使用 jndi 数据源\n\n如果 spring 应用部署在支持 jndi 的 web 服务器上（如 websphere、jboss、tomcat 等），就可以使用 jndi 获取数据源。\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n  xmlns:jee="http://www.springframework.org/schema/jee"\n  xsi:schemalocation="http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\nhttp://www.springframework.org/schema/jee\nhttp://www.springframework.org/schema/jee/spring-jee-3.2.xsd">\n\n  \x3c!-- 1.使用bean配置jndi数据源 --\x3e\n  <bean id="datasource" class="org.springframework.jndi.jndiobjectfactorybean">\n    <property name="jndiname" value="java:comp/env/jdbc/orclight" />\n  </bean>\n\n  \x3c!-- 2.使用jee标签配置jndi数据源，与1等价，但是需要引入命名空间 --\x3e\n  <jee:jndi-lookup id="datasource" jndi-name=" java:comp/env/jdbc/orclight" />\n</beans>\n\n\n# 使用数据库连接池\n\nspring 本身并没有提供数据库连接池的实现，需要自行选择合适的数据库连接池。下面是一个使用 druid 作为数据库连接池的示例：\n\n<bean id="datasource" class="com.alibaba.druid.pool.druiddatasource"\n        init-method="init" destroy-method="close">\n    <property name="driverclassname" value="${jdbc.driver}"/>\n    <property name="url" value="${jdbc.url}"/>\n    <property name="username" value="${jdbc.username}"/>\n    <property name="password" value="${jdbc.password}"/>\n\n    \x3c!-- 配置初始化大小、最小、最大 --\x3e\n    <property name="initialsize" value="1"/>\n    <property name="minidle" value="1"/>\n    <property name="maxactive" value="10"/>\n\n    \x3c!-- 配置获取连接等待超时的时间 --\x3e\n    <property name="maxwait" value="10000"/>\n\n    \x3c!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --\x3e\n    <property name="timebetweenevictionrunsmillis" value="60000"/>\n\n    \x3c!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --\x3e\n    <property name="minevictableidletimemillis" value="300000"/>\n\n    <property name="testwhileidle" value="true"/>\n\n    \x3c!-- 这里建议配置为true，防止取到的连接不可用 --\x3e\n    <property name="testonborrow" value="true"/>\n    <property name="testonreturn" value="false"/>\n\n    \x3c!-- 打开pscache，并且指定每个连接上pscache的大小 --\x3e\n    <property name="poolpreparedstatements" value="true"/>\n    <property name="maxpoolpreparedstatementperconnectionsize"\n              value="20"/>\n\n    \x3c!-- 这里配置提交方式，默认就是true，可以不用配置 --\x3e\n\n    <property name="defaultautocommit" value="true"/>\n\n    \x3c!-- 验证连接有效与否的sql，不同的数据配置不同 --\x3e\n    <property name="validationquery" value="select 1 "/>\n    <property name="filters" value="stat"/>\n  </bean>\n\n\n# 基于 jdbc 驱动的数据源\n\n<bean id="datasource" class="org.springframework.jdbc.datasource.drivermanagerdatasource">\n  <property name="driverclassname" value="${jdbc.driver}"/>\n  <property name="url" value="${jdbc.url}"/>\n  <property name="username" value="${jdbc.username}"/>\n  <property name="password" value="${jdbc.password}"/>\n</bean>\n\n\n\n# springboot 数据源配置\n\n> spring boot 数据库配置官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/data.html#data.sql\n\n通过前面的实战，我们已经知道了 spring、spring boot 是如何连接数据源，并通过 jdbc 方式访问数据库。\n\nspringboot 数据源的配置方式是在 application.properties 或 application.yml 文件中指定 spring.datasource.* 的配置。\n\n（1）数据源基本配置方式是指定 url、用户名、密码\n\nspring.datasource.url=jdbc:mysql://localhost/test\nspring.datasource.username=dbuser\nspring.datasource.password=dbpass\n\n\n（2）配置 jndi\n\n如果想要通过 jndi 方式连接数据源，可以采用如下方式：\n\nspring.datasource.jndi-name=java:jboss/datasources/customers\n\n\n\n# datasourceautoconfiguration 类\n\n显而易见，spring boot 的配置更加简化，那么， spring boot 做了哪些工作，使得接入更加便捷呢？奥秘就在于 spring-boot-autoconfigure jar 包，其中定义了大量的 spring boot 自动配置类。其中，与数据库访问相关的比较核心的配置类有：\n\n * datasourceautoconfiguration：数据源自动配置类\n * jdbctemplateautoconfiguration：jdbctemplate 自动配置类\n * datasourcetransactionmanagerautoconfiguration：数据源事务管理自动配置类\n * jndidatasourceautoconfiguration：jndi 数据源自动配置类\n * embeddeddatasourceconfiguration：嵌入式数据库数据源自动配置类\n * 等等\n\n这些自动配置类会根据各种条件控制核心类的实例化。\n\ndatasourceautoconfiguration 是数据源自动配置类，它负责实例化 datasource。\n\ndatasourceautoconfiguration 的源码如下（省略部分代码）：\n\n@autoconfiguration(before = sqlinitializationautoconfiguration.class)\n@conditionalonclass({ datasource.class, embeddeddatabasetype.class })\n@conditionalonmissingbean(type = "io.r2dbc.spi.connectionfactory")\n@enableconfigurationproperties(datasourceproperties.class)\n@import(datasourcepoolmetadataprovidersconfiguration.class)\npublic class datasourceautoconfiguration {\n\n\t@configuration(proxybeanmethods = false)\n\t@conditional(embeddeddatabasecondition.class)\n\t@conditionalonmissingbean({ datasource.class, xadatasource.class })\n\t@import(embeddeddatasourceconfiguration.class)\n\tprotected static class embeddeddatabaseconfiguration {\n\t}\n\n\t@configuration(proxybeanmethods = false)\n\t@conditional(pooleddatasourcecondition.class)\n\t@conditionalonmissingbean({ datasource.class, xadatasource.class })\n\t@import({ datasourceconfiguration.hikari.class, datasourceconfiguration.tomcat.class,\n\t\t\tdatasourceconfiguration.dbcp2.class, datasourceconfiguration.oracleucp.class,\n\t\t\tdatasourceconfiguration.generic.class, datasourcejmxconfiguration.class })\n\tprotected static class pooleddatasourceconfiguration {\n  }\n\n\tstatic class pooleddatasourcecondition extends anynestedcondition {\n    // 略\n\t}\n\n\tstatic class pooleddatasourceavailablecondition extends springbootcondition {\n    // 略\n\t}\n\n\tstatic class embeddeddatabasecondition extends springbootcondition {\n    // 略\n\t}\n}\n\n\ndatasourceautoconfiguration 类的源码解读：\n\n * datasourceproperties 是 datasourceautoconfiguration 的配置选项类，允许使用者通过设置选项控制 datasource 初始化行为。\n * datasourceautoconfiguration 通过 @import 注解引入 datasourcepoolmetadataprovidersconfiguration 类。\n * datasourceautoconfiguration 中定义了两个内部类：嵌入式数据源配置类 embeddeddatabaseconfiguration 和 池化数据源配置类 pooleddatasourceconfiguration，分别标记了不同的实例化条件。\n   * 当满足 embeddeddatabaseconfiguration 的示例化条件时，将引入 embeddeddatasourceconfiguration 类初始化数据源，这个类实际上是加载嵌入式数据源驱动的 classloader 去进行初始化。\n   * 当满足 pooleddatasourceconfiguration 的示例化条件时，将引入 datasourceconfiguration.hikari.class、datasourceconfiguration.tomcat.class、datasourceconfiguration.dbcp2.class、datasourceconfiguration.oracleucp.class、datasourceconfiguration.generic.class、datasourcejmxconfiguration.class 这些配置类，分别对应不同的数据库连接池方式。具体选用哪种数据库连接池，可以通过 spring.datasource.type 配置指定。其中，hikari 是 spring boot 默认的数据库连接池，spring-boot-starter-data-jdbc 中内置了 hikari 连接池驱动包。如果想要替换其他数据库连接池，前提是必须先手动引入对应的连接池驱动包。\n\n\n# 参考资料\n\n * spring 官网\n * spring framework 官方文档\n * spring boot 官方文档',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 之事务",frontmatter:{title:"Spring 之事务",date:"2022-09-22T07:46:49.000Z",order:3,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","事务"],permalink:"/pages/128c54/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/03.Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/03.Spring之事务.md",key:"v-ab53d220",path:"/pages/128c54/",headers:[{level:2,title:"理解事务",slug:"理解事务",normalizedTitle:"理解事务",charIndex:234},{level:3,title:"事务的特性",slug:"事务的特性",normalizedTitle:"事务的特性",charIndex:360},{level:3,title:"全局事务",slug:"全局事务",normalizedTitle:"全局事务",charIndex:334},{level:3,title:"本地事务",slug:"本地事务",normalizedTitle:"本地事务",charIndex:339},{level:3,title:"Spring 对事务的支持",slug:"spring-对事务的支持",normalizedTitle:"spring 对事务的支持",charIndex:1371},{level:3,title:"Spring 事务的优点",slug:"spring-事务的优点",normalizedTitle:"spring 事务的优点",charIndex:1727},{level:2,title:"核心 API",slug:"核心-api",normalizedTitle:"核心 api",charIndex:1950},{level:3,title:"TransactionManager",slug:"transactionmanager",normalizedTitle:"transactionmanager",charIndex:1961},{level:4,title:"PlatformTransactionManager",slug:"platformtransactionmanager",normalizedTitle:"platformtransactionmanager",charIndex:2078},{level:4,title:"JDBC 事务",slug:"jdbc-事务",normalizedTitle:"jdbc 事务",charIndex:3408},{level:4,title:"Hibernate 事务",slug:"hibernate-事务",normalizedTitle:"hibernate 事务",charIndex:3858},{level:4,title:"Java 持久化 API 事务（JPA）",slug:"java-持久化-api-事务-jpa",normalizedTitle:"java 持久化 api 事务（jpa）",charIndex:4402},{level:4,title:"Java 原生 API 事务（JTA）",slug:"java-原生-api-事务-jta",normalizedTitle:"java 原生 api 事务（jta）",charIndex:4907},{level:4,title:"ReactiveTransactionManager",slug:"reactivetransactionmanager",normalizedTitle:"reactivetransactionmanager",charIndex:2151},{level:3,title:"TransactionDefinition",slug:"transactiondefinition",normalizedTitle:"transactiondefinition",charIndex:2371},{level:4,title:"传播行为",slug:"传播行为",normalizedTitle:"传播行为",charIndex:6300},{level:4,title:"隔离级别",slug:"隔离级别",normalizedTitle:"隔离级别",charIndex:6342},{level:4,title:"只读",slug:"只读",normalizedTitle:"只读",charIndex:6451},{level:4,title:"事务超时",slug:"事务超时",normalizedTitle:"事务超时",charIndex:15e3},{level:4,title:"回滚规则",slug:"回滚规则",normalizedTitle:"回滚规则",charIndex:15126},{level:3,title:"TransactionStatus",slug:"transactionstatus",normalizedTitle:"transactionstatus",charIndex:2338},{level:3,title:"TransactionTemplate",slug:"transactiontemplate",normalizedTitle:"transactiontemplate",charIndex:15827},{level:2,title:"声明式事务管理",slug:"声明式事务管理",normalizedTitle:"声明式事务管理",charIndex:936},{level:3,title:"Spring 声明式事务管理的实现",slug:"spring-声明式事务管理的实现",normalizedTitle:"spring 声明式事务管理的实现",charIndex:17682},{level:3,title:"声明式事务示例",slug:"声明式事务示例",normalizedTitle:"声明式事务示例",charIndex:18398},{level:3,title:"回滚一个声明性事务",slug:"回滚一个声明性事务",normalizedTitle:"回滚一个声明性事务",charIndex:23170},{level:3,title:"为不同的 Bean 配置不同的事务语义",slug:"为不同的-bean-配置不同的事务语义",normalizedTitle:"为不同的 bean 配置不同的事务语义",charIndex:25286},{level:3,title:"<tx:advice/> 配置",slug:"tx-advice-配置",normalizedTitle:'<routerlink to="./tx:advice/">tx:advice/</routerlink> 配置',charIndex:null},{level:3,title:"使用 @Transactional 注解",slug:"使用-transactional-注解",normalizedTitle:"使用 @transactional 注解",charIndex:29784},{level:4,title:"@Transactional 配置",slug:"transactional-配置",normalizedTitle:"@transactional 配置",charIndex:31864},{level:4,title:"多事务管理器场景下使用 @Transactional",slug:"多事务管理器场景下使用-transactional",normalizedTitle:"多事务管理器场景下使用 @transactional",charIndex:34797},{level:4,title:"自定义组合注解",slug:"自定义组合注解",normalizedTitle:"自定义组合注解",charIndex:36024},{level:4,title:"事务传播",slug:"事务传播",normalizedTitle:"事务传播",charIndex:13015},{level:2,title:"JDBC 异常抽象",slug:"jdbc-异常抽象",normalizedTitle:"jdbc 异常抽象",charIndex:37551},{level:2,title:"Spring 事务最佳实践",slug:"spring-事务最佳实践",normalizedTitle:"spring 事务最佳实践",charIndex:37710},{level:3,title:"Spring 事务未生效",slug:"spring-事务未生效",normalizedTitle:"spring 事务未生效",charIndex:37730},{level:4,title:"@Transactional 方法必须是 public",slug:"transactional-方法必须是-public",normalizedTitle:"@transactional 方法必须是 public",charIndex:37821},{level:4,title:"必须通过 Spring 注入的 Bean 进行调用",slug:"必须通过-spring-注入的-bean-进行调用",normalizedTitle:"必须通过 spring 注入的 bean 进行调用",charIndex:38538},{level:3,title:"事务虽然生效但未回滚",slug:"事务虽然生效但未回滚",normalizedTitle:"事务虽然生效但未回滚",charIndex:39195},{level:3,title:"细化事务传播方式",slug:"细化事务传播方式",normalizedTitle:"细化事务传播方式",charIndex:41141},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:41582}],headersStr:"理解事务 事务的特性 全局事务 本地事务 Spring 对事务的支持 Spring 事务的优点 核心 API TransactionManager PlatformTransactionManager JDBC 事务 Hibernate 事务 Java 持久化 API 事务（JPA） Java 原生 API 事务（JTA） ReactiveTransactionManager TransactionDefinition 传播行为 隔离级别 只读 事务超时 回滚规则 TransactionStatus TransactionTemplate 声明式事务管理 Spring 声明式事务管理的实现 声明式事务示例 回滚一个声明性事务 为不同的 Bean 配置不同的事务语义 <tx:advice/> 配置 使用 @Transactional 注解 @Transactional 配置 多事务管理器场景下使用 @Transactional 自定义组合注解 事务传播 JDBC 异常抽象 Spring 事务最佳实践 Spring 事务未生效 @Transactional 方法必须是 public 必须通过 Spring 注入的 Bean 进行调用 事务虽然生效但未回滚 细化事务传播方式 参考资料",content:'# Spring 之事务\n\nSpring 针对 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API(JPA) 等事务 API，实现了一致的编程模型，而 Spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 Spring Boot 的自动配置，大多数 Spring Boot 项目只需要在方法上标记 @Transactional 注解，即可一键开启方法的事务性配置。\n\n\n# 理解事务\n\n在软件开发领域，全有或全无的操作被称为事务（transaction）。事务允许你将几个操作组合成一个要么全部发生要么全部不发生的工作单元。传统上 Java EE 开发对事务管理有两种选择：全局事务或本地事务，两者都有很大的局限性。\n\n\n# 事务的特性\n\n事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID。\n\n * 原子性（Atomic）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n * 一致性（Consistent）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n * 隔离性（Isolated）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n * 持久性（Durable）：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n\n\n# 全局事务\n\n全局事务允许您使用多个事务资源，通常是关系数据库和消息队列。应用服务器通过 JTA 管理全局事务，这是一个繁琐的 API（部分原因在于其异常模型）。此外，JTA UserTransaction 通常需要来自 JNDI，这意味着您还需要使用 JNDI 才能使用 JTA。全局事务的使用限制了应用程序代码的任何潜在重用，因为 JTA 通常仅在应用程序服务器环境中可用。\n\n以前，使用全局事务的首选方式是通过 EJB CMT（容器管理事务）。 CMT 是一种声明式事务管理（不同于程序化事务管理）。 EJB CMT 消除了对与事务相关的 JNDI 查找的需要，尽管使用 EJB 本身就需要使用 JNDI。它消除了大部分（但不是全部）编写 Java 代码来控制事务的需要。其明显的缺点是 CMT 与 JTA 和应用程序服务器环境相关联。此外，它仅在选择在 EJB 中实现业务逻辑（或至少在事务性 EJB 外观之后）时才可用。一般来说，EJB 的负面影响是如此之大，以至于这不是一个有吸引力的提议，尤其是在面对声明式事务管理的引人注目的替代方案时。\n\n\n# 本地事务\n\n本地事务是指定资源的，例如与 JDBC 连接关联的事务。本地事务可能更容易使用，但有一个明显的缺点：它们不能跨多个事务资源工作。例如，使用 JDBC 连接管理事务的代码不能在全局 JTA 事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个资源的正确性（值得注意的是，大多数应用程序使用单个事务资源。）。另一个缺点是本地事务对编程模型具有侵入性。\n\n\n# Spring 对事务的支持\n\nSpring 通过回调机制将实际的事务实现从事务性的代码中抽象出来。Spring 解决了全局和本地事务的缺点。它允许开发人员在任何环境中使用一致的编程模型。您只需编写一次代码，它就可以从不同环境中的不同事务管理策略中受益。Spring 提供了对编码式和声明式事务管理的支持，大多数情况下都推荐使用声明式事务管理。\n\n * 编码式事务允许用户在代码中精确定义事务的边界\n * 声明式事务（基于 AOP）有助于用户将操作与事务规则进行解耦\n\n通过程序化事务管理，开发人员可以使用 Spring 事务抽象，它可以在任何底层事务基础上运行。使用首选的声明性模型，开发人员通常编写很少或根本不编写与事务管理相关的代码，因此不依赖 Spring 事务 API 或任何其他事务 API。\n\n\n# Spring 事务的优点\n\nSpring 框架为事务管理提供了一致的抽象，具有以下好处：\n\n * 跨不同事务 API 的一致编程模型，例如 Java Transaction API (JTA)、JDBC、Hibernate 和 Java Persistence API (JPA)。\n * 支持声明式事务管理。\n * 用于编程事务管理的 API 比复杂事务 API（如 JTA）更简单。\n * 与 Spring 的数据访问抽象完美集成。\n\n\n# 核心 API\n\n\n# TransactionManager\n\nSpring 事务抽象的关键是事务策略的概念。事务策略由 TransactionManager 定义，特别是用于命令式事务管理的 org.springframework.transaction.PlatformTransactionManager 接口和用于响应式事务管理的 org.springframework.transaction.ReactiveTransactionManager 接口。\n\n\n\n# PlatformTransactionManager\n\n以下清单显示了 PlatformTransactionManager API 的定义：\n\npublic interface PlatformTransactionManager extends TransactionManager {\n\n    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n\n    void commit(TransactionStatus status) throws TransactionException;\n\n    void rollback(TransactionStatus status) throws TransactionException;\n}\n\n\nPlatformTransactionManager 是一个 SPI 接口，所以使用者可以以编程方式使用它。因为 PlatformTransactionManager 是一个接口，所以可以根据需要轻松地 MOCK 或存根。它不依赖于查找策略，例如 JNDI。 PlatformTransactionManager 实现的定义与 Spring IoC 容器中的任何其他对象（或 bean）一样。仅此一项优势就使 Spring 事务成为有价值的抽象，即使您使用 JTA 也是如此。与直接使用 JTA 相比，您可以更轻松地测试事务代码。\n\n同样，为了与 Spring 的理念保持一致，任何 PlatformTransactionManager 接口的方法可以抛出的 TransactionException 都是未经检查的（也就是说，它扩展了 java.lang.RuntimeException 类）。事务架构故障几乎总是致命的。极少数情况下，应用程序可以从事务失败中恢复，开发人员可以选择捕获和处理 TransactionException。重点是开发人员并非被迫这样做。\n\ngetTransaction(..) 方法根据 TransactionDefinition 参数返回一个 TransactionStatus 对象。如果当前调用堆栈中存在匹配的事务，则返回的 TransactionStatus 可能表示新事务或可以表示现有事务。后一种情况的含义是，与 Java EE 事务上下文一样，TransactionStatus 与执行线程相关联。\n\n从以上可以看出，具体的事务管理机制对 Spring 来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以 Spring 事务管理的一个优点就是为不同的事务 API 提供一致的编程模型，如 JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。\n\n# JDBC 事务\n\n如果应用程序中直接使用 JDBC 来进行持久化，DataSourceTransactionManager 会为你处理事务边界。为了使用 DataSourceTransactionManager，你需要使用如下的 XML 将其装配到应用程序的上下文定义中：\n\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource" ref="dataSource" />\n</bean>\n\n\n实际上，DataSourceTransactionManager 是通过调用 java.sql.Connection 来管理事务，而后者是通过 DataSource 获取到的。通过调用连接的 commit() 方法来提交事务，同样，事务失败则通过调用 rollback() 方法进行回滚。\n\n# Hibernate 事务\n\n如果应用程序的持久化是通过 Hibernate 实现的，那么你需要使用 HibernateTransactionManager。对于 Hibernate3，需要在 Spring 上下文定义中添加如下的 bean 声明：\n\n<bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager">\n  <property name="sessionFactory" ref="sessionFactory" />\n</bean>\n\n\nsessionFactory 属性需要装配一个 Hibernate 的 session 工厂，HibernateTransactionManager 的实现细节是它将事务管理的职责委托给 org.hibernate.Transaction 对象，而后者是从 Hibernate Session 中获取到的。当事务成功完成时，HibernateTransactionManager 将会调用 Transaction 对象的 commit() 方法，反之，将会调用 rollback() 方法。\n\n# Java 持久化 API 事务（JPA）\n\nHibernate 多年来一直是事实上的 Java 持久化标准，但是现在 Java 持久化 API 作为真正的 Java 持久化标准进入大家的视野。如果你计划使用 JPA 的话，那你需要使用 Spring 的 JpaTransactionManager 来处理事务。你需要在 Spring 中这样配置 JpaTransactionManager：\n\n<bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">\n  <property name="sessionFactory" ref="sessionFactory" />\n</bean>\n\n\nJpaTransactionManager 只需要装配一个 JPA 实体管理工厂（javax.persistence.EntityManagerFactory 接口的任意实现）。JpaTransactionManager 将与由工厂所产生的 JPA EntityManager 合作来构建事务。\n\n# Java 原生 API 事务（JTA）\n\n如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager：\n\n<bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager">\n  <property name="transactionManagerName" value="java:/TransactionManager" />\n</bean>\n\n\nJtaTransactionManager 将事务管理的责任委托给 javax.transaction.UserTransaction 和 javax.transaction.TransactionManager 对象，其中事务成功完成通过 UserTransaction.commit() 方法提交，事务失败通过 UserTransaction.rollback() 方法回滚。\n\n# ReactiveTransactionManager\n\nSpring 还为使用响应式类型或 Kotlin 协程的响应式应用程序提供了事务管理抽象。以下清单显示了 org.springframework.transaction.ReactiveTransactionManager 定义的事务策略：\n\npublic interface ReactiveTransactionManager extends TransactionManager {\n\n    Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;\n\n    Mono<Void> commit(ReactiveTransaction status) throws TransactionException;\n\n    Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;\n}\n\n\n响应式事务管理器主要是一个 SPI，所以使用者可以以编程方式使用它。因为 ReactiveTransactionManager 是一个接口，所以可以根据需要轻松地 MOCK 或存根。\n\n\n# TransactionDefinition\n\nPlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到事务，这个方法里面的参数是 TransactionDefinition 类，这个类就定义了一些基本的事务属性。事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。\n\nTransactionDefinition 接口内容如下：\n\npublic interface TransactionDefinition {\n    int getPropagationBehavior(); // 返回事务的传播行为\n    int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据\n    int getTimeout();  // 返回事务必须在多少秒内完成\n    boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的\n}\n\n\n我们可以发现 TransactionDefinition 正好用来定义事务属性，下面详细介绍一下各个事务属性。\n\n# 传播行为\n\n事务的传播行为（propagation behavior）是指：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring 定义了七种传播行为：\n\n传播行为                        含义\nPROPAGATION_REQUIRED        表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务\nPROPAGATION_SUPPORTS        表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行\nPROPAGATION_MANDATORY       表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常\nPROPAGATION_REQUIRED_NEW    表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用\n                            JTATransactionManager 的话，则需要访问 TransactionManager\nPROPAGATION_NOT_SUPPORTED   表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用\n                            JTATransactionManager 的话，则需要访问 TransactionManager\nPROPAGATION_NEVER           表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常\nPROPAGATION_NESTED          表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与\n                            PROPAGATION_REQUIRED\n                            一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务\n\n注：以下具体讲解传播行为的内容参考自 Spring 事务机制详解\n\n 1. PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。\n\n// 事务属性 PROPAGATION_REQUIRED\nmethodA {\n    ……\n    methodB();\n    ……\n}\n\n\n// 事务属性 PROPAGATION_REQUIRED\nmethodB {\n   ……\n}\n\n\n使用 spring 声明式事务，spring 使用 AOP 来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。\n\n单独调用 methodB 方法：\n\nmain {\n    metodB();\n}\n\n\n相当于\n\nMain {\n    Connection con=null;\n    try{\n        con = getConnection();\n        con.setAutoCommit(false);\n\n        //方法调用\n        methodB();\n\n        //提交事务\n        con.commit();\n    } Catch(RuntimeException ex) {\n        //回滚事务\n        con.rollback();\n    } finally {\n        //释放资源\n        closeCon();\n    }\n}\n\n\nSpring 保证在 methodB 方法中所有的调用都获得到一个相同的连接。在调用 methodB 时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。 单独调用 MethodA 时，在 MethodA 内又会调用 MethodB.\n\n执行效果相当于：\n\nmain{\n    Connection con = null;\n    try{\n        con = getConnection();\n        methodA();\n        con.commit();\n    } catch(RuntimeException ex) {\n        con.rollback();\n    } finally {\n        closeCon();\n    }\n}\n\n\n调用 MethodA 时，环境中没有事务，所以开启一个新的事务.当在 MethodA 中调用 MethodB 时，环境中已经有了一个事务，所以 methodB 就加入当前事务。\n\n 2. PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS 与不使用事务有少许不同。\n\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n  methodB();\n}\n\n//事务属性 PROPAGATION_SUPPORTS\nmethodB(){\n  ……\n}\n\n\n单纯的调用 methodB 时，methodB 方法是非事务的执行的。当调用 methdA 时,methodB 则加入了 methodA 的事务中,事务地执行。\n\n 3. PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。\n\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    methodB();\n}\n\n//事务属性 PROPAGATION_MANDATORY\n    methodB(){\n    ……\n}\n\n\n当单独调用 methodB 时，因为当前没有一个活动的事务，则会抛出异常 throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用 methodA 时，methodB 则加入到 methodA 的事务中，事务地执行。\n\n 4. PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。\n\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    doSomeThingA();\n    methodB();\n    doSomeThingB();\n}\n\n//事务属性 PROPAGATION_REQUIRES_NEW\nmethodB(){\n    ……\n}\n\n\n调用 A 方法：\n\nmain(){\n    methodA();\n}\n\n\n相当于\n\nmain(){\n    TransactionManager tm = null;\n    try{\n        //获得一个JTA事务管理器\n        tm = getTransactionManager();\n        tm.begin();//开启一个新的事务\n        Transaction ts1 = tm.getTransaction();\n        doSomeThing();\n        tm.suspend();//挂起当前事务\n        try{\n            tm.begin();//重新开启第二个事务\n            Transaction ts2 = tm.getTransaction();\n            methodB();\n            ts2.commit();//提交第二个事务\n        } Catch(RunTimeException ex) {\n            ts2.rollback();//回滚第二个事务\n        } finally {\n            //释放资源\n        }\n        //methodB执行完后，恢复第一个事务\n        tm.resume(ts1);\n        doSomeThingB();\n        ts1.commit();//提交第一个事务\n    } catch(RunTimeException ex) {\n        ts1.rollback();//回滚第一个事务\n    } finally {\n        //释放资源\n    }\n}\n\n\n在这里，我把 ts1 称为外层事务，ts2 称为内层事务。从上面的代码可以看出，ts2 与 ts1 是两个独立的事务，互不相干。Ts2 是否成功并不依赖于 ts1。如果 methodA 方法在调用 methodB 方法后的 doSomeThingB 方法失败了，而 methodB 方法所做的结果依然被提交。而除了 methodB 之外的其它代码导致的结果却被回滚了。使用 PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager 作为事务管理器。\n\n 5. PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。使用 PROPAGATION_NOT_SUPPORTED,也需要使用 JtaTransactionManager 作为事务管理器。（代码示例同上，可同理推出）\n 6. PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常。\n 7. PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按 TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用 JDBC 3.0 驱动时,仅仅支持 DataSourceTransactionManager 作为事务管理器。需要 JDBC 驱动的 java.sql.Savepoint 类。有一些 JTA 的事务管理器实现可能也提供了同样的功能。使用 PROPAGATION_NESTED，还需要把 PlatformTransactionManager 的 nestedTransactionAllowed 属性设为 true;而 nestedTransactionAllowed 属性值默认为 false。\n\n//事务属性 PROPAGATION_REQUIRED\nmethodA(){\n    doSomeThingA();\n    methodB();\n    doSomeThingB();\n}\n\n//事务属性 PROPAGATION_NESTED\nmethodB(){\n    ……\n}\n\n\n如果单独调用 methodB 方法，则按 REQUIRED 属性执行。如果调用 methodA 方法，相当于下面的效果：\n\nmain(){\n    Connection con = null;\n    Savepoint savepoint = null;\n    try{\n        con = getConnection();\n        con.setAutoCommit(false);\n        doSomeThingA();\n        savepoint = con2.setSavepoint();\n        try{\n            methodB();\n        } catch(RuntimeException ex) {\n            con.rollback(savepoint);\n        } finally {\n            //释放资源\n        }\n        doSomeThingB();\n        con.commit();\n    } catch(RuntimeException ex) {\n        con.rollback();\n    } finally {\n        //释放资源\n    }\n}\n\n\n当 methodB 方法调用之前，调用 setSavepoint 方法，保存当前的状态到 savepoint。如果 methodB 方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括 methodB 方法的所有操作。\n\n嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。\n\nPROPAGATION_NESTED 与 PROPAGATION_REQUIRES_NEW 的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW 时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要 JTA 事务管理器的支持。\n\n使用 PROPAGATION_NESTED 时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager 使用 savepoint 支持 PROPAGATION_NESTED 时，需要 JDBC 3.0 以上驱动及 1.4 以上的 JDK 版本支持。其它的 JTA TrasactionManager 实现可能有不同的支持方式。\n\nPROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。\n\n另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。\n\n由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.\n\nPROPAGATION_REQUIRED 应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。\n\n# 隔离级别\n\n事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。\n\n 1. 并发事务引起的问题\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。\n\n * 脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。\n * 不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。\n * 幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。\n\n不可重复读与幻读的区别\n\n不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 例如：在事务 1 中，Mary 读取了自己的工资为 1000,操作并没有完成\n\n    con1 = getConnection();\n    select salary from employee empId ="Mary";\n\n\n在事务 2 中，这时财务人员修改了 Mary 的工资为 2000,并提交了事务.\n\n    con2 = getConnection();\n    update employee set salary = 2000;\n    con2.commit();\n\n\n在事务 1 中，Mary 再次读取自己的工资时，工资变为了 2000\n\n    //con1\n    select salary from employee empId ="Mary";\n\n\n在一个事务中前后两次读取的结果并不一致，导致了不可重复读。\n\n幻读的重点在于新增或者删除： 同样的条件, 第 1 次和第 2 次读出来的记录数不一样 例如：目前工资为 1000 的员工有 10 人。事务 1,读取所有工资为 1000 的员工。\n\n    con1 = getConnection();\n    Select * from employee where salary =1000;\n\n\n共读取 10 条记录\n\n这时另一个事务向 employee 表插入了一条员工记录，工资也为 1000\n\n    con2 = getConnection();\n    Insert into employee(empId,salary) values("Lili",1000);\n    con2.commit();\n\n\n事务 1 再次读取所有工资为 1000 的员工\n\n    //con1\n    select * from employee where salary =1000;\n\n\n共读取到了 11 条记录，这就产生了幻像读。\n\n从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。 对于前者, 只需要锁住满足条件的记录。 对于后者, 要锁住满足条件及其相近的记录。\n\n 2. 隔离级别\n\n隔离级别                         含义\nISOLATION_DEFAULT            使用后端数据库默认的隔离级别\nISOLATION_READ_UNCOMMITTED   最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\nISOLATION_READ_COMMITTED     允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\nISOLATION_REPEATABLE_READ    对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生\nISOLATION_SERIALIZABLE       最高的隔离级别，完全服从 ACID\n                             的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的\n\n# 只读\n\n事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。\n\n# 事务超时\n\n为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。\n\n# 回滚规则\n\n事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与 EJB 的回滚行为是一致的） 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。\n\n\n# TransactionStatus\n\nTransactionStatus 接口为事务代码提供了一种简单的方式来控制事务执行和查询事务状态。这些概念应该很熟悉，因为它们对所有事务 API 都是通用的。以下清单显示了 TransactionStatus 接口：\n\npublic interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {\n\n    @Override\n    boolean isNewTransaction();\n\n    boolean hasSavepoint();\n\n    @Override\n    void setRollbackOnly();\n\n    @Override\n    boolean isRollbackOnly();\n\n    void flush();\n\n    @Override\n    boolean isCompleted();\n}\n\n\n可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。\n\n\n# TransactionTemplate\n\nSpring 提供了对编程式事务和声明式事务的支持。编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于 AOP）有助于用户将操作与事务规则进行解耦。TransactionTemplate 就是用于支持编程式事务的核心 API。\n\n采用 TransactionTemplate 和采用其他 Spring 模板，如 JdbcTempalte 和 HibernateTemplate 是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate 是线程安全的。代码片段：\n\n    TransactionTemplate tt = new TransactionTemplate(); // 新建一个TransactionTemplate\n    Object result = tt.execute(\n        new TransactionCallback(){\n            public Object doTransaction(TransactionStatus status){\n                updateOperation();\n                return resultOfUpdateOperation();\n            }\n    }); // 执行execute方法进行事务管理\n\n\n使用 TransactionCallback()可以返回一个值。如果使用 TransactionCallbackWithoutResult 则没有返回值。\n\n\n# 声明式事务管理\n\n> 大多数 Spring 用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。\n\nSpring 框架的声明式事务管理是通过 Spring AOP 实现的。然而，由于事务方面代码随 Spring 发行版一起提供并且可以以样板方式使用，因此通常不必理解 AOP 概念即可有效地使用此代码。\n\nSpring 框架的声明式事务管理类似于 EJB CMT，因为您可以指定事务行为（或缺少它）到单个方法级别。如有必要，您可以在事务上下文中进行 setRollbackOnly() 调用。两种类型的事务管理之间的区别是：\n\n * 与绑定到 JTA 的 EJB CMT 不同，Spring 框架的声明式事务管理适用于任何环境。通过调整配置文件，它可以使用 JDBC、JPA 或 Hibernate 处理 JTA 事务或本地事务。\n * 您可以将 Spring 声明式事务管理应用于任何类，而不仅仅是诸如 EJB 之类的特殊类。\n * Spring 提供声明性回滚规则，这是一个没有 EJB 等效功能的特性。提供了对回滚规则的编程和声明性支持。\n * Spring 允许您使用 AOP 自定义事务行为。例如，您可以在事务回滚的情况下插入自定义行为。您还可以添加任意 advice 以及事务性 advice。使用 EJB CMT，您无法影响容器的事务管理，除非使用 setRollbackOnly()。\n * Spring 不像高端应用服务器那样支持跨远程调用传播事务上下文。如果您需要此功能，我们建议您使用 EJB。但是，在使用这种特性之前要仔细考虑，因为通常情况下，不希望事务跨越远程调用。\n\n回滚规则的概念很重要。它们让您指定哪些异常（和 throwable）应该导致自动回滚。您可以在配置中以声明方式指定它，而不是在 Java 代码中。因此，尽管您仍然可以在 TransactionStatus 对象上调用 setRollbackOnly() 来回滚当前事务，但通常您可以指定 MyApplicationException 必须始终导致回滚的规则。此选项的显着优势是业务对象不依赖于事务基础架构。例如，它们通常不需要导入 Spring 事务 API 或其他 Spring API。\n\n尽管 EJB 容器默认行为会在系统异常（通常是运行时异常）上自动回滚事务，但 EJB CMT 不会在应用程序异常（即除 java.rmi.RemoteException 之外的检查异常）上自动回滚事务。虽然声明式事务管理的 Spring 默认行为遵循 EJB 约定（回滚仅在未经检查的异常上自动），但自定义此行为通常很有用。\n\n\n# Spring 声明式事务管理的实现\n\n关于 Spring 框架的声明式事务支持，最重要的概念是这种支持是通过 AOP 代理启用的，并且事务 advice 是由元数据驱动的（目前是基于 XML 或基于注释的）。 AOP 与事务元数据的结合产生了一个 AOP 代理，它使用 TransactionInterceptor 和适当的 TransactionManager 实现来驱动围绕方法调用的事务。\n\nSpring 的 TransactionInterceptor 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。返回响应式类型的方法，例如 Publisher 或 Kotlin Flow（或它们的子类型）有资格进行响应式事务管理。包括 void 在内的所有其他返回类型都使用代码路径进行命令式事务管理。\n\n事务管理风格会影响需要哪个事务管理器。命令式事务需要 PlatformTransactionManager，而响应式事务使用 ReactiveTransactionManager 实现。\n\n> @Transactional 通常与 PlatformTransactionManager 管理的线程绑定事务一起使用，将事务公开给当前执行线程中的所有数据访问操作。注意：这不会传播到方法中新启动的线程。\n> \n> 由 ReactiveTransactionManager 管理的反应式事务使用 Reactor 上下文而不是线程本地属性。因此，所有参与的数据访问操作都需要在同一个反应式管道中的同一个 Reactor 上下文中执行。\n\n下图显示了在事务代理上调用方法的概念视图：\n\n\n\n\n# 声明式事务示例\n\n考虑以下接口及其伴随的实现。此示例使用 Foo 和 Bar 类作为占位符，以便您可以专注于事务使用，而无需关注特定的域模型。就本示例而言，DefaultFooService 类在每个已实现方法的主体中抛出 UnsupportedOperationException 实例这一事实很好。该行为使您可以看到正在创建的事务，然后回滚以响应 UnsupportedOperationException 实例。\n\n以下清单显示了 FooService 接口：\n\n// the service interface that we want to make transactional\n\npackage x.y.service;\n\npublic interface FooService {\n\n    Foo getFoo(String fooName);\n\n    Foo getFoo(String fooName, String barName);\n\n    void insertFoo(Foo foo);\n\n    void updateFoo(Foo foo);\n\n}\n\n\n以下示例显示了上述接口的实现：\n\npackage x.y.service;\n\npublic class DefaultFooService implements FooService {\n\n    @Override\n    public Foo getFoo(String fooName) {\n        // ...\n    }\n\n    @Override\n    public Foo getFoo(String fooName, String barName) {\n        // ...\n    }\n\n    @Override\n    public void insertFoo(Foo foo) {\n        // ...\n    }\n\n    @Override\n    public void updateFoo(Foo foo) {\n        // ...\n    }\n}\n\n\n假设 FooService 接口的前两个方法 getFoo(String) 和 getFoo(String, String) 必须在具有只读语义的事务上下文中运行，并且其他方法 insertFoo(Foo) 和 updateFoo(Foo )，必须在具有读写语义的事务上下文中运行。以下配置将在接下来的几段中详细说明：\n\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- the transactional advice (what \'happens\'; see the <aop:advisor/> bean below) --\x3e\n    <tx:advice id="txAdvice" transaction-manager="txManager">\n        \x3c!-- the transactional semantics... --\x3e\n        <tx:attributes>\n            \x3c!-- all methods starting with \'get\' are read-only --\x3e\n            <tx:method name="get*" read-only="true"/>\n            \x3c!-- other methods use the default transaction settings (see below) --\x3e\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- ensure that the above transactional advice runs for any execution\n        of an operation defined by the FooService interface --\x3e\n    <aop:config>\n        <aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>\n        <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>\n    </aop:config>\n\n    \x3c!-- don\'t forget the DataSource --\x3e\n    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">\n        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>\n        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>\n        <property name="username" value="scott"/>\n        <property name="password" value="tiger"/>\n    </bean>\n\n    \x3c!-- similarly, don\'t forget the TransactionManager --\x3e\n    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n\n\n检查前面的配置。它假定您要使服务对象 fooService bean 具有事务性。要应用的事务语义封装在 <tx:advice/> 定义中。<tx:advice/> 定义读作“所有以 get 开头的方法都将在只读事务的上下文中运行，所有其他方法都将以默认事务语义运行”。<tx:advice/> 标签的 transaction-manager 属性设置为将驱动事务的 TransactionManager bean 的名称（在本例中为 txManager bean）。\n\n> 如果要连接的 TransactionManager 的 bean 名称具有名称 transactionManager，则可以省略事务 advice (tx:advice/) 中的 transaction-manager 属性。如果要连接的 TransactionManager bean 有任何其他名称，则必须显式使用 transaction-manager 属性，如前面的示例所示。\n\n<aop:config/> 定义确保由 txAdvice bean 定义的事务性建议在程序中的适当位置运行。首先，您定义一个切入点，该切入点与 FooService 接口 (fooServiceOperation) 中定义的任何操作的执行相匹配。然后，您使用一个 adviser 将切入点与 txAdvice 相关联。结果表明，在执行 fooServiceOperation 时，会运行 txAdvice 定义的建议。\n\n一个常见的要求是使整个服务层具有事务性。最好的方法是更改切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：\n\n<aop:config>\n    <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>\n    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>\n</aop:config>\n\n\n前面显示的配置用于围绕从 fooService bean 定义创建的对象创建事务代理。代理配置了事务 advice，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，启动、暂停、标记为只读等事务。考虑以下测试驱动前面显示的配置的程序：\n\npublic final class Boot {\n\n    public static void main(final String[] args) throws Exception {\n        ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");\n        FooService fooService = ctx.getBean(FooService.class);\n        fooService.insertFoo(new Foo());\n    }\n}\n\n\n\n# 回滚一个声明性事务\n\nSpring 框架中，触发事务回滚的推荐方式是在事务上下文的代码中抛出异常。Spring 事务框架会捕获任何未处理的异常，并确定是否将事务标记为回滚。\n\n在其默认配置中，Spring 事务框架只会将存在运行时且未经检查异常的事务标记为回滚。也就是说，当抛出的异常是 RuntimeException 的实例或子类时。 （默认情况下，错误实例也会导致回滚）。从事务方法抛出的检查异常不会导致默认配置中的回滚。\n\n您可以通过指定回滚规则，明确指定哪些异常类型将导致事务回滚。\n\n> 回滚规则约定在抛出指定异常时是否应回滚事务，并且规则基于模式。模式可以是完全限定的类名或异常类型的完全限定类名的子字符串（必须是 Throwable 的子类），目前不支持通配符。例如，javax.servlet.ServletException 或 ServletException 的值将匹配 javax.servlet.ServletException 及其子类。\n> \n> 回滚规则可以通过 rollback-for 和 no-rollback-for 属性在 XML 中配置，这允许将模式指定为字符串。使用 @Transactional 时，可以通过 rollbackFor / noRollbackFor 和rollbackForClassName / noRollbackForClassName 属性配置回滚规则，它们允许将模式分别指定为类引用或字符串。当异常类型被指定为类引用时，其完全限定名称将用作模式。因此，@Transactional(rollbackFor = example.CustomException.class) 等价于 @Transactional(rollbackForClassName = \'example.CustomException\')。\n\n以下 XML 片段演示了如何通过 rollback-for 属性提供异常模式来为已检查的、特定的 Exception 类型配置回滚：\n\n<tx:advice id="txAdvice" transaction-manager="txManager">\n    <tx:attributes>\n    <tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n\n\n如果您不希望在抛出异常时回滚事务，您还可以指定“不回滚”规则。下面的例子告诉 Spring 事务框架，即使在面对未处理的 InstrumentNotFoundException 时也要提交伴随事务。\n\n<tx:advice id="txAdvice">\n    <tx:attributes>\n    <tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n\n\n当 Spring Framework 事务框架捕获到异常，并检查配置的回滚规则以确定是否将事务标记为回滚时，由最重要的匹配规则决定。因此，在以下配置的情况下，除 InstrumentNotFoundException 之外的任何异常都会导致伴随事务的回滚。\n\n<tx:advice id="txAdvice">\n    <tx:attributes>\n    <tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>\n    </tx:attributes>\n</tx:advice>\n\n\n您还可以以编程方式指示所需的回滚。虽然很简单，但这个过程非常具有侵入性，并且将您的代码与 Spring Framework 的事务基础设施紧密耦合。以下示例显示如何以编程方式指示所需的回滚。\n\npublic void resolvePosition() {\n    try {\n        // some business logic...\n    } catch (NoProductInStockException ex) {\n        // trigger rollback programmatically\n        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n    }\n}\n\n\n如果可能的话，强烈建议您使用声明性方法进行回滚。如果您绝对需要，可以使用程序化回滚，但它的使用与实现干净的基于 POJO 的架构背道而驰。\n\n\n# 为不同的 Bean 配置不同的事务语义\n\n考虑您有许多服务层对象的场景，并且您希望对每个对象应用完全不同的事务配置。您可以通过定义具有不同 <aop:advisor/> 元素和不同 advice-ref 属性值的切点来实现这一点。\n\n作为一个比较点，首先假设您的所有服务层类都定义在根 x.y.service 包中。 要使作为该包（或子包）中定义的类的实例并且名称以 Service 结尾的所有 bean 都具有默认的事务配置，您可以编写以下内容：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="serviceOperation"\n                expression="execution(* x.y.service..*Service.*(..))"/>\n\n        <aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/>\n\n    </aop:config>\n\n    \x3c!-- these two beans will be transactional... --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n    <bean id="barService" class="x.y.service.extras.SimpleBarService"/>\n\n    \x3c!-- ... and these two beans won\'t --\x3e\n    <bean id="anotherService" class="org.xyz.SomeService"/> \x3c!-- (not in the right package) --\x3e\n    <bean id="barManager" class="x.y.service.SimpleBarManager"/> \x3c!-- (doesn\'t end in \'Service\') --\x3e\n\n    <tx:advice id="txAdvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a TransactionManager omitted... --\x3e\n\n</beans>\n\n\n以下示例显示了如何使用完全不同的事务设置配置两个不同的 bean\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="defaultServiceOperation"\n                expression="execution(* x.y.service.*Service.*(..))"/>\n\n        <aop:pointcut id="noTxServiceOperation"\n                expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/>\n\n        <aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/>\n\n        <aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/>\n\n    </aop:config>\n\n    \x3c!-- this bean will be transactional (see the \'defaultServiceOperation\' pointcut) --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- this bean will also be transactional, but with totally different transactional settings --\x3e\n    <bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/>\n\n    <tx:advice id="defaultTxAdvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <tx:advice id="noTxAdvice">\n        <tx:attributes>\n            <tx:method name="*" propagation="NEVER"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a TransactionManager omitted... --\x3e\n\n</beans>\n\n\n\n# <tx:advice/> 配置\n\n<tx:advice/> 的默认配置为：\n\n * 传播设置是 REQUIRED\n\n * 隔离级别为 DEFAULT\n\n * 事务是 read-write\n\n * 事务超时默认为底层事务系统的默认超时，如果不支持超时，则为无。\n\n * 任何 RuntimeException 都会触发回滚，而任何已检查的 Exception 都不会\n\n<tx:advice/> 配置属性\n\n属性                是否必要   默认值        描述\nname              Yes               与事务属性关联的方法名称。支持通配符，如：get*、handle*、on*Event\npropagation       No     REQUIRED   事务传播行为\nisolation         No     DEFAULT    事务隔离级别。仅适用于 REQUIRED 或 REQUIRES_NEW 的传播设置。\ntimeout           No     -1         事务超时时间（单位：秒）。仅适用于 REQUIRED 或 REQUIRES_NEW 的传播设置。\nread-only         No     false      read-write 或 read-only 事务。\nrollback-for      No                触发回滚的 Exception 实例列表（通过逗号分隔）。\nno-rollback-for   No                不触发回滚的 Exception 实例列表（通过逗号分隔）。\n\n\n# 使用 @Transactional 注解\n\n除了基于 XML 的声明式事务配置方法之外，您还可以使用基于注解的方法。\n\n下面是一个使用 @Transactional 注解的示例：\n\n@Transactional\npublic class DefaultFooService implements FooService {\n\n    @Override\n    public Foo getFoo(String fooName) {\n        // ...\n    }\n\n    @Override\n    public Foo getFoo(String fooName, String barName) {\n        // ...\n    }\n\n    @Override\n    public void insertFoo(Foo foo) {\n        // ...\n    }\n\n    @Override\n    public void updateFoo(Foo foo) {\n        // ...\n    }\n}\n\n\n如上所述在类级别使用，@Transactional 注解表明声明类（及其子类）的所有方法都使用默认事务配置。 或者，可以单独为每个方法指定注解。请注意，类级别的注解不适用于类层次结构中的祖先类； 在这种情况下，继承的方法需要在本地重新声明才能参与子类级别的注解。\n\n当上面的 POJO 类在 Spring 上下文中定义为 bean 时，您可以通过 @Configuration 类中的 @EnableTransactionManagement 注解使 bean 实例具有事务性。\n\n在 XML 配置中， <tx:annotation-driven/> 标签提供了类似的便利：\n\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooService" class="x.y.service.DefaultFooService"/>\n\n    \x3c!-- enable the configuration of transactional behavior based on annotations --\x3e\n    \x3c!-- a TransactionManager is still required --\x3e\n    <tx:annotation-driven transaction-manager="txManager"/>\n\n    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        \x3c!-- (this dependency is defined somewhere else) --\x3e\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n\n\n# @Transactional 配置\n\nPROPERTY                 TYPE                                                         DESCRIPTION\nvalue                    String                                                       Optional qualifier that specifies the transaction manager to\n                                                                                      be used.\ntransactionManager       String                                                       Alias for value.\nlabel                    Array of String labels to add an expressive description to   Labels may be evaluated by transaction managers to associate\n                         the transaction.                                             implementation-specific behavior with the actual\n                                                                                      transaction.\npropagation              enum: Propagation                                            Optional propagation setting.\nisolation                enum: Isolation                                              Optional isolation level. Applies only to propagation values\n                                                                                      of REQUIRED or REQUIRES_NEW.\ntimeout                  int (in seconds of granularity)                              Optional transaction timeout. Applies only to propagation\n                                                                                      values of REQUIRED or REQUIRES_NEW.\ntimeoutString            String (in seconds of granularity)                           Alternative for specifying the timeout in seconds as a\n                                                                                      String value — for example, as a placeholder.\nreadOnly                 boolean                                                      Read-write versus read-only transaction. Only applicable to\n                                                                                      values of REQUIRED or REQUIRES_NEW.\nrollbackFor              Array of Class objects, which must be derived from           Optional array of exception types that must cause rollback.\n                         Throwable.\nrollbackForClassName     Array of exception name patterns.                            Optional array of exception name patterns that must cause\n                                                                                      rollback.\nnoRollbackFor            Array of Class objects, which must be derived from           Optional array of exception types that must not cause\n                         Throwable.                                                   rollback.\nnoRollbackForClassName   Array of exception name patterns.                            Optional array of exception name patterns that must not\n                                                                                      cause rollback.\n\n# 多事务管理器场景下使用 @Transactional\n\n某些情况下，应用程序中可能需要接入多个数据源，相应的，也需要多个独立的事务管理器。使用者可以使用 @Transactional 注释的 value 或 transactionManager 属性来选择性地指定要使用的 TransactionManager 的标识。这可以是 bean 名称或事务管理器 bean 的限定符值。\n\npublic class TransactionalService {\n\n    @Transactional("order")\n    public void setSomething(String name) { ... }\n\n    @Transactional("account")\n    public void doSomething() { ... }\n\n    @Transactional("reactive-account")\n    public Mono<Void> doSomethingReactive() { ... }\n}\n\n\n下面展示如何定义 TransactionManager：\n\n<tx:annotation-driven/>\n\n    <bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        ...\n        <qualifier value="order"/>\n    </bean>\n\n    <bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        ...\n        <qualifier value="account"/>\n    </bean>\n\n    <bean id="transactionManager3" class="org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager">\n        ...\n        <qualifier value="reactive-account"/>\n    </bean>\n\n\n在这种情况下，TransactionalService 上的各个方法在单独的事务管理器下运行，由 order、account 和 reactive-account 限定符区分。 如果没有找到明确指定的 TransactionManager bean，则仍使用默认的 <tx:annotation-driven> 目标 bean 名称。\n\n# 自定义组合注解\n\n如果您发现在许多不同的方法上重复使用 @Transactional 相同的属性，可以使用 Spring 的元注解自定义组合注解。\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = "order", label = "causal-consistency")\npublic @interface OrderTx {\n}\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Transactional(transactionManager = "account", label = "retryable")\npublic @interface AccountTx {\n}\n\n\n使用示例：\n\npublic class TransactionalService {\n\n    @OrderTx\n    public void setSomething(String name) {\n        // ...\n    }\n\n    @AccountTx\n    public void doSomething() {\n        // ...\n    }\n}\n\n\n在上面的示例中，我们使用语法来定义事务管理器限定符和事务标签，但我们也可以包括传播行为、回滚规则、超时和其他特性。\n\n# 事务传播\n\n在 Spring 管理的事务中，请注意物理事务和逻辑事务之间的差异，以及传播设置如何应用于这种差异。\n\n\n\nPROPAGATION_REQUIRED 强制执行物理事务，如果尚不存在事务，则在当前范围的本地执行或参与更大范围定义的现有“外部”事务。 这是同一线程内的常见调用堆栈安排中的一个很好的默认设置（例如，委托给多个存储库方法的服务外观，其中所有底层资源都必须参与服务级事务）。\n\n当传播设置为 PROPAGATION_REQUIRED 时，将为应用该设置的每个方法创建一个逻辑事务范围。每个这样的逻辑事务范围可以单独确定仅回滚状态，外部事务范围在逻辑上独立于内部事务范围。在标准 PROPAGATION_REQUIRED 行为的情况下，所有这些范围都映射到同一个物理事务。因此，在内部事务范围内设置的仅回滚标记确实会影响外部事务实际提交的机会。\n\n但是，在内部事务范围设置了仅回滚标记的情况下，外部事务尚未决定回滚本身，因此回滚（由内部事务范围静默触发）是意外的。此时会引发相应的 UnexpectedRollbackException。这是预期的行为，因此事务的调用者永远不会被误导以为执行了提交，而实际上并没有执行。因此，如果内部事务（外部调用者不知道）默默地将事务标记为仅回滚，外部调用者仍会调用提交。外部调用者需要接收 UnexpectedRollbackException 以清楚地指示执行了回滚。\n\n\n\nPROPAGATION_REQUIRES_NEW 与 PROPAGATION_REQUIRED 相比，始终为每个受影响的事务范围使用独立的物理事务，从不参与外部范围的现有事务。 在这种安排下，底层资源事务是不同的，因此可以独立提交或回滚，外部事务不受内部事务回滚状态的影响，内部事务的锁在完成后立即释放。 这样一个独立的内部事务也可以声明自己的隔离级别、超时和只读设置，而不是继承外部事务的特性。\n\n\n# JDBC 异常抽象\n\nSpring 会将数据操作的异常转换为 DataAccessException。\n\nSpring 是怎么认识那些错误码的\n\n通过 SQLErrorCodeSQLExceptionTranslator 解析错误码\n\nErrorCode 定义（sql-error-codes.xml 文件）\n\n\n# Spring 事务最佳实践\n\n\n\n\n# Spring 事务未生效\n\n使用 @Transactional 注解开启声明式事务时， 最容易忽略的问题是，很可能事务并没有生效。\n\n@Transactional 生效原则：\n\n# @Transactional 方法必须是 public\n\n原则一：除非特殊配置（比如使用 AspectJ 静态织入实现 AOP），否则只有定义在 public 方法上的 @Transactional 才能生效。原因是，Spring 默认通过动态代理的方式实现 AOP，对目标方法进行增强，private 方法无法代理到，Spring 自然也无法动态增强事务处理逻辑。\n\n【示例】错误使用 @Transactional 案例一\n\n\t@Transactional\n\tvoid createUserPrivate(UserEntity entity) {\n\t\tuserRepository.save(entity);\n\t\tif (entity.getName().contains("test")) { throw new RuntimeException("invalid username!"); }\n\t}\n\n\t//私有方法\n\tpublic int createUserWrong1(String name) {\n\t\ttry {\n\t\t\tthis.createUserPrivate(new UserEntity(name));\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getMessage());\n\t\t}\n\t\treturn userRepository.findByName(name).size();\n\t}\n\n\n当传入名为 test 的用户实体，会抛出异常，但 @Transactional 未生效，不会触发回滚。\n\n# 必须通过 Spring 注入的 Bean 进行调用\n\n原则二：必须通过代理过的类从外部调用目标方法才能生效。\n\n【示例】错误使用 @Transactional 案例二\n\n\t//自调用\n\tpublic int createUserWrong2(String name) {\n\t\ttry {\n\t\t\tthis.createUserPublic(new UserEntity(name));\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getMessage());\n\t\t}\n\t\treturn userRepository.findByName(name).size();\n\t}\n\n\t//可以传播出异常\n\t@Transactional\n\tpublic void createUserPublic(UserEntity entity) {\n\t\tuserRepository.save(entity);\n\t\tif (entity.getName().contains("test")) { throw new RuntimeException("invalid username!"); }\n\t}\n\n\n当传入名为 test 的用户实体，会抛出异常，但 @Transactional 未生效，不会触发回滚。\n\n说明：Spring 通过 AOP 技术对方法进行字节码增强，要调用增强过的方法必然是调用代理后的对象。\n\n\n# 事务虽然生效但未回滚\n\n通过 AOP 实现事务处理可以理解为，使用 try…catch… 来包裹标记了 @Transactional 注解的方法，当方法出现了异常并且满足一定条件的时候，在 catch 里面我们可以设置事务回滚，没有异常则直接提交事务。\n\n“一定条件”，主要包括两点：\n\n第一，只有异常传播出了标记了 @Transactional 注解的方法，事务才能回滚。在 Spring 的 TransactionAspectSupport 里有个 invokeWithinTransaction 方法，里面就是处理事务的逻辑。\n\n第二，默认情况下，出现 RuntimeException（非受检异常）或 Error 的时候，Spring 才会回滚事务。\n\n@Service\n@Slf4j\npublic class UserService {\n\n\t@Autowired\n\tprivate UserRepository userRepository;\n\n\t//异常无法传播出方法，导致事务无法回滚\n\t@Transactional\n\tpublic void createUserWrong1(String name) {\n\t\ttry {\n\t\t\tuserRepository.save(new UserEntity(name));\n\t\t\tthrow new RuntimeException("error");\n\t\t} catch (Exception ex) {\n\t\t\tlog.error("create user failed", ex);\n\t\t}\n\t}\n\n\t//即使出了受检异常也无法让事务回滚\n\t@Transactional\n\tpublic void createUserWrong2(String name) throws IOException {\n\t\tuserRepository.save(new UserEntity(name));\n\t\totherTask();\n\t}\n\n\t//因为文件不存在，一定会抛出一个IOException\n\tprivate void otherTask() throws IOException {\n\t\tFiles.readAllLines(Paths.get("file-that-not-exist"));\n\t}\n\n}\n\n\n在 createUserWrong1 方法中会抛出一个 RuntimeException，但由于方法内 catch 了所有异常，异常无法从方法传播出去，事务自然无法回滚。\n\n在 createUserWrong2 方法中，注册用户的同时会有一次 otherTask 文件读取操作，如果文件读取失败，我们希望用户注册的数据库操作回滚。虽然这里没有捕获异常，但因为 otherTask 方法抛出的是受检异常，createUserWrong2 传播出去的也是受检异常，事务同样不会回滚。\n\n【解决方案一】如果你希望自己捕获异常进行处理的话，也没关系，可以手动设置 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); 让当前事务处于回滚状态：\n\n@Transactional\npublic void createUserRight1(String name) {\n   try {\n      userRepository.save(new UserEntity(name));\n      throw new RuntimeException("error");\n   } catch (Exception ex) {\n      log.error("create user failed", ex);\n      TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n   }\n}\n\n\n【解决方案二】在注解中声明 @Transactional(rollbackFor = Exception.class)，期望遇到所有的 Exception 都回滚事务（来突破默认不回滚受检异常的限制）：\n\n@Transactional(rollbackFor = Exception.class)\npublic void createUserRight2(String name) throws IOException {\n   userRepository.save(new UserEntity(name));\n   otherTask();\n}\n\n\n\n# 细化事务传播方式\n\n如果方法涉及多次数据库操作，并希望将它们作为独立的事务进行提交或回滚，那么 我们需要考虑进一步细化配置事务传播方式，也就是 @Transactional 注解的 Propagation 属性。\n\n/**\n * {@link Propagation#REQUIRES_NEW} 表示执行到这个方法时需要开启新的事务，并挂起当前事务\n */\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void createSubUserWithExceptionRight(UserEntity entity) {\n   log.info("createSubUserWithExceptionRight start");\n   userRepository.save(entity);\n   throw new RuntimeException("invalid status");\n}\n\n\n\n# 参考资料\n\n * Spring 官网\n * Spring 官方文档\n * Spring Boot 官方文档\n * 《Java 业务开发常见错误 100 例》',normalizedContent:'# spring 之事务\n\nspring 针对 java transaction api (jta)、jdbc、hibernate 和 java persistence api(jpa) 等事务 api，实现了一致的编程模型，而 spring 的声明式事务功能更是提供了极其方便的事务配置方式，配合 spring boot 的自动配置，大多数 spring boot 项目只需要在方法上标记 @transactional 注解，即可一键开启方法的事务性配置。\n\n\n# 理解事务\n\n在软件开发领域，全有或全无的操作被称为事务（transaction）。事务允许你将几个操作组合成一个要么全部发生要么全部不发生的工作单元。传统上 java ee 开发对事务管理有两种选择：全局事务或本地事务，两者都有很大的局限性。\n\n\n# 事务的特性\n\n事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 acid。\n\n * 原子性（atomic）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n * 一致性（consistent）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n * 隔离性（isolated）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n * 持久性（durable）：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n\n\n# 全局事务\n\n全局事务允许您使用多个事务资源，通常是关系数据库和消息队列。应用服务器通过 jta 管理全局事务，这是一个繁琐的 api（部分原因在于其异常模型）。此外，jta usertransaction 通常需要来自 jndi，这意味着您还需要使用 jndi 才能使用 jta。全局事务的使用限制了应用程序代码的任何潜在重用，因为 jta 通常仅在应用程序服务器环境中可用。\n\n以前，使用全局事务的首选方式是通过 ejb cmt（容器管理事务）。 cmt 是一种声明式事务管理（不同于程序化事务管理）。 ejb cmt 消除了对与事务相关的 jndi 查找的需要，尽管使用 ejb 本身就需要使用 jndi。它消除了大部分（但不是全部）编写 java 代码来控制事务的需要。其明显的缺点是 cmt 与 jta 和应用程序服务器环境相关联。此外，它仅在选择在 ejb 中实现业务逻辑（或至少在事务性 ejb 外观之后）时才可用。一般来说，ejb 的负面影响是如此之大，以至于这不是一个有吸引力的提议，尤其是在面对声明式事务管理的引人注目的替代方案时。\n\n\n# 本地事务\n\n本地事务是指定资源的，例如与 jdbc 连接关联的事务。本地事务可能更容易使用，但有一个明显的缺点：它们不能跨多个事务资源工作。例如，使用 jdbc 连接管理事务的代码不能在全局 jta 事务中运行。因为应用服务器不参与事务管理，它不能确保跨多个资源的正确性（值得注意的是，大多数应用程序使用单个事务资源。）。另一个缺点是本地事务对编程模型具有侵入性。\n\n\n# spring 对事务的支持\n\nspring 通过回调机制将实际的事务实现从事务性的代码中抽象出来。spring 解决了全局和本地事务的缺点。它允许开发人员在任何环境中使用一致的编程模型。您只需编写一次代码，它就可以从不同环境中的不同事务管理策略中受益。spring 提供了对编码式和声明式事务管理的支持，大多数情况下都推荐使用声明式事务管理。\n\n * 编码式事务允许用户在代码中精确定义事务的边界\n * 声明式事务（基于 aop）有助于用户将操作与事务规则进行解耦\n\n通过程序化事务管理，开发人员可以使用 spring 事务抽象，它可以在任何底层事务基础上运行。使用首选的声明性模型，开发人员通常编写很少或根本不编写与事务管理相关的代码，因此不依赖 spring 事务 api 或任何其他事务 api。\n\n\n# spring 事务的优点\n\nspring 框架为事务管理提供了一致的抽象，具有以下好处：\n\n * 跨不同事务 api 的一致编程模型，例如 java transaction api (jta)、jdbc、hibernate 和 java persistence api (jpa)。\n * 支持声明式事务管理。\n * 用于编程事务管理的 api 比复杂事务 api（如 jta）更简单。\n * 与 spring 的数据访问抽象完美集成。\n\n\n# 核心 api\n\n\n# transactionmanager\n\nspring 事务抽象的关键是事务策略的概念。事务策略由 transactionmanager 定义，特别是用于命令式事务管理的 org.springframework.transaction.platformtransactionmanager 接口和用于响应式事务管理的 org.springframework.transaction.reactivetransactionmanager 接口。\n\n\n\n# platformtransactionmanager\n\n以下清单显示了 platformtransactionmanager api 的定义：\n\npublic interface platformtransactionmanager extends transactionmanager {\n\n    transactionstatus gettransaction(transactiondefinition definition) throws transactionexception;\n\n    void commit(transactionstatus status) throws transactionexception;\n\n    void rollback(transactionstatus status) throws transactionexception;\n}\n\n\nplatformtransactionmanager 是一个 spi 接口，所以使用者可以以编程方式使用它。因为 platformtransactionmanager 是一个接口，所以可以根据需要轻松地 mock 或存根。它不依赖于查找策略，例如 jndi。 platformtransactionmanager 实现的定义与 spring ioc 容器中的任何其他对象（或 bean）一样。仅此一项优势就使 spring 事务成为有价值的抽象，即使您使用 jta 也是如此。与直接使用 jta 相比，您可以更轻松地测试事务代码。\n\n同样，为了与 spring 的理念保持一致，任何 platformtransactionmanager 接口的方法可以抛出的 transactionexception 都是未经检查的（也就是说，它扩展了 java.lang.runtimeexception 类）。事务架构故障几乎总是致命的。极少数情况下，应用程序可以从事务失败中恢复，开发人员可以选择捕获和处理 transactionexception。重点是开发人员并非被迫这样做。\n\ngettransaction(..) 方法根据 transactiondefinition 参数返回一个 transactionstatus 对象。如果当前调用堆栈中存在匹配的事务，则返回的 transactionstatus 可能表示新事务或可以表示现有事务。后一种情况的含义是，与 java ee 事务上下文一样，transactionstatus 与执行线程相关联。\n\n从以上可以看出，具体的事务管理机制对 spring 来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以 spring 事务管理的一个优点就是为不同的事务 api 提供一致的编程模型，如 jta、jdbc、hibernate、jpa。下面分别介绍各个平台框架实现事务管理的机制。\n\n# jdbc 事务\n\n如果应用程序中直接使用 jdbc 来进行持久化，datasourcetransactionmanager 会为你处理事务边界。为了使用 datasourcetransactionmanager，你需要使用如下的 xml 将其装配到应用程序的上下文定义中：\n\n<bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n  <property name="datasource" ref="datasource" />\n</bean>\n\n\n实际上，datasourcetransactionmanager 是通过调用 java.sql.connection 来管理事务，而后者是通过 datasource 获取到的。通过调用连接的 commit() 方法来提交事务，同样，事务失败则通过调用 rollback() 方法进行回滚。\n\n# hibernate 事务\n\n如果应用程序的持久化是通过 hibernate 实现的，那么你需要使用 hibernatetransactionmanager。对于 hibernate3，需要在 spring 上下文定义中添加如下的 bean 声明：\n\n<bean id="transactionmanager" class="org.springframework.orm.hibernate3.hibernatetransactionmanager">\n  <property name="sessionfactory" ref="sessionfactory" />\n</bean>\n\n\nsessionfactory 属性需要装配一个 hibernate 的 session 工厂，hibernatetransactionmanager 的实现细节是它将事务管理的职责委托给 org.hibernate.transaction 对象，而后者是从 hibernate session 中获取到的。当事务成功完成时，hibernatetransactionmanager 将会调用 transaction 对象的 commit() 方法，反之，将会调用 rollback() 方法。\n\n# java 持久化 api 事务（jpa）\n\nhibernate 多年来一直是事实上的 java 持久化标准，但是现在 java 持久化 api 作为真正的 java 持久化标准进入大家的视野。如果你计划使用 jpa 的话，那你需要使用 spring 的 jpatransactionmanager 来处理事务。你需要在 spring 中这样配置 jpatransactionmanager：\n\n<bean id="transactionmanager" class="org.springframework.orm.jpa.jpatransactionmanager">\n  <property name="sessionfactory" ref="sessionfactory" />\n</bean>\n\n\njpatransactionmanager 只需要装配一个 jpa 实体管理工厂（javax.persistence.entitymanagerfactory 接口的任意实现）。jpatransactionmanager 将与由工厂所产生的 jpa entitymanager 合作来构建事务。\n\n# java 原生 api 事务（jta）\n\n如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用jtatransactionmanager：\n\n<bean id="transactionmanager" class="org.springframework.transaction.jta.jtatransactionmanager">\n  <property name="transactionmanagername" value="java:/transactionmanager" />\n</bean>\n\n\njtatransactionmanager 将事务管理的责任委托给 javax.transaction.usertransaction 和 javax.transaction.transactionmanager 对象，其中事务成功完成通过 usertransaction.commit() 方法提交，事务失败通过 usertransaction.rollback() 方法回滚。\n\n# reactivetransactionmanager\n\nspring 还为使用响应式类型或 kotlin 协程的响应式应用程序提供了事务管理抽象。以下清单显示了 org.springframework.transaction.reactivetransactionmanager 定义的事务策略：\n\npublic interface reactivetransactionmanager extends transactionmanager {\n\n    mono<reactivetransaction> getreactivetransaction(transactiondefinition definition) throws transactionexception;\n\n    mono<void> commit(reactivetransaction status) throws transactionexception;\n\n    mono<void> rollback(reactivetransaction status) throws transactionexception;\n}\n\n\n响应式事务管理器主要是一个 spi，所以使用者可以以编程方式使用它。因为 reactivetransactionmanager 是一个接口，所以可以根据需要轻松地 mock 或存根。\n\n\n# transactiondefinition\n\nplatformtransactionmanager 通过 gettransaction(transactiondefinition definition) 方法来得到事务，这个方法里面的参数是 transactiondefinition 类，这个类就定义了一些基本的事务属性。事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。\n\ntransactiondefinition 接口内容如下：\n\npublic interface transactiondefinition {\n    int getpropagationbehavior(); // 返回事务的传播行为\n    int getisolationlevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据\n    int gettimeout();  // 返回事务必须在多少秒内完成\n    boolean isreadonly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的\n}\n\n\n我们可以发现 transactiondefinition 正好用来定义事务属性，下面详细介绍一下各个事务属性。\n\n# 传播行为\n\n事务的传播行为（propagation behavior）是指：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。spring 定义了七种传播行为：\n\n传播行为                        含义\npropagation_required        表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务\npropagation_supports        表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行\npropagation_mandatory       表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常\npropagation_required_new    表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用\n                            jtatransactionmanager 的话，则需要访问 transactionmanager\npropagation_not_supported   表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用\n                            jtatransactionmanager 的话，则需要访问 transactionmanager\npropagation_never           表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常\npropagation_nested          表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与\n                            propagation_required\n                            一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务\n\n注：以下具体讲解传播行为的内容参考自 spring 事务机制详解\n\n 1. propagation_required 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。\n\n// 事务属性 propagation_required\nmethoda {\n    ……\n    methodb();\n    ……\n}\n\n\n// 事务属性 propagation_required\nmethodb {\n   ……\n}\n\n\n使用 spring 声明式事务，spring 使用 aop 来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。\n\n单独调用 methodb 方法：\n\nmain {\n    metodb();\n}\n\n\n相当于\n\nmain {\n    connection con=null;\n    try{\n        con = getconnection();\n        con.setautocommit(false);\n\n        //方法调用\n        methodb();\n\n        //提交事务\n        con.commit();\n    } catch(runtimeexception ex) {\n        //回滚事务\n        con.rollback();\n    } finally {\n        //释放资源\n        closecon();\n    }\n}\n\n\nspring 保证在 methodb 方法中所有的调用都获得到一个相同的连接。在调用 methodb 时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。 单独调用 methoda 时，在 methoda 内又会调用 methodb.\n\n执行效果相当于：\n\nmain{\n    connection con = null;\n    try{\n        con = getconnection();\n        methoda();\n        con.commit();\n    } catch(runtimeexception ex) {\n        con.rollback();\n    } finally {\n        closecon();\n    }\n}\n\n\n调用 methoda 时，环境中没有事务，所以开启一个新的事务.当在 methoda 中调用 methodb 时，环境中已经有了一个事务，所以 methodb 就加入当前事务。\n\n 2. propagation_supports 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，propagation_supports 与不使用事务有少许不同。\n\n//事务属性 propagation_required\nmethoda(){\n  methodb();\n}\n\n//事务属性 propagation_supports\nmethodb(){\n  ……\n}\n\n\n单纯的调用 methodb 时，methodb 方法是非事务的执行的。当调用 methda 时,methodb 则加入了 methoda 的事务中,事务地执行。\n\n 3. propagation_mandatory 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。\n\n//事务属性 propagation_required\nmethoda(){\n    methodb();\n}\n\n//事务属性 propagation_mandatory\n    methodb(){\n    ……\n}\n\n\n当单独调用 methodb 时，因为当前没有一个活动的事务，则会抛出异常 throw new illegaltransactionstateexception(“transaction propagation ‘mandatory’ but no existing transaction found”);当调用 methoda 时，methodb 则加入到 methoda 的事务中，事务地执行。\n\n 4. propagation_requires_new 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。\n\n//事务属性 propagation_required\nmethoda(){\n    dosomethinga();\n    methodb();\n    dosomethingb();\n}\n\n//事务属性 propagation_requires_new\nmethodb(){\n    ……\n}\n\n\n调用 a 方法：\n\nmain(){\n    methoda();\n}\n\n\n相当于\n\nmain(){\n    transactionmanager tm = null;\n    try{\n        //获得一个jta事务管理器\n        tm = gettransactionmanager();\n        tm.begin();//开启一个新的事务\n        transaction ts1 = tm.gettransaction();\n        dosomething();\n        tm.suspend();//挂起当前事务\n        try{\n            tm.begin();//重新开启第二个事务\n            transaction ts2 = tm.gettransaction();\n            methodb();\n            ts2.commit();//提交第二个事务\n        } catch(runtimeexception ex) {\n            ts2.rollback();//回滚第二个事务\n        } finally {\n            //释放资源\n        }\n        //methodb执行完后，恢复第一个事务\n        tm.resume(ts1);\n        dosomethingb();\n        ts1.commit();//提交第一个事务\n    } catch(runtimeexception ex) {\n        ts1.rollback();//回滚第一个事务\n    } finally {\n        //释放资源\n    }\n}\n\n\n在这里，我把 ts1 称为外层事务，ts2 称为内层事务。从上面的代码可以看出，ts2 与 ts1 是两个独立的事务，互不相干。ts2 是否成功并不依赖于 ts1。如果 methoda 方法在调用 methodb 方法后的 dosomethingb 方法失败了，而 methodb 方法所做的结果依然被提交。而除了 methodb 之外的其它代码导致的结果却被回滚了。使用 propagation_requires_new,需要使用 jtatransactionmanager 作为事务管理器。\n\n 5. propagation_not_supported 总是非事务地执行，并挂起任何存在的事务。使用 propagation_not_supported,也需要使用 jtatransactionmanager 作为事务管理器。（代码示例同上，可同理推出）\n 6. propagation_never 总是非事务地执行，如果存在一个活动事务，则抛出异常。\n 7. propagation_nested 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按 transactiondefinition.propagation_required 属性执行。这是一个嵌套事务,使用 jdbc 3.0 驱动时,仅仅支持 datasourcetransactionmanager 作为事务管理器。需要 jdbc 驱动的 java.sql.savepoint 类。有一些 jta 的事务管理器实现可能也提供了同样的功能。使用 propagation_nested，还需要把 platformtransactionmanager 的 nestedtransactionallowed 属性设为 true;而 nestedtransactionallowed 属性值默认为 false。\n\n//事务属性 propagation_required\nmethoda(){\n    dosomethinga();\n    methodb();\n    dosomethingb();\n}\n\n//事务属性 propagation_nested\nmethodb(){\n    ……\n}\n\n\n如果单独调用 methodb 方法，则按 required 属性执行。如果调用 methoda 方法，相当于下面的效果：\n\nmain(){\n    connection con = null;\n    savepoint savepoint = null;\n    try{\n        con = getconnection();\n        con.setautocommit(false);\n        dosomethinga();\n        savepoint = con2.setsavepoint();\n        try{\n            methodb();\n        } catch(runtimeexception ex) {\n            con.rollback(savepoint);\n        } finally {\n            //释放资源\n        }\n        dosomethingb();\n        con.commit();\n    } catch(runtimeexception ex) {\n        con.rollback();\n    } finally {\n        //释放资源\n    }\n}\n\n\n当 methodb 方法调用之前，调用 setsavepoint 方法，保存当前的状态到 savepoint。如果 methodb 方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(dosomethingb()方法)调用失败，则回滚包括 methodb 方法的所有操作。\n\n嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。\n\npropagation_nested 与 propagation_requires_new 的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 propagation_requires_new 时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要 jta 事务管理器的支持。\n\n使用 propagation_nested 时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。datasourcetransactionmanager 使用 savepoint 支持 propagation_nested 时，需要 jdbc 3.0 以上驱动及 1.4 以上的 jdk 版本支持。其它的 jta trasactionmanager 实现可能有不同的支持方式。\n\npropagation_requires_new 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。\n\n另一方面, propagation_nested 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。\n\n由此可见, propagation_requires_new 和 propagation_nested 的最大区别在于, propagation_requires_new 完全是一个新的事务, 而 propagation_nested 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.\n\npropagation_required 应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。\n\n# 隔离级别\n\n事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。\n\n 1. 并发事务引起的问题\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。\n\n * 脏读（dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。\n * 不可重复读（nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。\n * 幻读（phantom read）——幻读与不可重复读类似。它发生在一个事务（t1）读取了几行数据，接着另一个并发事务（t2）插入了一些数据时。在随后的查询中，第一个事务（t1）就会发现多了一些原本不存在的记录。\n\n不可重复读与幻读的区别\n\n不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 例如：在事务 1 中，mary 读取了自己的工资为 1000,操作并没有完成\n\n    con1 = getconnection();\n    select salary from employee empid ="mary";\n\n\n在事务 2 中，这时财务人员修改了 mary 的工资为 2000,并提交了事务.\n\n    con2 = getconnection();\n    update employee set salary = 2000;\n    con2.commit();\n\n\n在事务 1 中，mary 再次读取自己的工资时，工资变为了 2000\n\n    //con1\n    select salary from employee empid ="mary";\n\n\n在一个事务中前后两次读取的结果并不一致，导致了不可重复读。\n\n幻读的重点在于新增或者删除： 同样的条件, 第 1 次和第 2 次读出来的记录数不一样 例如：目前工资为 1000 的员工有 10 人。事务 1,读取所有工资为 1000 的员工。\n\n    con1 = getconnection();\n    select * from employee where salary =1000;\n\n\n共读取 10 条记录\n\n这时另一个事务向 employee 表插入了一条员工记录，工资也为 1000\n\n    con2 = getconnection();\n    insert into employee(empid,salary) values("lili",1000);\n    con2.commit();\n\n\n事务 1 再次读取所有工资为 1000 的员工\n\n    //con1\n    select * from employee where salary =1000;\n\n\n共读取到了 11 条记录，这就产生了幻像读。\n\n从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。 对于前者, 只需要锁住满足条件的记录。 对于后者, 要锁住满足条件及其相近的记录。\n\n 2. 隔离级别\n\n隔离级别                         含义\nisolation_default            使用后端数据库默认的隔离级别\nisolation_read_uncommitted   最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\nisolation_read_committed     允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\nisolation_repeatable_read    对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生\nisolation_serializable       最高的隔离级别，完全服从 acid\n                             的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的\n\n# 只读\n\n事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。\n\n# 事务超时\n\n为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。\n\n# 回滚规则\n\n事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与 ejb 的回滚行为是一致的） 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。\n\n\n# transactionstatus\n\ntransactionstatus 接口为事务代码提供了一种简单的方式来控制事务执行和查询事务状态。这些概念应该很熟悉，因为它们对所有事务 api 都是通用的。以下清单显示了 transactionstatus 接口：\n\npublic interface transactionstatus extends transactionexecution, savepointmanager, flushable {\n\n    @override\n    boolean isnewtransaction();\n\n    boolean hassavepoint();\n\n    @override\n    void setrollbackonly();\n\n    @override\n    boolean isrollbackonly();\n\n    void flush();\n\n    @override\n    boolean iscompleted();\n}\n\n\n可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。\n\n\n# transactiontemplate\n\nspring 提供了对编程式事务和声明式事务的支持。编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于 aop）有助于用户将操作与事务规则进行解耦。transactiontemplate 就是用于支持编程式事务的核心 api。\n\n采用 transactiontemplate 和采用其他 spring 模板，如 jdbctempalte 和 hibernatetemplate 是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，transactiontemplate 是线程安全的。代码片段：\n\n    transactiontemplate tt = new transactiontemplate(); // 新建一个transactiontemplate\n    object result = tt.execute(\n        new transactioncallback(){\n            public object dotransaction(transactionstatus status){\n                updateoperation();\n                return resultofupdateoperation();\n            }\n    }); // 执行execute方法进行事务管理\n\n\n使用 transactioncallback()可以返回一个值。如果使用 transactioncallbackwithoutresult 则没有返回值。\n\n\n# 声明式事务管理\n\n> 大多数 spring 用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此最符合非侵入式轻量级容器的理想。\n\nspring 框架的声明式事务管理是通过 spring aop 实现的。然而，由于事务方面代码随 spring 发行版一起提供并且可以以样板方式使用，因此通常不必理解 aop 概念即可有效地使用此代码。\n\nspring 框架的声明式事务管理类似于 ejb cmt，因为您可以指定事务行为（或缺少它）到单个方法级别。如有必要，您可以在事务上下文中进行 setrollbackonly() 调用。两种类型的事务管理之间的区别是：\n\n * 与绑定到 jta 的 ejb cmt 不同，spring 框架的声明式事务管理适用于任何环境。通过调整配置文件，它可以使用 jdbc、jpa 或 hibernate 处理 jta 事务或本地事务。\n * 您可以将 spring 声明式事务管理应用于任何类，而不仅仅是诸如 ejb 之类的特殊类。\n * spring 提供声明性回滚规则，这是一个没有 ejb 等效功能的特性。提供了对回滚规则的编程和声明性支持。\n * spring 允许您使用 aop 自定义事务行为。例如，您可以在事务回滚的情况下插入自定义行为。您还可以添加任意 advice 以及事务性 advice。使用 ejb cmt，您无法影响容器的事务管理，除非使用 setrollbackonly()。\n * spring 不像高端应用服务器那样支持跨远程调用传播事务上下文。如果您需要此功能，我们建议您使用 ejb。但是，在使用这种特性之前要仔细考虑，因为通常情况下，不希望事务跨越远程调用。\n\n回滚规则的概念很重要。它们让您指定哪些异常（和 throwable）应该导致自动回滚。您可以在配置中以声明方式指定它，而不是在 java 代码中。因此，尽管您仍然可以在 transactionstatus 对象上调用 setrollbackonly() 来回滚当前事务，但通常您可以指定 myapplicationexception 必须始终导致回滚的规则。此选项的显着优势是业务对象不依赖于事务基础架构。例如，它们通常不需要导入 spring 事务 api 或其他 spring api。\n\n尽管 ejb 容器默认行为会在系统异常（通常是运行时异常）上自动回滚事务，但 ejb cmt 不会在应用程序异常（即除 java.rmi.remoteexception 之外的检查异常）上自动回滚事务。虽然声明式事务管理的 spring 默认行为遵循 ejb 约定（回滚仅在未经检查的异常上自动），但自定义此行为通常很有用。\n\n\n# spring 声明式事务管理的实现\n\n关于 spring 框架的声明式事务支持，最重要的概念是这种支持是通过 aop 代理启用的，并且事务 advice 是由元数据驱动的（目前是基于 xml 或基于注释的）。 aop 与事务元数据的结合产生了一个 aop 代理，它使用 transactioninterceptor 和适当的 transactionmanager 实现来驱动围绕方法调用的事务。\n\nspring 的 transactioninterceptor 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。返回响应式类型的方法，例如 publisher 或 kotlin flow（或它们的子类型）有资格进行响应式事务管理。包括 void 在内的所有其他返回类型都使用代码路径进行命令式事务管理。\n\n事务管理风格会影响需要哪个事务管理器。命令式事务需要 platformtransactionmanager，而响应式事务使用 reactivetransactionmanager 实现。\n\n> @transactional 通常与 platformtransactionmanager 管理的线程绑定事务一起使用，将事务公开给当前执行线程中的所有数据访问操作。注意：这不会传播到方法中新启动的线程。\n> \n> 由 reactivetransactionmanager 管理的反应式事务使用 reactor 上下文而不是线程本地属性。因此，所有参与的数据访问操作都需要在同一个反应式管道中的同一个 reactor 上下文中执行。\n\n下图显示了在事务代理上调用方法的概念视图：\n\n\n\n\n# 声明式事务示例\n\n考虑以下接口及其伴随的实现。此示例使用 foo 和 bar 类作为占位符，以便您可以专注于事务使用，而无需关注特定的域模型。就本示例而言，defaultfooservice 类在每个已实现方法的主体中抛出 unsupportedoperationexception 实例这一事实很好。该行为使您可以看到正在创建的事务，然后回滚以响应 unsupportedoperationexception 实例。\n\n以下清单显示了 fooservice 接口：\n\n// the service interface that we want to make transactional\n\npackage x.y.service;\n\npublic interface fooservice {\n\n    foo getfoo(string fooname);\n\n    foo getfoo(string fooname, string barname);\n\n    void insertfoo(foo foo);\n\n    void updatefoo(foo foo);\n\n}\n\n\n以下示例显示了上述接口的实现：\n\npackage x.y.service;\n\npublic class defaultfooservice implements fooservice {\n\n    @override\n    public foo getfoo(string fooname) {\n        // ...\n    }\n\n    @override\n    public foo getfoo(string fooname, string barname) {\n        // ...\n    }\n\n    @override\n    public void insertfoo(foo foo) {\n        // ...\n    }\n\n    @override\n    public void updatefoo(foo foo) {\n        // ...\n    }\n}\n\n\n假设 fooservice 接口的前两个方法 getfoo(string) 和 getfoo(string, string) 必须在具有只读语义的事务上下文中运行，并且其他方法 insertfoo(foo) 和 updatefoo(foo )，必须在具有读写语义的事务上下文中运行。以下配置将在接下来的几段中详细说明：\n\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemalocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooservice" class="x.y.service.defaultfooservice"/>\n\n    \x3c!-- the transactional advice (what \'happens\'; see the <aop:advisor/> bean below) --\x3e\n    <tx:advice id="txadvice" transaction-manager="txmanager">\n        \x3c!-- the transactional semantics... --\x3e\n        <tx:attributes>\n            \x3c!-- all methods starting with \'get\' are read-only --\x3e\n            <tx:method name="get*" read-only="true"/>\n            \x3c!-- other methods use the default transaction settings (see below) --\x3e\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- ensure that the above transactional advice runs for any execution\n        of an operation defined by the fooservice interface --\x3e\n    <aop:config>\n        <aop:pointcut id="fooserviceoperation" expression="execution(* x.y.service.fooservice.*(..))"/>\n        <aop:advisor advice-ref="txadvice" pointcut-ref="fooserviceoperation"/>\n    </aop:config>\n\n    \x3c!-- don\'t forget the datasource --\x3e\n    <bean id="datasource" class="org.apache.commons.dbcp.basicdatasource" destroy-method="close">\n        <property name="driverclassname" value="oracle.jdbc.driver.oracledriver"/>\n        <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>\n        <property name="username" value="scott"/>\n        <property name="password" value="tiger"/>\n    </bean>\n\n    \x3c!-- similarly, don\'t forget the transactionmanager --\x3e\n    <bean id="txmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n\n\n检查前面的配置。它假定您要使服务对象 fooservice bean 具有事务性。要应用的事务语义封装在 <tx:advice/> 定义中。<tx:advice/> 定义读作“所有以 get 开头的方法都将在只读事务的上下文中运行，所有其他方法都将以默认事务语义运行”。<tx:advice/> 标签的 transaction-manager 属性设置为将驱动事务的 transactionmanager bean 的名称（在本例中为 txmanager bean）。\n\n> 如果要连接的 transactionmanager 的 bean 名称具有名称 transactionmanager，则可以省略事务 advice (tx:advice/) 中的 transaction-manager 属性。如果要连接的 transactionmanager bean 有任何其他名称，则必须显式使用 transaction-manager 属性，如前面的示例所示。\n\n<aop:config/> 定义确保由 txadvice bean 定义的事务性建议在程序中的适当位置运行。首先，您定义一个切入点，该切入点与 fooservice 接口 (fooserviceoperation) 中定义的任何操作的执行相匹配。然后，您使用一个 adviser 将切入点与 txadvice 相关联。结果表明，在执行 fooserviceoperation 时，会运行 txadvice 定义的建议。\n\n一个常见的要求是使整个服务层具有事务性。最好的方法是更改切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：\n\n<aop:config>\n    <aop:pointcut id="fooservicemethods" expression="execution(* x.y.service.*.*(..))"/>\n    <aop:advisor advice-ref="txadvice" pointcut-ref="fooservicemethods"/>\n</aop:config>\n\n\n前面显示的配置用于围绕从 fooservice bean 定义创建的对象创建事务代理。代理配置了事务 advice，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，启动、暂停、标记为只读等事务。考虑以下测试驱动前面显示的配置的程序：\n\npublic final class boot {\n\n    public static void main(final string[] args) throws exception {\n        applicationcontext ctx = new classpathxmlapplicationcontext("context.xml");\n        fooservice fooservice = ctx.getbean(fooservice.class);\n        fooservice.insertfoo(new foo());\n    }\n}\n\n\n\n# 回滚一个声明性事务\n\nspring 框架中，触发事务回滚的推荐方式是在事务上下文的代码中抛出异常。spring 事务框架会捕获任何未处理的异常，并确定是否将事务标记为回滚。\n\n在其默认配置中，spring 事务框架只会将存在运行时且未经检查异常的事务标记为回滚。也就是说，当抛出的异常是 runtimeexception 的实例或子类时。 （默认情况下，错误实例也会导致回滚）。从事务方法抛出的检查异常不会导致默认配置中的回滚。\n\n您可以通过指定回滚规则，明确指定哪些异常类型将导致事务回滚。\n\n> 回滚规则约定在抛出指定异常时是否应回滚事务，并且规则基于模式。模式可以是完全限定的类名或异常类型的完全限定类名的子字符串（必须是 throwable 的子类），目前不支持通配符。例如，javax.servlet.servletexception 或 servletexception 的值将匹配 javax.servlet.servletexception 及其子类。\n> \n> 回滚规则可以通过 rollback-for 和 no-rollback-for 属性在 xml 中配置，这允许将模式指定为字符串。使用 @transactional 时，可以通过 rollbackfor / norollbackfor 和rollbackforclassname / norollbackforclassname 属性配置回滚规则，它们允许将模式分别指定为类引用或字符串。当异常类型被指定为类引用时，其完全限定名称将用作模式。因此，@transactional(rollbackfor = example.customexception.class) 等价于 @transactional(rollbackforclassname = \'example.customexception\')。\n\n以下 xml 片段演示了如何通过 rollback-for 属性提供异常模式来为已检查的、特定的 exception 类型配置回滚：\n\n<tx:advice id="txadvice" transaction-manager="txmanager">\n    <tx:attributes>\n    <tx:method name="get*" read-only="true" rollback-for="noproductinstockexception"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n\n\n如果您不希望在抛出异常时回滚事务，您还可以指定“不回滚”规则。下面的例子告诉 spring 事务框架，即使在面对未处理的 instrumentnotfoundexception 时也要提交伴随事务。\n\n<tx:advice id="txadvice">\n    <tx:attributes>\n    <tx:method name="updatestock" no-rollback-for="instrumentnotfoundexception"/>\n    <tx:method name="*"/>\n    </tx:attributes>\n</tx:advice>\n\n\n当 spring framework 事务框架捕获到异常，并检查配置的回滚规则以确定是否将事务标记为回滚时，由最重要的匹配规则决定。因此，在以下配置的情况下，除 instrumentnotfoundexception 之外的任何异常都会导致伴随事务的回滚。\n\n<tx:advice id="txadvice">\n    <tx:attributes>\n    <tx:method name="*" rollback-for="throwable" no-rollback-for="instrumentnotfoundexception"/>\n    </tx:attributes>\n</tx:advice>\n\n\n您还可以以编程方式指示所需的回滚。虽然很简单，但这个过程非常具有侵入性，并且将您的代码与 spring framework 的事务基础设施紧密耦合。以下示例显示如何以编程方式指示所需的回滚。\n\npublic void resolveposition() {\n    try {\n        // some business logic...\n    } catch (noproductinstockexception ex) {\n        // trigger rollback programmatically\n        transactionaspectsupport.currenttransactionstatus().setrollbackonly();\n    }\n}\n\n\n如果可能的话，强烈建议您使用声明性方法进行回滚。如果您绝对需要，可以使用程序化回滚，但它的使用与实现干净的基于 pojo 的架构背道而驰。\n\n\n# 为不同的 bean 配置不同的事务语义\n\n考虑您有许多服务层对象的场景，并且您希望对每个对象应用完全不同的事务配置。您可以通过定义具有不同 <aop:advisor/> 元素和不同 advice-ref 属性值的切点来实现这一点。\n\n作为一个比较点，首先假设您的所有服务层类都定义在根 x.y.service 包中。 要使作为该包（或子包）中定义的类的实例并且名称以 service 结尾的所有 bean 都具有默认的事务配置，您可以编写以下内容：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemalocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="serviceoperation"\n                expression="execution(* x.y.service..*service.*(..))"/>\n\n        <aop:advisor pointcut-ref="serviceoperation" advice-ref="txadvice"/>\n\n    </aop:config>\n\n    \x3c!-- these two beans will be transactional... --\x3e\n    <bean id="fooservice" class="x.y.service.defaultfooservice"/>\n    <bean id="barservice" class="x.y.service.extras.simplebarservice"/>\n\n    \x3c!-- ... and these two beans won\'t --\x3e\n    <bean id="anotherservice" class="org.xyz.someservice"/> \x3c!-- (not in the right package) --\x3e\n    <bean id="barmanager" class="x.y.service.simplebarmanager"/> \x3c!-- (doesn\'t end in \'service\') --\x3e\n\n    <tx:advice id="txadvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a transactionmanager omitted... --\x3e\n\n</beans>\n\n\n以下示例显示了如何使用完全不同的事务设置配置两个不同的 bean\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemalocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <aop:config>\n\n        <aop:pointcut id="defaultserviceoperation"\n                expression="execution(* x.y.service.*service.*(..))"/>\n\n        <aop:pointcut id="notxserviceoperation"\n                expression="execution(* x.y.service.ddl.defaultddlmanager.*(..))"/>\n\n        <aop:advisor pointcut-ref="defaultserviceoperation" advice-ref="defaulttxadvice"/>\n\n        <aop:advisor pointcut-ref="notxserviceoperation" advice-ref="notxadvice"/>\n\n    </aop:config>\n\n    \x3c!-- this bean will be transactional (see the \'defaultserviceoperation\' pointcut) --\x3e\n    <bean id="fooservice" class="x.y.service.defaultfooservice"/>\n\n    \x3c!-- this bean will also be transactional, but with totally different transactional settings --\x3e\n    <bean id="anotherfooservice" class="x.y.service.ddl.defaultddlmanager"/>\n\n    <tx:advice id="defaulttxadvice">\n        <tx:attributes>\n            <tx:method name="get*" read-only="true"/>\n            <tx:method name="*"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <tx:advice id="notxadvice">\n        <tx:attributes>\n            <tx:method name="*" propagation="never"/>\n        </tx:attributes>\n    </tx:advice>\n\n    \x3c!-- other transaction infrastructure beans such as a transactionmanager omitted... --\x3e\n\n</beans>\n\n\n\n# <tx:advice/> 配置\n\n<tx:advice/> 的默认配置为：\n\n * 传播设置是 required\n\n * 隔离级别为 default\n\n * 事务是 read-write\n\n * 事务超时默认为底层事务系统的默认超时，如果不支持超时，则为无。\n\n * 任何 runtimeexception 都会触发回滚，而任何已检查的 exception 都不会\n\n<tx:advice/> 配置属性\n\n属性                是否必要   默认值        描述\nname              yes               与事务属性关联的方法名称。支持通配符，如：get*、handle*、on*event\npropagation       no     required   事务传播行为\nisolation         no     default    事务隔离级别。仅适用于 required 或 requires_new 的传播设置。\ntimeout           no     -1         事务超时时间（单位：秒）。仅适用于 required 或 requires_new 的传播设置。\nread-only         no     false      read-write 或 read-only 事务。\nrollback-for      no                触发回滚的 exception 实例列表（通过逗号分隔）。\nno-rollback-for   no                不触发回滚的 exception 实例列表（通过逗号分隔）。\n\n\n# 使用 @transactional 注解\n\n除了基于 xml 的声明式事务配置方法之外，您还可以使用基于注解的方法。\n\n下面是一个使用 @transactional 注解的示例：\n\n@transactional\npublic class defaultfooservice implements fooservice {\n\n    @override\n    public foo getfoo(string fooname) {\n        // ...\n    }\n\n    @override\n    public foo getfoo(string fooname, string barname) {\n        // ...\n    }\n\n    @override\n    public void insertfoo(foo foo) {\n        // ...\n    }\n\n    @override\n    public void updatefoo(foo foo) {\n        // ...\n    }\n}\n\n\n如上所述在类级别使用，@transactional 注解表明声明类（及其子类）的所有方法都使用默认事务配置。 或者，可以单独为每个方法指定注解。请注意，类级别的注解不适用于类层次结构中的祖先类； 在这种情况下，继承的方法需要在本地重新声明才能参与子类级别的注解。\n\n当上面的 pojo 类在 spring 上下文中定义为 bean 时，您可以通过 @configuration 类中的 @enabletransactionmanagement 注解使 bean 实例具有事务性。\n\n在 xml 配置中， <tx:annotation-driven/> 标签提供了类似的便利：\n\n\x3c!-- from the file \'context.xml\' --\x3e\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xmlns:tx="http://www.springframework.org/schema/tx"\n    xsi:schemalocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/tx\n        https://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    \x3c!-- this is the service object that we want to make transactional --\x3e\n    <bean id="fooservice" class="x.y.service.defaultfooservice"/>\n\n    \x3c!-- enable the configuration of transactional behavior based on annotations --\x3e\n    \x3c!-- a transactionmanager is still required --\x3e\n    <tx:annotation-driven transaction-manager="txmanager"/>\n\n    <bean id="txmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        \x3c!-- (this dependency is defined somewhere else) --\x3e\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\n    \x3c!-- other <bean/> definitions here --\x3e\n\n</beans>\n\n\n# @transactional 配置\n\nproperty                 type                                                         description\nvalue                    string                                                       optional qualifier that specifies the transaction manager to\n                                                                                      be used.\ntransactionmanager       string                                                       alias for value.\nlabel                    array of string labels to add an expressive description to   labels may be evaluated by transaction managers to associate\n                         the transaction.                                             implementation-specific behavior with the actual\n                                                                                      transaction.\npropagation              enum: propagation                                            optional propagation setting.\nisolation                enum: isolation                                              optional isolation level. applies only to propagation values\n                                                                                      of required or requires_new.\ntimeout                  int (in seconds of granularity)                              optional transaction timeout. applies only to propagation\n                                                                                      values of required or requires_new.\ntimeoutstring            string (in seconds of granularity)                           alternative for specifying the timeout in seconds as a\n                                                                                      string value — for example, as a placeholder.\nreadonly                 boolean                                                      read-write versus read-only transaction. only applicable to\n                                                                                      values of required or requires_new.\nrollbackfor              array of class objects, which must be derived from           optional array of exception types that must cause rollback.\n                         throwable.\nrollbackforclassname     array of exception name patterns.                            optional array of exception name patterns that must cause\n                                                                                      rollback.\nnorollbackfor            array of class objects, which must be derived from           optional array of exception types that must not cause\n                         throwable.                                                   rollback.\nnorollbackforclassname   array of exception name patterns.                            optional array of exception name patterns that must not\n                                                                                      cause rollback.\n\n# 多事务管理器场景下使用 @transactional\n\n某些情况下，应用程序中可能需要接入多个数据源，相应的，也需要多个独立的事务管理器。使用者可以使用 @transactional 注释的 value 或 transactionmanager 属性来选择性地指定要使用的 transactionmanager 的标识。这可以是 bean 名称或事务管理器 bean 的限定符值。\n\npublic class transactionalservice {\n\n    @transactional("order")\n    public void setsomething(string name) { ... }\n\n    @transactional("account")\n    public void dosomething() { ... }\n\n    @transactional("reactive-account")\n    public mono<void> dosomethingreactive() { ... }\n}\n\n\n下面展示如何定义 transactionmanager：\n\n<tx:annotation-driven/>\n\n    <bean id="transactionmanager1" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        ...\n        <qualifier value="order"/>\n    </bean>\n\n    <bean id="transactionmanager2" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        ...\n        <qualifier value="account"/>\n    </bean>\n\n    <bean id="transactionmanager3" class="org.springframework.data.r2dbc.connectionfactory.r2dbctransactionmanager">\n        ...\n        <qualifier value="reactive-account"/>\n    </bean>\n\n\n在这种情况下，transactionalservice 上的各个方法在单独的事务管理器下运行，由 order、account 和 reactive-account 限定符区分。 如果没有找到明确指定的 transactionmanager bean，则仍使用默认的 <tx:annotation-driven> 目标 bean 名称。\n\n# 自定义组合注解\n\n如果您发现在许多不同的方法上重复使用 @transactional 相同的属性，可以使用 spring 的元注解自定义组合注解。\n\n@target({elementtype.method, elementtype.type})\n@retention(retentionpolicy.runtime)\n@transactional(transactionmanager = "order", label = "causal-consistency")\npublic @interface ordertx {\n}\n\n@target({elementtype.method, elementtype.type})\n@retention(retentionpolicy.runtime)\n@transactional(transactionmanager = "account", label = "retryable")\npublic @interface accounttx {\n}\n\n\n使用示例：\n\npublic class transactionalservice {\n\n    @ordertx\n    public void setsomething(string name) {\n        // ...\n    }\n\n    @accounttx\n    public void dosomething() {\n        // ...\n    }\n}\n\n\n在上面的示例中，我们使用语法来定义事务管理器限定符和事务标签，但我们也可以包括传播行为、回滚规则、超时和其他特性。\n\n# 事务传播\n\n在 spring 管理的事务中，请注意物理事务和逻辑事务之间的差异，以及传播设置如何应用于这种差异。\n\n\n\npropagation_required 强制执行物理事务，如果尚不存在事务，则在当前范围的本地执行或参与更大范围定义的现有“外部”事务。 这是同一线程内的常见调用堆栈安排中的一个很好的默认设置（例如，委托给多个存储库方法的服务外观，其中所有底层资源都必须参与服务级事务）。\n\n当传播设置为 propagation_required 时，将为应用该设置的每个方法创建一个逻辑事务范围。每个这样的逻辑事务范围可以单独确定仅回滚状态，外部事务范围在逻辑上独立于内部事务范围。在标准 propagation_required 行为的情况下，所有这些范围都映射到同一个物理事务。因此，在内部事务范围内设置的仅回滚标记确实会影响外部事务实际提交的机会。\n\n但是，在内部事务范围设置了仅回滚标记的情况下，外部事务尚未决定回滚本身，因此回滚（由内部事务范围静默触发）是意外的。此时会引发相应的 unexpectedrollbackexception。这是预期的行为，因此事务的调用者永远不会被误导以为执行了提交，而实际上并没有执行。因此，如果内部事务（外部调用者不知道）默默地将事务标记为仅回滚，外部调用者仍会调用提交。外部调用者需要接收 unexpectedrollbackexception 以清楚地指示执行了回滚。\n\n\n\npropagation_requires_new 与 propagation_required 相比，始终为每个受影响的事务范围使用独立的物理事务，从不参与外部范围的现有事务。 在这种安排下，底层资源事务是不同的，因此可以独立提交或回滚，外部事务不受内部事务回滚状态的影响，内部事务的锁在完成后立即释放。 这样一个独立的内部事务也可以声明自己的隔离级别、超时和只读设置，而不是继承外部事务的特性。\n\n\n# jdbc 异常抽象\n\nspring 会将数据操作的异常转换为 dataaccessexception。\n\nspring 是怎么认识那些错误码的\n\n通过 sqlerrorcodesqlexceptiontranslator 解析错误码\n\nerrorcode 定义（sql-error-codes.xml 文件）\n\n\n# spring 事务最佳实践\n\n\n\n\n# spring 事务未生效\n\n使用 @transactional 注解开启声明式事务时， 最容易忽略的问题是，很可能事务并没有生效。\n\n@transactional 生效原则：\n\n# @transactional 方法必须是 public\n\n原则一：除非特殊配置（比如使用 aspectj 静态织入实现 aop），否则只有定义在 public 方法上的 @transactional 才能生效。原因是，spring 默认通过动态代理的方式实现 aop，对目标方法进行增强，private 方法无法代理到，spring 自然也无法动态增强事务处理逻辑。\n\n【示例】错误使用 @transactional 案例一\n\n\t@transactional\n\tvoid createuserprivate(userentity entity) {\n\t\tuserrepository.save(entity);\n\t\tif (entity.getname().contains("test")) { throw new runtimeexception("invalid username!"); }\n\t}\n\n\t//私有方法\n\tpublic int createuserwrong1(string name) {\n\t\ttry {\n\t\t\tthis.createuserprivate(new userentity(name));\n\t\t} catch (exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getmessage());\n\t\t}\n\t\treturn userrepository.findbyname(name).size();\n\t}\n\n\n当传入名为 test 的用户实体，会抛出异常，但 @transactional 未生效，不会触发回滚。\n\n# 必须通过 spring 注入的 bean 进行调用\n\n原则二：必须通过代理过的类从外部调用目标方法才能生效。\n\n【示例】错误使用 @transactional 案例二\n\n\t//自调用\n\tpublic int createuserwrong2(string name) {\n\t\ttry {\n\t\t\tthis.createuserpublic(new userentity(name));\n\t\t} catch (exception ex) {\n\t\t\tlog.error("create user failed because {}", ex.getmessage());\n\t\t}\n\t\treturn userrepository.findbyname(name).size();\n\t}\n\n\t//可以传播出异常\n\t@transactional\n\tpublic void createuserpublic(userentity entity) {\n\t\tuserrepository.save(entity);\n\t\tif (entity.getname().contains("test")) { throw new runtimeexception("invalid username!"); }\n\t}\n\n\n当传入名为 test 的用户实体，会抛出异常，但 @transactional 未生效，不会触发回滚。\n\n说明：spring 通过 aop 技术对方法进行字节码增强，要调用增强过的方法必然是调用代理后的对象。\n\n\n# 事务虽然生效但未回滚\n\n通过 aop 实现事务处理可以理解为，使用 try…catch… 来包裹标记了 @transactional 注解的方法，当方法出现了异常并且满足一定条件的时候，在 catch 里面我们可以设置事务回滚，没有异常则直接提交事务。\n\n“一定条件”，主要包括两点：\n\n第一，只有异常传播出了标记了 @transactional 注解的方法，事务才能回滚。在 spring 的 transactionaspectsupport 里有个 invokewithintransaction 方法，里面就是处理事务的逻辑。\n\n第二，默认情况下，出现 runtimeexception（非受检异常）或 error 的时候，spring 才会回滚事务。\n\n@service\n@slf4j\npublic class userservice {\n\n\t@autowired\n\tprivate userrepository userrepository;\n\n\t//异常无法传播出方法，导致事务无法回滚\n\t@transactional\n\tpublic void createuserwrong1(string name) {\n\t\ttry {\n\t\t\tuserrepository.save(new userentity(name));\n\t\t\tthrow new runtimeexception("error");\n\t\t} catch (exception ex) {\n\t\t\tlog.error("create user failed", ex);\n\t\t}\n\t}\n\n\t//即使出了受检异常也无法让事务回滚\n\t@transactional\n\tpublic void createuserwrong2(string name) throws ioexception {\n\t\tuserrepository.save(new userentity(name));\n\t\tothertask();\n\t}\n\n\t//因为文件不存在，一定会抛出一个ioexception\n\tprivate void othertask() throws ioexception {\n\t\tfiles.readalllines(paths.get("file-that-not-exist"));\n\t}\n\n}\n\n\n在 createuserwrong1 方法中会抛出一个 runtimeexception，但由于方法内 catch 了所有异常，异常无法从方法传播出去，事务自然无法回滚。\n\n在 createuserwrong2 方法中，注册用户的同时会有一次 othertask 文件读取操作，如果文件读取失败，我们希望用户注册的数据库操作回滚。虽然这里没有捕获异常，但因为 othertask 方法抛出的是受检异常，createuserwrong2 传播出去的也是受检异常，事务同样不会回滚。\n\n【解决方案一】如果你希望自己捕获异常进行处理的话，也没关系，可以手动设置 transactionaspectsupport.currenttransactionstatus().setrollbackonly(); 让当前事务处于回滚状态：\n\n@transactional\npublic void createuserright1(string name) {\n   try {\n      userrepository.save(new userentity(name));\n      throw new runtimeexception("error");\n   } catch (exception ex) {\n      log.error("create user failed", ex);\n      transactionaspectsupport.currenttransactionstatus().setrollbackonly();\n   }\n}\n\n\n【解决方案二】在注解中声明 @transactional(rollbackfor = exception.class)，期望遇到所有的 exception 都回滚事务（来突破默认不回滚受检异常的限制）：\n\n@transactional(rollbackfor = exception.class)\npublic void createuserright2(string name) throws ioexception {\n   userrepository.save(new userentity(name));\n   othertask();\n}\n\n\n\n# 细化事务传播方式\n\n如果方法涉及多次数据库操作，并希望将它们作为独立的事务进行提交或回滚，那么 我们需要考虑进一步细化配置事务传播方式，也就是 @transactional 注解的 propagation 属性。\n\n/**\n * {@link propagation#requires_new} 表示执行到这个方法时需要开启新的事务，并挂起当前事务\n */\n@transactional(propagation = propagation.requires_new)\npublic void createsubuserwithexceptionright(userentity entity) {\n   log.info("createsubuserwithexceptionright start");\n   userrepository.save(entity);\n   throw new runtimeexception("invalid status");\n}\n\n\n\n# 参考资料\n\n * spring 官网\n * spring 官方文档\n * spring boot 官方文档\n * 《java 业务开发常见错误 100 例》',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 之 JPA",frontmatter:{title:"Spring 之 JPA",date:"2019-02-18T14:33:55.000Z",order:4,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","JPA"],permalink:"/pages/a03d7b/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/04.Spring%E4%B9%8BJPA.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/04.Spring之JPA.md",key:"v-44814011",path:"/pages/a03d7b/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:97},{level:2,title:"常用 JPA 注解",slug:"常用-jpa-注解",normalizedTitle:"常用 jpa 注解",charIndex:6402},{level:3,title:"实体",slug:"实体",normalizedTitle:"实体",charIndex:1098},{level:4,title:"@Entity",slug:"entity",normalizedTitle:"@entity",charIndex:306},{level:4,title:"@MappedSuperclass",slug:"mappedsuperclass",normalizedTitle:"@mappedsuperclass",charIndex:6433},{level:4,title:"@Table",slug:"table",normalizedTitle:"@table",charIndex:6525},{level:3,title:"主键",slug:"主键",normalizedTitle:"主键",charIndex:6593},{level:4,title:"@Id",slug:"id",normalizedTitle:"@id",charIndex:1357},{level:4,title:"@GeneratedValue",slug:"generatedvalue",normalizedTitle:"@generatedvalue",charIndex:1365},{level:3,title:"映射",slug:"映射",normalizedTitle:"映射",charIndex:25},{level:4,title:"@Column",slug:"column",normalizedTitle:"@column",charIndex:1439},{level:3,title:"关系",slug:"关系",normalizedTitle:"关系",charIndex:23},{level:4,title:"@OneToOne",slug:"onetoone",normalizedTitle:"@onetoone",charIndex:8020},{level:4,title:"@OneToMany",slug:"onetomany",normalizedTitle:"@onetomany",charIndex:8039},{level:2,title:"查询",slug:"查询",normalizedTitle:"查询",charIndex:8291},{level:3,title:"方法名字方式查询方式",slug:"方法名字方式查询方式",normalizedTitle:"方法名字方式查询方式",charIndex:8669},{level:3,title:"@Query 注解方式查询",slug:"query-注解方式查询",normalizedTitle:"@query 注解方式查询",charIndex:8319},{level:3,title:"动态 SQL 方式查询",slug:"动态-sql-方式查询",normalizedTitle:"动态 sql 方式查询",charIndex:8337},{level:3,title:"Example 方式查询",slug:"example-方式查询",normalizedTitle:"example 方式查询",charIndex:8353},{level:3,title:"排序 Sort",slug:"排序-sort",normalizedTitle:"排序 sort",charIndex:14731},{level:3,title:"分页 Page 和 Pageable",slug:"分页-page-和-pageable",normalizedTitle:"分页 page 和 pageable",charIndex:15353},{level:2,title:"核心 API",slug:"核心-api",normalizedTitle:"核心 api",charIndex:15938},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:15951}],headersStr:"快速入门 常用 JPA 注解 实体 @Entity @MappedSuperclass @Table 主键 @Id @GeneratedValue 映射 @Column 关系 @OneToOne @OneToMany 查询 方法名字方式查询方式 @Query 注解方式查询 动态 SQL 方式查询 Example 方式查询 排序 Sort 分页 Page 和 Pageable 核心 API 参考资料",content:'# Spring 之 JPA\n\nJPA 为对象关系映射提供了一种基于 POJO 的持久化模型。\n\n * 简化数据持久化代码的开发\n * 为 Java 社区屏蔽不同持久化 API 的差异\n\n\n# 快速入门\n\n（1）在 pom.xml 中引入依赖\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n\n（2）设置启动注解\n\n// 【可选】指定扫描的 Entity 目录，如果不指定，会扫描全部目录\n@EntityScan("io.github.dunwu.springboot.data.jpa")\n// 【可选】指定扫描的 Repository 目录，如果不指定，会扫描全部目录\n@EnableJpaRepositories(basePackages = {"io.github.dunwu.springboot.data.jpa"})\n// 【可选】开启 JPA auditing 能力，可以自动赋值一些字段，比如创建时间、最后一次修改时间等等\n@EnableJpaAuditing\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n\n（3）配置\n\n# 数据库连接\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver\nspring.datasource.username = root\nspring.datasource.password = root\n# 是否打印 JPA SQL 日志\nspring.jpa.show-sql = true\n# Hibernate的DDL策略\nspring.jpa.hibernate.ddl-auto = create-drop\n\n\n（4）定义实体\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.util.Objects;\nimport javax.persistence.*;\n\n@Entity\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    @Column(unique = true)\n    private String name;\n\n    private Integer age;\n\n    private String address;\n\n    private String email;\n\n    public User(String name, Integer age, String address, String email) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n        this.email = email;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (!(o instanceof User)) {\n            return false;\n        }\n\n        User user = (User) o;\n\n        if (id != null && id.equals(user.id)) {\n            return true;\n        }\n\n        return name.equals(user.name);\n    }\n\n}\n\n\n（5）定义 Repository\n\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.bind.annotation.PathVariable;\n\nimport java.util.List;\n\n@RepositoryRestResource(collectionResourceRel = "user", path = "user")\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    User findUserById(@PathVariable("id") Long id);\n\n    /**\n     * 根据用户名查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findByName?name=lisi\n     *\n     * @param name 用户名\n     * @return {@link User}\n     */\n    User findUserByName(@Param("name") String name);\n\n    /**\n     * 根据邮箱查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findByEmail?email=xxx@163.com\n     *\n     * @param email 邮箱\n     * @return {@link User}\n     */\n    @Query("from User u where u.email=:email")\n    List<User> findByEmail(@Param("email") String email);\n\n    /**\n     * 根据用户名删除用户\n     *\n     * @param name 用户名\n     */\n    @Transactional(rollbackFor = Exception.class)\n    void deleteByName(@Param("name") String name);\n\n}\n\n\n（6）测试\n\n@Slf4j\n@SpringBootTest(classes = { DataJpaApplication.class })\npublic class DataJpaTests {\n\n    @Autowired\n    private UserRepository repository;\n\n    @BeforeEach\n    public void before() {\n        repository.deleteAll();\n    }\n\n    @Test\n    public void insert() {\n        User user = new User("张三", 18, "北京", "user1@163.com");\n        repository.save(user);\n        Optional<User> optional = repository.findById(user.getId());\n        assertThat(optional).isNotNull();\n        assertThat(optional.isPresent()).isTrue();\n    }\n\n    @Test\n    public void batchInsert() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        long count = repository.count();\n        assertThat(count).isEqualTo(4);\n\n        List<User> list = repository.findAll();\n        assertThat(list).isNotEmpty().hasSize(4);\n        list.forEach(this::accept);\n    }\n\n    private void accept(User user) { log.info(user.toString()); }\n\n    @Test\n    public void delete() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        repository.deleteByName("张三");\n        assertThat(repository.findUserByName("张三")).isNull();\n\n        repository.deleteAll();\n        List<User> list = repository.findAll();\n        assertThat(list).isEmpty();\n    }\n\n    @Test\n    public void findAllInPage() {\n        List<User> users = new ArrayList<>();\n        users.add(new User("张三", 18, "北京", "user1@163.com"));\n        users.add(new User("李四", 19, "上海", "user1@163.com"));\n        users.add(new User("王五", 18, "南京", "user1@163.com"));\n        users.add(new User("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveAll(users);\n\n        PageRequest pageRequest = PageRequest.of(1, 2);\n        Page<User> page = repository.findAll(pageRequest);\n        assertThat(page).isNotNull();\n        assertThat(page.isEmpty()).isFalse();\n        assertThat(page.getTotalElements()).isEqualTo(4);\n        assertThat(page.getTotalPages()).isEqualTo(2);\n\n        List<User> list = page.get().collect(Collectors.toList());\n        System.out.println("user list: ");\n        list.forEach(System.out::println);\n    }\n\n    @Test\n    public void update() {\n        User oldUser = new User("张三", 18, "北京", "user1@163.com");\n        oldUser.setName("张三丰");\n        repository.save(oldUser);\n\n        User newUser = repository.findUserByName("张三丰");\n        assertThat(newUser).isNotNull();\n    }\n\n}\n\n\n\n# 常用 JPA 注解\n\n\n# 实体\n\n# @Entity\n\n# @MappedSuperclass\n\n当多个实体有共同的属性字段，比如说 id，则可以把它提炼出一个父类，并且加上 @MappedSuperclass，则实体基类就可以继承了。\n\n# @Table\n\n当实体名和表名不一致时，可以通过 @Table(name="CUSTOMERS") 的形式来明确指定一个表名。\n\n\n# 主键\n\n# @Id\n\n@Id 注解用于声明一个实体类的属性映射为数据库的主键。\n\n# @GeneratedValue\n\n@GeneratedValue 用于标注主键的生成策略，通过 strategy 属性指定。\n\n默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer 对应 identity，MySQL 对应 auto increment。\n\n在 javax.persistence.GenerationType 中定义了以下几种可供选择的策略：\n\npublic enum GenerationType {\n    TABLE,\n    SEQUENCE,\n    IDENTITY,\n    AUTO\n}\n\n\n * IDENTITY：采用数据库 ID 自增长的方式来自增主键字段，Oracle 不支持这种方式；\n * AUTO： JPA 自动选择合适的策略，是默认选项；\n * SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式\n * TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。\n\n也就是如果你没有指定 strategy 属性，默认策略是 AUTO，JPA 会根据你使用的数据库来自动选择策略，比如说我使用的是 mysql 则，自动的主键策略就是 IDENTITY （auto increment）。\n\n\n# 映射\n\n# @Column\n\n当你的 entity 属性名和数据库中的字段名不一致，可以使用 @Column 明确指定，它也可以设置一些属性\n\n@Column(length = 10, nullable = false, unique = true)\n\n\n@Column(columnDefinition = "INT(3)")\nprivate int age;\n\n\n@Column 支持的参数：\n\n * unique 属性表示该字段是否为唯一标识，默认为 false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用 @Table 标记中的 @UniqueConstraint。\n * nullable 属性表示该字段是否可以为 null 值，默认为 true。\n * insertable 属性表示在使用 INSERT 插入数据时，是否需要插入该字段的值。\n * updatable 属性表示在使用 UPDATE 更新数据时，是否需要更新该字段的值。insertable 和 updatable 属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。\n * columnDefinition 属性表示创建表时，该字段创建的 SQL 语句，一般用于通过 Entity 生成表定义时使用。\n * table 属性表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。\n * length 属性表示字段的长度，当字段的类型为 varchar 时，该属性才有效，默认为 255 个字符。\n * precision 属性和 scale 属性表示精度，当字段类型为 double 时，precision 表示数值的总长度，scale 表示小数点所占的位数。\n\n@JoinTable\n\n@JoinColumn\n\n\n# 关系\n\n表关系映射（双向映射）\n\n * @OneToOne：一对一关系\n * @OneToMany：一对多\n * @ManyToMany（不推荐使用，而是采用用中间对象，把多对多拆成两个对多一关系）\n\n字段映射（单向映射）：\n\n * @Embedded、@Embeddable 嵌入式关系（单向映射）\n * @ElementCollection 集合一对多关系（单向映射）\n\n# @OneToOne\n\n@OneToOne 表示一对一关系\n\n# @OneToMany\n\n@OneToMany 表示一对多关系\n\n@ManyToOne\n\n@ManyToMany\n\nOrderBy\n\n\n# 查询\n\n查询方式有：\n\n * 方法名字方式查询\n\n * @Query 注解方式查询\n\n * 动态 SQL 方式查询\n\n * Example 方式查询\n\nJpaRepository 提供了如下表所述的内置查询\n\n * List<T> findAll(); - 返回所有实体\n * List<T> findAllById(Iterable<ID> var1); - 返回指定 id 的所有实体\n * T getOne(ID var1); - 根据 id 返回对应的实体，如果未找到，则返回空。\n * List<T> findAll(Sort var1); - 返回所有实体，按照指定顺序返回。\n * Page<T> findAll(Pageable var1); - 返回实体列表，实体的 offset 和 limit 通过 pageable 来指定\n\n\n# 方法名字方式查询方式\n\nSpring Data 通过查询的方法名和参数名来自动构造一个 JPA QQL 查询。\n\npublic interface UserRepository extends JpaRepository<User, Integer> {\n    public User findByName(String name);\n}\n\n\n方法名和参数名要遵守一定的规则，Spring Data JPA 才能自动转换为 JPQL：\n\n * 方法名通常包含多个实体属性用于查询，属性之间可以使用 AND 和 OR 连接，也支持 Between、LessThan、GreaterThan、Like；\n\n * 方法名可以以 findBy、getBy、queryBy 开头；\n\n * 查询结果可以排序，方法名包含 OrderBy+属性+ASC（DESC）；\n\n * 可以通过 Top、First 来限定查询的结果集；\n\n * 一些特殊的参数可以出现在参数列表里，比如 Pageeable、Sort\n\n示例：\n\n// 根据名字查询，且按照名字升序\nList<Person> findByLastnameOrderByFirstnameAsc(String name);\n\n// 根据名字查询，且使用翻页查询\nPage<User> findByLastname(String lastname, Pageable pageable);\n\n// 查询满足条件的前10个用户\nList<User> findFirst10ByLastname(String lastname, Sort sort);\n\n// 使用And联合查询\nList<Person> findByFirstnameAndLastname(String firstname, String lastname);\n\n// 使用Or查询\nList<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\n\n// 使用like查询，name 必须包含like中的%或者?\npublic User findByNameLike(String name);\n\n\nKEYWORD             SAMPLE                                                    JPQL SNIPPET\nAnd                 findByLastnameAndFirstname                                … where x.lastname = ?1 and x.firstname = ?2\nOr                  findByLastnameOrFirstname                                 … where x.lastname = ?1 or x.firstname = ?2\nIs,Equals           findByFirstname,findByFirstnameIs,findByFirstnameEquals   … where x.firstname = 1?\nBetween             findByStartDateBetween                                    … where x.startDate between 1? and ?2\nLessThan            findByAgeLessThan                                         … where x.age < ?1\nLessThanEqual       findByAgeLessThanEqual                                    … where x.age <= ?1\nGreaterThan         findByAgeGreaterThan                                      … where x.age > ?1\nGreaterThanEqual    findByAgeGreaterThanEqual                                 … where x.age >= ?1\nAfter               findByStartDateAfter                                      … where x.startDate > ?1\nBefore              findByStartDateBefore                                     … where x.startDate < ?1\nIsNull              findByAgeIsNull                                           … where x.age is null\nIsNotNull,NotNull   findByAge(Is)NotNull                                      … where x.age not null\nLike                findByFirstnameLike                                       … where x.firstname like ?1\nNotLike             findByFirstnameNotLike                                    … where x.firstname not like ?1\nStartingWith        findByFirstnameStartingWith                               … where x.firstname like ?1 (parameter bound with appended\n                                                                              %)\nEndingWith          findByFirstnameEndingWith                                 … where x.firstname like ?1 (parameter bound with prepended\n                                                                              %)\nContaining          findByFirstnameContaining                                 … where x.firstname like ?1 (parameter bound wrapped in %)\nOrderBy             findByAgeOrderByLastnameDesc                              … where x.age = ?1 order by x.lastname desc\nNot                 findByLastnameNot                                         … where x.lastname <> ?1\nIn                  findByAgeIn(Collection<Age> ages)                         … where x.age in ?1\nNotIn               findByAgeNotIn(Collection<Age> age)                       … where x.age not in ?1\nTrue                findByActiveTrue()                                        … where x.active = true\nFalse               findByActiveFalse()                                       … where x.active = false\nIgnoreCase          findByFirstnameIgnoreCase                                 … where UPPER(x.firstame) = UPPER(?1)\n\n\n# @Query 注解方式查询\n\n注解 @Query 允许在方法上使用 JPQL。\n\n其中操作针对的是对象名和对象属性名，而非数据库中的表名和字段名。\n\n@Query("select u form User u where u.name=?1 and u.depantment.id=?2");\npublic User findUser(String name, Integer departmentId);\n\n\n@Query("form User u where u.name=?1 and u.depantment.id=?2");\npublic User findUser(String name, Integer departmentId);\n\n\n如果使用 SQL 而不是 JPSQL，可以使用 nativeQuery 属性，设置为 true。\n\n@Query(value="select * from user where name=?1 and department_id=?2", nativeQuery=true)\npublic User nativeQuery(String name, Integer departmentId);\n\n\n无论 JPQL，还是 SQL，都支持"命名参数"：\n\n@Query(value="select * from user where name=:name and department_id=:departmentId", nativeQuery=true)\npublic User nativeQuery2(String name, Integer departmentId);\n\n\n如果 SQL 活着 JPQL 查询结果集并非 Entity，可以用 Object[] 数组代替，比如分组统计每个部分的用户数\n\n@Query(value="select department_id,count(*) from user group by department_id", nativeQuery=true)\npublic List<Object[]> queryUserCount()\n\n\n这条查询将返回数组，对象类型依赖于查询结果，被示例中，返回的是 String 和 BigInteger 类型\n\n查询时可以使用 Pageable 和 Sort 来完成翻页和排序。\n\n@Query("select u from User u where department.id=?1")\npublic Page<User> QueryUsers(Integer departmentId, Pageable page);\n\n\n@Query 还允许 SQL 更新、删除语句，此时必须搭配 @Modifying 使用，比如：\n\n@Modifying\n@Query("update User u set u.name= ?1 where u.id= ?2")\nint updateName(String name, Integer id);\n\n\n\n# 动态 SQL 方式查询\n\n可参考：SpringDataJpa 中的复杂查询和动态查询，多表查询\n\n\n# Example 方式查询\n\n允许根据实体创建一个 Example 对象，Spring Data 通过 Example 对象来构造 JPQL。但是使用不灵活条件是 AND,不能使用 or，时间的大于小于，between 等。\n\n继承 JpaRepository\n\n<S extends T> List<S> findAll(Example<S> var1);\n<S extends T> List<S> findAll(Example<S> var1, Sort var2);\n\n\npublic List<User> getByExample(String name) {\n    Department dept = new Department();\n    dept.setId(1);\n\n    User user = new User();\n    user.setName(name);\n    user.setDepartment(dept);\n    Example<User> example = Example.of(user);\n    List<User> list = userDao.findAll(example);\n    return list\n}\n\n\n以上代码首先创建了 User 对象，设置 查询条件，名称为参数 name，部门 id 为 1，通过 Example.of 构造了此查询。\n\n大部分查询并非完全匹配查询，ExampleMatcher 提供了更多的条件指定.比如以 xxx 开头的所有用户，则可以使用以下代码构造\n\nExampleMatcher matcher = ExampleMatcher.matching().withMatcher("xxx",\n    GenericPropertyMatchers.startsWith().ignoreCase());\nExample<User> example = Example.of(user, matcher);\n\n\n\n# 排序 Sort\n\nSort 对象用来指定排序，最简单的 Sort 对象构造可以传入一个属性名列表（不是数据库列名，是属性名）。默认采用升序排序。\n\nSort sort = new Sort("id");\n//Sort sort = new Sort(Direction.DESC, "id");\nreturn userDao.findAll(sort);\n\n\nHibernate 根据 Sort 构造了排序条件，Sort("id") 表示按照 id 采用默认 升序进行排序\n\n其他 Sort 的构造方法还包括以下主要的一些：\n\n * public Sort(String... properties)，按照指定的属性列表升序排序。\n * public Sort(Sort.Direction direction, String... properties)，按照指定属性列表排序，排序由 direction 指定，direction 是一个枚举类型，有 Direction.ASC 和 Direction.DESC。\n * public Sort(Sort.Order... orders)，可以通过 Order 静态方法来创建\n   * public static Sort.Order asc(String property)\n   * public static Sort.Order desc(String property)\n\n\n# 分页 Page 和 Pageable\n\nPageable 接口用于构造翻页查询，PageRequest 是其实现类，可以通过提供的工厂方法创建 PageRequest：\n\n注意我这边使用的是 sring boot 2.0.2 ，jpa 版本是 2.0.8，新版本与之前版本的操作方法有所不同。\n\n * public static PageRequest of(int page, int size)\n\n * public static PageRequest of(int page, int size, Sort sort) - 也可以在 PageRequest 中加入排序\n\n * public static PageRequest of(int page, int size, Direction direction, String... properties)，或者自定义排序规则\n\npage 是从 0 开始，表示查询页，size 指每页的期望行数。\n\nSpring Data 翻页查询总是返回 Page 对象，Page 对象提供了以下常用的方法\n\n * int getTotalPages();，总的页数\n * long getTotalElements(); - 返回总数\n * List<T> getContent(); - 返回此次查询的结果集\n\n\n# 核心 API\n\n\n\n\n# 参考资料\n\n * Spring 官网\n * Spring Framework 官方文档\n * Spring Boot 官方文档',normalizedContent:'# spring 之 jpa\n\njpa 为对象关系映射提供了一种基于 pojo 的持久化模型。\n\n * 简化数据持久化代码的开发\n * 为 java 社区屏蔽不同持久化 api 的差异\n\n\n# 快速入门\n\n（1）在 pom.xml 中引入依赖\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-jpa</artifactid>\n</dependency>\n\n\n（2）设置启动注解\n\n// 【可选】指定扫描的 entity 目录，如果不指定，会扫描全部目录\n@entityscan("io.github.dunwu.springboot.data.jpa")\n// 【可选】指定扫描的 repository 目录，如果不指定，会扫描全部目录\n@enablejparepositories(basepackages = {"io.github.dunwu.springboot.data.jpa"})\n// 【可选】开启 jpa auditing 能力，可以自动赋值一些字段，比如创建时间、最后一次修改时间等等\n@enablejpaauditing\n@springbootapplication\npublic class application {\n    public static void main(string[] args) {\n        springapplication.run(application.class, args);\n    }\n}\n\n\n（3）配置\n\n# 数据库连接\nspring.datasource.url = jdbc:mysql://localhost:3306/spring_tutorial?servertimezone=utc&useunicode=true&characterencoding=utf8\nspring.datasource.driver-class-name = com.mysql.cj.jdbc.driver\nspring.datasource.username = root\nspring.datasource.password = root\n# 是否打印 jpa sql 日志\nspring.jpa.show-sql = true\n# hibernate的ddl策略\nspring.jpa.hibernate.ddl-auto = create-drop\n\n\n（4）定义实体\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport lombok.tostring;\n\nimport java.util.objects;\nimport javax.persistence.*;\n\n@entity\n@data\n@tostring\n@noargsconstructor\n@allargsconstructor\npublic class user {\n\n    @id\n    @generatedvalue(strategy = generationtype.auto)\n    private long id;\n\n    @column(unique = true)\n    private string name;\n\n    private integer age;\n\n    private string address;\n\n    private string email;\n\n    public user(string name, integer age, string address, string email) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n        this.email = email;\n    }\n\n    @override\n    public int hashcode() {\n        return objects.hash(id, name);\n    }\n\n    @override\n    public boolean equals(object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (!(o instanceof user)) {\n            return false;\n        }\n\n        user user = (user) o;\n\n        if (id != null && id.equals(user.id)) {\n            return true;\n        }\n\n        return name.equals(user.name);\n    }\n\n}\n\n\n（5）定义 repository\n\n\nimport org.springframework.data.jpa.repository.jparepository;\nimport org.springframework.data.jpa.repository.query;\nimport org.springframework.data.repository.query.param;\nimport org.springframework.data.rest.core.annotation.repositoryrestresource;\nimport org.springframework.transaction.annotation.transactional;\nimport org.springframework.web.bind.annotation.pathvariable;\n\nimport java.util.list;\n\n@repositoryrestresource(collectionresourcerel = "user", path = "user")\npublic interface userrepository extends jparepository<user, long> {\n\n    user finduserbyid(@pathvariable("id") long id);\n\n    /**\n     * 根据用户名查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findbyname?name=lisi\n     *\n     * @param name 用户名\n     * @return {@link user}\n     */\n    user finduserbyname(@param("name") string name);\n\n    /**\n     * 根据邮箱查找用户\n     * <p>\n     * 示例：http://localhost:8080/user/search/findbyemail?email=xxx@163.com\n     *\n     * @param email 邮箱\n     * @return {@link user}\n     */\n    @query("from user u where u.email=:email")\n    list<user> findbyemail(@param("email") string email);\n\n    /**\n     * 根据用户名删除用户\n     *\n     * @param name 用户名\n     */\n    @transactional(rollbackfor = exception.class)\n    void deletebyname(@param("name") string name);\n\n}\n\n\n（6）测试\n\n@slf4j\n@springboottest(classes = { datajpaapplication.class })\npublic class datajpatests {\n\n    @autowired\n    private userrepository repository;\n\n    @beforeeach\n    public void before() {\n        repository.deleteall();\n    }\n\n    @test\n    public void insert() {\n        user user = new user("张三", 18, "北京", "user1@163.com");\n        repository.save(user);\n        optional<user> optional = repository.findbyid(user.getid());\n        assertthat(optional).isnotnull();\n        assertthat(optional.ispresent()).istrue();\n    }\n\n    @test\n    public void batchinsert() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveall(users);\n\n        long count = repository.count();\n        assertthat(count).isequalto(4);\n\n        list<user> list = repository.findall();\n        assertthat(list).isnotempty().hassize(4);\n        list.foreach(this::accept);\n    }\n\n    private void accept(user user) { log.info(user.tostring()); }\n\n    @test\n    public void delete() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveall(users);\n\n        repository.deletebyname("张三");\n        assertthat(repository.finduserbyname("张三")).isnull();\n\n        repository.deleteall();\n        list<user> list = repository.findall();\n        assertthat(list).isempty();\n    }\n\n    @test\n    public void findallinpage() {\n        list<user> users = new arraylist<>();\n        users.add(new user("张三", 18, "北京", "user1@163.com"));\n        users.add(new user("李四", 19, "上海", "user1@163.com"));\n        users.add(new user("王五", 18, "南京", "user1@163.com"));\n        users.add(new user("赵六", 20, "武汉", "user1@163.com"));\n        repository.saveall(users);\n\n        pagerequest pagerequest = pagerequest.of(1, 2);\n        page<user> page = repository.findall(pagerequest);\n        assertthat(page).isnotnull();\n        assertthat(page.isempty()).isfalse();\n        assertthat(page.gettotalelements()).isequalto(4);\n        assertthat(page.gettotalpages()).isequalto(2);\n\n        list<user> list = page.get().collect(collectors.tolist());\n        system.out.println("user list: ");\n        list.foreach(system.out::println);\n    }\n\n    @test\n    public void update() {\n        user olduser = new user("张三", 18, "北京", "user1@163.com");\n        olduser.setname("张三丰");\n        repository.save(olduser);\n\n        user newuser = repository.finduserbyname("张三丰");\n        assertthat(newuser).isnotnull();\n    }\n\n}\n\n\n\n# 常用 jpa 注解\n\n\n# 实体\n\n# @entity\n\n# @mappedsuperclass\n\n当多个实体有共同的属性字段，比如说 id，则可以把它提炼出一个父类，并且加上 @mappedsuperclass，则实体基类就可以继承了。\n\n# @table\n\n当实体名和表名不一致时，可以通过 @table(name="customers") 的形式来明确指定一个表名。\n\n\n# 主键\n\n# @id\n\n@id 注解用于声明一个实体类的属性映射为数据库的主键。\n\n# @generatedvalue\n\n@generatedvalue 用于标注主键的生成策略，通过 strategy 属性指定。\n\n默认情况下，jpa 自动选择一个最适合底层数据库的主键生成策略：sqlserver 对应 identity，mysql 对应 auto increment。\n\n在 javax.persistence.generationtype 中定义了以下几种可供选择的策略：\n\npublic enum generationtype {\n    table,\n    sequence,\n    identity,\n    auto\n}\n\n\n * identity：采用数据库 id 自增长的方式来自增主键字段，oracle 不支持这种方式；\n * auto： jpa 自动选择合适的策略，是默认选项；\n * sequence：通过序列产生主键，通过 @sequencegenerator 注解指定序列名，mysql 不支持这种方式\n * table：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。\n\n也就是如果你没有指定 strategy 属性，默认策略是 auto，jpa 会根据你使用的数据库来自动选择策略，比如说我使用的是 mysql 则，自动的主键策略就是 identity （auto increment）。\n\n\n# 映射\n\n# @column\n\n当你的 entity 属性名和数据库中的字段名不一致，可以使用 @column 明确指定，它也可以设置一些属性\n\n@column(length = 10, nullable = false, unique = true)\n\n\n@column(columndefinition = "int(3)")\nprivate int age;\n\n\n@column 支持的参数：\n\n * unique 属性表示该字段是否为唯一标识，默认为 false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用 @table 标记中的 @uniqueconstraint。\n * nullable 属性表示该字段是否可以为 null 值，默认为 true。\n * insertable 属性表示在使用 insert 插入数据时，是否需要插入该字段的值。\n * updatable 属性表示在使用 update 更新数据时，是否需要更新该字段的值。insertable 和 updatable 属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。\n * columndefinition 属性表示创建表时，该字段创建的 sql 语句，一般用于通过 entity 生成表定义时使用。\n * table 属性表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。\n * length 属性表示字段的长度，当字段的类型为 varchar 时，该属性才有效，默认为 255 个字符。\n * precision 属性和 scale 属性表示精度，当字段类型为 double 时，precision 表示数值的总长度，scale 表示小数点所占的位数。\n\n@jointable\n\n@joincolumn\n\n\n# 关系\n\n表关系映射（双向映射）\n\n * @onetoone：一对一关系\n * @onetomany：一对多\n * @manytomany（不推荐使用，而是采用用中间对象，把多对多拆成两个对多一关系）\n\n字段映射（单向映射）：\n\n * @embedded、@embeddable 嵌入式关系（单向映射）\n * @elementcollection 集合一对多关系（单向映射）\n\n# @onetoone\n\n@onetoone 表示一对一关系\n\n# @onetomany\n\n@onetomany 表示一对多关系\n\n@manytoone\n\n@manytomany\n\norderby\n\n\n# 查询\n\n查询方式有：\n\n * 方法名字方式查询\n\n * @query 注解方式查询\n\n * 动态 sql 方式查询\n\n * example 方式查询\n\njparepository 提供了如下表所述的内置查询\n\n * list<t> findall(); - 返回所有实体\n * list<t> findallbyid(iterable<id> var1); - 返回指定 id 的所有实体\n * t getone(id var1); - 根据 id 返回对应的实体，如果未找到，则返回空。\n * list<t> findall(sort var1); - 返回所有实体，按照指定顺序返回。\n * page<t> findall(pageable var1); - 返回实体列表，实体的 offset 和 limit 通过 pageable 来指定\n\n\n# 方法名字方式查询方式\n\nspring data 通过查询的方法名和参数名来自动构造一个 jpa qql 查询。\n\npublic interface userrepository extends jparepository<user, integer> {\n    public user findbyname(string name);\n}\n\n\n方法名和参数名要遵守一定的规则，spring data jpa 才能自动转换为 jpql：\n\n * 方法名通常包含多个实体属性用于查询，属性之间可以使用 and 和 or 连接，也支持 between、lessthan、greaterthan、like；\n\n * 方法名可以以 findby、getby、queryby 开头；\n\n * 查询结果可以排序，方法名包含 orderby+属性+asc（desc）；\n\n * 可以通过 top、first 来限定查询的结果集；\n\n * 一些特殊的参数可以出现在参数列表里，比如 pageeable、sort\n\n示例：\n\n// 根据名字查询，且按照名字升序\nlist<person> findbylastnameorderbyfirstnameasc(string name);\n\n// 根据名字查询，且使用翻页查询\npage<user> findbylastname(string lastname, pageable pageable);\n\n// 查询满足条件的前10个用户\nlist<user> findfirst10bylastname(string lastname, sort sort);\n\n// 使用and联合查询\nlist<person> findbyfirstnameandlastname(string firstname, string lastname);\n\n// 使用or查询\nlist<person> finddistinctpeoplebylastnameorfirstname(string lastname, string firstname);\n\n// 使用like查询，name 必须包含like中的%或者?\npublic user findbynamelike(string name);\n\n\nkeyword             sample                                                    jpql snippet\nand                 findbylastnameandfirstname                                … where x.lastname = ?1 and x.firstname = ?2\nor                  findbylastnameorfirstname                                 … where x.lastname = ?1 or x.firstname = ?2\nis,equals           findbyfirstname,findbyfirstnameis,findbyfirstnameequals   … where x.firstname = 1?\nbetween             findbystartdatebetween                                    … where x.startdate between 1? and ?2\nlessthan            findbyagelessthan                                         … where x.age < ?1\nlessthanequal       findbyagelessthanequal                                    … where x.age <= ?1\ngreaterthan         findbyagegreaterthan                                      … where x.age > ?1\ngreaterthanequal    findbyagegreaterthanequal                                 … where x.age >= ?1\nafter               findbystartdateafter                                      … where x.startdate > ?1\nbefore              findbystartdatebefore                                     … where x.startdate < ?1\nisnull              findbyageisnull                                           … where x.age is null\nisnotnull,notnull   findbyage(is)notnull                                      … where x.age not null\nlike                findbyfirstnamelike                                       … where x.firstname like ?1\nnotlike             findbyfirstnamenotlike                                    … where x.firstname not like ?1\nstartingwith        findbyfirstnamestartingwith                               … where x.firstname like ?1 (parameter bound with appended\n                                                                              %)\nendingwith          findbyfirstnameendingwith                                 … where x.firstname like ?1 (parameter bound with prepended\n                                                                              %)\ncontaining          findbyfirstnamecontaining                                 … where x.firstname like ?1 (parameter bound wrapped in %)\norderby             findbyageorderbylastnamedesc                              … where x.age = ?1 order by x.lastname desc\nnot                 findbylastnamenot                                         … where x.lastname <> ?1\nin                  findbyagein(collection<age> ages)                         … where x.age in ?1\nnotin               findbyagenotin(collection<age> age)                       … where x.age not in ?1\ntrue                findbyactivetrue()                                        … where x.active = true\nfalse               findbyactivefalse()                                       … where x.active = false\nignorecase          findbyfirstnameignorecase                                 … where upper(x.firstame) = upper(?1)\n\n\n# @query 注解方式查询\n\n注解 @query 允许在方法上使用 jpql。\n\n其中操作针对的是对象名和对象属性名，而非数据库中的表名和字段名。\n\n@query("select u form user u where u.name=?1 and u.depantment.id=?2");\npublic user finduser(string name, integer departmentid);\n\n\n@query("form user u where u.name=?1 and u.depantment.id=?2");\npublic user finduser(string name, integer departmentid);\n\n\n如果使用 sql 而不是 jpsql，可以使用 nativequery 属性，设置为 true。\n\n@query(value="select * from user where name=?1 and department_id=?2", nativequery=true)\npublic user nativequery(string name, integer departmentid);\n\n\n无论 jpql，还是 sql，都支持"命名参数"：\n\n@query(value="select * from user where name=:name and department_id=:departmentid", nativequery=true)\npublic user nativequery2(string name, integer departmentid);\n\n\n如果 sql 活着 jpql 查询结果集并非 entity，可以用 object[] 数组代替，比如分组统计每个部分的用户数\n\n@query(value="select department_id,count(*) from user group by department_id", nativequery=true)\npublic list<object[]> queryusercount()\n\n\n这条查询将返回数组，对象类型依赖于查询结果，被示例中，返回的是 string 和 biginteger 类型\n\n查询时可以使用 pageable 和 sort 来完成翻页和排序。\n\n@query("select u from user u where department.id=?1")\npublic page<user> queryusers(integer departmentid, pageable page);\n\n\n@query 还允许 sql 更新、删除语句，此时必须搭配 @modifying 使用，比如：\n\n@modifying\n@query("update user u set u.name= ?1 where u.id= ?2")\nint updatename(string name, integer id);\n\n\n\n# 动态 sql 方式查询\n\n可参考：springdatajpa 中的复杂查询和动态查询，多表查询\n\n\n# example 方式查询\n\n允许根据实体创建一个 example 对象，spring data 通过 example 对象来构造 jpql。但是使用不灵活条件是 and,不能使用 or，时间的大于小于，between 等。\n\n继承 jparepository\n\n<s extends t> list<s> findall(example<s> var1);\n<s extends t> list<s> findall(example<s> var1, sort var2);\n\n\npublic list<user> getbyexample(string name) {\n    department dept = new department();\n    dept.setid(1);\n\n    user user = new user();\n    user.setname(name);\n    user.setdepartment(dept);\n    example<user> example = example.of(user);\n    list<user> list = userdao.findall(example);\n    return list\n}\n\n\n以上代码首先创建了 user 对象，设置 查询条件，名称为参数 name，部门 id 为 1，通过 example.of 构造了此查询。\n\n大部分查询并非完全匹配查询，examplematcher 提供了更多的条件指定.比如以 xxx 开头的所有用户，则可以使用以下代码构造\n\nexamplematcher matcher = examplematcher.matching().withmatcher("xxx",\n    genericpropertymatchers.startswith().ignorecase());\nexample<user> example = example.of(user, matcher);\n\n\n\n# 排序 sort\n\nsort 对象用来指定排序，最简单的 sort 对象构造可以传入一个属性名列表（不是数据库列名，是属性名）。默认采用升序排序。\n\nsort sort = new sort("id");\n//sort sort = new sort(direction.desc, "id");\nreturn userdao.findall(sort);\n\n\nhibernate 根据 sort 构造了排序条件，sort("id") 表示按照 id 采用默认 升序进行排序\n\n其他 sort 的构造方法还包括以下主要的一些：\n\n * public sort(string... properties)，按照指定的属性列表升序排序。\n * public sort(sort.direction direction, string... properties)，按照指定属性列表排序，排序由 direction 指定，direction 是一个枚举类型，有 direction.asc 和 direction.desc。\n * public sort(sort.order... orders)，可以通过 order 静态方法来创建\n   * public static sort.order asc(string property)\n   * public static sort.order desc(string property)\n\n\n# 分页 page 和 pageable\n\npageable 接口用于构造翻页查询，pagerequest 是其实现类，可以通过提供的工厂方法创建 pagerequest：\n\n注意我这边使用的是 sring boot 2.0.2 ，jpa 版本是 2.0.8，新版本与之前版本的操作方法有所不同。\n\n * public static pagerequest of(int page, int size)\n\n * public static pagerequest of(int page, int size, sort sort) - 也可以在 pagerequest 中加入排序\n\n * public static pagerequest of(int page, int size, direction direction, string... properties)，或者自定义排序规则\n\npage 是从 0 开始，表示查询页，size 指每页的期望行数。\n\nspring data 翻页查询总是返回 page 对象，page 对象提供了以下常用的方法\n\n * int gettotalpages();，总的页数\n * long gettotalelements(); - 返回总数\n * list<t> getcontent(); - 返回此次查询的结果集\n\n\n# 核心 api\n\n\n\n\n# 参考资料\n\n * spring 官网\n * spring framework 官方文档\n * spring boot 官方文档',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 集成 Mybatis",frontmatter:{title:"Spring 集成 Mybatis",date:"2019-05-09T17:09:25.000Z",order:10,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","MyBatis","PageHelper","Mapper"],permalink:"/pages/88219e/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/10.Spring%E9%9B%86%E6%88%90Mybatis.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/10.Spring集成Mybatis.md",key:"v-1eb14240",path:"/pages/88219e/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:202},{level:3,title:"从 XML 中构建 SqlSessionFactory",slug:"从-xml-中构建-sqlsessionfactory",normalizedTitle:"从 xml 中构建 sqlsessionfactory",charIndex:438},{level:3,title:"不使用 XML 构建 SqlSessionFactory",slug:"不使用-xml-构建-sqlsessionfactory",normalizedTitle:"不使用 xml 构建 sqlsessionfactory",charIndex:2056},{level:3,title:"从 SqlSessionFactory 中获取 SqlSession",slug:"从-sqlsessionfactory-中获取-sqlsession",normalizedTitle:"从 sqlsessionfactory 中获取 sqlsession",charIndex:2877},{level:3,title:"探究已映射的 SQL 语句",slug:"探究已映射的-sql-语句",normalizedTitle:"探究已映射的 sql 语句",charIndex:3532},{level:3,title:"作用域（Scope）和生命周期",slug:"作用域-scope-和生命周期",normalizedTitle:"作用域（scope）和生命周期",charIndex:5848},{level:4,title:"SqlSessionFactoryBuilder",slug:"sqlsessionfactorybuilder",normalizedTitle:"sqlsessionfactorybuilder",charIndex:541},{level:4,title:"SqlSessionFactory",slug:"sqlsessionfactory",normalizedTitle:"sqlsessionfactory",charIndex:448},{level:4,title:"SqlSession",slug:"sqlsession",normalizedTitle:"sqlsession",charIndex:448},{level:4,title:"映射器实例",slug:"映射器实例",normalizedTitle:"映射器实例",charIndex:7059},{level:2,title:"Mybatis 扩展工具",slug:"mybatis-扩展工具",normalizedTitle:"mybatis 扩展工具",charIndex:7471},{level:3,title:"Mybatis Plus",slug:"mybatis-plus",normalizedTitle:"mybatis plus",charIndex:7488},{level:3,title:"Mapper",slug:"mapper",normalizedTitle:"mapper",charIndex:1842},{level:3,title:"PageHelper",slug:"pagehelper",normalizedTitle:"pagehelper",charIndex:7793},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7879}],headersStr:"快速入门 从 XML 中构建 SqlSessionFactory 不使用 XML 构建 SqlSessionFactory 从 SqlSessionFactory 中获取 SqlSession 探究已映射的 SQL 语句 作用域（Scope）和生命周期 SqlSessionFactoryBuilder SqlSessionFactory SqlSession 映射器实例 Mybatis 扩展工具 Mybatis Plus Mapper PageHelper 参考资料",content:'# Spring 集成 Mybatis\n\nMybatis 官网 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n\n# 快速入门\n\n要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。\n\n如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>x.x.x</version>\n</dependency>\n\n\n\n# 从 XML 中构建 SqlSessionFactory\n\n每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。\n\n从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。\n\nString resource = "org/mybatis/example/mybatis-config.xml";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\n\nXML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n  "https://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionManager type="JDBC"/>\n      <dataSource type="POOLED">\n        <property name="driver" value="${driver}"/>\n        <property name="url" value="${url}"/>\n        <property name="username" value="${username}"/>\n        <property name="password" value="${password}"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="org/mybatis/example/BlogMapper.xml"/>\n  </mappers>\n</configuration>\n\n\n当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。\n\n\n# 不使用 XML 构建 SqlSessionFactory\n\n如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置构建器，MyBatis 也提供了完整的配置类，提供了所有与 XML 文件等价的配置项。\n\nDataSource dataSource = BlogDataSourceFactory.getBlogDataSource();\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\nEnvironment environment = new Environment("development", transactionFactory, dataSource);\nConfiguration configuration = new Configuration(environment);\nconfiguration.addMapper(BlogMapper.class);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);\n\n\n注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射注解从而避免依赖 XML 映射文件。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 映射文件进行映射。有鉴于此，如果存在一个同名 XML 映射文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载 BlogMapper.xml）。具体细节稍后讨论。\n\n\n# 从 SqlSessionFactory 中获取 SqlSession\n\n既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);\n}\n\n\n诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。\n\n例如：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  Blog blog = mapper.selectBlog(101);\n}\n\n\n现在我们来探究一下这段代码究竟做了些什么。\n\n\n# 探究已映射的 SQL 语句\n\n现在你可能很想知道 SqlSession 和 Mapper 到底具体执行了些什么操作，但 SQL 语句映射是个相当广泛的话题，可能会占去文档的大部分篇幅。 但为了让你能够了解个大概，这里先给出几个例子。\n\n在上面提到的例子中，一个语句既可以通过 XML 定义，也可以通过注解定义。我们先看看 XML 定义语句的方式，事实上 MyBatis 提供的所有特性都可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你用过旧版本的 MyBatis，你应该对这个概念比较熟悉。 但相比于之前的版本，新版本改进了许多 XML 的配置，后面我们会提到这些改进。这里给出一个基于 XML 映射语句的示例，它应该可以满足上个示例中 SqlSession 的调用。\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="org.mybatis.example.BlogMapper">\n  <select id="selectBlog" resultType="Blog">\n    select * from Blog where id = #{id}\n  </select>\n</mapper>\n\n\n为了这个简单的例子，我们似乎写了不少配置，但其实并不多。在一个 XML 映射文件中，可以定义无数个映射语句，这样一来，XML 头部和文档类型声明部分就显得微不足道了。文档的其它部分很直白，容易理解。 它在命名空间 “org.mybatis.example.BlogMapper” 中定义了一个名为 “selectBlog” 的映射语句，这样你就可以用全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句了，就像上面例子中那样：\n\nBlog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);\n\n\n你可能会注意到，这种方式和用全限定名调用 Java 对象的方法类似。这样，该命名就可以直接映射到在命名空间中同名的映射器类，并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法。因此你就可以像上面那样，不费吹灰之力地在对应的映射器接口调用方法，就像下面这样：\n\nBlogMapper mapper = session.getMapper(BlogMapper.class);\nBlog blog = mapper.selectBlog(101);\n\n\n第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 SQL 语句。\n\n提示 对命名空间的一点补充\n\n在之前版本的 MyBatis 中，**命名空间（Namespaces）**的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。\n\n命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。\n\n**命名解析：**为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。\n\n * 全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。\n * 短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。\n\n对于像 BlogMapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可以被替换成如下的配置：\n\npackage org.mybatis.example;\npublic interface BlogMapper {\n  @Select("SELECT * FROM blog WHERE id = #{id}")\n  Blog selectBlog(int id);\n}\n\n\n使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。\n\n选择何种方式来配置映射，以及是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松地在基于注解和 XML 的语句映射方式间自由移植和切换。\n\n\n# 作用域（Scope）和生命周期\n\n理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\n提示 对象生命周期和依赖注入框架\n\n依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。\n\n# SqlSessionFactoryBuilder\n\n这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。\n\n# SqlSessionFactory\n\nSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。\n\n# SqlSession\n\n每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  // 你的应用逻辑代码\n}\n\n\n在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。\n\n# 映射器实例\n\n映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：\n\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // 你的应用逻辑代码\n}\n\n\n\n# Mybatis 扩展工具\n\n\n# Mybatis Plus\n\nMyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n【集成示例】spring-boot-data-mybatis-plus\n\n\n# Mapper\n\nMapper 是一个 Mybatis CRUD 扩展插件。\n\nMapper 的基本原理是将实体类映射为数据库中的表和字段信息，因此实体类需要通过注解配置基本的元数据，配置好实体后， 只需要创建一个继承基础接口的 Mapper 接口就可以开始使用了。\n\n【集成示例】spring-boot-data-mybatis-mapper\n\n\n# PageHelper\n\nPageHelper 是一个 Mybatis 通用分页插件。\n\n【集成示例】spring-boot-data-mybatis-mapper\n\n\n# 参考资料\n\n * 官方\n   * Mybatis Github\n   * Mybatis 官网\n   * MyBatis 官方代码生成（mybatis-generator）\n   * MyBatis 官方集成 Spring（mybatis-spring）\n   * Mybatis 官方集成 Spring Boot（mybatis-spring-boot）\n * 扩展插件\n   * MyBatis-Plus - CRUD 扩展插件、代码生成器、分页器等多功能\n   * Mapper - Mybatis CRUD 扩展插件\n   * PageHelper - Mybatis 通用分页插件\n * 文章\n   * 深入理解 mybatis 原理\n   * mybatis 源码中文注释\n   * MyBatis Generator 详解\n   * Mybatis 常见面试题\n   * Mybatis 中强大的 resultMap',normalizedContent:'# spring 集成 mybatis\n\nmybatis 官网 是一款持久层框架，它支持定制化 sql、存储过程以及高级映射。mybatis 避免了几乎所有的 jdbc 代码和手动设置参数以及获取结果集。mybatis 可以使用简单的 xml 或注解来配置和映射原生类型、接口和 java 的 pojo（plain old java objects，普通老式 java 对象）为数据库中的记录。\n\n\n# 快速入门\n\n要使用 mybatis， 只需将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。\n\n如果使用 maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：\n\n<dependency>\n  <groupid>org.mybatis</groupid>\n  <artifactid>mybatis</artifactid>\n  <version>x.x.x</version>\n</dependency>\n\n\n\n# 从 xml 中构建 sqlsessionfactory\n\n每个基于 mybatis 的应用都是以一个 sqlsessionfactory 的实例为核心的。sqlsessionfactory 的实例可以通过 sqlsessionfactorybuilder 获得。而 sqlsessionfactorybuilder 则可以从 xml 配置文件或一个预先配置的 configuration 实例来构建出 sqlsessionfactory 实例。\n\n从 xml 文件中构建 sqlsessionfactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（inputstream）实例，比如用文件路径字符串或 file:// url 构造的输入流。mybatis 包含一个名叫 resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。\n\nstring resource = "org/mybatis/example/mybatis-config.xml";\ninputstream inputstream = resources.getresourceasstream(resource);\nsqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(inputstream);\n\n\nxml 配置文件中包含了对 mybatis 系统的核心设置，包括获取数据库连接实例的数据源（datasource）以及决定事务作用域和控制方式的事务管理器（transactionmanager）。后面会再探讨 xml 配置文件的详细内容，这里先给出一个简单的示例：\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n  public "-//mybatis.org//dtd config 3.0//en"\n  "https://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n  <environments default="development">\n    <environment id="development">\n      <transactionmanager type="jdbc"/>\n      <datasource type="pooled">\n        <property name="driver" value="${driver}"/>\n        <property name="url" value="${url}"/>\n        <property name="username" value="${username}"/>\n        <property name="password" value="${password}"/>\n      </datasource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource="org/mybatis/example/blogmapper.xml"/>\n  </mappers>\n</configuration>\n\n\n当然，还有很多可以在 xml 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 xml 头部的声明，它用来验证 xml 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 xml 映射文件包含了 sql 代码和映射定义信息。\n\n\n# 不使用 xml 构建 sqlsessionfactory\n\n如果你更愿意直接从 java 代码而不是 xml 文件中创建配置，或者想要创建你自己的配置构建器，mybatis 也提供了完整的配置类，提供了所有与 xml 文件等价的配置项。\n\ndatasource datasource = blogdatasourcefactory.getblogdatasource();\ntransactionfactory transactionfactory = new jdbctransactionfactory();\nenvironment environment = new environment("development", transactionfactory, datasource);\nconfiguration configuration = new configuration(environment);\nconfiguration.addmapper(blogmapper.class);\nsqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(configuration);\n\n\n注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 java 类，它们包含 sql 映射注解从而避免依赖 xml 映射文件。不过，由于 java 注解的一些限制以及某些 mybatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 xml 映射文件进行映射。有鉴于此，如果存在一个同名 xml 映射文件，mybatis 会自动查找并加载它（在这个例子中，基于类路径和 blogmapper.class 的类名，会加载 blogmapper.xml）。具体细节稍后讨论。\n\n\n# 从 sqlsessionfactory 中获取 sqlsession\n\n既然有了 sqlsessionfactory，顾名思义，我们可以从中获得 sqlsession 的实例。sqlsession 提供了在数据库执行 sql 命令所需的所有方法。你可以通过 sqlsession 实例来直接执行已映射的 sql 语句。例如：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  blog blog = (blog) session.selectone("org.mybatis.example.blogmapper.selectblog", 101);\n}\n\n\n诚然，这种方式能够正常工作，对使用旧版本 mybatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 blogmapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。\n\n例如：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  blogmapper mapper = session.getmapper(blogmapper.class);\n  blog blog = mapper.selectblog(101);\n}\n\n\n现在我们来探究一下这段代码究竟做了些什么。\n\n\n# 探究已映射的 sql 语句\n\n现在你可能很想知道 sqlsession 和 mapper 到底具体执行了些什么操作，但 sql 语句映射是个相当广泛的话题，可能会占去文档的大部分篇幅。 但为了让你能够了解个大概，这里先给出几个例子。\n\n在上面提到的例子中，一个语句既可以通过 xml 定义，也可以通过注解定义。我们先看看 xml 定义语句的方式，事实上 mybatis 提供的所有特性都可以利用基于 xml 的映射语言来实现，这使得 mybatis 在过去的数年间得以流行。如果你用过旧版本的 mybatis，你应该对这个概念比较熟悉。 但相比于之前的版本，新版本改进了许多 xml 的配置，后面我们会提到这些改进。这里给出一个基于 xml 映射语句的示例，它应该可以满足上个示例中 sqlsession 的调用。\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper\n  public "-//mybatis.org//dtd mapper 3.0//en"\n  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="org.mybatis.example.blogmapper">\n  <select id="selectblog" resulttype="blog">\n    select * from blog where id = #{id}\n  </select>\n</mapper>\n\n\n为了这个简单的例子，我们似乎写了不少配置，但其实并不多。在一个 xml 映射文件中，可以定义无数个映射语句，这样一来，xml 头部和文档类型声明部分就显得微不足道了。文档的其它部分很直白，容易理解。 它在命名空间 “org.mybatis.example.blogmapper” 中定义了一个名为 “selectblog” 的映射语句，这样你就可以用全限定名 “org.mybatis.example.blogmapper.selectblog” 来调用映射语句了，就像上面例子中那样：\n\nblog blog = (blog) session.selectone("org.mybatis.example.blogmapper.selectblog", 101);\n\n\n你可能会注意到，这种方式和用全限定名调用 java 对象的方法类似。这样，该命名就可以直接映射到在命名空间中同名的映射器类，并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法。因此你就可以像上面那样，不费吹灰之力地在对应的映射器接口调用方法，就像下面这样：\n\nblogmapper mapper = session.getmapper(blogmapper.class);\nblog blog = mapper.selectblog(101);\n\n\n第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 ide 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 sql 语句。\n\n提示 对命名空间的一点补充\n\n在之前版本的 mybatis 中，**命名空间（namespaces）**的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。\n\n命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 mybatis。\n\n**命名解析：**为了减少输入量，mybatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。\n\n * 全限定名（比如 “com.mypackage.mymapper.selectallthings）将被直接用于查找及使用。\n * 短名称（比如 “selectallthings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectallthings” 和 “com.bar.selectallthings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。\n\n对于像 blogmapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 xml 来配置，而可以使用 java 注解来配置。比如，上面的 xml 示例可以被替换成如下的配置：\n\npackage org.mybatis.example;\npublic interface blogmapper {\n  @select("select * from blog where id = #{id}")\n  blog selectblog(int id);\n}\n\n\n使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，java 注解不仅力不从心，还会让本就复杂的 sql 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 xml 来映射语句。\n\n选择何种方式来配置映射，以及是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松地在基于注解和 xml 的语句映射方式间自由移植和切换。\n\n\n# 作用域（scope）和生命周期\n\n理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\n提示 对象生命周期和依赖注入框架\n\n依赖注入框架可以创建线程安全的、基于事务的 sqlsession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 mybatis 感兴趣，可以研究一下 mybatis-spring 或 mybatis-guice 两个子项目。\n\n# sqlsessionfactorybuilder\n\n这个类可以被实例化、使用和丢弃，一旦创建了 sqlsessionfactory，就不再需要它了。 因此 sqlsessionfactorybuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 sqlsessionfactorybuilder 来创建多个 sqlsessionfactory 实例，但最好还是不要一直保留着它，以保证所有的 xml 解析资源可以被释放给更重要的事情。\n\n# sqlsessionfactory\n\nsqlsessionfactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 sqlsessionfactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 sqlsessionfactory 被视为一种代码“坏习惯”。因此 sqlsessionfactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。\n\n# sqlsession\n\n每个线程都应该有它自己的 sqlsession 实例。sqlsession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 sqlsession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 sqlsession 实例的引用放在任何类型的托管作用域中，比如 servlet 框架中的 httpsession。 如果你现在正在使用一种 web 框架，考虑将 sqlsession 放在一个和 http 请求相似的作用域中。 换句话说，每次收到 http 请求，就可以打开一个 sqlsession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 sqlsession 关闭的标准模式：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  // 你的应用逻辑代码\n}\n\n\n在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。\n\n# 映射器实例\n\n映射器是一些绑定映射语句的接口。映射器接口的实例是从 sqlsession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 sqlsession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 sqlsession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：\n\ntry (sqlsession session = sqlsessionfactory.opensession()) {\n  blogmapper mapper = session.getmapper(blogmapper.class);\n  // 你的应用逻辑代码\n}\n\n\n\n# mybatis 扩展工具\n\n\n# mybatis plus\n\nmybatis-plus（简称 mp）是一个 mybatis 的增强工具，在 mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n【集成示例】spring-boot-data-mybatis-plus\n\n\n# mapper\n\nmapper 是一个 mybatis crud 扩展插件。\n\nmapper 的基本原理是将实体类映射为数据库中的表和字段信息，因此实体类需要通过注解配置基本的元数据，配置好实体后， 只需要创建一个继承基础接口的 mapper 接口就可以开始使用了。\n\n【集成示例】spring-boot-data-mybatis-mapper\n\n\n# pagehelper\n\npagehelper 是一个 mybatis 通用分页插件。\n\n【集成示例】spring-boot-data-mybatis-mapper\n\n\n# 参考资料\n\n * 官方\n   * mybatis github\n   * mybatis 官网\n   * mybatis 官方代码生成（mybatis-generator）\n   * mybatis 官方集成 spring（mybatis-spring）\n   * mybatis 官方集成 spring boot（mybatis-spring-boot）\n * 扩展插件\n   * mybatis-plus - crud 扩展插件、代码生成器、分页器等多功能\n   * mapper - mybatis crud 扩展插件\n   * pagehelper - mybatis 通用分页插件\n * 文章\n   * 深入理解 mybatis 原理\n   * mybatis 源码中文注释\n   * mybatis generator 详解\n   * mybatis 常见面试题\n   * mybatis 中强大的 resultmap',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 访问 Redis",frontmatter:{title:"Spring 访问 Redis",date:"2023-01-31T20:54:42.000Z",order:21,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","Redis"],permalink:"/pages/65e4a2/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/21.Spring%E8%AE%BF%E9%97%AERedis.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/21.Spring访问Redis.md",key:"v-5be0fc7d",path:"/pages/65e4a2/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:22},{level:2,title:"Spring Boot 快速入门",slug:"spring-boot-快速入门",normalizedTitle:"spring boot 快速入门",charIndex:259},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:280},{level:3,title:"数据源配置",slug:"数据源配置",normalizedTitle:"数据源配置",charIndex:440},{level:3,title:"定义实体",slug:"定义实体",normalizedTitle:"定义实体",charIndex:557},{level:3,title:"定义 CRUD 接口",slug:"定义-crud-接口",normalizedTitle:"定义 crud 接口",charIndex:1010},{level:3,title:"创建 CRUD 接口实现",slug:"创建-crud-接口实现",normalizedTitle:"创建 crud 接口实现",charIndex:1211},{level:3,title:"创建 Application",slug:"创建-application",normalizedTitle:"创建 application",charIndex:2299},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:4653},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:5614},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5660}],headersStr:"简介 Spring Boot 快速入门 引入依赖 数据源配置 定义实体 定义 CRUD 接口 创建 CRUD 接口实现 创建 Application 测试 示例源码 参考资料",content:'# Spring 访问 Redis\n\n\n# 简介\n\nRedis 是一个被数百万开发人员用作数据库、缓存、流引擎和消息代理的开源内存数据库。\n\n在 Spring 中，spring-data-redis 项目对访问 Redis 进行了 API 封装，提供了便捷的访问方式。 spring-data-redis\n\nspring-boot 项目中的子模块 spring-boot-starter-data-redis 基于 spring-data-redis 项目，做了二次封装，大大简化了 Redis 的相关配置。\n\n\n# Spring Boot 快速入门\n\n\n# 引入依赖\n\n在 pom.xml 中引入依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n\n# 数据源配置\n\nspring.redis.database = 0\nspring.redis.host = localhost\nspring.redis.port = 6379\nspring.redis.password =\n\n\n\n# 定义实体\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport java.io.Serializable;\n\n@Data\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 4142994984277644695L;\n\n    private Long id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String email;\n\n}\n\n\n\n# 定义 CRUD 接口\n\nimport java.util.Map;\n\npublic interface UserService {\n\n    void batchSetUsers(Map<String, User> users);\n\n    long count();\n\n    User getUser(Long id);\n\n    void setUser(User user);\n\n}\n\n\n\n# 创建 CRUD 接口实现\n\n\nimport cn.hutool.core.bean.BeanUtil;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Map;\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    public static final String DEFAULT_KEY = "spring:tutorial:user";\n\n    private final RedisTemplate<String, Object> redisTemplate;\n\n    public UserServiceImpl(RedisTemplate<String, Object> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    @Override\n    public void batchSetUsers(Map<String, User> users) {\n        redisTemplate.opsForHash().putAll(DEFAULT_KEY, users);\n    }\n\n    @Override\n    public long count() {\n        return redisTemplate.opsForHash().size(DEFAULT_KEY);\n    }\n\n    @Override\n    public User getUser(Long id) {\n        Object obj = redisTemplate.opsForHash().get(DEFAULT_KEY, id.toString());\n        return BeanUtil.toBean(obj, User.class);\n    }\n\n    @Override\n    public void setUser(User user) {\n        redisTemplate.opsForHash().put(DEFAULT_KEY, user.getId().toString(), user);\n    }\n\n}\n\n\n\n# 创建 Application\n\n创建 Application，实例化一个 RedisTemplate 对象。\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Slf4j\n@SpringBootApplication\npublic class RedisQuickstartApplication {\n\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    @Bean\n    @Primary\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n\n        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        // // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常\n        // objectMapper.activateDefaultTyping(new DefaultBaseTypeLimitingValidator(),\n        //     ObjectMapper.DefaultTyping.NON_FINAL);\n\n        // 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）\n        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        serializer.setObjectMapper(objectMapper);\n\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 配置连接工厂\n        template.setConnectionFactory(factory);\n        // 值采用json序列化\n        template.setValueSerializer(serializer);\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        // 设置hash key 和value序列化模式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n        template.afterPropertiesSet();\n\n        return template;\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(RedisQuickstartApplication.class, args);\n    }\n\n}\n\n\n\n# 测试\n\n@Slf4j\n@SpringBootTest(classes = { RedisQuickstartApplication.class })\npublic class RedisQuickstartTests {\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void test() {\n        final long SIZE = 1000L;\n        Map<String, User> map = new HashMap<>();\n        for (long i = 0; i < SIZE; i++) {\n            User user = new User(i, RandomUtil.randomChineseName(),\n                RandomUtil.randomInt(1, 100),\n                RandomUtil.randomEnum(Location.class).name(),\n                RandomUtil.randomEmail());\n            map.put(String.valueOf(i), user);\n        }\n        userService.batchSetUsers(map);\n        long count = userService.count();\n        Assertions.assertThat(count).isEqualTo(SIZE);\n\n        for (int i = 0; i < 100; i++) {\n            long id = RandomUtil.randomLong(0, 1000);\n            User user = userService.getUser(id);\n            log.info("user-{}: {}", id, user.toString());\n        }\n    }\n\n}\n\n\n\n# 示例源码\n\n更多 Spring 访问 Redis 示例请参考：Redis 示例源码\n\n\n# 参考资料\n\n * Redis 官网\n * Redis Github\n * spring-data-redis Github\n * Spring Data Redis 官方文档\n * Spring Data 官方示例',normalizedContent:'# spring 访问 redis\n\n\n# 简介\n\nredis 是一个被数百万开发人员用作数据库、缓存、流引擎和消息代理的开源内存数据库。\n\n在 spring 中，spring-data-redis 项目对访问 redis 进行了 api 封装，提供了便捷的访问方式。 spring-data-redis\n\nspring-boot 项目中的子模块 spring-boot-starter-data-redis 基于 spring-data-redis 项目，做了二次封装，大大简化了 redis 的相关配置。\n\n\n# spring boot 快速入门\n\n\n# 引入依赖\n\n在 pom.xml 中引入依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n\n# 数据源配置\n\nspring.redis.database = 0\nspring.redis.host = localhost\nspring.redis.port = 6379\nspring.redis.password =\n\n\n\n# 定义实体\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\nimport lombok.tostring;\n\nimport java.io.serializable;\n\n@data\n@tostring\n@noargsconstructor\n@allargsconstructor\npublic class user implements serializable {\n\n    private static final long serialversionuid = 4142994984277644695l;\n\n    private long id;\n    private string name;\n    private integer age;\n    private string address;\n    private string email;\n\n}\n\n\n\n# 定义 crud 接口\n\nimport java.util.map;\n\npublic interface userservice {\n\n    void batchsetusers(map<string, user> users);\n\n    long count();\n\n    user getuser(long id);\n\n    void setuser(user user);\n\n}\n\n\n\n# 创建 crud 接口实现\n\n\nimport cn.hutool.core.bean.beanutil;\nimport org.springframework.data.redis.core.redistemplate;\nimport org.springframework.stereotype.service;\n\nimport java.util.map;\n\n@service\npublic class userserviceimpl implements userservice {\n\n    public static final string default_key = "spring:tutorial:user";\n\n    private final redistemplate<string, object> redistemplate;\n\n    public userserviceimpl(redistemplate<string, object> redistemplate) {\n        this.redistemplate = redistemplate;\n    }\n\n    @override\n    public void batchsetusers(map<string, user> users) {\n        redistemplate.opsforhash().putall(default_key, users);\n    }\n\n    @override\n    public long count() {\n        return redistemplate.opsforhash().size(default_key);\n    }\n\n    @override\n    public user getuser(long id) {\n        object obj = redistemplate.opsforhash().get(default_key, id.tostring());\n        return beanutil.tobean(obj, user.class);\n    }\n\n    @override\n    public void setuser(user user) {\n        redistemplate.opsforhash().put(default_key, user.getid().tostring(), user);\n    }\n\n}\n\n\n\n# 创建 application\n\n创建 application，实例化一个 redistemplate 对象。\n\nimport com.fasterxml.jackson.annotation.jsonautodetect;\nimport com.fasterxml.jackson.annotation.propertyaccessor;\nimport com.fasterxml.jackson.databind.objectmapper;\nimport lombok.extern.slf4j.slf4j;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.primary;\nimport org.springframework.data.redis.connection.redisconnectionfactory;\nimport org.springframework.data.redis.core.redistemplate;\nimport org.springframework.data.redis.serializer.jackson2jsonredisserializer;\nimport org.springframework.data.redis.serializer.stringredisserializer;\n\n@slf4j\n@springbootapplication\npublic class redisquickstartapplication {\n\n    @autowired\n    private objectmapper objectmapper;\n\n    @bean\n    @primary\n    public redistemplate<string, object> redistemplate(redisconnectionfactory factory) {\n\n        // 指定要序列化的域，field,get和set,以及修饰符范围，any是都有包括private和public\n        objectmapper.setvisibility(propertyaccessor.all, jsonautodetect.visibility.any);\n        // // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如string,integer等会跑出异常\n        // objectmapper.activatedefaulttyping(new defaultbasetypelimitingvalidator(),\n        //     objectmapper.defaulttyping.non_final);\n\n        // 使用jackson2jsonredisserializer来序列化和反序列化redis的value值（默认使用jdk的序列化方式）\n        jackson2jsonredisserializer<object> serializer = new jackson2jsonredisserializer<>(object.class);\n        serializer.setobjectmapper(objectmapper);\n\n        redistemplate<string, object> template = new redistemplate<>();\n        // 配置连接工厂\n        template.setconnectionfactory(factory);\n        // 值采用json序列化\n        template.setvalueserializer(serializer);\n        // 使用stringredisserializer来序列化和反序列化redis的key值\n        template.setkeyserializer(new stringredisserializer());\n        // 设置hash key 和value序列化模式\n        template.sethashkeyserializer(new stringredisserializer());\n        template.sethashvalueserializer(serializer);\n        template.afterpropertiesset();\n\n        return template;\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(redisquickstartapplication.class, args);\n    }\n\n}\n\n\n\n# 测试\n\n@slf4j\n@springboottest(classes = { redisquickstartapplication.class })\npublic class redisquickstarttests {\n\n    @autowired\n    private userservice userservice;\n\n    @test\n    public void test() {\n        final long size = 1000l;\n        map<string, user> map = new hashmap<>();\n        for (long i = 0; i < size; i++) {\n            user user = new user(i, randomutil.randomchinesename(),\n                randomutil.randomint(1, 100),\n                randomutil.randomenum(location.class).name(),\n                randomutil.randomemail());\n            map.put(string.valueof(i), user);\n        }\n        userservice.batchsetusers(map);\n        long count = userservice.count();\n        assertions.assertthat(count).isequalto(size);\n\n        for (int i = 0; i < 100; i++) {\n            long id = randomutil.randomlong(0, 1000);\n            user user = userservice.getuser(id);\n            log.info("user-{}: {}", id, user.tostring());\n        }\n    }\n\n}\n\n\n\n# 示例源码\n\n更多 spring 访问 redis 示例请参考：redis 示例源码\n\n\n# 参考资料\n\n * redis 官网\n * redis github\n * spring-data-redis github\n * spring data redis 官方文档\n * spring data 官方示例',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring Data 综合",frontmatter:{title:"Spring Data 综合",date:"2023-02-08T09:10:35.000Z",order:20,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/191cdb/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/20.SpringData%E7%BB%BC%E5%90%88.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/20.SpringData综合.md",key:"v-35ee501b",path:"/pages/191cdb/",headers:[{level:2,title:"核心概念",slug:"核心概念",normalizedTitle:"核心概念",charIndex:72},{level:2,title:"查询方法",slug:"查询方法",normalizedTitle:"查询方法",charIndex:1089},{level:2,title:"定义 Repository",slug:"定义-repository",normalizedTitle:"定义 repository",charIndex:2162},{level:3,title:"微调 Repository 定义",slug:"微调-repository-定义",normalizedTitle:"微调 repository 定义",charIndex:2286},{level:3,title:"使用多个 Spring 数据模块",slug:"使用多个-spring-数据模块",normalizedTitle:"使用多个 spring 数据模块",charIndex:3341},{level:2,title:"定义查询方法",slug:"定义查询方法",normalizedTitle:"定义查询方法",charIndex:5447},{level:3,title:"查询策略",slug:"查询策略",normalizedTitle:"查询策略",charIndex:5567},{level:3,title:"查询创建",slug:"查询创建",normalizedTitle:"查询创建",charIndex:5826},{level:2,title:"创建 Repository 实例",slug:"创建-repository-实例",normalizedTitle:"创建 repository 实例",charIndex:6943},{level:2,title:"自定义 Repository 实现",slug:"自定义-repository-实现",normalizedTitle:"自定义 repository 实现",charIndex:6964},{level:2,title:"Spring Data 扩展",slug:"spring-data-扩展",normalizedTitle:"spring data 扩展",charIndex:6986},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7005}],headersStr:"核心概念 查询方法 定义 Repository 微调 Repository 定义 使用多个 Spring 数据模块 定义查询方法 查询策略 查询创建 创建 Repository 实例 自定义 Repository 实现 Spring Data 扩展 参考资料",content:'# Spring Data 综合\n\nSpring Data Repository 抽象的目标是显著减少各种访问持久化存储的样板式代码。\n\n\n# 核心概念\n\nRepository 是 Spring Data 的核心接口。此接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展此接口的接口。CrudRepository 和 ListCrudRepository 接口为被管理的实体类提供复杂的 CRUD 功能。ListCrudRepository 提供等效方法，但它们返回 List，而 CrudRepository 方法返回 Iterable。\n\nCrudRepository 接口定义：\n\npublic interface CrudRepository<T, ID> extends Repository<T, ID> {\n\n  <S extends T> S save(S entity);\n\n  Optional<T> findById(ID primaryKey);\n\n  Iterable<T> findAll();\n\n  long count();\n\n  void delete(T entity);\n\n  boolean existsById(ID primaryKey);\n\n  // … more functionality omitted.\n}\n\n\n> Spring Data 项目也提供了一些特定持久化技术的抽象接口，如：JpaRepository 或 MongoRepository。这些接口扩展了 CrudRepository 并暴露了一些持久化技术的底层功能。\n\n除了 CrudRepository 之外，还有一个 PagingAndSortingRepository 接口，它添加了额外的方法来简化对实体的分页访问：\n\npublic interface PagingAndSortingRepository<T, ID>  {\n\n  Iterable<T> findAll(Sort sort);\n\n  Page<T> findAll(Pageable pageable);\n}\n\n\n【示例】要按页面大小 20 访问 User 的第二页，可以执行如下操作\n\nPagingAndSortingRepository<User, Long> repository = // … get access to a bean\nPage<User> users = repository.findAll(PageRequest.of(1, 20));\n\n\n除了查询方法之外，计数和删除时的查询也是可用的。\n\n【示例】根据姓氏计数\n\ninterface UserRepository extends CrudRepository<User, Long> {\n  long countByLastname(String lastname);\n}\n\n\n【示例】根据姓氏删除\n\ninterface UserRepository extends CrudRepository<User, Long> {\n\n  long deleteByLastname(String lastname);\n\n  List<User> removeByLastname(String lastname);\n}\n\n\n\n# 查询方法\n\n使用 Spring Data 对数据库进行查询有以下四步：\n\n 1. 声明一个扩展 Repository 或其子接口的接口，并指定泛型类型（实体类和 ID 类型），如以下示例所示：\n    \n    interface PersonRepository extends Repository<Person, Long> { … }\n    \n\n 2. 在接口中声明查询方法\n    \n    interface PersonRepository extends Repository<Person, Long> {\n      List<Person> findByLastname(String lastname);\n    }\n    \n\n 3. 使用 JavaConfig 或 XML 配置为这些接口创建代理实例\n    \n    @EnableJpaRepositories\n    class Config { … }\n    \n\n 4. 注入 Repository 实例并使用\n    \n    class SomeClient {\n    \n      private final PersonRepository repository;\n    \n      SomeClient(PersonRepository repository) {\n        this.repository = repository;\n      }\n    \n      void doSomething() {\n        List<Person> persons = repository.findByLastname("Matthews");\n      }\n    }\n    \n\n\n# 定义 Repository\n\n首先需要定义一个 Repository 接口，该接口必须扩展 Repository 并且指定泛型类型（实体类和 ID 类型）。如果想为该实体暴露 CRUD 方法，可以扩展 CrudRepository 接口。\n\n\n# 微调 Repository 定义\n\nSpring Data 提供了很多种 Repository 以应对不同的需求场景。\n\nCrudRepository 提供了 CRUD 功能。\n\nListCrudRepository 和 CrudRepository 类似，但对于那些返回多个实体的方法，它返回一个 List 而不是 Iterable，这样使用可能更方便。\n\n如果使用响应式框架，可以使用 ReactiveCrudRepository 或 RxJava3CrudRepository。\n\nCoroutineCrudRepository 支持 Kotlin 的协程特性。\n\nPagingAndSortingRepository 提供了分页、排序功能。\n\n如果不想扩展 Spring Data 接口，还可以使用 @RepositoryDefinition 注释您的 Repository 接口。 扩展一个 CRUD Repository 接口，需要暴露一组完整的方法来操作实体。如果希望对暴露的方法有选择性，可以将要暴露的方法从 CRUD Repository 复制到自定义的 Repository 中。 这样做时，可以更改方法的返回类型。 如果可能，Spring Data 将遵循返回类型。 例如，对于返回多个实体的方法，可以选择 Iterable<T>、List<T>、Collection<T> 或 VAVR 列表。\n\n自定义基础 Repository 接口，必须用 @NoRepositoryBean 标记。 这可以防止 Spring Data 尝试直接创建它的实例并失败，因为它无法确定该 Repository 的实体，因为它仍然包含一个通用类型变量。\n\n以下示例显示了如何有选择地暴露 CRUD 方法（在本例中为 findById 和 save）：\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends Repository<T, ID> {\n\n  Optional<T> findById(ID id);\n\n  <S extends T> S save(S entity);\n}\n\ninterface UserRepository extends MyBaseRepository<User, Long> {\n  User findByEmailAddress(EmailAddress emailAddress);\n}\n\n\n\n# 使用多个 Spring 数据模块\n\n有时，程序中需要使用多个 Spring Data 模块。在这种情况下，必须区分持久化技术。当检测到类路径上有多个 Repository 工厂时，Spring Data 进入严格的配置模式。\n\n如果定义的 Repository 扩展了特定模块中的 Repository，则它是特定 Spring Data 模块的有效候选者。\n\n如果实体类使用了特定模块的类型注解，则它是特定 Spring Data 模块的有效候选者。 Spring Data 模块接受第三方注解（例如 JPA 的 @Entity）或提供自己的注解（例如用于 Spring Data MongoDB 和 Spring Data Elasticsearch 的 @Document）。\n\n以下示例显示了一个使用模块特定接口（在本例中为 JPA）的 Repository：\n\ninterface MyRepository extends JpaRepository<User, Long> { }\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends JpaRepository<T, ID> { … }\n\ninterface UserRepository extends MyBaseRepository<User, Long> { … }\n\n\nMyRepository 和 UserRepository 扩展了 JpaRepository。它们是 Spring Data JPA 模块的有效候选者。\n\n以下示例显示了一个使用通用接口的 Repository\n\ninterface AmbiguousRepository extends Repository<User, Long> { … }\n\n@NoRepositoryBean\ninterface MyBaseRepository<T, ID> extends CrudRepository<T, ID> { … }\n\ninterface AmbiguousUserRepository extends MyBaseRepository<User, Long> { … }\n\n\nAmbiguousRepository 和 AmbiguousUserRepository 仅扩展了 Repository 和 CrudRepository。 虽然这在使用唯一的 Spring Data 模块时很好，但是存在多个模块时，无法区分这些 Repository 应该绑定到哪个特定的 Spring Data。\n\n以下示例显示了一个使用带注解的实体类的 Repository\n\ninterface PersonRepository extends Repository<Person, Long> { … }\n\n@Entity\nclass Person { … }\n\ninterface UserRepository extends Repository<User, Long> { … }\n\n@Document\nclass User { … }\n\n\nPersonRepository 引用 Person，它使用 JPA @Entity 注解进行标记，因此这个 Repository 显然属于 Spring Data JPA。 UserRepository 引用 User，它使用 Spring Data MongoDB 的 @Document 注解进行标记。\n\n以下错误示例显示了一个使用带有混合注解的实体类的 Repository\n\ninterface JpaPersonRepository extends Repository<Person, Long> { … }\n\ninterface MongoDBPersonRepository extends Repository<Person, Long> { … }\n\n@Entity\n@Document\nclass Person { … }\n\n\n此示例中的实体类同时使用了 JPA 和 Spring Data MongoDB 的注解。示例中定义了两个 Repository：JpaPersonRepository 和 MongoDBPersonRepository。 一个用于 JPA，另一个用于 MongoDB。 Spring Data 不再能够区分 Repository，这会导致未定义的行为。\n\n区分 Repository 的最后一种方法是确定 Repository 扫描 package 的范围。\n\n@EnableJpaRepositories(basePackages = "com.acme.repositories.jpa")\n@EnableMongoRepositories(basePackages = "com.acme.repositories.mongo")\nclass Configuration { … }\n\n\n\n# 定义查询方法\n\nRepository 代理有两种方法可以从方法名称派生特定于存储的查询：\n\n * 通过直接从方法名称派生查询。\n * 通过使用手动定义的查询。\n\n可用选项取决于实际存储。但是，必须有一个策略来决定创建什么实际查询。\n\n\n# 查询策略\n\n以下策略可用于Repository 基础结构来解析查询。 对于 Java 配置，您可以使用 EnableJpaRepositories 注释的 queryLookupStrategy 属性。 特定数据存储可能不支持某些策略。\n\n * CREATE 尝试从查询方法名称构造特定存储的查询。\n * USE_DECLARED_QUERY 尝试查找已声明的查询，如果找不到则抛出异常。\n * CREATE_IF_NOT_FOUND （默认）结合了 CREATE 和 USE_DECLARED_QUERY。\n\n\n# 查询创建\n\nSpring Data 中有一套内置的查询构建器机制，可以自动映射符合命名和参数规则的方法。\n\ninterface PersonRepository extends Repository<Person, Long> {\n\n  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);\n\n  // Enables the distinct flag for the query\n  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\n  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);\n\n  // Enabling ignoring case for an individual property\n  List<Person> findByLastnameIgnoreCase(String lastname);\n  // Enabling ignoring case for all suitable properties\n  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);\n\n  // Enabling static ORDER BY for a query\n  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);\n  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);\n}\n\n\n解析查询方法名称分为主语和谓语。第一部分 (find…By, exists…By) 定义查询的主语，第二部分构成谓词。 主语可以包含更多的表达。 find（或其他引入关键字）和 By 之间的任何文本都被认为是描述性的，除非使用其中一个结果限制关键字，例如 Distinct 在要创建的查询上设置不同的标志或 Top/First 限制查询结果。\n\n> 参考：\n> \n> Spring Data 支持的查询主语关键词\n> \n> Spring Data 支持的查询谓语关键词\n\n\n# 创建 Repository 实例\n\n\n# 自定义 Repository 实现\n\n\n# Spring Data 扩展\n\n\n# 参考资料\n\n * Redis 官网\n * Redis Github\n * spring-data-redis Github\n * Spring Data Redis 官方文档\n * Spring Data 官方示例',normalizedContent:'# spring data 综合\n\nspring data repository 抽象的目标是显著减少各种访问持久化存储的样板式代码。\n\n\n# 核心概念\n\nrepository 是 spring data 的核心接口。此接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展此接口的接口。crudrepository 和 listcrudrepository 接口为被管理的实体类提供复杂的 crud 功能。listcrudrepository 提供等效方法，但它们返回 list，而 crudrepository 方法返回 iterable。\n\ncrudrepository 接口定义：\n\npublic interface crudrepository<t, id> extends repository<t, id> {\n\n  <s extends t> s save(s entity);\n\n  optional<t> findbyid(id primarykey);\n\n  iterable<t> findall();\n\n  long count();\n\n  void delete(t entity);\n\n  boolean existsbyid(id primarykey);\n\n  // … more functionality omitted.\n}\n\n\n> spring data 项目也提供了一些特定持久化技术的抽象接口，如：jparepository 或 mongorepository。这些接口扩展了 crudrepository 并暴露了一些持久化技术的底层功能。\n\n除了 crudrepository 之外，还有一个 pagingandsortingrepository 接口，它添加了额外的方法来简化对实体的分页访问：\n\npublic interface pagingandsortingrepository<t, id>  {\n\n  iterable<t> findall(sort sort);\n\n  page<t> findall(pageable pageable);\n}\n\n\n【示例】要按页面大小 20 访问 user 的第二页，可以执行如下操作\n\npagingandsortingrepository<user, long> repository = // … get access to a bean\npage<user> users = repository.findall(pagerequest.of(1, 20));\n\n\n除了查询方法之外，计数和删除时的查询也是可用的。\n\n【示例】根据姓氏计数\n\ninterface userrepository extends crudrepository<user, long> {\n  long countbylastname(string lastname);\n}\n\n\n【示例】根据姓氏删除\n\ninterface userrepository extends crudrepository<user, long> {\n\n  long deletebylastname(string lastname);\n\n  list<user> removebylastname(string lastname);\n}\n\n\n\n# 查询方法\n\n使用 spring data 对数据库进行查询有以下四步：\n\n 1. 声明一个扩展 repository 或其子接口的接口，并指定泛型类型（实体类和 id 类型），如以下示例所示：\n    \n    interface personrepository extends repository<person, long> { … }\n    \n\n 2. 在接口中声明查询方法\n    \n    interface personrepository extends repository<person, long> {\n      list<person> findbylastname(string lastname);\n    }\n    \n\n 3. 使用 javaconfig 或 xml 配置为这些接口创建代理实例\n    \n    @enablejparepositories\n    class config { … }\n    \n\n 4. 注入 repository 实例并使用\n    \n    class someclient {\n    \n      private final personrepository repository;\n    \n      someclient(personrepository repository) {\n        this.repository = repository;\n      }\n    \n      void dosomething() {\n        list<person> persons = repository.findbylastname("matthews");\n      }\n    }\n    \n\n\n# 定义 repository\n\n首先需要定义一个 repository 接口，该接口必须扩展 repository 并且指定泛型类型（实体类和 id 类型）。如果想为该实体暴露 crud 方法，可以扩展 crudrepository 接口。\n\n\n# 微调 repository 定义\n\nspring data 提供了很多种 repository 以应对不同的需求场景。\n\ncrudrepository 提供了 crud 功能。\n\nlistcrudrepository 和 crudrepository 类似，但对于那些返回多个实体的方法，它返回一个 list 而不是 iterable，这样使用可能更方便。\n\n如果使用响应式框架，可以使用 reactivecrudrepository 或 rxjava3crudrepository。\n\ncoroutinecrudrepository 支持 kotlin 的协程特性。\n\npagingandsortingrepository 提供了分页、排序功能。\n\n如果不想扩展 spring data 接口，还可以使用 @repositorydefinition 注释您的 repository 接口。 扩展一个 crud repository 接口，需要暴露一组完整的方法来操作实体。如果希望对暴露的方法有选择性，可以将要暴露的方法从 crud repository 复制到自定义的 repository 中。 这样做时，可以更改方法的返回类型。 如果可能，spring data 将遵循返回类型。 例如，对于返回多个实体的方法，可以选择 iterable<t>、list<t>、collection<t> 或 vavr 列表。\n\n自定义基础 repository 接口，必须用 @norepositorybean 标记。 这可以防止 spring data 尝试直接创建它的实例并失败，因为它无法确定该 repository 的实体，因为它仍然包含一个通用类型变量。\n\n以下示例显示了如何有选择地暴露 crud 方法（在本例中为 findbyid 和 save）：\n\n@norepositorybean\ninterface mybaserepository<t, id> extends repository<t, id> {\n\n  optional<t> findbyid(id id);\n\n  <s extends t> s save(s entity);\n}\n\ninterface userrepository extends mybaserepository<user, long> {\n  user findbyemailaddress(emailaddress emailaddress);\n}\n\n\n\n# 使用多个 spring 数据模块\n\n有时，程序中需要使用多个 spring data 模块。在这种情况下，必须区分持久化技术。当检测到类路径上有多个 repository 工厂时，spring data 进入严格的配置模式。\n\n如果定义的 repository 扩展了特定模块中的 repository，则它是特定 spring data 模块的有效候选者。\n\n如果实体类使用了特定模块的类型注解，则它是特定 spring data 模块的有效候选者。 spring data 模块接受第三方注解（例如 jpa 的 @entity）或提供自己的注解（例如用于 spring data mongodb 和 spring data elasticsearch 的 @document）。\n\n以下示例显示了一个使用模块特定接口（在本例中为 jpa）的 repository：\n\ninterface myrepository extends jparepository<user, long> { }\n\n@norepositorybean\ninterface mybaserepository<t, id> extends jparepository<t, id> { … }\n\ninterface userrepository extends mybaserepository<user, long> { … }\n\n\nmyrepository 和 userrepository 扩展了 jparepository。它们是 spring data jpa 模块的有效候选者。\n\n以下示例显示了一个使用通用接口的 repository\n\ninterface ambiguousrepository extends repository<user, long> { … }\n\n@norepositorybean\ninterface mybaserepository<t, id> extends crudrepository<t, id> { … }\n\ninterface ambiguoususerrepository extends mybaserepository<user, long> { … }\n\n\nambiguousrepository 和 ambiguoususerrepository 仅扩展了 repository 和 crudrepository。 虽然这在使用唯一的 spring data 模块时很好，但是存在多个模块时，无法区分这些 repository 应该绑定到哪个特定的 spring data。\n\n以下示例显示了一个使用带注解的实体类的 repository\n\ninterface personrepository extends repository<person, long> { … }\n\n@entity\nclass person { … }\n\ninterface userrepository extends repository<user, long> { … }\n\n@document\nclass user { … }\n\n\npersonrepository 引用 person，它使用 jpa @entity 注解进行标记，因此这个 repository 显然属于 spring data jpa。 userrepository 引用 user，它使用 spring data mongodb 的 @document 注解进行标记。\n\n以下错误示例显示了一个使用带有混合注解的实体类的 repository\n\ninterface jpapersonrepository extends repository<person, long> { … }\n\ninterface mongodbpersonrepository extends repository<person, long> { … }\n\n@entity\n@document\nclass person { … }\n\n\n此示例中的实体类同时使用了 jpa 和 spring data mongodb 的注解。示例中定义了两个 repository：jpapersonrepository 和 mongodbpersonrepository。 一个用于 jpa，另一个用于 mongodb。 spring data 不再能够区分 repository，这会导致未定义的行为。\n\n区分 repository 的最后一种方法是确定 repository 扫描 package 的范围。\n\n@enablejparepositories(basepackages = "com.acme.repositories.jpa")\n@enablemongorepositories(basepackages = "com.acme.repositories.mongo")\nclass configuration { … }\n\n\n\n# 定义查询方法\n\nrepository 代理有两种方法可以从方法名称派生特定于存储的查询：\n\n * 通过直接从方法名称派生查询。\n * 通过使用手动定义的查询。\n\n可用选项取决于实际存储。但是，必须有一个策略来决定创建什么实际查询。\n\n\n# 查询策略\n\n以下策略可用于repository 基础结构来解析查询。 对于 java 配置，您可以使用 enablejparepositories 注释的 querylookupstrategy 属性。 特定数据存储可能不支持某些策略。\n\n * create 尝试从查询方法名称构造特定存储的查询。\n * use_declared_query 尝试查找已声明的查询，如果找不到则抛出异常。\n * create_if_not_found （默认）结合了 create 和 use_declared_query。\n\n\n# 查询创建\n\nspring data 中有一套内置的查询构建器机制，可以自动映射符合命名和参数规则的方法。\n\ninterface personrepository extends repository<person, long> {\n\n  list<person> findbyemailaddressandlastname(emailaddress emailaddress, string lastname);\n\n  // enables the distinct flag for the query\n  list<person> finddistinctpeoplebylastnameorfirstname(string lastname, string firstname);\n  list<person> findpeopledistinctbylastnameorfirstname(string lastname, string firstname);\n\n  // enabling ignoring case for an individual property\n  list<person> findbylastnameignorecase(string lastname);\n  // enabling ignoring case for all suitable properties\n  list<person> findbylastnameandfirstnameallignorecase(string lastname, string firstname);\n\n  // enabling static order by for a query\n  list<person> findbylastnameorderbyfirstnameasc(string lastname);\n  list<person> findbylastnameorderbyfirstnamedesc(string lastname);\n}\n\n\n解析查询方法名称分为主语和谓语。第一部分 (find…by, exists…by) 定义查询的主语，第二部分构成谓词。 主语可以包含更多的表达。 find（或其他引入关键字）和 by 之间的任何文本都被认为是描述性的，除非使用其中一个结果限制关键字，例如 distinct 在要创建的查询上设置不同的标志或 top/first 限制查询结果。\n\n> 参考：\n> \n> spring data 支持的查询主语关键词\n> \n> spring data 支持的查询谓语关键词\n\n\n# 创建 repository 实例\n\n\n# 自定义 repository 实现\n\n\n# spring data 扩展\n\n\n# 参考资料\n\n * redis 官网\n * redis github\n * spring-data-redis github\n * spring data redis 官方文档\n * spring data 官方示例',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 访问 MongoDB",frontmatter:{title:"Spring 访问 MongoDB",date:"2018-12-15T17:29:36.000Z",order:22,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","MongoDB"],permalink:"/pages/db2a41/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/22.Spring%E8%AE%BF%E9%97%AEMongoDB.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/22.Spring访问MongoDB.md",key:"v-361cf50d",path:"/pages/db2a41/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:24},{level:2,title:"Spring Boot 快速入门",slug:"spring-boot-快速入门",normalizedTitle:"spring boot 快速入门",charIndex:440},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:461},{level:3,title:"数据源配置",slug:"数据源配置",normalizedTitle:"数据源配置",charIndex:623},{level:3,title:"定义实体",slug:"定义实体",normalizedTitle:"定义实体",charIndex:813},{level:3,title:"创建 Repository",slug:"创建-repository",normalizedTitle:"创建 repository",charIndex:1442},{level:3,title:"创建 Application",slug:"创建-application",normalizedTitle:"创建 application",charIndex:1952},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:4240},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4290}],headersStr:"简介 Spring Boot 快速入门 引入依赖 数据源配置 定义实体 创建 Repository 创建 Application 示例源码 参考资料",content:'# Spring 访问 MongoDB\n\n\n# 简介\n\nMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。\n\n在 Spring 中，spring-data-mongodb 项目对访问 MongoDB 进行了 API 封装，提供了便捷的访问方式。 Spring Data MongoDB 的核心是一个以 POJO 为中心的模型，用于与 MongoDB DBCollection 交互并轻松编写 Repository 样式的数据访问层。\n\nspring-boot 项目中的子模块 spring-boot-starter-data-mongodb 基于 spring-data-mongodb 项目，做了二次封装，大大简化了 MongoDB 的相关配置。\n\n\n# Spring Boot 快速入门\n\n\n# 引入依赖\n\n在 pom.xml 中引入依赖：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-mongodb</artifactId>\n</dependency>\n\n\n\n# 数据源配置\n\nspring.data.mongodb.host = localhost\nspring.data.mongodb.port = 27017\nspring.data.mongodb.database = test\nspring.data.mongodb.username = root\nspring.data.mongodb.password = root\n\n\n\n# 定义实体\n\n定义一个具有三个属性的 Customer 类：id、firstName 和 lastName\n\nimport org.springframework.data.annotation.Id;\n\npublic class Customer {\n\n    @Id\n    public String id;\n\n    public String firstName;\n\n    public String lastName;\n\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n            "Customer[id=%s, firstName=\'%s\', lastName=\'%s\']",\n            id, firstName, lastName);\n    }\n\n}\n\n\nspring-data-mongodb 会将 Customer 类映射到一个名为 customer 的集合中。如果要更改集合的名称，可以在类上使用 @Document 注解。\n\n\n# 创建 Repository\n\nspring-data-mongodb 继承了 Spring Data Commons 项目的能力，所以可以使用其通用 API——Repository。\n\n先定义一个 CustomerRepository 类，继承 MongoRepository 接口，并指定其泛型参数：Customer 和 String。MongoRepository 接口支持多种操作，包括 CRUD 和分页查询。在下面的例子中，定义了两个查询方法：\n\nimport java.util.List;\n\nimport org.springframework.data.mongodb.repository.MongoRepository;\n\npublic interface CustomerRepository extends MongoRepository<Customer, String> {\n\n    Customer findByFirstName(String firstName);\n    List<Customer> findByLastName(String lastName);\n\n}\n\n\n\n# 创建 Application\n\n创建一个 Spring Boot 的启动类 Application，并在启动的 main 方法中使用 CustomerRepository 实例访问 MongoDB。\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DataMongodbApplication implements CommandLineRunner {\n\n    @Autowired\n    private CustomerRepository repository;\n\n    public static void main(String[] args) {\n        SpringApplication.run(DataMongodbApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) {\n\n        repository.deleteAll();\n\n        // save a couple of customers\n        repository.save(new Customer("Alice", "Smith"));\n        repository.save(new Customer("Bob", "Smith"));\n\n        // fetch all customers\n        System.out.println("Customers found with findAll():");\n        System.out.println("-------------------------------");\n        for (Customer customer : repository.findAll()) {\n            System.out.println(customer);\n        }\n        System.out.println();\n\n        // fetch an individual customer\n        System.out.println("Customer found with findByFirstName(\'Alice\'):");\n        System.out.println("--------------------------------");\n        System.out.println(repository.findByFirstName("Alice"));\n\n        System.out.println("Customers found with findByLastName(\'Smith\'):");\n        System.out.println("--------------------------------");\n        for (Customer customer : repository.findByLastName("Smith")) {\n            System.out.println(customer);\n        }\n    }\n\n}\n\n\n运行 DataMongodbApplication 的 main 方法后，输出类似如下类容：\n\nCustomers found with findAll():\n-------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomer(id=63d6157b265e7c5e48077f64, firstName=Bob, lastName=Smith)\n\nCustomer found with findByFirstName(\'Alice\'):\n--------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomers found with findByLastName(\'Smith\'):\n--------------------------------\nCustomer(id=63d6157b265e7c5e48077f63, firstName=Alice, lastName=Smith)\nCustomer(id=63d6157b265e7c5e48077f64, firstName=Bob, lastName=Smith)\n\n\n\n# 示例源码\n\n更多 Spring 访问 MongoDB 示例请参考：MongoDB 示例源码\n\n\n# 参考资料\n\n * MongoDB 官网\n * MongoDB Github\n * MongoDB 官方免费教程\n * spring-data-mongodb Github\n * Spring Data MongoDB 官方文档\n * Spring Data 官方示例\n * Accessing Data with MongoDB\n * Accessing MongoDB Data with REST',normalizedContent:'# spring 访问 mongodb\n\n\n# 简介\n\nmongodb 是一个基于分布式文件存储的数据库。由 c++ 语言编写。旨在为 web 应用提供可扩展的高性能数据存储解决方案。mongodb 将数据存储为一个文档，数据结构由键值对组成。mongodb 文档类似于 json 对象。字段值可以包含其他文档，数组及文档数组。\n\n在 spring 中，spring-data-mongodb 项目对访问 mongodb 进行了 api 封装，提供了便捷的访问方式。 spring data mongodb 的核心是一个以 pojo 为中心的模型，用于与 mongodb dbcollection 交互并轻松编写 repository 样式的数据访问层。\n\nspring-boot 项目中的子模块 spring-boot-starter-data-mongodb 基于 spring-data-mongodb 项目，做了二次封装，大大简化了 mongodb 的相关配置。\n\n\n# spring boot 快速入门\n\n\n# 引入依赖\n\n在 pom.xml 中引入依赖：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-data-mongodb</artifactid>\n</dependency>\n\n\n\n# 数据源配置\n\nspring.data.mongodb.host = localhost\nspring.data.mongodb.port = 27017\nspring.data.mongodb.database = test\nspring.data.mongodb.username = root\nspring.data.mongodb.password = root\n\n\n\n# 定义实体\n\n定义一个具有三个属性的 customer 类：id、firstname 和 lastname\n\nimport org.springframework.data.annotation.id;\n\npublic class customer {\n\n    @id\n    public string id;\n\n    public string firstname;\n\n    public string lastname;\n\n    public customer(string firstname, string lastname) {\n        this.firstname = firstname;\n        this.lastname = lastname;\n    }\n\n    @override\n    public string tostring() {\n        return string.format(\n            "customer[id=%s, firstname=\'%s\', lastname=\'%s\']",\n            id, firstname, lastname);\n    }\n\n}\n\n\nspring-data-mongodb 会将 customer 类映射到一个名为 customer 的集合中。如果要更改集合的名称，可以在类上使用 @document 注解。\n\n\n# 创建 repository\n\nspring-data-mongodb 继承了 spring data commons 项目的能力，所以可以使用其通用 api——repository。\n\n先定义一个 customerrepository 类，继承 mongorepository 接口，并指定其泛型参数：customer 和 string。mongorepository 接口支持多种操作，包括 crud 和分页查询。在下面的例子中，定义了两个查询方法：\n\nimport java.util.list;\n\nimport org.springframework.data.mongodb.repository.mongorepository;\n\npublic interface customerrepository extends mongorepository<customer, string> {\n\n    customer findbyfirstname(string firstname);\n    list<customer> findbylastname(string lastname);\n\n}\n\n\n\n# 创建 application\n\n创建一个 spring boot 的启动类 application，并在启动的 main 方法中使用 customerrepository 实例访问 mongodb。\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.commandlinerunner;\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\n\n@springbootapplication\npublic class datamongodbapplication implements commandlinerunner {\n\n    @autowired\n    private customerrepository repository;\n\n    public static void main(string[] args) {\n        springapplication.run(datamongodbapplication.class, args);\n    }\n\n    @override\n    public void run(string... args) {\n\n        repository.deleteall();\n\n        // save a couple of customers\n        repository.save(new customer("alice", "smith"));\n        repository.save(new customer("bob", "smith"));\n\n        // fetch all customers\n        system.out.println("customers found with findall():");\n        system.out.println("-------------------------------");\n        for (customer customer : repository.findall()) {\n            system.out.println(customer);\n        }\n        system.out.println();\n\n        // fetch an individual customer\n        system.out.println("customer found with findbyfirstname(\'alice\'):");\n        system.out.println("--------------------------------");\n        system.out.println(repository.findbyfirstname("alice"));\n\n        system.out.println("customers found with findbylastname(\'smith\'):");\n        system.out.println("--------------------------------");\n        for (customer customer : repository.findbylastname("smith")) {\n            system.out.println(customer);\n        }\n    }\n\n}\n\n\n运行 datamongodbapplication 的 main 方法后，输出类似如下类容：\n\ncustomers found with findall():\n-------------------------------\ncustomer(id=63d6157b265e7c5e48077f63, firstname=alice, lastname=smith)\ncustomer(id=63d6157b265e7c5e48077f64, firstname=bob, lastname=smith)\n\ncustomer found with findbyfirstname(\'alice\'):\n--------------------------------\ncustomer(id=63d6157b265e7c5e48077f63, firstname=alice, lastname=smith)\ncustomers found with findbylastname(\'smith\'):\n--------------------------------\ncustomer(id=63d6157b265e7c5e48077f63, firstname=alice, lastname=smith)\ncustomer(id=63d6157b265e7c5e48077f64, firstname=bob, lastname=smith)\n\n\n\n# 示例源码\n\n更多 spring 访问 mongodb 示例请参考：mongodb 示例源码\n\n\n# 参考资料\n\n * mongodb 官网\n * mongodb github\n * mongodb 官方免费教程\n * spring-data-mongodb github\n * spring data mongodb 官方文档\n * spring data 官方示例\n * accessing data with mongodb\n * accessing mongodb data with rest',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 数据篇",frontmatter:{title:"Spring 数据篇",date:"2022-09-18T11:05:36.000Z",categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","数据库"],permalink:"/pages/b912d1/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/README.md",key:"v-f86530fc",path:"/pages/b912d1/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:17},{level:2,title:"💻 示例",slug:"💻-示例",normalizedTitle:"💻 示例",charIndex:178},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:1554},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:1733}],headersStr:"📖 内容 💻 示例 📚 资料 🚪 传送",content:"# Spring 数据篇\n\n\n# 📖 内容\n\n * Spring 之数据源\n * Spring 之 JDBC\n * Spring 之事务\n * Spring 之 JPA\n * Spring 集成 Mybatis\n * Spring 访问 Redis\n * Spring 访问 MongoDB\n * Spring 访问 Elasticsearch\n\n\n# 💻 示例\n\n * JDBC\n   * spring-data-jdbc-basics - Spring Boot 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n   * spring-data-jdbc-druid - SpringBoot 使用 Druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - SpringBoot 连接多数据源示例。\n   * spring-data-jdbc-xml - Spring 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n * ORM\n   * spring-data-orm-jpa - SpringBoot 使用 JPA 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis - Spring 使用 MyBatis 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - SpringBoot 使用 MyBatis + Mapper + PageHelper 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - SpringBoot 连接多数据源，并使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - SpringBoot 使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n * Nosql\n   * spring-data-nosql-basics - Spring 访问各种 NoSQL 的示例。\n   * spring-data-nosql-mongodb - SpringBoot 访问 MongoDB 的示例。\n   * spring-data-nosql-redis - SpringBoot 访问 Redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - SpringBoot 访问 Elasticsearch 的示例。\n   * spring-data-nosql-hdfs - SpringBoot 访问 HDFS 的示例。\n * Cache\n   * spring-data-cache-basics - SpringBoot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - SpringBoot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - SpringBoot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - Spring 使用版本管理中间件 Flyway 示例。\n   * spring-data-middleware-sharding - Spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring 数据篇\n\n\n# 📖 内容\n\n * spring 之数据源\n * spring 之 jdbc\n * spring 之事务\n * spring 之 jpa\n * spring 集成 mybatis\n * spring 访问 redis\n * spring 访问 mongodb\n * spring 访问 elasticsearch\n\n\n# 💻 示例\n\n * jdbc\n   * spring-data-jdbc-basics - spring boot 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n   * spring-data-jdbc-druid - springboot 使用 druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - springboot 连接多数据源示例。\n   * spring-data-jdbc-xml - spring 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n * orm\n   * spring-data-orm-jpa - springboot 使用 jpa 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis - spring 使用 mybatis 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - springboot 使用 mybatis + mapper + pagehelper 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - springboot 连接多数据源，并使用 mybatis plus 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - springboot 使用 mybatis plus 作为 orm 框架访问数据库示例。\n * nosql\n   * spring-data-nosql-basics - spring 访问各种 nosql 的示例。\n   * spring-data-nosql-mongodb - springboot 访问 mongodb 的示例。\n   * spring-data-nosql-redis - springboot 访问 redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - springboot 访问 elasticsearch 的示例。\n   * spring-data-nosql-hdfs - springboot 访问 hdfs 的示例。\n * cache\n   * spring-data-cache-basics - springboot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - springboot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - springboot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - spring 使用版本管理中间件 flyway 示例。\n   * spring-data-middleware-sharding - spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 访问 Elasticsearch",frontmatter:{title:"Spring 访问 Elasticsearch",date:"2018-12-25T14:06:36.000Z",order:23,categories:["Java","框架","Spring","Spring数据"],tags:["Java","框架","Spring","SpringBoot","Elasticsearch"],permalink:"/pages/fac14c/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E6%95%B0%E6%8D%AE/23.Spring%E8%AE%BF%E9%97%AEElasticsearch.html",relativePath:"01.Java/13.框架/01.Spring/02.Spring数据/23.Spring访问Elasticsearch.md",key:"v-c6474816",path:"/pages/fac14c/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:30},{level:3,title:"通过 REST 客户端连接 Elasticsearch",slug:"通过-rest-客户端连接-elasticsearch",normalizedTitle:"通过 rest 客户端连接 elasticsearch",charIndex:72},{level:3,title:"通过 Jest 连接 Elasticsearch",slug:"通过-jest-连接-elasticsearch",normalizedTitle:"通过 jest 连接 elasticsearch",charIndex:660},{level:3,title:"通过 Spring Data 访问 Elasticsearch",slug:"通过-spring-data-访问-elasticsearch",normalizedTitle:"通过 spring data 访问 elasticsearch",charIndex:1321},{level:3,title:"Elasticsearch Repositories",slug:"elasticsearch-repositories",normalizedTitle:"elasticsearch repositories",charIndex:1852},{level:2,title:"源码",slug:"源码",normalizedTitle:"源码",charIndex:2013},{level:2,title:"版本",slug:"版本",normalizedTitle:"版本",charIndex:2111},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2914}],headersStr:"简介 通过 REST 客户端连接 Elasticsearch 通过 Jest 连接 Elasticsearch 通过 Spring Data 访问 Elasticsearch Elasticsearch Repositories 源码 版本 参考资料",content:"# Spring 访问 Elasticsearch\n\n\n# 简介\n\nElasticsearch 是一个开源的、分布式的搜索和分析引擎。\n\n\n# 通过 REST 客户端连接 Elasticsearch\n\n如果在 classpath 路径下存在 org.elasticsearch.client:elasticsearch-rest-client jar 包，Spring Boot 会自动配置并注册一个 RestClient Bean，它的默认访问路径为：localhost:9200。\n\n你可以使用如下方式进行定制：\n\nspring.elasticsearch.rest.uris=http://search.example.com:9200\nspring.elasticsearch.rest.username=user\nspring.elasticsearch.rest.password=secret\n\n\n您还可以注册实现任意数量的 RestClientBuilderCustomizer bean，以进行更高级的定制。要完全控制注册，请定义 RestClient bean。\n\n如果 classpath 路径有 org.elasticsearch.client：elasticsearch-rest-high-level-client jar 包，Spring Boot 将自动配置一个 RestHighLevelClient，它包装任何现有的 RestClient bean，重用其 HTTP 配置。\n\n\n# 通过 Jest 连接 Elasticsearch\n\n如果 classpath 上有 Jest，你可以注入一个自动配置的 JestClient，默认情况下是 localhost:9200。您可以进一步调整客户端的配置方式，如以下示例所示：\n\nspring.elasticsearch.jest.uris=http://search.example.com:9200\nspring.elasticsearch.jest.read-timeout=10000\nspring.elasticsearch.jest.username=user\nspring.elasticsearch.jest.password=secret\n\n\n您还可以注册实现任意数量的 HttpClientConfigBuilderCustomizer bean，以进行更高级的定制。以下示例调整为其他 HTTP 设置：\n\nstatic class HttpSettingsCustomizer implements HttpClientConfigBuilderCustomizer {\n\n\t@Override\n\tpublic void customize(HttpClientConfig.Builder builder) {\n\t\tbuilder.maxTotalConnection(100).defaultMaxTotalConnectionPerRoute(5);\n\t}\n\n}\n\n\n要完全控制注册，请定义 JestClient bean。\n\n\n# 通过 Spring Data 访问 Elasticsearch\n\n要连接到 Elasticsearch，您必须提供一个或多个集群节点的地址。可以通过将 spring.data.elasticsearch.cluster-nodes 属性设置为以逗号分隔的 host:port 列表来指定地址。使用此配置，可以像任何其他 Spring bean 一样注入 ElasticsearchTemplate 或 TransportClient，如以下示例所示：\n\nspring.data.elasticsearch.cluster-nodes=localhost:9300\n@Component\npublic class MyBean {\n\n\tprivate final ElasticsearchTemplate template;\n\n\tpublic MyBean(ElasticsearchTemplate template) {\n\t\tthis.template = template;\n\t}\n\n\t// ...\n\n}\n\n\n如果你添加了自定义的 ElasticsearchTemplate 或 TransportClient @Bean ，就会替换默认的配置。\n\n\n# Elasticsearch Repositories\n\nSpring Data 包含对 Elasticsearch 的 repository 支持。基本原则是根据方法名称自动为您构建查询。\n\n事实上，Spring Data JPA 和 Spring Data Elasticsearch 共享相同的通用基础架构。\n\n\n# 源码\n\n完整示例：源码\n\n使用方法：\n\nmvn clean package\ncd target\njava -jar spring-boot-data-elasticsearch.jar\n\n\n\n# 版本\n\nSpring 和 Elasticsearch 匹配版本：\n\nSPRING DATA ELASTICSEARCH   ELASTICSEARCH   SPRING FRAMEWORK   SPRING BOOT\n5.0.x                       8.5.3           6.0.x              3.0.x\n4.4.x                       7.17.3          5.3.x              2.7.x\n4.3.x                       7.15.2          5.3.x              2.6.x\n4.2.x[1]                    7.12.0          5.3.x              2.5.x\n4.1.x[1]                    7.9.3           5.3.2              2.4.x\n4.0.x[1]                    7.6.2           5.2.12             2.3.x\n3.2.x[1]                    6.8.12          5.2.12             2.2.x\n3.1.x[1]                    6.2.2           5.1.19             2.1.x\n3.0.x[1]                    5.5.0           5.0.13             2.0.x\n2.1.x[1]                    2.4.0           4.3.25             1.5.x\n\n\n# 参考资料\n\n * 官方\n   * Elasticsearch 官网\n   * Elasticsearch Github\n   * Elasticsearch 官方文档\n   * Elasticsearch: The Definitive Guide - ElasticSearch 官方学习资料\n * Spring Boot 官方文档之 boot-features-elasticsearch\n * Spring Data Elasticsearch Github\n * Spring Data Elasticsearch 官方文档",normalizedContent:"# spring 访问 elasticsearch\n\n\n# 简介\n\nelasticsearch 是一个开源的、分布式的搜索和分析引擎。\n\n\n# 通过 rest 客户端连接 elasticsearch\n\n如果在 classpath 路径下存在 org.elasticsearch.client:elasticsearch-rest-client jar 包，spring boot 会自动配置并注册一个 restclient bean，它的默认访问路径为：localhost:9200。\n\n你可以使用如下方式进行定制：\n\nspring.elasticsearch.rest.uris=http://search.example.com:9200\nspring.elasticsearch.rest.username=user\nspring.elasticsearch.rest.password=secret\n\n\n您还可以注册实现任意数量的 restclientbuildercustomizer bean，以进行更高级的定制。要完全控制注册，请定义 restclient bean。\n\n如果 classpath 路径有 org.elasticsearch.client：elasticsearch-rest-high-level-client jar 包，spring boot 将自动配置一个 resthighlevelclient，它包装任何现有的 restclient bean，重用其 http 配置。\n\n\n# 通过 jest 连接 elasticsearch\n\n如果 classpath 上有 jest，你可以注入一个自动配置的 jestclient，默认情况下是 localhost:9200。您可以进一步调整客户端的配置方式，如以下示例所示：\n\nspring.elasticsearch.jest.uris=http://search.example.com:9200\nspring.elasticsearch.jest.read-timeout=10000\nspring.elasticsearch.jest.username=user\nspring.elasticsearch.jest.password=secret\n\n\n您还可以注册实现任意数量的 httpclientconfigbuildercustomizer bean，以进行更高级的定制。以下示例调整为其他 http 设置：\n\nstatic class httpsettingscustomizer implements httpclientconfigbuildercustomizer {\n\n\t@override\n\tpublic void customize(httpclientconfig.builder builder) {\n\t\tbuilder.maxtotalconnection(100).defaultmaxtotalconnectionperroute(5);\n\t}\n\n}\n\n\n要完全控制注册，请定义 jestclient bean。\n\n\n# 通过 spring data 访问 elasticsearch\n\n要连接到 elasticsearch，您必须提供一个或多个集群节点的地址。可以通过将 spring.data.elasticsearch.cluster-nodes 属性设置为以逗号分隔的 host:port 列表来指定地址。使用此配置，可以像任何其他 spring bean 一样注入 elasticsearchtemplate 或 transportclient，如以下示例所示：\n\nspring.data.elasticsearch.cluster-nodes=localhost:9300\n@component\npublic class mybean {\n\n\tprivate final elasticsearchtemplate template;\n\n\tpublic mybean(elasticsearchtemplate template) {\n\t\tthis.template = template;\n\t}\n\n\t// ...\n\n}\n\n\n如果你添加了自定义的 elasticsearchtemplate 或 transportclient @bean ，就会替换默认的配置。\n\n\n# elasticsearch repositories\n\nspring data 包含对 elasticsearch 的 repository 支持。基本原则是根据方法名称自动为您构建查询。\n\n事实上，spring data jpa 和 spring data elasticsearch 共享相同的通用基础架构。\n\n\n# 源码\n\n完整示例：源码\n\n使用方法：\n\nmvn clean package\ncd target\njava -jar spring-boot-data-elasticsearch.jar\n\n\n\n# 版本\n\nspring 和 elasticsearch 匹配版本：\n\nspring data elasticsearch   elasticsearch   spring framework   spring boot\n5.0.x                       8.5.3           6.0.x              3.0.x\n4.4.x                       7.17.3          5.3.x              2.7.x\n4.3.x                       7.15.2          5.3.x              2.6.x\n4.2.x[1]                    7.12.0          5.3.x              2.5.x\n4.1.x[1]                    7.9.3           5.3.2              2.4.x\n4.0.x[1]                    7.6.2           5.2.12             2.3.x\n3.2.x[1]                    6.8.12          5.2.12             2.2.x\n3.1.x[1]                    6.2.2           5.1.19             2.1.x\n3.0.x[1]                    5.5.0           5.0.13             2.0.x\n2.1.x[1]                    2.4.0           4.3.25             1.5.x\n\n\n# 参考资料\n\n * 官方\n   * elasticsearch 官网\n   * elasticsearch github\n   * elasticsearch 官方文档\n   * elasticsearch: the definitive guide - elasticsearch 官方学习资料\n * spring boot 官方文档之 boot-features-elasticsearch\n * spring data elasticsearch github\n * spring data elasticsearch 官方文档",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring Web 综述",frontmatter:{title:"Spring Web 综述",date:"2017-11-08T16:53:27.000Z",categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","Web"],permalink:"/pages/65351b/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/01.SpringWeb%E7%BB%BC%E8%BF%B0.html",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/01.SpringWeb综述.md",key:"v-443c98b2",path:"/pages/65351b/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:20},{level:2,title:"SpringMVC 工作流程",slug:"springmvc-工作流程",normalizedTitle:"springmvc 工作流程",charIndex:1369},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2345}],headersStr:"快速入门 SpringMVC 工作流程 参考资料",content:'# Spring Web 综述\n\n\n# 快速入门\n\n下面，通过一个简单的示例来展示如何通过 Spring 创建一个 Hello World Web 服务。\n\n（1）pom.xml 中引入依赖\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\n（2）定义 Controller\n\nSpring 构建 RESTful 服务的方法，HTTP 请求由 Controller 处理。 这些组件由 @RestController 注解标识。\n\n【示例】下面的示例定义了一个处理 /greeting 的 GET 请求\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class GreetingController {\n\n    @GetMapping("/greeting")\n    public String greeting(@RequestParam(name = "name", required = false, defaultValue = "World") String name,\n        Model model) {\n        model.addAttribute("name", name);\n        return "greeting";\n    }\n\n}\n\n\n（3）创建启动类\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloWorldApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloWorldApplication.class);\n    }\n\n}\n\n\n（4）启动服务：执行 HelloWorldApplication.main 方法启动 web 服务\n\n（5）测试\n\n打开浏览器，访问 http://localhost:8080/greeting，页面会显示如下内容：\n\nHello, World!\n\n\n打开浏览器，访问 http://localhost:8080/greeting?name=dunwu，页面会显示如下内容：\n\nHello, dunwu!\n\n\n\n# SpringMVC 工作流程\n\nSpring MVC 的工作流程可以用一幅图来说明：\n\n\n\n 1. 向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。\n 2. DispatcherServlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。\n 3. DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(...)方法）。\n 4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\n    * HttpMessageConverter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。\n    * 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。\n 5. Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；\n 6. 根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。\n 7. ViewResolver 结合Model和View，来渲染视图。\n 8. 视图负责将渲染结果返回给客户端。\n\n\n# 参考资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3',normalizedContent:'# spring web 综述\n\n\n# 快速入门\n\n下面，通过一个简单的示例来展示如何通过 spring 创建一个 hello world web 服务。\n\n（1）pom.xml 中引入依赖\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\n（2）定义 controller\n\nspring 构建 restful 服务的方法，http 请求由 controller 处理。 这些组件由 @restcontroller 注解标识。\n\n【示例】下面的示例定义了一个处理 /greeting 的 get 请求\n\nimport org.springframework.stereotype.controller;\nimport org.springframework.ui.model;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.requestparam;\n\n@controller\npublic class greetingcontroller {\n\n    @getmapping("/greeting")\n    public string greeting(@requestparam(name = "name", required = false, defaultvalue = "world") string name,\n        model model) {\n        model.addattribute("name", name);\n        return "greeting";\n    }\n\n}\n\n\n（3）创建启动类\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\n\n@springbootapplication\npublic class helloworldapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(helloworldapplication.class);\n    }\n\n}\n\n\n（4）启动服务：执行 helloworldapplication.main 方法启动 web 服务\n\n（5）测试\n\n打开浏览器，访问 http://localhost:8080/greeting，页面会显示如下内容：\n\nhello, world!\n\n\n打开浏览器，访问 http://localhost:8080/greeting?name=dunwu，页面会显示如下内容：\n\nhello, dunwu!\n\n\n\n# springmvc 工作流程\n\nspring mvc 的工作流程可以用一幅图来说明：\n\n\n\n 1. 向服务器发送 http 请求，请求被前端控制器 dispatcherservlet 捕获。\n 2. dispatcherservlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 url 进行解析，得到请求资源标识符（uri）。然后根据该 uri，调用 handlermapping 获得该 handler 配置的所有相关的对象（包括 handler 对象以及 handler 对象对应的拦截器），最后以handlerexecutionchain 对象的形式返回。\n 3. dispatcherservlet 根据获得的handler，选择一个合适的 handleradapter。（附注：如果成功获得handleradapter后，此时将开始执行拦截器的 prehandler(...)方法）。\n 4. 提取request中的模型数据，填充handler入参，开始执行handler（controller)。 在填充handler的入参过程中，根据你的配置，spring 将帮你做一些额外的工作：\n    * httpmessageconverter： 将请求消息（如 json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如string转换成integer、double等。\n    * 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到bindingresult或error中。\n 5. handler(controller)执行完成后，向 dispatcherservlet 返回一个 modelandview 对象；\n 6. 根据返回的modelandview，选择一个适合的 viewresolver（必须是已经注册到 spring 容器中的viewresolver)返回给dispatcherservlet。\n 7. viewresolver 结合model和view，来渲染视图。\n 8. 视图负责将渲染结果返回给客户端。\n\n\n# 参考资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring Web 应用",frontmatter:{title:"Spring Web 应用",date:"2023-02-14T19:21:22.000Z",categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","Web","Controller"],permalink:"/pages/5d002f/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/02.SpringWeb%E5%BA%94%E7%94%A8.html",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/02.SpringWeb应用.md",key:"v-cab5a862",path:"/pages/5d002f/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:408},{level:2,title:"Spring Web 组件",slug:"spring-web-组件",normalizedTitle:"spring web 组件",charIndex:1757},{level:3,title:"组件扫描",slug:"组件扫描",normalizedTitle:"组件扫描",charIndex:1775},{level:3,title:"AOP 代理",slug:"aop-代理",normalizedTitle:"aop 代理",charIndex:2772},{level:3,title:"@Controller",slug:"controller",normalizedTitle:"@controller",charIndex:43},{level:3,title:"@RequestMapping",slug:"requestmapping",normalizedTitle:"@requestmapping",charIndex:3282},{level:4,title:"URI 模式",slug:"uri-模式",normalizedTitle:"uri 模式",charIndex:4093},{level:4,title:"模式比较",slug:"模式比较",normalizedTitle:"模式比较",charIndex:5919},{level:4,title:"后缀匹配",slug:"后缀匹配",normalizedTitle:"后缀匹配",charIndex:6288},{level:4,title:"后缀匹配和 RFD",slug:"后缀匹配和-rfd",normalizedTitle:"后缀匹配和 rfd",charIndex:6913},{level:4,title:"限定数据类型",slug:"限定数据类型",normalizedTitle:"限定数据类型",charIndex:7512},{level:4,title:"Producible Media Types",slug:"producible-media-types",normalizedTitle:"producible media types",charIndex:7831},{level:4,title:"参数、请求头",slug:"参数、请求头",normalizedTitle:"参数、请求头",charIndex:8202},{level:4,title:"HTTP HEAD, OPTIONS",slug:"http-head-options",normalizedTitle:"http head, options",charIndex:8589},{level:4,title:"自定义注解",slug:"自定义注解",normalizedTitle:"自定义注解",charIndex:3655},{level:4,title:"显示注册",slug:"显示注册",normalizedTitle:"显示注册",charIndex:9828},{level:2,title:"处理方法",slug:"处理方法",normalizedTitle:"处理方法",charIndex:10441},{level:3,title:"请求数据",slug:"请求数据",normalizedTitle:"请求数据",charIndex:10450},{level:3,title:"响应数据",slug:"响应数据",normalizedTitle:"响应数据",charIndex:10575},{level:2,title:"@ModelAttribute",slug:"modelattribute",normalizedTitle:"@modelattribute",charIndex:10697},{level:2,title:"@InitBinder",slug:"initbinder",normalizedTitle:"@initbinder",charIndex:11841},{level:2,title:"表单处理",slug:"表单处理",normalizedTitle:"表单处理",charIndex:14649},{level:3,title:"创建处理表单的 Controller",slug:"创建处理表单的-controller",normalizedTitle:"创建处理表单的 controller",charIndex:14658},{level:3,title:"定义需要提交的表单实体",slug:"定义需要提交的表单实体",normalizedTitle:"定义需要提交的表单实体",charIndex:15519},{level:3,title:"提交表单前端代码",slug:"提交表单前端代码",normalizedTitle:"提交表单前端代码",charIndex:15642},{level:2,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:16339},{level:3,title:"创建文件上传处理 Controller",slug:"创建文件上传处理-controller",normalizedTitle:"创建文件上传处理 controller",charIndex:16348},{level:3,title:"定义存储文件的 Service",slug:"定义存储文件的-service",normalizedTitle:"定义存储文件的 service",charIndex:19222},{level:3,title:"创建文件上传表单",slug:"创建文件上传表单",normalizedTitle:"创建文件上传表单",charIndex:22736},{level:3,title:"文件上传限制",slug:"文件上传限制",normalizedTitle:"文件上传限制",charIndex:23266},{level:2,title:"异常处理",slug:"异常处理",normalizedTitle:"异常处理",charIndex:92},{level:3,title:"@ExceptionHandler",slug:"exceptionhandler",normalizedTitle:"@exceptionhandler",charIndex:18664},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:25152}],headersStr:"快速入门 Spring Web 组件 组件扫描 AOP 代理 @Controller @RequestMapping URI 模式 模式比较 后缀匹配 后缀匹配和 RFD 限定数据类型 Producible Media Types 参数、请求头 HTTP HEAD, OPTIONS 自定义注解 显示注册 处理方法 请求数据 响应数据 @ModelAttribute @InitBinder 表单处理 创建处理表单的 Controller 定义需要提交的表单实体 提交表单前端代码 文件上传 创建文件上传处理 Controller 定义存储文件的 Service 创建文件上传表单 文件上传限制 异常处理 @ExceptionHandler 参考资料",content:'# Spring Web 应用\n\nSpring MVC 提供了一种基于注解的编程模型，@Controller 和 @RestController 组件使用注解来表达请求映射、请求输入、异常处理等。注解控制器具有灵活的方法签名，并且不必扩展基类或实现特定接口。以下示例显示了一个由注解定义的控制器：\n\n@Controller\npublic class HelloController {\n\n    @GetMapping("/hello")\n    public String handle(Model model) {\n        model.addAttribute("message", "Hello World!");\n        return "index";\n    }\n}\n\n\n在前面的示例中，该方法接受一个 Model 并以 String 形式返回一个视图名称，但还存在许多其他选项。\n\n\n# 快速入门\n\n下面，通过一个简单的示例来展示如何通过 Spring 创建一个 Hello World Web 服务。\n\n（1）pom.xml 中引入依赖\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n\n（2）定义 Controller\n\nSpring 构建 RESTful 服务的方法，HTTP 请求由 Controller 处理。 这些组件由 @RestController 注解标识。\n\n【示例】下面的示例定义了一个处理 /greeting 的 GET 请求\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class GreetingController {\n\n    @GetMapping("/greeting")\n    public String greeting(@RequestParam(name = "name", required = false, defaultValue = "World") String name,\n        Model model) {\n        model.addAttribute("name", name);\n        return "greeting";\n    }\n\n}\n\n\n（3）创建启动类\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloWorldApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloWorldApplication.class);\n    }\n\n}\n\n\n（4）启动服务：执行 HelloWorldApplication.main 方法启动 web 服务\n\n（5）测试\n\n打开浏览器，访问 http://localhost:8080/greeting，页面会显示如下内容：\n\nHello, World!\n\n\n打开浏览器，访问 http://localhost:8080/greeting?name=dunwu，页面会显示如下内容：\n\nHello, dunwu!\n\n\n\n# Spring Web 组件\n\n\n# 组件扫描\n\n可以使用 Servlet 的 WebApplicationContext 中的标准 Spring bean 定义来定义控制器。@Controller 构造型允许自动检测，与 Spring 对检测类路径中的 @Component 类并为它们自动注册 bean 定义的一般支持保持一致。它还充当带注解类的构造型，表明其作为 Web 组件的角色。\n\n要启用此类 @Controller 的自动检测，可以将组件扫描添加到您的 Java 配置中，如以下示例所示：\n\n@Configuration\n@ComponentScan("org.example.web")\npublic class WebConfig {\n\n    // ...\n}\n\n\n以下示例显示了与上述示例等效的 XML 配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:p="http://www.springframework.org/schema/p"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xsi:schemaLocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:component-scan base-package="org.example.web"/>\n\n    \x3c!-- ... --\x3e\n\n</beans>\n\n\n\n# AOP 代理\n\n在某些情况下，可能需要在运行时使用 AOP 代理装饰控制器。一个例子是，如果选择直接在控制器上使用 @Transactional 注解。在这种情况下，特别是对于控制器，建议使用基于类的代理。直接在控制器上使用此类注解会自动出现这种情况。\n\n如果控制器实现了一个接口，并且需要 AOP 代理，您可能需要显式配置基于类的代理。例如，对于 @EnableTransactionManagement ，可以更改为 @EnableTransactionManagement(proxyTargetClass = true)，对于 <tx:annotation-driven/> ，您可以更改为 <tx:annotation-driven proxy-target-class="true"/>。\n\n\n# @Controller\n\n@RestController 是一个组合注解，它本身使用 @Controller 和 @ResponseBody 元注解进行标记，以指示控制器的每个方法继承了类型级别的 @ResponseBody 注解，因此直接写入响应主体，而不是使用 HTML 模板进行视图解析和渲染。\n\n\n# @RequestMapping\n\n可以使用 @RequestMapping 注解将请求映射到控制器方法。它具有各种属性，可以通过 URL、HTTP 方法、请求参数、标头和媒体类型进行匹配。可以在类级别使用它来表达共享映射，或者在方法级别使用它来缩小到特定端点的映射。\n\n@RequestMapping 的主要参数：\n\n * path / method 指定映射路径与方法\n * params / headers 限定映射范围\n * consumes / produces 限定请求与响应格式\n\nSpring 还提供了以下 @RequestMapping 的变体：\n\n * @GetMapping\n * @PostMapping\n * @PutMapping\n * @DeleteMapping\n * @PatchMapping\n\n快捷方式是提供的自定义注解，因为可以说，大多数控制器方法应该映射到特定的 HTTP 方法，而不是使用 @RequestMapping，默认情况下，它与所有 HTTP 方法匹配。在类级别仍然需要 @RequestMapping 来表达共享映射。\n\n以下示例具有类型和方法级别的映射：\n\n@RestController\n@RequestMapping("/persons")\nclass PersonController {\n\n    @GetMapping("/{id}")\n    public Person getPerson(@PathVariable Long id) {\n        // ...\n    }\n\n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public void add(@RequestBody Person person) {\n        // ...\n    }\n}\n\n\n# URI 模式\n\n@RequestMapping 方法可以使用 URL 模式进行映射。有两种选择：\n\n * PathPattern - 与 URL 路径匹配的预解析模式也预解析为 PathContainer。该解决方案专为网络使用而设计，可有效处理编码和路径参数，并高效匹配。\n * AntPathMatcher - 根据字符串路径匹配字符串模式。这是在 Spring 配置中也使用的原始解决方案，用于在类路径、文件系统和其他位置选择资源。它的效率较低，并且字符串路径输入对于有效处理 URL 的编码和其他问题是一个挑战。\n\nPathPattern 是 Web 应用程序的推荐解决方案，它是 Spring WebFlux 中的唯一选择。它从 5.3 版开始在 Spring MVC 中使用，从 6.0 版开始默认启用。请参阅 MVC 配置 以自定义路径匹配选项。\n\nPathPattern 支持与 AntPathMatcher 相同的模式语法。此外，它还支持捕获模式，例如 {spring}，用于匹配路径末尾的 0 个或多个路径段。PathPattern 还限制使用 ** 来匹配多个路径段，这样它只允许出现在模式的末尾。这消除了在为给定请求选择最佳匹配模式时出现的许多歧义。有关完整模式语法，请参阅 PathPattern 和 AntPathMatcher。\n\n一些示例模式：\n\n * "/resources/ima?e.png" -匹配一个字符\n * "/resources/*.png" - 匹配零个或多个字符\n * "/resources/**" - 匹配多个字符\n * "/projects/{project}/versions" - 匹配路径段并将其捕获为变量\n * "/projects/{project:[a-z]+}/versions" - 使用正则表达式匹配并捕获变量\n\n可以使用 @PathVariable 访问捕获的 URI 变量。例如：\n\n@GetMapping("/owners/{ownerId}/pets/{petId}")\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n    // ...\n}\n\n\n可以在类和方法级别声明 URI 变量，如以下示例所示：\n\n@Controller\n@RequestMapping("/owners/{ownerId}")\npublic class OwnerController {\n\n    @GetMapping("/pets/{petId}")\n    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n        // ...\n    }\n}\n\n\nURI 变量会自动转换为适当的类型，否则会引发 TypeMismatchException。默认支持简单类型（int、long、Date 等），可以注册对任何其他数据类型的支持。请参见类型转换和 DataBinder。\n\n可以显式命名 URI 变量（例如，@PathVariable("customId")），但如果名称相同并且代码是使用 -parameters 编译器标志编译的，则可以省略该细节。\n\n语法 {varName:regex} 使用正则表达式声明一个 URI 变量。例如，给定 URL "/spring-web-3.0.5.jar"，以下方法提取名称、版本和文件扩展名：\n\n@GetMapping("/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}")\npublic void handle(@PathVariable String name, @PathVariable String version, @PathVariable String ext) {\n    // ...\n}\n\n\nURI 路径模式还可以嵌入 ${…} 占位符，这些占位符在启动时通过使用 PropertySourcesPlaceholderConfigurer 针对本地、系统、环境和其他属性源进行解析。例如，可以使用它来根据某些外部配置参数化基本 URL。\n\n# 模式比较\n\n当多个模式匹配一个 URL 时，必须选择最佳匹配。这是通过以下方式之一完成的，具体取决于是否启用了已解析的 PathPattern 以供使用：\n\n * PathPattern.SPECIFICITY_COMPARATOR\n * AntPathMatcher.getPatternComparator(String path)\n\n两者都有助于对模式进行排序，更具体的模式位于顶部。如果模式具有较少的 URI 变量（计为 1）、单通配符（计为 1）和双通配符（计为 2），则模式不太具体。如果得分相同，则选择较长的模式。给定相同的分数和长度，选择 URI 变量多于通配符的模式。\n\n默认映射模式 (/**) 被排除在评分之外并始终排在最后。此外，前缀模式（例如 /public/**）被认为不如其他没有双通配符的模式具体。\n\n# 后缀匹配\n\n从 5.3 开始，默认情况下 Spring MVC 不再执行 .* 后缀模式匹配，其中映射到 person 的控制器也隐式映射到 /person.*。因此，路径扩展不再用于解释请求的响应内容类型⟩——例如，/person.pdf、/person.xml 等。\n\n当浏览器过去发送难以一致解释的 Accept 请求头时，以这种方式使用文件扩展名是必要的。现在，这不再是必需的，使用 Accept 请求头应该是首选。\n\n随着时间的推移，文件扩展名的使用在很多方面都被证明是有问题的。当使用 URI 变量、路径参数和 URI 编码覆盖时，它可能会导致歧义。关于基于 URL 的授权和安全性的推理也变得更加困难。\n\n要在 5.3 之前的版本中完全禁用路径扩展，请设置以下内容：\n\n * useSuffixPatternMatching(false) - 参考：PathMatchConfigurer\n * favorPathExtension(false) - 参考：ContentNegotiationConfigurer\n\n除了通过 Accept 请求头之外，还有一种请求内容类型的方法仍然有用，例如在浏览器中键入 URL 时。路径扩展的一种安全替代方法是使用查询参数策略。如果您必须使用文件扩展名，请考虑通过 ContentNegotiationConfigurer 的 mediaTypes 属性将它们限制为明确注册的扩展名列表。\n\n# 后缀匹配和 RFD\n\n反射文件下载 (RFD) 攻击与 XSS 类似，因为它依赖于响应中反映的请求输入（例如，查询参数和 URI 变量）。然而，RFD 攻击不是将 JavaScript 插入 HTML，而是依赖于浏览器切换来执行下载，并在稍后双击时将响应视为可执行脚本。\n\n在 Spring MVC 中，@ResponseBody 和 ResponseEntity 方法存在风险，因为它们可以渲染不同的内容类型，客户端可以通过 URL 路径扩展请求这些内容类型。禁用后缀模式匹配并使用路径扩展进行内容协商可以降低风险，但不足以防止 RFD 攻击。\n\n为了防止 RFD 攻击，在渲染响应主体之前，Spring MVC 添加了一个 Content-Disposition:inline;filename=f.txt 头以建议一个固定且安全的下载文件。仅当 URL 路径包含的文件扩展名既不安全也不明确注册用于内容协商时，才会执行此操作。但是，当 URL 直接输入浏览器时，它可能会产生副作用。\n\n默认情况下，允许许多常见的路径扩展是安全的。具有自定义 HttpMessageConverter 实现的应用程序可以显式注册文件扩展名以进行内容协商，以避免为这些扩展名添加 Content-Disposition 头。请参阅 内容类型。\n\n关于 RFD 更多细节推荐参考 CVE-2015-5211\n\n# 限定数据类型\n\n您可以根据请求的 Content-Type 缩小请求映射，如以下示例所示：\n\n@PostMapping(path = "/pets", consumes = "application/json")\npublic void addPet(@RequestBody Pet pet) {\n    // ...\n}\n\n\nconsumes 属性还支持否定表达式 - 例如，!textplain 表示除 textplain 之外的任何内容类型。\n\n您可以在类级别声明一个共享的 consumes 属性。然而，与大多数其他请求映射属性不同的是，当在类级别使用时，方法级别的 consumes 属性会覆盖而不是扩展类级别的声明。\n\n# Producible Media Types\n\n可以根据 Accept 请求头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：\n\n@GetMapping(path = "/pets/{petId}", produces = "application/json")\n@ResponseBody\npublic Pet getPet(@PathVariable String petId) {\n    // ...\n}\n\n\n媒体类型可以指定一个字符集。支持否定表达式——例如，!textplain 表示除 "text/plain" 之外的任何内容类型。\n\n可以在类级别声明一个共享的 produces 属性。然而，与大多数其他请求映射属性不同，当在类级别使用时，方法级别的 produces 属性会覆盖而不是扩展类级别的声明。\n\n# 参数、请求头\n\n可以根据请求参数条件缩小请求映射范围。可以测试是否存在请求参数 (myParam)、是否缺少请求参数 (!myParam) 或特定值 (myParam=myValue)。以下示例显示如何测试特定值：\n\n@GetMapping(path = "/pets/{petId}", params = "myParam=myValue")\npublic void findPet(@PathVariable String petId) {\n    // ...\n}\n\n\n还可以使用相同的请求头条件，如以下示例所示：\n\n@GetMapping(path = "/pets", headers = "myHeader=myValue")\npublic void findPet(@PathVariable String petId) {\n    // ...\n}\n\n\n# HTTP HEAD, OPTIONS\n\n@GetMapping（和 @RequestMapping(method=HttpMethod.GET)）透明地支持 HTTP HEAD 以进行请求映射。控制器方法不需要改变。在 jakarta.servlet.http.HttpServlet 中应用的响应包装器确保将 Content-Length 头设置为写入的字节数（实际上没有写入响应）。\n\n@GetMapping（和@RequestMapping(method=HttpMethod.GET)）被隐式映射并支持 HTTP HEAD。HTTP HEAD 请求的处理方式就好像它是 HTTP GET 一样，除了不写入正文，而是计算字节数并设置 Content-Length 头。\n\n默认情况下，通过将 Allow 响应头设置为所有具有匹配 URL 模式的 @RequestMapping 方法中列出的 HTTP 方法列表来处理 HTTP OPTIONS。\n\n对于没有 HTTP 方法声明的 @RequestMapping ，Allow 头设置为 GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS。控制器方法应始终声明支持的 HTTP 方法（例如，通过使用 HTTP 方法特定变体：@GetMapping、@PostMapping 等）。\n\nYou can explicitly map the @RequestMapping method to HTTP HEAD and HTTP OPTIONS, but that is not necessary in the common case.\n\n可以显式地将 @RequestMapping 方法映射到 HTTP HEAD 和 HTTP OPTIONS，但在常见情况下这不是必需的。\n\n# 自定义注解\n\nSpring MVC 支持使用组合注解 进行请求映射。这些注解本身是用 @RequestMapping 进行元注解的，并且组合起来重新声明 @RequestMapping 属性的一个子集（或全部），具有更明确的目的。\n\n@GetMapping、@PostMapping、@PutMapping、@DeleteMapping 和 @PatchMapping 是组合注解的示例。提供它们是因为，可以说，大多数控制器方法应该映射到特定的 HTTP 方法，而不是使用 @RequestMapping，默认情况下，它与所有 HTTP 方法匹配。如果您需要组合注解的示例，请查看这些注解的声明方式。\n\nSpring MVC 还支持具有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要继承 RequestMappingHandlerMapping 并覆盖 getCustomMethodCondition 方法，您可以在其中检查自定义属性并返回您自己的 RequestCondition。\n\n# 显示注册\n\n您可以以编程方式注册处理程序方法，您可以将其用于动态注册或高级情况，例如不同 URL 下的同一处理程序的不同实例。以下示例注册了一个处理程序方法\n\n@Configuration\npublic class MyConfig {\n\n    @Autowired\n    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler)\n            throws NoSuchMethodException {\n\n        RequestMappingInfo info = RequestMappingInfo\n                .paths("/user/{id}").methods(RequestMethod.GET).build();\n\n        Method method = UserHandler.class.getMethod("getUser", Long.class);\n\n        mapping.registerMapping(info, handler, method);\n    }\n}\n\n\n 1. 为控制器注入目标处理程序和处理程序映射。\n\n 2. 准备请求映射元数据。\n\n 3. 获取处理程序方法。\n\n 4. 添加注册。\n\n\n# 处理方法\n\n\n# 请求数据\n\n * @RequestParam\n\n * @RequestBody\n\n * @PathVariable\n\n * @RequestHeader\n\n> 更多 Spring Web 方法参数可以参考： Method Arguments\n\n\n# 响应数据\n\n * @ResponseBody\n\n * @ResponseStatus\n\n * ResponseEntity\n\n * HttpEntity\n\n> 更多 Spring Web 方法返回值可以参考：Return Values\n\n\n# @ModelAttribute\n\n可以使用 @ModelAttribute 注解：\n\n * 在 @RequestMapping 方法中的方法参数上，用于模型创建或访问对象，并通过 WebDataBinder 将其绑定到请求。\n * 作为 @Controller 或 @ControllerAdvice 类中的方法级注解，有助于在任何 @RequestMapping 方法调用之前初始化模型。\n * 在 @RequestMapping 方法上标记它的返回值是一个模型属性。\n\n本节讨论 @ModelAttribute 方法——前面列表中的第二项。一个控制器可以有任意数量的 @ModelAttribute 方法。所有这些方法都在同一控制器中的 @RequestMapping 方法之前被调用。@ModelAttribute 方法也可以通过 @ControllerAdvice 在控制器之间共享。\n\n@ModelAttribute 方法具有灵活的方法签名。它们支持许多与 @RequestMapping 方法相同的参数，除了 @ModelAttribute 本身或与请求主体相关的任何内容。\n\n以下示例显示了 @ModelAttribute 方法：\n\n@ModelAttribute\npublic void populateModel(@RequestParam String number, Model model) {\n    model.addAttribute(accountRepository.findAccount(number));\n    // add more ...\n}\n\n\n以下示例仅添加一个属性：\n\n@ModelAttribute\npublic Account addAccount(@RequestParam String number) {\n    return accountRepository.findAccount(number);\n}\n\n\n还可以将 @ModelAttribute 用作 @RequestMapping 方法上的方法级注解，在这种情况下，@RequestMapping 方法的返回值被解释为模型属性。这通常不是必需的，因为它是 HTML 控制器中的默认行为，除非返回值是一个 String 否则将被解释为视图名称。 @ModelAttribute 还可以自定义模型属性名称，如下例所示：\n\n@GetMapping("/accounts/{id}")\n@ModelAttribute("myAccount")\npublic Account handle() {\n    // ...\n    return account;\n}\n\n\n\n# @InitBinder\n\n@Controller 或 @ControllerAdvice 类可以用 @InitBinder 方法来初始化 WebDataBinder 的实例，而这些方法又可以：\n\n * 将请求参数（即表单或查询数据）绑定到模型对象。\n * 将基于字符串的请求值（例如请求参数、路径变量、标头、cookie 等）转换为控制器方法参数的目标类型。\n * 在渲染 HTML 表单时将模型对象值格式化为 String 值。\n\n@InitBinder 方法可以注册指定控制器 java.beans.PropertyEditor 或 Spring Converter 和 Formatter 组件。此外，您可以使用 MVC 配置 在全局共享的 FormattingConversionService 中注册 Converter 和 Formatter 类型。\n\n@InitBinder 方法支持许多与 @RequestMapping 方法相同的参数，除了 @ModelAttribute（命令对象）参数。通常，它们使用 WebDataBinder 参数（用于注册）和 void 返回值声明。下面展示了一个示例：\n\n@Controller\npublic class FormController {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");\n        dateFormat.setLenient(false);\n        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n    }\n\n    // ...\n}\n\n\n或者，当您通过共享的 FormattingConversionService 使用基于 Formatter 的设置时，您可以重复使用相同的方法并注册指定控制器的 Formatter 实现，如以下示例所示：\n\n@Controller\npublic class FormController {\n\n    @InitBinder\n    protected void initBinder(WebDataBinder binder) {\n        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));\n    }\n\n    // ...\n}\n\n\n在 Web 应用程序的上下文中，数据绑定涉及将 HTTP 请求参数（即表单数据或查询参数）绑定到模型对象及其嵌套对象中的属性。\n\n仅公开遵循 JavaBeans 命名约定 的 public 属性用于数据绑定——例如，firstName 属性的 get/set 方法：public String getFirstName() 和 public void setFirstName(String)。\n\n默认情况下，Spring 允许绑定到模型对象图中的所有公共属性。这意味着您需要仔细考虑模型具有哪些公共属性，因为客户端可以将任何公共属性路径作为目标，甚至是一些预计不会针对给定用例的公共属性路径。\n\n例如，给定一个 HTTP 表单数据端点，恶意客户端可以为存在于模型对象图中但不属于浏览器中显示的 HTML 表单的属性提供值。这可能导致在模型对象及其任何嵌套对象上设置数据，这些数据预计不会更新。\n\n荐的方法是使用一个专用模型对象，它只公开与表单提交相关的属性。例如，在用于更改用户电子邮件地址的表单上，模型对象应声明最少的一组属性，例如以下 ChangeEmailForm。\n\npublic class ChangeEmailForm {\n\n    private String oldEmailAddress;\n    private String newEmailAddress;\n\n    public void setOldEmailAddress(String oldEmailAddress) {\n        this.oldEmailAddress = oldEmailAddress;\n    }\n\n    public String getOldEmailAddress() {\n        return this.oldEmailAddress;\n    }\n\n    public void setNewEmailAddress(String newEmailAddress) {\n        this.newEmailAddress = newEmailAddress;\n    }\n\n    public String getNewEmailAddress() {\n        return this.newEmailAddress;\n    }\n\n}\n\n\n如果您不能或不想为每个数据绑定用例使用专用模型对象，则必须限制允许用于数据绑定的属性。理想情况下，可以通过 WebDataBinder 上的 setAllowedFields() 方法注册允许的字段模式 来实现这一点。\n\n例如，要在您的应用程序中注册允许的字段模式，您可以在 @Controller 或 @ControllerAdvice 组件中实现 @InitBinder 方法，如下所示：\n\n@Controller\npublic class ChangeEmailController {\n\n    @InitBinder\n    void initBinder(WebDataBinder binder) {\n        binder.setAllowedFields("oldEmailAddress", "newEmailAddress");\n    }\n\n    // @RequestMapping methods, etc.\n\n}\n\n\n除了注册允许的模式外，还可以通过 DataBinder及其子类中的 setDisallowedFields() 方法注册 允许的字段模式。但是请注意，“允许列表”比“拒绝列表”更安全。因此，setAllowedFields() 应该优于 setDisallowedFields()。\n\n请注意，匹配允许的字段模式是区分大小写的；然而，与不允许的字段模式匹配是不区分大小写的。此外，匹配不允许的模式的字段将不会被接受，即使它也恰好匹配允许列表中的模式。\n\n\n# 表单处理\n\n\n# 创建处理表单的 Controller\n\nGreetingController 通过返回视图的名称处理 /greeting 的 GET 请求，这意味着返回的内容是名为 greeting.html 的视图内容。\n\ngreetingForm() 方法是通过使用 @GetMapping 专门映射到 GET 请求的，而 greetingSubmit() 是通过 @PostMapping 映射到 POST 请求的。\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.PostMapping;\n\n@Controller\npublic class GreetingController {\n\n  @GetMapping("/greeting")\n  public String greetingForm(Model model) {\n    model.addAttribute("greeting", new Greeting());\n    return "greeting";\n  }\n\n  @PostMapping("/greeting")\n  public String greetingSubmit(@ModelAttribute Greeting greeting, Model model) {\n    model.addAttribute("greeting", greeting);\n    return "result";\n  }\n\n}\n\n\n\n# 定义需要提交的表单实体\n\nimport lombok.Data;\n\n@Data\npublic class Greeting {\n\n    private long id;\n\n    private String content;\n\n}\n\n\n\n# 提交表单前端代码\n\n提交实体的页面必须依赖某种视图技术，通过将视图名称转换为模板进行渲染，从而对HTML进行服务端渲染。在下面的例子中，使用了 Thymeleaf 模板引擎作为视图，它解析 greeting.html 的各种模板表达式以渲染表单。\n\n<!DOCTYPE html>\n<html xmlns:th="https://www.thymeleaf.org">\n  <head>\n    <title>Getting Started: Handling Form Submission</title>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n  </head>\n  <body>\n    <h1>Form</h1>\n    <form action="#" th:action="@{/greeting}" th:object="${greeting}" method="post">\n      <p>Id: <input type="text" th:field="*{id}" /></p>\n      <p>Message: <input type="text" th:field="*{content}" /></p>\n      <p><input type="submit" value="Submit" /> <input type="reset" value="Reset" /></p>\n    </form>\n  </body>\n</html>\n\n\n\n# 文件上传\n\n\n# 创建文件上传处理 Controller\n\nimport java.io.IOException;\nimport java.util.stream.Collectors;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.Resource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\nimport com.example.uploadingfiles.storage.StorageFileNotFoundException;\nimport com.example.uploadingfiles.storage.StorageService;\n\n@Controller\npublic class FileUploadController {\n\n\tprivate final StorageService storageService;\n\n\t@Autowired\n\tpublic FileUploadController(StorageService storageService) {\n\t\tthis.storageService = storageService;\n\t}\n\n\t@GetMapping("/")\n\tpublic String listUploadedFiles(Model model) throws IOException {\n\n\t\tmodel.addAttribute("files", storageService.loadAll().map(\n\t\t\t\tpath -> MvcUriComponentsBuilder.fromMethodName(FileUploadController.class,\n\t\t\t\t\t\t"serveFile", path.getFileName().toString()).build().toUri().toString())\n\t\t\t\t.collect(Collectors.toList()));\n\n\t\treturn "uploadForm";\n\t}\n\n\t@GetMapping("/files/{filename:.+}")\n\t@ResponseBody\n\tpublic ResponseEntity<Resource> serveFile(@PathVariable String filename) {\n\n\t\tResource file = storageService.loadAsResource(filename);\n\t\treturn ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION,\n\t\t\t\t"attachment; filename=\\"" + file.getFilename() + "\\"").body(file);\n\t}\n\n\t@PostMapping("/")\n\tpublic String handleFileUpload(@RequestParam("file") MultipartFile file,\n\t\t\tRedirectAttributes redirectAttributes) {\n\n\t\tstorageService.store(file);\n\t\tredirectAttributes.addFlashAttribute("message",\n\t\t\t\t"You successfully uploaded " + file.getOriginalFilename() + "!");\n\n\t\treturn "redirect:/";\n\t}\n\n\t@ExceptionHandler(StorageFileNotFoundException.class)\n\tpublic ResponseEntity<?> handleStorageFileNotFound(StorageFileNotFoundException exc) {\n\t\treturn ResponseEntity.notFound().build();\n\t}\n\n}\n\n\nFileUploadController 类使用 @Controller 注解，以便 Spring 可以扫描并注册它。 每个方法都标有 @GetMapping 或 @PostMapping ，将路径和 HTTP 操作映射到指定的控制器。\n\n在这种情况下：\n\n * GET /：从 StorageService 中查找当前上传文件的列表，并将其加载到 Thymeleaf 模板中。 它使用 MvcUriComponentsBuilder 计算指向实际资源的链接。\n\n * GET /files/{filename}：加载资源（如果存在）并使用 Content-Disposition 响应标头将其发送到浏览器进行下载。\n\n * POST /：处理一个多部分的消息文件，并将其交给 StorageService 进行保存。\n\n\n# 定义存储文件的 Service\n\nimport org.springframework.core.io.Resource;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.nio.file.Path;\nimport java.util.stream.Stream;\n\npublic interface StorageService {\n\n\tvoid init();\n\n\tvoid store(MultipartFile file);\n\n\tStream<Path> loadAll();\n\n\tPath load(String filename);\n\n\tResource loadAsResource(String filename);\n\n\tvoid deleteAll();\n\n}\n\n\n一个加单的 StorageService 实现：\n\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.UrlResource;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.FileSystemUtils;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.stream.Stream;\n\n@Service\npublic class FileSystemStorageServiceImpl implements StorageService {\n\n    private final Path rootLocation;\n\n    @Autowired\n    public FileSystemStorageServiceImpl(StorageProperties properties) {\n        this.rootLocation = Paths.get(properties.getLocation());\n    }\n\n    @Override\n    public void deleteAll() {\n        FileSystemUtils.deleteRecursively(rootLocation.toFile());\n    }\n\n    @Override\n    public void init() {\n        try {\n            Files.createDirectories(rootLocation);\n        } catch (IOException e) {\n            throw new StorageException("Could not initialize storage", e);\n        }\n    }\n\n    @Override\n    public Path load(String filename) {\n        return rootLocation.resolve(filename);\n    }\n\n    @Override\n    public Stream<Path> loadAll() {\n        try {\n            return Files.walk(this.rootLocation, 1).filter(path -> !path.equals(this.rootLocation))\n                .map(this.rootLocation::relativize);\n        } catch (IOException e) {\n            throw new StorageException("Failed to read stored files", e);\n        }\n    }\n\n    @Override\n    public Resource loadAsResource(String filename) {\n        try {\n            Path file = load(filename);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            } else {\n                throw new StorageFileNotFoundException("Could not read file: " + filename);\n            }\n        } catch (MalformedURLException e) {\n            throw new StorageFileNotFoundException("Could not read file: " + filename, e);\n        }\n    }\n\n    @Override\n    public void store(MultipartFile file) {\n        String filename = StringUtils.cleanPath(file.getOriginalFilename());\n        try {\n            if (file.isEmpty()) {\n                throw new StorageException("Failed to store empty file " + filename);\n            }\n            if (filename.contains("..")) {\n                // This is a security check\n                throw new StorageException(\n                    "Cannot store file with relative path outside current directory " + filename);\n            }\n            try (InputStream inputStream = file.getInputStream()) {\n                Files.copy(inputStream, this.rootLocation.resolve(filename), StandardCopyOption.REPLACE_EXISTING);\n            }\n        } catch (IOException e) {\n            throw new StorageException("Failed to store file " + filename, e);\n        }\n    }\n\n}\n\n\n\n# 创建文件上传表单\n\n<html xmlns:th="https://www.thymeleaf.org">\n<body>\n\n\t<div th:if="${message}">\n\t\t<h2 th:text="${message}"/>\n\t</div>\n\n\t<div>\n\t\t<form method="POST" enctype="multipart/form-data" action="/">\n\t\t\t<table>\n\t\t\t\t<tr><td>File to upload:</td><td><input type="file" name="file" /></td></tr>\n\t\t\t\t<tr><td></td><td><input type="submit" value="Upload" /></td></tr>\n\t\t\t</table>\n\t\t</form>\n\t</div>\n\n\t<div>\n\t\t<ul>\n\t\t\t<li th:each="file : ${files}">\n\t\t\t\t<a th:href="${file}" th:text="${file}" />\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n\n</body>\n</html>\n\n\n\n# 文件上传限制\n\n如果使用 Spring Boot，可以使用一些属性设置来调整其自动配置的 MultipartConfigElement。\n\n将以下属性添加到现有属性设置中（在 src/main/resources/application.properties 中）：\n\nspring.servlet.multipart.max-file-size=128KB\nspring.servlet.multipart.max-request-size=128KB\n\n\n * spring.servlet.multipart.max-file-size 设置为 128KB，表示总文件大小不能超过 128KB。\n * spring.servlet.multipart.max-request-size 设置为 128KB，这意味着 multipart/form-data 的总请求大小不能超过 128KB。\n\n\n# 异常处理\n\n\n# @ExceptionHandler\n\n@Controller 和 @ControllerAdvice 类可以用 @ExceptionHandler 方法来处理来自控制器方法的异常，如以下示例所示：\n\n@Controller\npublic class SimpleController {\n\n    // ...\n\n    @ExceptionHandler\n    public ResponseEntity<String> handle(IOException ex) {\n        // ...\n    }\n}\n\n\n异常可能与正在传播的顶级异常（例如，抛出直接的 IOException）或包装器异常中的嵌套原因（例如，包装在 IllegalStateException 中的 IOException）相匹配。从 5.3 开始，这可以匹配任意原因级别，而以前只考虑直接原因。\n\n对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根异常匹配通常优先于原因异常匹配。更具体地说，ExceptionDepthComparator 用于根据抛出的异常类型的深度对异常进行排序。\n\n或者，注解声明可以缩小要匹配的异常类型，如以下示例所示：\n\n@ExceptionHandler({FileSystemException.class, RemoteException.class})\npublic ResponseEntity<String> handle(IOException ex) {\n    // ...\n}\n\n\n您甚至可以使用具有非常通用的参数签名的特定异常类型列表，如以下示例所示：\n\n@ExceptionHandler({FileSystemException.class, RemoteException.class})\npublic ResponseEntity<String> handle(Exception ex) {\n    // ...\n}\n\n\n通常建议您在参数签名中尽可能具体，以减少根本和原因异常类型之间不匹配的可能性。考虑将一个多重匹配方法分解为单独的 @ExceptionHandler 方法，每个方法通过其签名匹配一个特定的异常类型。\n\n在多 @ControllerAdvice 安排中，建议在具有相应顺序优先级的 @ControllerAdvice 上声明您的主要根异常映射。虽然根异常匹配优于原因，但这是在给定控制器或 @ControllerAdvice 类的方法中定义的。这意味着优先级较高的 @ControllerAdvice 上的原因匹配优于优先级较低的 @ControllerAdvice 上的任何匹配（例如，root）。\n\n最后但同样重要的是， @ExceptionHandler 方法实现可以选择通过以原始形式重新抛出给定异常实例来退出处理。这在您只对根级匹配或无法静态确定的特定上下文中的匹配感兴趣的情况下很有用。重新抛出的异常通过剩余的解析链传播，就好像给定的 @ExceptionHandler 方法一开始就不会匹配一样。\n\nSpring MVC 中对 @ExceptionHandler 方法的支持建立在 DispatcherServlet 级别 HandlerExceptionResolver 机制上。\n\n> 附录：\n> \n> @ExceptionHandler 支持的参数\n> \n> @ExceptionHandler 支持返回值\n\n\n# 参考资料\n\n * Spring Framework 官方文档\n * Spring Framework 官方文档之 Web',normalizedContent:'# spring web 应用\n\nspring mvc 提供了一种基于注解的编程模型，@controller 和 @restcontroller 组件使用注解来表达请求映射、请求输入、异常处理等。注解控制器具有灵活的方法签名，并且不必扩展基类或实现特定接口。以下示例显示了一个由注解定义的控制器：\n\n@controller\npublic class hellocontroller {\n\n    @getmapping("/hello")\n    public string handle(model model) {\n        model.addattribute("message", "hello world!");\n        return "index";\n    }\n}\n\n\n在前面的示例中，该方法接受一个 model 并以 string 形式返回一个视图名称，但还存在许多其他选项。\n\n\n# 快速入门\n\n下面，通过一个简单的示例来展示如何通过 spring 创建一个 hello world web 服务。\n\n（1）pom.xml 中引入依赖\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n\n（2）定义 controller\n\nspring 构建 restful 服务的方法，http 请求由 controller 处理。 这些组件由 @restcontroller 注解标识。\n\n【示例】下面的示例定义了一个处理 /greeting 的 get 请求\n\nimport org.springframework.stereotype.controller;\nimport org.springframework.ui.model;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.requestparam;\n\n@controller\npublic class greetingcontroller {\n\n    @getmapping("/greeting")\n    public string greeting(@requestparam(name = "name", required = false, defaultvalue = "world") string name,\n        model model) {\n        model.addattribute("name", name);\n        return "greeting";\n    }\n\n}\n\n\n（3）创建启动类\n\nimport org.springframework.boot.springapplication;\nimport org.springframework.boot.autoconfigure.springbootapplication;\n\n@springbootapplication\npublic class helloworldapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(helloworldapplication.class);\n    }\n\n}\n\n\n（4）启动服务：执行 helloworldapplication.main 方法启动 web 服务\n\n（5）测试\n\n打开浏览器，访问 http://localhost:8080/greeting，页面会显示如下内容：\n\nhello, world!\n\n\n打开浏览器，访问 http://localhost:8080/greeting?name=dunwu，页面会显示如下内容：\n\nhello, dunwu!\n\n\n\n# spring web 组件\n\n\n# 组件扫描\n\n可以使用 servlet 的 webapplicationcontext 中的标准 spring bean 定义来定义控制器。@controller 构造型允许自动检测，与 spring 对检测类路径中的 @component 类并为它们自动注册 bean 定义的一般支持保持一致。它还充当带注解类的构造型，表明其作为 web 组件的角色。\n\n要启用此类 @controller 的自动检测，可以将组件扫描添加到您的 java 配置中，如以下示例所示：\n\n@configuration\n@componentscan("org.example.web")\npublic class webconfig {\n\n    // ...\n}\n\n\n以下示例显示了与上述示例等效的 xml 配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:p="http://www.springframework.org/schema/p"\n    xmlns:context="http://www.springframework.org/schema/context"\n    xsi:schemalocation="\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:component-scan base-package="org.example.web"/>\n\n    \x3c!-- ... --\x3e\n\n</beans>\n\n\n\n# aop 代理\n\n在某些情况下，可能需要在运行时使用 aop 代理装饰控制器。一个例子是，如果选择直接在控制器上使用 @transactional 注解。在这种情况下，特别是对于控制器，建议使用基于类的代理。直接在控制器上使用此类注解会自动出现这种情况。\n\n如果控制器实现了一个接口，并且需要 aop 代理，您可能需要显式配置基于类的代理。例如，对于 @enabletransactionmanagement ，可以更改为 @enabletransactionmanagement(proxytargetclass = true)，对于 <tx:annotation-driven/> ，您可以更改为 <tx:annotation-driven proxy-target-class="true"/>。\n\n\n# @controller\n\n@restcontroller 是一个组合注解，它本身使用 @controller 和 @responsebody 元注解进行标记，以指示控制器的每个方法继承了类型级别的 @responsebody 注解，因此直接写入响应主体，而不是使用 html 模板进行视图解析和渲染。\n\n\n# @requestmapping\n\n可以使用 @requestmapping 注解将请求映射到控制器方法。它具有各种属性，可以通过 url、http 方法、请求参数、标头和媒体类型进行匹配。可以在类级别使用它来表达共享映射，或者在方法级别使用它来缩小到特定端点的映射。\n\n@requestmapping 的主要参数：\n\n * path / method 指定映射路径与方法\n * params / headers 限定映射范围\n * consumes / produces 限定请求与响应格式\n\nspring 还提供了以下 @requestmapping 的变体：\n\n * @getmapping\n * @postmapping\n * @putmapping\n * @deletemapping\n * @patchmapping\n\n快捷方式是提供的自定义注解，因为可以说，大多数控制器方法应该映射到特定的 http 方法，而不是使用 @requestmapping，默认情况下，它与所有 http 方法匹配。在类级别仍然需要 @requestmapping 来表达共享映射。\n\n以下示例具有类型和方法级别的映射：\n\n@restcontroller\n@requestmapping("/persons")\nclass personcontroller {\n\n    @getmapping("/{id}")\n    public person getperson(@pathvariable long id) {\n        // ...\n    }\n\n    @postmapping\n    @responsestatus(httpstatus.created)\n    public void add(@requestbody person person) {\n        // ...\n    }\n}\n\n\n# uri 模式\n\n@requestmapping 方法可以使用 url 模式进行映射。有两种选择：\n\n * pathpattern - 与 url 路径匹配的预解析模式也预解析为 pathcontainer。该解决方案专为网络使用而设计，可有效处理编码和路径参数，并高效匹配。\n * antpathmatcher - 根据字符串路径匹配字符串模式。这是在 spring 配置中也使用的原始解决方案，用于在类路径、文件系统和其他位置选择资源。它的效率较低，并且字符串路径输入对于有效处理 url 的编码和其他问题是一个挑战。\n\npathpattern 是 web 应用程序的推荐解决方案，它是 spring webflux 中的唯一选择。它从 5.3 版开始在 spring mvc 中使用，从 6.0 版开始默认启用。请参阅 mvc 配置 以自定义路径匹配选项。\n\npathpattern 支持与 antpathmatcher 相同的模式语法。此外，它还支持捕获模式，例如 {spring}，用于匹配路径末尾的 0 个或多个路径段。pathpattern 还限制使用 ** 来匹配多个路径段，这样它只允许出现在模式的末尾。这消除了在为给定请求选择最佳匹配模式时出现的许多歧义。有关完整模式语法，请参阅 pathpattern 和 antpathmatcher。\n\n一些示例模式：\n\n * "/resources/ima?e.png" -匹配一个字符\n * "/resources/*.png" - 匹配零个或多个字符\n * "/resources/**" - 匹配多个字符\n * "/projects/{project}/versions" - 匹配路径段并将其捕获为变量\n * "/projects/{project:[a-z]+}/versions" - 使用正则表达式匹配并捕获变量\n\n可以使用 @pathvariable 访问捕获的 uri 变量。例如：\n\n@getmapping("/owners/{ownerid}/pets/{petid}")\npublic pet findpet(@pathvariable long ownerid, @pathvariable long petid) {\n    // ...\n}\n\n\n可以在类和方法级别声明 uri 变量，如以下示例所示：\n\n@controller\n@requestmapping("/owners/{ownerid}")\npublic class ownercontroller {\n\n    @getmapping("/pets/{petid}")\n    public pet findpet(@pathvariable long ownerid, @pathvariable long petid) {\n        // ...\n    }\n}\n\n\nuri 变量会自动转换为适当的类型，否则会引发 typemismatchexception。默认支持简单类型（int、long、date 等），可以注册对任何其他数据类型的支持。请参见类型转换和 databinder。\n\n可以显式命名 uri 变量（例如，@pathvariable("customid")），但如果名称相同并且代码是使用 -parameters 编译器标志编译的，则可以省略该细节。\n\n语法 {varname:regex} 使用正则表达式声明一个 uri 变量。例如，给定 url "/spring-web-3.0.5.jar"，以下方法提取名称、版本和文件扩展名：\n\n@getmapping("/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}")\npublic void handle(@pathvariable string name, @pathvariable string version, @pathvariable string ext) {\n    // ...\n}\n\n\nuri 路径模式还可以嵌入 ${…} 占位符，这些占位符在启动时通过使用 propertysourcesplaceholderconfigurer 针对本地、系统、环境和其他属性源进行解析。例如，可以使用它来根据某些外部配置参数化基本 url。\n\n# 模式比较\n\n当多个模式匹配一个 url 时，必须选择最佳匹配。这是通过以下方式之一完成的，具体取决于是否启用了已解析的 pathpattern 以供使用：\n\n * pathpattern.specificity_comparator\n * antpathmatcher.getpatterncomparator(string path)\n\n两者都有助于对模式进行排序，更具体的模式位于顶部。如果模式具有较少的 uri 变量（计为 1）、单通配符（计为 1）和双通配符（计为 2），则模式不太具体。如果得分相同，则选择较长的模式。给定相同的分数和长度，选择 uri 变量多于通配符的模式。\n\n默认映射模式 (/**) 被排除在评分之外并始终排在最后。此外，前缀模式（例如 /public/**）被认为不如其他没有双通配符的模式具体。\n\n# 后缀匹配\n\n从 5.3 开始，默认情况下 spring mvc 不再执行 .* 后缀模式匹配，其中映射到 person 的控制器也隐式映射到 /person.*。因此，路径扩展不再用于解释请求的响应内容类型⟩——例如，/person.pdf、/person.xml 等。\n\n当浏览器过去发送难以一致解释的 accept 请求头时，以这种方式使用文件扩展名是必要的。现在，这不再是必需的，使用 accept 请求头应该是首选。\n\n随着时间的推移，文件扩展名的使用在很多方面都被证明是有问题的。当使用 uri 变量、路径参数和 uri 编码覆盖时，它可能会导致歧义。关于基于 url 的授权和安全性的推理也变得更加困难。\n\n要在 5.3 之前的版本中完全禁用路径扩展，请设置以下内容：\n\n * usesuffixpatternmatching(false) - 参考：pathmatchconfigurer\n * favorpathextension(false) - 参考：contentnegotiationconfigurer\n\n除了通过 accept 请求头之外，还有一种请求内容类型的方法仍然有用，例如在浏览器中键入 url 时。路径扩展的一种安全替代方法是使用查询参数策略。如果您必须使用文件扩展名，请考虑通过 contentnegotiationconfigurer 的 mediatypes 属性将它们限制为明确注册的扩展名列表。\n\n# 后缀匹配和 rfd\n\n反射文件下载 (rfd) 攻击与 xss 类似，因为它依赖于响应中反映的请求输入（例如，查询参数和 uri 变量）。然而，rfd 攻击不是将 javascript 插入 html，而是依赖于浏览器切换来执行下载，并在稍后双击时将响应视为可执行脚本。\n\n在 spring mvc 中，@responsebody 和 responseentity 方法存在风险，因为它们可以渲染不同的内容类型，客户端可以通过 url 路径扩展请求这些内容类型。禁用后缀模式匹配并使用路径扩展进行内容协商可以降低风险，但不足以防止 rfd 攻击。\n\n为了防止 rfd 攻击，在渲染响应主体之前，spring mvc 添加了一个 content-disposition:inline;filename=f.txt 头以建议一个固定且安全的下载文件。仅当 url 路径包含的文件扩展名既不安全也不明确注册用于内容协商时，才会执行此操作。但是，当 url 直接输入浏览器时，它可能会产生副作用。\n\n默认情况下，允许许多常见的路径扩展是安全的。具有自定义 httpmessageconverter 实现的应用程序可以显式注册文件扩展名以进行内容协商，以避免为这些扩展名添加 content-disposition 头。请参阅 内容类型。\n\n关于 rfd 更多细节推荐参考 cve-2015-5211\n\n# 限定数据类型\n\n您可以根据请求的 content-type 缩小请求映射，如以下示例所示：\n\n@postmapping(path = "/pets", consumes = "application/json")\npublic void addpet(@requestbody pet pet) {\n    // ...\n}\n\n\nconsumes 属性还支持否定表达式 - 例如，!textplain 表示除 textplain 之外的任何内容类型。\n\n您可以在类级别声明一个共享的 consumes 属性。然而，与大多数其他请求映射属性不同的是，当在类级别使用时，方法级别的 consumes 属性会覆盖而不是扩展类级别的声明。\n\n# producible media types\n\n可以根据 accept 请求头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：\n\n@getmapping(path = "/pets/{petid}", produces = "application/json")\n@responsebody\npublic pet getpet(@pathvariable string petid) {\n    // ...\n}\n\n\n媒体类型可以指定一个字符集。支持否定表达式——例如，!textplain 表示除 "text/plain" 之外的任何内容类型。\n\n可以在类级别声明一个共享的 produces 属性。然而，与大多数其他请求映射属性不同，当在类级别使用时，方法级别的 produces 属性会覆盖而不是扩展类级别的声明。\n\n# 参数、请求头\n\n可以根据请求参数条件缩小请求映射范围。可以测试是否存在请求参数 (myparam)、是否缺少请求参数 (!myparam) 或特定值 (myparam=myvalue)。以下示例显示如何测试特定值：\n\n@getmapping(path = "/pets/{petid}", params = "myparam=myvalue")\npublic void findpet(@pathvariable string petid) {\n    // ...\n}\n\n\n还可以使用相同的请求头条件，如以下示例所示：\n\n@getmapping(path = "/pets", headers = "myheader=myvalue")\npublic void findpet(@pathvariable string petid) {\n    // ...\n}\n\n\n# http head, options\n\n@getmapping（和 @requestmapping(method=httpmethod.get)）透明地支持 http head 以进行请求映射。控制器方法不需要改变。在 jakarta.servlet.http.httpservlet 中应用的响应包装器确保将 content-length 头设置为写入的字节数（实际上没有写入响应）。\n\n@getmapping（和@requestmapping(method=httpmethod.get)）被隐式映射并支持 http head。http head 请求的处理方式就好像它是 http get 一样，除了不写入正文，而是计算字节数并设置 content-length 头。\n\n默认情况下，通过将 allow 响应头设置为所有具有匹配 url 模式的 @requestmapping 方法中列出的 http 方法列表来处理 http options。\n\n对于没有 http 方法声明的 @requestmapping ，allow 头设置为 get,head,post,put,patch,delete,options。控制器方法应始终声明支持的 http 方法（例如，通过使用 http 方法特定变体：@getmapping、@postmapping 等）。\n\nyou can explicitly map the @requestmapping method to http head and http options, but that is not necessary in the common case.\n\n可以显式地将 @requestmapping 方法映射到 http head 和 http options，但在常见情况下这不是必需的。\n\n# 自定义注解\n\nspring mvc 支持使用组合注解 进行请求映射。这些注解本身是用 @requestmapping 进行元注解的，并且组合起来重新声明 @requestmapping 属性的一个子集（或全部），具有更明确的目的。\n\n@getmapping、@postmapping、@putmapping、@deletemapping 和 @patchmapping 是组合注解的示例。提供它们是因为，可以说，大多数控制器方法应该映射到特定的 http 方法，而不是使用 @requestmapping，默认情况下，它与所有 http 方法匹配。如果您需要组合注解的示例，请查看这些注解的声明方式。\n\nspring mvc 还支持具有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要继承 requestmappinghandlermapping 并覆盖 getcustommethodcondition 方法，您可以在其中检查自定义属性并返回您自己的 requestcondition。\n\n# 显示注册\n\n您可以以编程方式注册处理程序方法，您可以将其用于动态注册或高级情况，例如不同 url 下的同一处理程序的不同实例。以下示例注册了一个处理程序方法\n\n@configuration\npublic class myconfig {\n\n    @autowired\n    public void sethandlermapping(requestmappinghandlermapping mapping, userhandler handler)\n            throws nosuchmethodexception {\n\n        requestmappinginfo info = requestmappinginfo\n                .paths("/user/{id}").methods(requestmethod.get).build();\n\n        method method = userhandler.class.getmethod("getuser", long.class);\n\n        mapping.registermapping(info, handler, method);\n    }\n}\n\n\n 1. 为控制器注入目标处理程序和处理程序映射。\n\n 2. 准备请求映射元数据。\n\n 3. 获取处理程序方法。\n\n 4. 添加注册。\n\n\n# 处理方法\n\n\n# 请求数据\n\n * @requestparam\n\n * @requestbody\n\n * @pathvariable\n\n * @requestheader\n\n> 更多 spring web 方法参数可以参考： method arguments\n\n\n# 响应数据\n\n * @responsebody\n\n * @responsestatus\n\n * responseentity\n\n * httpentity\n\n> 更多 spring web 方法返回值可以参考：return values\n\n\n# @modelattribute\n\n可以使用 @modelattribute 注解：\n\n * 在 @requestmapping 方法中的方法参数上，用于模型创建或访问对象，并通过 webdatabinder 将其绑定到请求。\n * 作为 @controller 或 @controlleradvice 类中的方法级注解，有助于在任何 @requestmapping 方法调用之前初始化模型。\n * 在 @requestmapping 方法上标记它的返回值是一个模型属性。\n\n本节讨论 @modelattribute 方法——前面列表中的第二项。一个控制器可以有任意数量的 @modelattribute 方法。所有这些方法都在同一控制器中的 @requestmapping 方法之前被调用。@modelattribute 方法也可以通过 @controlleradvice 在控制器之间共享。\n\n@modelattribute 方法具有灵活的方法签名。它们支持许多与 @requestmapping 方法相同的参数，除了 @modelattribute 本身或与请求主体相关的任何内容。\n\n以下示例显示了 @modelattribute 方法：\n\n@modelattribute\npublic void populatemodel(@requestparam string number, model model) {\n    model.addattribute(accountrepository.findaccount(number));\n    // add more ...\n}\n\n\n以下示例仅添加一个属性：\n\n@modelattribute\npublic account addaccount(@requestparam string number) {\n    return accountrepository.findaccount(number);\n}\n\n\n还可以将 @modelattribute 用作 @requestmapping 方法上的方法级注解，在这种情况下，@requestmapping 方法的返回值被解释为模型属性。这通常不是必需的，因为它是 html 控制器中的默认行为，除非返回值是一个 string 否则将被解释为视图名称。 @modelattribute 还可以自定义模型属性名称，如下例所示：\n\n@getmapping("/accounts/{id}")\n@modelattribute("myaccount")\npublic account handle() {\n    // ...\n    return account;\n}\n\n\n\n# @initbinder\n\n@controller 或 @controlleradvice 类可以用 @initbinder 方法来初始化 webdatabinder 的实例，而这些方法又可以：\n\n * 将请求参数（即表单或查询数据）绑定到模型对象。\n * 将基于字符串的请求值（例如请求参数、路径变量、标头、cookie 等）转换为控制器方法参数的目标类型。\n * 在渲染 html 表单时将模型对象值格式化为 string 值。\n\n@initbinder 方法可以注册指定控制器 java.beans.propertyeditor 或 spring converter 和 formatter 组件。此外，您可以使用 mvc 配置 在全局共享的 formattingconversionservice 中注册 converter 和 formatter 类型。\n\n@initbinder 方法支持许多与 @requestmapping 方法相同的参数，除了 @modelattribute（命令对象）参数。通常，它们使用 webdatabinder 参数（用于注册）和 void 返回值声明。下面展示了一个示例：\n\n@controller\npublic class formcontroller {\n\n    @initbinder\n    public void initbinder(webdatabinder binder) {\n        simpledateformat dateformat = new simpledateformat("yyyy-mm-dd");\n        dateformat.setlenient(false);\n        binder.registercustomeditor(date.class, new customdateeditor(dateformat, false));\n    }\n\n    // ...\n}\n\n\n或者，当您通过共享的 formattingconversionservice 使用基于 formatter 的设置时，您可以重复使用相同的方法并注册指定控制器的 formatter 实现，如以下示例所示：\n\n@controller\npublic class formcontroller {\n\n    @initbinder\n    protected void initbinder(webdatabinder binder) {\n        binder.addcustomformatter(new dateformatter("yyyy-mm-dd"));\n    }\n\n    // ...\n}\n\n\n在 web 应用程序的上下文中，数据绑定涉及将 http 请求参数（即表单数据或查询参数）绑定到模型对象及其嵌套对象中的属性。\n\n仅公开遵循 javabeans 命名约定 的 public 属性用于数据绑定——例如，firstname 属性的 get/set 方法：public string getfirstname() 和 public void setfirstname(string)。\n\n默认情况下，spring 允许绑定到模型对象图中的所有公共属性。这意味着您需要仔细考虑模型具有哪些公共属性，因为客户端可以将任何公共属性路径作为目标，甚至是一些预计不会针对给定用例的公共属性路径。\n\n例如，给定一个 http 表单数据端点，恶意客户端可以为存在于模型对象图中但不属于浏览器中显示的 html 表单的属性提供值。这可能导致在模型对象及其任何嵌套对象上设置数据，这些数据预计不会更新。\n\n荐的方法是使用一个专用模型对象，它只公开与表单提交相关的属性。例如，在用于更改用户电子邮件地址的表单上，模型对象应声明最少的一组属性，例如以下 changeemailform。\n\npublic class changeemailform {\n\n    private string oldemailaddress;\n    private string newemailaddress;\n\n    public void setoldemailaddress(string oldemailaddress) {\n        this.oldemailaddress = oldemailaddress;\n    }\n\n    public string getoldemailaddress() {\n        return this.oldemailaddress;\n    }\n\n    public void setnewemailaddress(string newemailaddress) {\n        this.newemailaddress = newemailaddress;\n    }\n\n    public string getnewemailaddress() {\n        return this.newemailaddress;\n    }\n\n}\n\n\n如果您不能或不想为每个数据绑定用例使用专用模型对象，则必须限制允许用于数据绑定的属性。理想情况下，可以通过 webdatabinder 上的 setallowedfields() 方法注册允许的字段模式 来实现这一点。\n\n例如，要在您的应用程序中注册允许的字段模式，您可以在 @controller 或 @controlleradvice 组件中实现 @initbinder 方法，如下所示：\n\n@controller\npublic class changeemailcontroller {\n\n    @initbinder\n    void initbinder(webdatabinder binder) {\n        binder.setallowedfields("oldemailaddress", "newemailaddress");\n    }\n\n    // @requestmapping methods, etc.\n\n}\n\n\n除了注册允许的模式外，还可以通过 databinder及其子类中的 setdisallowedfields() 方法注册 允许的字段模式。但是请注意，“允许列表”比“拒绝列表”更安全。因此，setallowedfields() 应该优于 setdisallowedfields()。\n\n请注意，匹配允许的字段模式是区分大小写的；然而，与不允许的字段模式匹配是不区分大小写的。此外，匹配不允许的模式的字段将不会被接受，即使它也恰好匹配允许列表中的模式。\n\n\n# 表单处理\n\n\n# 创建处理表单的 controller\n\ngreetingcontroller 通过返回视图的名称处理 /greeting 的 get 请求，这意味着返回的内容是名为 greeting.html 的视图内容。\n\ngreetingform() 方法是通过使用 @getmapping 专门映射到 get 请求的，而 greetingsubmit() 是通过 @postmapping 映射到 post 请求的。\n\nimport org.springframework.stereotype.controller;\nimport org.springframework.ui.model;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.modelattribute;\nimport org.springframework.web.bind.annotation.postmapping;\n\n@controller\npublic class greetingcontroller {\n\n  @getmapping("/greeting")\n  public string greetingform(model model) {\n    model.addattribute("greeting", new greeting());\n    return "greeting";\n  }\n\n  @postmapping("/greeting")\n  public string greetingsubmit(@modelattribute greeting greeting, model model) {\n    model.addattribute("greeting", greeting);\n    return "result";\n  }\n\n}\n\n\n\n# 定义需要提交的表单实体\n\nimport lombok.data;\n\n@data\npublic class greeting {\n\n    private long id;\n\n    private string content;\n\n}\n\n\n\n# 提交表单前端代码\n\n提交实体的页面必须依赖某种视图技术，通过将视图名称转换为模板进行渲染，从而对html进行服务端渲染。在下面的例子中，使用了 thymeleaf 模板引擎作为视图，它解析 greeting.html 的各种模板表达式以渲染表单。\n\n<!doctype html>\n<html xmlns:th="https://www.thymeleaf.org">\n  <head>\n    <title>getting started: handling form submission</title>\n    <meta http-equiv="content-type" content="text/html; charset=utf-8" />\n  </head>\n  <body>\n    <h1>form</h1>\n    <form action="#" th:action="@{/greeting}" th:object="${greeting}" method="post">\n      <p>id: <input type="text" th:field="*{id}" /></p>\n      <p>message: <input type="text" th:field="*{content}" /></p>\n      <p><input type="submit" value="submit" /> <input type="reset" value="reset" /></p>\n    </form>\n  </body>\n</html>\n\n\n\n# 文件上传\n\n\n# 创建文件上传处理 controller\n\nimport java.io.ioexception;\nimport java.util.stream.collectors;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.core.io.resource;\nimport org.springframework.http.httpheaders;\nimport org.springframework.http.responseentity;\nimport org.springframework.stereotype.controller;\nimport org.springframework.ui.model;\nimport org.springframework.web.bind.annotation.exceptionhandler;\nimport org.springframework.web.bind.annotation.getmapping;\nimport org.springframework.web.bind.annotation.pathvariable;\nimport org.springframework.web.bind.annotation.postmapping;\nimport org.springframework.web.bind.annotation.requestparam;\nimport org.springframework.web.bind.annotation.responsebody;\nimport org.springframework.web.multipart.multipartfile;\nimport org.springframework.web.servlet.mvc.method.annotation.mvcuricomponentsbuilder;\nimport org.springframework.web.servlet.mvc.support.redirectattributes;\n\nimport com.example.uploadingfiles.storage.storagefilenotfoundexception;\nimport com.example.uploadingfiles.storage.storageservice;\n\n@controller\npublic class fileuploadcontroller {\n\n\tprivate final storageservice storageservice;\n\n\t@autowired\n\tpublic fileuploadcontroller(storageservice storageservice) {\n\t\tthis.storageservice = storageservice;\n\t}\n\n\t@getmapping("/")\n\tpublic string listuploadedfiles(model model) throws ioexception {\n\n\t\tmodel.addattribute("files", storageservice.loadall().map(\n\t\t\t\tpath -> mvcuricomponentsbuilder.frommethodname(fileuploadcontroller.class,\n\t\t\t\t\t\t"servefile", path.getfilename().tostring()).build().touri().tostring())\n\t\t\t\t.collect(collectors.tolist()));\n\n\t\treturn "uploadform";\n\t}\n\n\t@getmapping("/files/{filename:.+}")\n\t@responsebody\n\tpublic responseentity<resource> servefile(@pathvariable string filename) {\n\n\t\tresource file = storageservice.loadasresource(filename);\n\t\treturn responseentity.ok().header(httpheaders.content_disposition,\n\t\t\t\t"attachment; filename=\\"" + file.getfilename() + "\\"").body(file);\n\t}\n\n\t@postmapping("/")\n\tpublic string handlefileupload(@requestparam("file") multipartfile file,\n\t\t\tredirectattributes redirectattributes) {\n\n\t\tstorageservice.store(file);\n\t\tredirectattributes.addflashattribute("message",\n\t\t\t\t"you successfully uploaded " + file.getoriginalfilename() + "!");\n\n\t\treturn "redirect:/";\n\t}\n\n\t@exceptionhandler(storagefilenotfoundexception.class)\n\tpublic responseentity<?> handlestoragefilenotfound(storagefilenotfoundexception exc) {\n\t\treturn responseentity.notfound().build();\n\t}\n\n}\n\n\nfileuploadcontroller 类使用 @controller 注解，以便 spring 可以扫描并注册它。 每个方法都标有 @getmapping 或 @postmapping ，将路径和 http 操作映射到指定的控制器。\n\n在这种情况下：\n\n * get /：从 storageservice 中查找当前上传文件的列表，并将其加载到 thymeleaf 模板中。 它使用 mvcuricomponentsbuilder 计算指向实际资源的链接。\n\n * get /files/{filename}：加载资源（如果存在）并使用 content-disposition 响应标头将其发送到浏览器进行下载。\n\n * post /：处理一个多部分的消息文件，并将其交给 storageservice 进行保存。\n\n\n# 定义存储文件的 service\n\nimport org.springframework.core.io.resource;\nimport org.springframework.web.multipart.multipartfile;\n\nimport java.nio.file.path;\nimport java.util.stream.stream;\n\npublic interface storageservice {\n\n\tvoid init();\n\n\tvoid store(multipartfile file);\n\n\tstream<path> loadall();\n\n\tpath load(string filename);\n\n\tresource loadasresource(string filename);\n\n\tvoid deleteall();\n\n}\n\n\n一个加单的 storageservice 实现：\n\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.core.io.resource;\nimport org.springframework.core.io.urlresource;\nimport org.springframework.stereotype.service;\nimport org.springframework.util.filesystemutils;\nimport org.springframework.util.stringutils;\nimport org.springframework.web.multipart.multipartfile;\n\nimport java.io.ioexception;\nimport java.io.inputstream;\nimport java.net.malformedurlexception;\nimport java.nio.file.files;\nimport java.nio.file.path;\nimport java.nio.file.paths;\nimport java.nio.file.standardcopyoption;\nimport java.util.stream.stream;\n\n@service\npublic class filesystemstorageserviceimpl implements storageservice {\n\n    private final path rootlocation;\n\n    @autowired\n    public filesystemstorageserviceimpl(storageproperties properties) {\n        this.rootlocation = paths.get(properties.getlocation());\n    }\n\n    @override\n    public void deleteall() {\n        filesystemutils.deleterecursively(rootlocation.tofile());\n    }\n\n    @override\n    public void init() {\n        try {\n            files.createdirectories(rootlocation);\n        } catch (ioexception e) {\n            throw new storageexception("could not initialize storage", e);\n        }\n    }\n\n    @override\n    public path load(string filename) {\n        return rootlocation.resolve(filename);\n    }\n\n    @override\n    public stream<path> loadall() {\n        try {\n            return files.walk(this.rootlocation, 1).filter(path -> !path.equals(this.rootlocation))\n                .map(this.rootlocation::relativize);\n        } catch (ioexception e) {\n            throw new storageexception("failed to read stored files", e);\n        }\n    }\n\n    @override\n    public resource loadasresource(string filename) {\n        try {\n            path file = load(filename);\n            resource resource = new urlresource(file.touri());\n            if (resource.exists() || resource.isreadable()) {\n                return resource;\n            } else {\n                throw new storagefilenotfoundexception("could not read file: " + filename);\n            }\n        } catch (malformedurlexception e) {\n            throw new storagefilenotfoundexception("could not read file: " + filename, e);\n        }\n    }\n\n    @override\n    public void store(multipartfile file) {\n        string filename = stringutils.cleanpath(file.getoriginalfilename());\n        try {\n            if (file.isempty()) {\n                throw new storageexception("failed to store empty file " + filename);\n            }\n            if (filename.contains("..")) {\n                // this is a security check\n                throw new storageexception(\n                    "cannot store file with relative path outside current directory " + filename);\n            }\n            try (inputstream inputstream = file.getinputstream()) {\n                files.copy(inputstream, this.rootlocation.resolve(filename), standardcopyoption.replace_existing);\n            }\n        } catch (ioexception e) {\n            throw new storageexception("failed to store file " + filename, e);\n        }\n    }\n\n}\n\n\n\n# 创建文件上传表单\n\n<html xmlns:th="https://www.thymeleaf.org">\n<body>\n\n\t<div th:if="${message}">\n\t\t<h2 th:text="${message}"/>\n\t</div>\n\n\t<div>\n\t\t<form method="post" enctype="multipart/form-data" action="/">\n\t\t\t<table>\n\t\t\t\t<tr><td>file to upload:</td><td><input type="file" name="file" /></td></tr>\n\t\t\t\t<tr><td></td><td><input type="submit" value="upload" /></td></tr>\n\t\t\t</table>\n\t\t</form>\n\t</div>\n\n\t<div>\n\t\t<ul>\n\t\t\t<li th:each="file : ${files}">\n\t\t\t\t<a th:href="${file}" th:text="${file}" />\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n\n</body>\n</html>\n\n\n\n# 文件上传限制\n\n如果使用 spring boot，可以使用一些属性设置来调整其自动配置的 multipartconfigelement。\n\n将以下属性添加到现有属性设置中（在 src/main/resources/application.properties 中）：\n\nspring.servlet.multipart.max-file-size=128kb\nspring.servlet.multipart.max-request-size=128kb\n\n\n * spring.servlet.multipart.max-file-size 设置为 128kb，表示总文件大小不能超过 128kb。\n * spring.servlet.multipart.max-request-size 设置为 128kb，这意味着 multipart/form-data 的总请求大小不能超过 128kb。\n\n\n# 异常处理\n\n\n# @exceptionhandler\n\n@controller 和 @controlleradvice 类可以用 @exceptionhandler 方法来处理来自控制器方法的异常，如以下示例所示：\n\n@controller\npublic class simplecontroller {\n\n    // ...\n\n    @exceptionhandler\n    public responseentity<string> handle(ioexception ex) {\n        // ...\n    }\n}\n\n\n异常可能与正在传播的顶级异常（例如，抛出直接的 ioexception）或包装器异常中的嵌套原因（例如，包装在 illegalstateexception 中的 ioexception）相匹配。从 5.3 开始，这可以匹配任意原因级别，而以前只考虑直接原因。\n\n对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根异常匹配通常优先于原因异常匹配。更具体地说，exceptiondepthcomparator 用于根据抛出的异常类型的深度对异常进行排序。\n\n或者，注解声明可以缩小要匹配的异常类型，如以下示例所示：\n\n@exceptionhandler({filesystemexception.class, remoteexception.class})\npublic responseentity<string> handle(ioexception ex) {\n    // ...\n}\n\n\n您甚至可以使用具有非常通用的参数签名的特定异常类型列表，如以下示例所示：\n\n@exceptionhandler({filesystemexception.class, remoteexception.class})\npublic responseentity<string> handle(exception ex) {\n    // ...\n}\n\n\n通常建议您在参数签名中尽可能具体，以减少根本和原因异常类型之间不匹配的可能性。考虑将一个多重匹配方法分解为单独的 @exceptionhandler 方法，每个方法通过其签名匹配一个特定的异常类型。\n\n在多 @controlleradvice 安排中，建议在具有相应顺序优先级的 @controlleradvice 上声明您的主要根异常映射。虽然根异常匹配优于原因，但这是在给定控制器或 @controlleradvice 类的方法中定义的。这意味着优先级较高的 @controlleradvice 上的原因匹配优于优先级较低的 @controlleradvice 上的任何匹配（例如，root）。\n\n最后但同样重要的是， @exceptionhandler 方法实现可以选择通过以原始形式重新抛出给定异常实例来退出处理。这在您只对根级匹配或无法静态确定的特定上下文中的匹配感兴趣的情况下很有用。重新抛出的异常通过剩余的解析链传播，就好像给定的 @exceptionhandler 方法一开始就不会匹配一样。\n\nspring mvc 中对 @exceptionhandler 方法的支持建立在 dispatcherservlet 级别 handlerexceptionresolver 机制上。\n\n> 附录：\n> \n> @exceptionhandler 支持的参数\n> \n> @exceptionhandler 支持返回值\n\n\n# 参考资料\n\n * spring framework 官方文档\n * spring framework 官方文档之 web',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring MVC 之 DispatcherServlet",frontmatter:{title:"Spring MVC 之 DispatcherServlet",date:"2023-02-13T09:57:52.000Z",categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","Web","DispatcherServlet"],permalink:"/pages/20287b/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/03.DispatcherServlet.html",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/03.DispatcherServlet.md",key:"v-06bc9c3d",path:"/pages/20287b/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:37},{level:3,title:"DispatcherServlet 工作原理",slug:"dispatcherservlet-工作原理",normalizedTitle:"dispatcherservlet 工作原理",charIndex:122},{level:4,title:"DispatcherServlet 工作流程",slug:"dispatcherservlet-工作流程",normalizedTitle:"dispatcherservlet 工作流程",charIndex:148},{level:4,title:"DispatcherServlet 源码解读",slug:"dispatcherservlet-源码解读",normalizedTitle:"dispatcherservlet 源码解读",charIndex:1746},{level:4,title:"上下文层次结构",slug:"上下文层次结构",normalizedTitle:"上下文层次结构",charIndex:7585},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:361},{level:2,title:"路径匹配",slug:"路径匹配",normalizedTitle:"路径匹配",charIndex:15347},{level:2,title:"拦截器",slug:"拦截器",normalizedTitle:"拦截器",charIndex:654},{level:2,title:"解析器",slug:"解析器",normalizedTitle:"解析器",charIndex:17433},{level:3,title:"HandlerExceptionResolver",slug:"handlerexceptionresolver",normalizedTitle:"handlerexceptionresolver",charIndex:2242},{level:4,title:"解析器链",slug:"解析器链",normalizedTitle:"解析器链",charIndex:18596},{level:4,title:"错误页面",slug:"错误页面",normalizedTitle:"错误页面",charIndex:18284},{level:3,title:"ViewResolver",slug:"viewresolver",normalizedTitle:"viewresolver",charIndex:1619},{level:4,title:"处理",slug:"处理",normalizedTitle:"处理",charIndex:105},{level:4,title:"重定向",slug:"重定向",normalizedTitle:"重定向",charIndex:21549},{level:4,title:"转发",slug:"转发",normalizedTitle:"转发",charIndex:10836},{level:4,title:"内容协商",slug:"内容协商",normalizedTitle:"内容协商",charIndex:22111},{level:3,title:"LocaleResolver",slug:"localeresolver",normalizedTitle:"localeresolver",charIndex:455},{level:4,title:"LocaleResolver",slug:"localeresolver-2",normalizedTitle:"localeresolver",charIndex:455},{level:4,title:"标头解析器",slug:"标头解析器",normalizedTitle:"标头解析器",charIndex:23361},{level:4,title:"CookieLocaleResolver",slug:"cookielocaleresolver",normalizedTitle:"cookielocaleresolver",charIndex:23462},{level:4,title:"SessionLocaleResolver",slug:"sessionlocaleresolver",normalizedTitle:"sessionlocaleresolver",charIndex:24666},{level:4,title:"LocaleChangeInterceptor",slug:"localechangeinterceptor",normalizedTitle:"localechangeinterceptor",charIndex:24978},{level:3,title:"ThemeResolver",slug:"themeresolver",normalizedTitle:"themeresolver",charIndex:470},{level:3,title:"MultipartResolver",slug:"multipartresolver",normalizedTitle:"multipartresolver",charIndex:2083},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:28820}],headersStr:"简介 DispatcherServlet 工作原理 DispatcherServlet 工作流程 DispatcherServlet 源码解读 上下文层次结构 配置 路径匹配 拦截器 解析器 HandlerExceptionResolver 解析器链 错误页面 ViewResolver 处理 重定向 转发 内容协商 LocaleResolver LocaleResolver 标头解析器 CookieLocaleResolver SessionLocaleResolver LocaleChangeInterceptor ThemeResolver MultipartResolver 参考资料",content:'# Spring MVC 之 DispatcherServlet\n\n\n# 简介\n\nDispatcherServlet 是 Spring MVC 框架的核心组件，负责将客户端请求映射到相应的控制器，然后调用控制器处理请求并返回响应结果。\n\n\n# DispatcherServlet 工作原理\n\n# DispatcherServlet 工作流程\n\nDispatcherServlet 的工作流程大致如下图所示：\n\n\n\n 1. 接收 Http 请求：当客户端发送 HTTP 请求时，DispatcherServlet 接收该请求并将其传递给 Spring MVC 框架。\n 2. 选择 Handler：DispatcherServlet 会根据请求的 URL 找到对应的处理器映射器 HandlerMapping，该映射器会根据配置文件中的 URL 映射规则找到合适的处理器 Handler。\n    * 绑定属性：DispatcherServlet 会根据程序的 web 初始化策略关联各种 Resolver，如：LocaleResolver、ThemeResolver 等。\n    * DispatcherServlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。\n      * 将请求映射到处理程序以及用于预处理和后处理的拦截器列表。映射基于一些标准，其细节因 HandlerMapping 实现而异。\n      * 两个主要的 HandlerMapping 实现是 RequestMappingHandlerMapping（支持 @RequestMapping 注释方法）和 SimpleUrlHandlerMapping（维护 URI 路径模式到处理程序的显式注册）。\n 3. 选择 HandlerAdapter： DispatcherServlet 根据获得的 Handler，选择一个合适的 HandlerAdapter。\n    * HandlerAdapter 帮助 DispatcherServlet 调用映射到请求的 Handler，而不管实际调用 Handler 的方式如何。例如，调用带注解的控制器需要解析注解。HandlerAdapter 的主要目的是保护 DispatcherServlet 免受此类细节的影响。\n 4. Handler 处理请求：DispatcherServlet 提取 Request 中的模型数据，填充 Handler 入参，由 HandlerAdapter 负责调用 Handler（Controller)。 在填充 Handler 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\n    * HttpMessageConverter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double等。\n    * 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中。\n 5. 返回 ModelAndView 对象：Handler 处理完请求后，会返回一个 ModelAndView 对象，其中包含了处理结果（Model）和视图（View）信息。\n 6. 选择 ViewResolver 渲染 ModelAndView：根据返回的 ModelAndView，选择一个适合的 ViewResolver，并将 ModelAndView 传递给 ViewResolver 进行渲染，最后将渲染后的结果返回给客户端。\n\n# DispatcherServlet 源码解读\n\n前面介绍了 DispatcherServlet 的工作流程，下面通过核心源码解读，来加深对 DispatcherServlet 工作原理的理解\n\n（1）onRefresh 方法\n\n\t@Override\n\tprotected void onRefresh(ApplicationContext context) {\n\t\tinitStrategies(context);\n\t}\n\n\t/**\n\t * 初始化此 servlet 使用的策略对象\n\t * 可以在子类中重写以初始化更多策略对象\n\t */\n\tprotected void initStrategies(ApplicationContext context) {\n\t\tinitMultipartResolver(context);\n\t\tinitLocaleResolver(context);\n\t\tinitThemeResolver(context);\n\t\tinitHandlerMappings(context);\n\t\tinitHandlerAdapters(context);\n\t\tinitHandlerExceptionResolvers(context);\n\t\tinitRequestToViewNameTranslator(context);\n\t\tinitViewResolvers(context);\n\t\tinitFlashMapManager(context);\n\t}\n\n\n（2）doService 方法\n\nDispatcherServlet 的核心方法 doService 源码如下：\n\n\t@Override\n\tprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tlogRequest(request);\n\n\t\t// 在包含的情况下保留请求属性的快照，以便能够在包含后恢复原始属性\n\t\tMap<String, Object> attributesSnapshot = null;\n\t\tif (WebUtils.isIncludeRequest(request)) {\n\t\t\tattributesSnapshot = new HashMap<>();\n\t\t\tEnumeration<?> attrNames = request.getAttributeNames();\n\t\t\twhile (attrNames.hasMoreElements()) {\n\t\t\t\tString attrName = (String) attrNames.nextElement();\n\t\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n\t\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 设置请求属性（绑定各种 Resolver），使框架对象可用于处理程序和视图对象\n\t\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n\t\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n\t\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n\t\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n\t\tif (this.flashMapManager != null) {\n\t\t\tFlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n\t\t\tif (inputFlashMap != null) {\n\t\t\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n\t\t\t}\n\t\t\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\t\t\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n\t\t}\n\n\t\tRequestPath previousRequestPath = null;\n\t\tif (this.parseRequestPath) {\n\t\t\tpreviousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);\n\t\t\tServletRequestPathUtils.parseAndCache(request);\n\t\t}\n\n\t\ttry {\n            // 请求分发\n\t\t\tdoDispatch(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n\t\t\t\t// 恢复原始属性快照，以防包含\n\t\t\t\tif (attributesSnapshot != null) {\n\t\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.parseRequestPath) {\n\t\t\t\tServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);\n\t\t\t}\n\t\t}\n\t}\n\n\n（3）doDispatch 方法\n\ndoService 中的核心方法是 doDispatch，负责分发请求。\n\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n   HttpServletRequest processedRequest = request;\n   HandlerExecutionChain mappedHandler = null;\n   boolean multipartRequestParsed = false;\n\n   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n   try {\n      ModelAndView mv = null;\n      Exception dispatchException = null;\n\n      try {\n         // 检查是否为multipart请求，如果是，则解析参数\n         processedRequest = checkMultipart(request);\n         multipartRequestParsed = (processedRequest != request);\n\n         // 确定适配当前请求的 Handler\n         mappedHandler = getHandler(processedRequest);\n         if (mappedHandler == null) {\n            noHandlerFound(processedRequest, response);\n            return;\n         }\n\n         // 确定适配当前请求的 HandlerAdapter\n         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n         // 如果 Handler 支持，则处理 last-modified 头\n         String method = request.getMethod();\n         boolean isGet = HttpMethod.GET.matches(method);\n         if (isGet || HttpMethod.HEAD.matches(method)) {\n            long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n            if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n               return;\n            }\n         }\n\n         // 请求的前置处理\n         if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n            return;\n         }\n\n         // 调用实际的 Handler 处理请求并返回 ModelAndView（有可能为 null）\n         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n         if (asyncManager.isConcurrentHandlingStarted()) {\n            return;\n         }\n\n         applyDefaultViewName(processedRequest, mv);\n         // 请求的后置处理\n         mappedHandler.applyPostHandle(processedRequest, response, mv);\n      }\n      catch (Exception ex) {\n         dispatchException = ex;\n      }\n      catch (Throwable err) {\n         // As of 4.3, we\'re processing Errors thrown from handler methods as well,\n         // making them available for @ExceptionHandler methods and other scenarios.\n         dispatchException = new NestedServletException("Handler dispatch failed", err);\n      }\n       // 处理响应结果\n      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n   }\n   catch (Exception ex) {\n      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n   }\n   catch (Throwable err) {\n      triggerAfterCompletion(processedRequest, response, mappedHandler,\n            new NestedServletException("Handler processing failed", err));\n   }\n   finally {\n      if (asyncManager.isConcurrentHandlingStarted()) {\n         // 替代 postHandle 和 afterCompletion\n         if (mappedHandler != null) {\n            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n         }\n      }\n      else {\n         // 清理 multipart 请求所使用的资源\n         if (multipartRequestParsed) {\n            cleanupMultipart(processedRequest);\n         }\n      }\n   }\n}\n\n\n# 上下文层次结构\n\nDispatcherServlet 需要一个 WebApplicationContext（ApplicationContext 的扩展类）用于它自己的配置。WebApplicationContext 有一个指向 ServletContext 和与之关联的 Servlet 的链接。它还绑定到 ServletContext，以便应用程序可以在 RequestContextUtils 上使用静态方法来查找 WebApplicationContext。\n\n对于多数应用程序来说，拥有一个 WebApplicationContext 单例就足够。也可以有一个上下文层次结构，其中有一个根 WebApplicationContext 在多个 DispatcherServlet（或其他 Servlet）实例之间共享，每个实例都有自己的子 WebApplicationContext 配置。\n\n根 WebApplicationContext 通常包含基础结构 bean，例如需要跨多个 Servlet 实例共享的数据存储和业务服务。这些 bean 是有效继承的，并且可以在特定 Servlet 的子 WebApplicationContext 中被覆盖（即重新声明），它通常包含指定 Servlet 的本地 bean。下图显示了这种关系：\n\n\n\n【示例】配置 WebApplicationContext 层次结构：\n\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { App1Config.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { "/app1/*" };\n    }\n}\n\n\n【示例】web.xml 方式配置 WebApplicationContext 层次结构：\n\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/root-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app1</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/app1-context.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app1</servlet-name>\n        <url-pattern>/app1/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n\n\n\n# 配置\n\nDispatcherServlet 与其他 Servlet 一样，需要使用 Java 配置或在 web.xml 中根据 Servlet 规范进行声明和映射。也就是说，DispatcherServlet 使用 Spring 配置来发现请求映射、视图解析、异常处理等所需的委托组件。\n\n可以通过将 Servlet 初始化参数（init-param 元素）添加到 web.xml 文件中的 Servlet 声明来自定义各个 DispatcherServlet 实例。下表列出了支持的参数：\n\n参数                               说明\ncontextClass                     实现 ConfigurableWebApplicationContext 的类，将由此 Servlet\n                                 实例化和本地配置。默认情况下，使用 XmlWebApplicationContext。\ncontextConfigLocation            传递给上下文实例（由 contextClass\n                                 指定）以指示可以在何处找到上下文的字符串。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。在具有两次定义的\n                                 bean 的多个上下文位置的情况下，最新的位置优先。\nnamespace                        WebApplicationContext 的命名空间。默认为 [servlet-name]-servlet。\nthrowExceptionIfNoHandlerFound   当找不到请求的处理程序时是否抛出 NoHandlerFoundException。然后可以使用\n                                 HandlerExceptionResolver（例如，通过使用 @ExceptionHandler\n                                 控制器方法）捕获异常并像其他任何方法一样处理。默认情况下，它设置为\n                                 false，在这种情况下，DispatcherServlet 设置响应状态为 404 (NOT_FOUND)\n                                 而不会引发异常。请注意，如果 [默认 servlet\n                                 处理](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc\n                                 -default-servlet-handler) 也被配置，未解决的请求总是转发到默认的 servlet\n                                 并且永远不会引发 404。\n\n应用程序可以声明处理请求所需的特殊 Bean 类型中列出的基础结构 bean。DispatcherServlet 检查每个特殊 bean 的 WebApplicationContext。如果没有匹配的 bean 类型，它将回退到 DispatcherServlet.properties 中列出的默认类型。\n\n在大多数情况下，MVC 配置是最好的起点。它以 Java 或 XML 声明所需的 bean，并提供更高级别的配置回调 API 来对其进行自定义。\n\n> 注意：Spring Boot 依赖于 MVC Java 配置来配置 Spring MVC，并提供了许多额外的方便选项。\n\n在 Servlet 环境中，您可以选择以编程方式配置 Servlet 容器作为替代方案或与 web.xml 文件结合使用。\n\nimport org.springframework.web.WebApplicationInitializer;\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext container) {\n        XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n        appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");\n\n        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));\n        registration.setLoadOnStartup(1);\n        registration.addMapping("/");\n    }\n}\n\n\nWebApplicationInitializer 是 Spring MVC 提供的接口，可确保检测到自定义的实现并自动用于初始化任何 Servlet 3 容器。名为 AbstractDispatcherServletInitializer 的 WebApplicationInitializer 的抽象基类实现通过覆盖方法来指定 servlet 映射和 DispatcherServlet 配置的位置，使得注册 DispatcherServlet 变得更加容易。\n\n对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示：\n\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return null;\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { MyWebConfig.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { "/" };\n    }\n}\n\n\n如果使用基于 XML 的 Spring 配置，则应直接从 AbstractDispatcherServletInitializer 扩展，如以下示例所示：\n\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n    @Override\n    protected WebApplicationContext createRootApplicationContext() {\n        return null;\n    }\n\n    @Override\n    protected WebApplicationContext createServletApplicationContext() {\n        XmlWebApplicationContext cxt = new XmlWebApplicationContext();\n        cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");\n        return cxt;\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { "/" };\n    }\n}\n\n\nAbstractDispatcherServletInitializer 还提供了一种方便的方法来添加 Filter 实例并将它们自动映射到 DispatcherServlet，如以下示例所示：\n\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n    // ...\n\n    @Override\n    protected Filter[] getServletFilters() {\n        return new Filter[] {\n            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };\n    }\n}\n\n\n每个过滤器都根据其具体类型添加一个默认名称，并自动映射到 DispatcherServlet。\n\nAbstractDispatcherServletInitializer 的 isAsyncSupported 保护方法提供了一个单独的位置来启用 DispatcherServlet 和映射到它的所有过滤器的异步支持。默认情况下，此标志设置为 true。\n\n最后，如果需要进一步自定义 DispatcherServlet 本身，可以重写 createDispatcherServlet 方法。\n\n【示例】Java 方式注册并初始化 DispatcherServlet，它由 Servlet 容器自动检测（请参阅 Servlet Config）：\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext servletContext) {\n\n        // Load Spring web application configuration\n        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n        context.register(AppConfig.class);\n\n        // Create and register the DispatcherServlet\n        DispatcherServlet servlet = new DispatcherServlet(context);\n        ServletRegistration.Dynamic registration = servletContext.addServlet("app", servlet);\n        registration.setLoadOnStartup(1);\n        registration.addMapping("/app/*");\n    }\n}\n\n\n【示例】web.xml 方式注册并初始化 DispatcherServlet\n\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/app-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value></param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app</servlet-name>\n        <url-pattern>/app/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n\n\n\n# 路径匹配\n\nServlet API 将完整的请求路径公开为 requestURI，并将其进一步细分为 contextPath、servletPath 和 pathInfo，它们的值因 Servlet 的映射方式而异。从这些输入中，Spring MVC 需要确定用于映射处理程序的查找路径，如果适用，它应该排除 contextPath 和任何 servletMapping 前缀。\n\nservletPath 和 pathInfo 已解码，这使得它们无法直接与完整的 requestURI 进行比较以派生 lookupPath，因此有必要对 requestURI 进行解码。然而，这引入了它自己的问题，因为路径可能包含编码的保留字符，例如 "/" 或 ";" 这反过来又会在解码后改变路径的结构，这也可能导致安全问题。此外，Servlet 容器可能会在不同程度上规范化 servletPath，这使得进一步无法对 requestURI 执行 startsWith 比较。\n\n这就是为什么最好避免依赖基于前缀的 servletPath 映射类型附带的 servletPath。如果 DispatcherServlet 被映射为带有 "/" 的默认 Servlet，或者没有带 "/*" 的前缀，并且 Servlet 容器是 4.0+，则 Spring MVC 能够检测 Servlet 映射类型，并避免使用 servletPath 和 pathInfo。在 3.1 Servlet 容器上，假设相同的 Servlet 映射类型，可以通过在 MVC 配置中通过路径匹配提供一个带有 alwaysUseFullPath=true 的 UrlPathHelper 来实现等效。\n\n幸运的是，默认的 Servlet 映射 "/" 是一个不错的选择。但是，仍然存在一个问题，即需要对 requestURI 进行解码才能与控制器映射进行比较。这也是不可取的，因为可能会解码改变路径结构的保留字。如果不需要这样的字符，那么您可以拒绝它们（如 Spring Security HTTP 防火墙），或者您可以使用 urlDecode=false 配置 UrlPathHelper，但控制器映射需要与编码路径匹配，这可能并不总是有效。此外，有时 DispatcherServlet 需要与另一个 Servlet 共享 URL 空间，并且可能需要通过前缀进行映射。\n\n在使用 PathPatternParser 和解析模式时解决了上述问题，作为使用 AntPathMatcher 进行字符串路径匹配的替代方法。PathPatternParser 从 5.3 版本开始就可以在 Spring MVC 中使用，并且从 6.0 版本开始默认启用。与需要解码查找路径或编码控制器映射的 AntPathMatcher 不同，解析的 PathPattern 与称为 RequestPath 的路径的解析表示匹配，一次一个路径段。这允许单独解码和清理路径段值，而没有改变路径结构的风险。解析的 PathPattern 也支持使用 servletPath 前缀映射，只要使用 Servlet 路径映射并且前缀保持简单，即它没有编码字符。\n\n\n# 拦截器\n\n所有 HandlerMapping 实现都支持处理拦截器，当想要将特定功能应用于某些请求时，这些拦截器很有用——例如，检查主体。拦截器必须使用 org.springframework.web.servlet 包中的三个方法实现 HandlerInterceptor，这三个方法应该提供足够的灵活性来进行各种预处理和后处理：\n\n * preHandle(..)：在实际 handler 之前执行\n * postHandle(..)：handler 之后执行\n * afterCompletion(..)：完成请求后执行\n\npreHandle(..) 方法返回一个布尔值。可以使用此方法中断或继续执行链的处理。当此方法返回 true 时，处理程序执行链将继续。当它返回 false 时，DispatcherServlet 假定拦截器本身已经处理请求（并且，例如，呈现适当的视图）并且不会继续执行其他拦截器和执行链中的实际处理程序。\n\n有关如何配置拦截器的示例，请参阅 MVC 配置部分中的拦截器。还可以通过在各个 HandlerMapping 实现上使用 setter 来直接注册它们。\n\npostHandle 方法对于 @ResponseBody 和 ResponseEntity 的方法不太有用，它们的响应是在 HandlerAdapter 中和 postHandle 之前编写和提交的。这意味着对响应进行任何更改都为时已晚，例如添加额外的标头。对于此类场景，您可以实现 ResponseBodyAdvice 并将其声明为 Controller Advice bean 或直接在 RequestMappingHandlerAdapter 上进行配置。\n\n\n# 解析器\n\nDispatcherServlet 会加载多种解析器来处理请求，比较常见的有以下几个：\n\n * HandlerExceptionResolver - 解决异常的策略，可能将它们映射到处理程序、HTML 错误视图或其他目标。\n * ViewResolver - 将从处理程序返回的基于字符串的逻辑视图名称解析为用于呈现响应的实际视图。\n * LocaleResolver, LocaleContextResolver - 解析用户正在使用的本地化设置，可能还有他们的时区，以便能够提供国际化的视图。\n * ThemeResolver - 解析 Web 应用程序可以使用的主题——例如，提供个性化布局。\n * MultipartResolver - 通过一些 multipart 解析库的帮助解析 multipart 请求（例如，通过浏览器上传文件）。\n\n\n# HandlerExceptionResolver\n\n在 WebApplicationContext 中声明的 HandlerExceptionResolver 用于解决请求处理期间抛出的异常。这些异常解析器允许自定义逻辑来解决异常。\n\n对于 HTTP 缓存支持，处理程序可以使用 WebRequest 的 checkNotModified 方法，以及用于控制器的 HTTP 缓存中所述的带注释控制器的更多选项。\n\n如果在请求映射期间发生异常或从请求处理程序（例如 @Controller）抛出异常，则 DispatcherServlet 委托 HandlerExceptionResolver 链来解决异常并提供替代处理，这通常是错误响应。\n\n下表列出了可用的 HandlerExceptionResolver 实现：\n\nHANDLEREXCEPTIONRESOLVER            说明\nSimpleMappingExceptionResolver      异常类名称和错误视图名称之间的映射。用于在浏览器应用程序中呈现错误页面。\nDefaultHandlerExceptionResolver     解决由 Spring MVC 引发的异常并将它们映射到 HTTP 状态代码。\nResponseStatusExceptionResolver     使用 @ResponseStatus 注解解决异常，并根据注解中的值将它们映射到 HTTP 状态代码。\nExceptionHandlerExceptionResolver   通过在 @Controller 或 @ControllerAdvice 类中调用 @ExceptionHandler\n                                    方法来解决异常。\n\n# 解析器链\n\n您可以通过在 Spring 配置中声明多个 HandlerExceptionResolver bean 并根据需要设置它们的顺序属性来构成异常解析器链。order 属性越高，异常解析器的位置就越靠后。\n\nHandlerExceptionResolver 的约定使它可以返回以下内容：\n\n * 指向错误视图的 ModelAndView。\n\n * 如果异常是在解析器中处理的，则为空的 ModelAndView。\n\n * 如果异常仍未解决，则为 null，供后续解析器尝试，如果异常仍然存在，则允许向上冒泡到 Servlet 容器。\n\nMVC Config 自动为默认的 Spring MVC 异常、@ResponseStatus 注释的异常和对 @ExceptionHandler 方法的支持声明内置解析器。您可以自定义该列表或替换它。\n\n# 错误页面\n\n如果异常仍未被任何 HandlerExceptionResolver 处理并因此继续传播，或者如果响应状态设置为错误状态（即 4xx、5xx），Servlet 容器可以在 HTML 中呈现默认错误页面。要自定义容器的默认错误页面，您可以在 web.xml 中声明一个错误页面映射。以下示例显示了如何执行此操作：\n\n<error-page>\n    <location>/error</location>\n</error-page>\n\n\n在前面的示例中，当出现异常或响应具有错误状态时，Servlet 容器会在容器内将 ERROR 分派到配置的 URL（例如，/error）。然后由 DispatcherServlet 处理，可能将其映射到 @Controller，后者可以返回带有模型的错误视图名称或呈现 JSON 响应，如以下示例所示：\n\n@RestController\npublic class ErrorController {\n\n    @RequestMapping(path = "/error")\n    public Map<String, Object> handle(HttpServletRequest request) {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put("status", request.getAttribute("jakarta.servlet.error.status_code"));\n        map.put("reason", request.getAttribute("jakarta.servlet.error.message"));\n        return map;\n    }\n}\n\n\n> 提示：Servlet API 不提供在 Java 中创建错误页面映射的方法。但是，您可以同时使用 WebApplicationInitializer 和最小的 web.xml。\n\n\n# ViewResolver\n\nSpring MVC 定义了 ViewResolver 和 View 接口，让用户可以在浏览器中渲染模型，而无需限定于特定的视图技术。ViewResolver 提供视图名称和实际视图之间的映射。View 解决了在移交给特定视图技术之前准备数据的问题。\n\n下表提供了有关 ViewResolver 一些子类：\n\nVIEWRESOLVER                     DESCRIPTION\nAbstractCachingViewResolver      AbstractCachingViewResolver\n                                 的子类缓存它们解析的视图实例。缓存提高了某些视图技术的性能。您可以通过将 cache 属性设置为 false\n                                 来关闭缓存。此外，如果您必须在运行时刷新某个视图（例如，修改 FreeMarker 模板时），您可以使用\n                                 removeFromCache(String viewName, Locale loc) 方法。\nUrlBasedViewResolver             ViewResolver 接口的简单实现，无需显式映射定义即可将逻辑视图名称直接解析为\n                                 URL。如果您的逻辑名称以直接的方式匹配您的视图资源的名称，而不需要任意映射，那么这是合适的。\nInternalResourceViewResolver     UrlBasedViewResolver 的子类，支持 InternalResourceView（实际上是\n                                 Servlet 和 JSP）以及 JstlView 和 TilesView 等子类。可以使用\n                                 setViewClass(..) 为该解析器生成的所有视图指定视图类。\nFreeMarkerViewResolver           UrlBasedViewResolver 的子类，支持 FreeMarkerView 和它们的自定义子类。\nContentNegotiatingViewResolver   ViewResolver 接口的实现，该接口根据请求文件名或 Accept 标头解析视图。\nBeanNameViewResolver             将视图名称解释为当前应用程序上下文中的 bean 名称的 ViewResolver\n                                 接口的实现。这是一个非常灵活的变体，允许根据不同的视图名称混合和匹配不同的视图类型。每个这样的“视图”都可以定义为一个\n                                 bean，例如 在 XML 或配置类中。\n\n# 处理\n\n可以通过声明多个解析器来构成视图解析器链，如果需要，还可以通过设置 order 属性来指定顺序。顺序属性越高，视图解析器在链中的位置就越靠后。\n\nViewResolver 的约定指定它可以返回 null 以指示找不到视图。但是，对于 JSP 和 InternalResourceViewResolver，确定 JSP 是否存在的唯一方法是通过 RequestDispatcher 执行分派。因此，您必须始终将 InternalResourceViewResolver 配置为在视图解析器的整体顺序中排在最后。\n\n配置视图解析就像将 ViewResolver 添加到 Spring 配置中一样简单。MVC Config 为视图解析器和添加无逻辑视图控制器提供了专用的配置 API，这对于没有控制器逻辑的 HTML 模板渲染很有用。\n\n# 重定向\n\n视图名称中的特殊前缀 redirect: 可以实现一个重定向。UrlBasedViewResolver（及其子类）将此识别为需要重定向的指令。视图名称的其余部分是重定向 URL。\n\n最终效果与控制器返回 RedirectView 相同，但现在控制器本身可以根据逻辑视图名称进行操作。逻辑视图名称（例如 redirect:/myapp/some/resource）相对于当前 Servlet 上下文重定向，而名称（例如 redirect:https://myhost.com/some/arbitrary/path）重定向到绝对 URL。\n\n请注意，如果使用 @ResponseStatus 注解标记控制器方法，则注解值优先于 RedirectView 设置的响应状态。\n\n# 转发\n\n视图名称中的特殊前缀 forward: 可以实现一个转发。这将创建一个 InternalResourceView，它执行 RequestDispatcher.forward()。因此，此前缀对 InternalResourceViewResolver 和 InternalResourceView（对于 JSP）没有用，但如果您使用另一种视图技术但仍想强制转发由 Servlet/JSP 引擎处理的资源，它可能会有所帮助。\n\n# 内容协商\n\nContentNegotiatingViewResolver 本身不解析视图，而是委托给其他视图解析器并选择类似于客户端请求的表示的视图。可以从 Accept 头或查询参数（例如，"/path?format=pdf"）确定表示形式。\n\nContentNegotiatingViewResolver 通过将请求媒体类型与其每个 ViewResolver 关联的 View 支持的媒体类型（也称为 Content-Type）进行比较，来选择合适的 View 来处理请求。列表中第一个具有兼容 Content-Type 的视图将处理结果返回给客户端。如果 ViewResolver 链无法提供兼容的视图，则会查阅通过 DefaultViews 属性指定的视图列表。后一个选项适用于单例视图，它可以呈现当前资源的适当表示，而不管逻辑视图名称如何。Accept 标头可以包含通配符（例如 text/*），在这种情况下，Content-Type 为 text/xml 的 View 是兼容的匹配项。\n\n\n# LocaleResolver\n\n大部分的 Spring 架构都支持国际化，就像 Spring web MVC 框架所做的那样。DispatcherServlet 允许您使用客户端的语言环境自动解析消息。这是通过 LocaleResolver 对象完成的。\n\n当收到请求时，DispatcherServlet 会寻找语言环境解析器，如果找到，它会尝试使用它来设置 Locale 环境。通过使用 RequestContext.getLocale() 方法，您始终可以检索由 Locale 解析器解析的语言环境。\n\n除了自动识别 Locale 环境之外，您还可以为 handle 映射附加拦截器，在特定情况下更改 Locale 环境设置（例如，基于请求中的参数）。\n\nLocale 解析器和拦截器在 org.springframework.web.servlet.i18n 包中定义，并以正常方式在您的应用程序上下文中配置。Spring 中有以下 Locale 解析器可供选择。\n\n * Time Zone\n * Header Resolver\n * Cookie Resolver\n * Session Resolver\n * Locale Interceptor\n\n# LocaleResolver\n\n除了获取客户端的区域设置外，了解其时区通常也很有用。LocaleContextResolver 接口提供了 LocaleResolver 的扩展，让解析器提供更丰富的 LocaleContext，其中可能包括时区信息。\n\n如果可用，可以使用 RequestContext.getTimeZone() 方法获取用户的 TimeZone。在 Spring 的 ConversionService 中注册的任何日期/时间 Converter 和 Formatter 对象会自动使用时区信息。\n\n# 标头解析器\n\n此 Locale 解析器检查客户端（例如网络浏览器）发送的请求中的 accept-language 头。通常，此头字段包含客户端操作系统的区域信息。请注意，此解析器不支持时区信息。\n\n# CookieLocaleResolver\n\nThis locale resolver inspects a Cookie that might exist on the client to see if a Locale or TimeZone is specified. If so, it uses the specified details. By using the properties of this locale resolver, you can specify the name of the cookie as well as the maximum age. The following example defines a CookieLocaleResolver:\n\n此 Locale 解析器检查客户端上是否存在 Cookie，以查看是否指定了 Locale 或 TimeZone。如果是，它会使用指定的详细信息。通过使用此 Locale 解析器的属性，可以指定 cookie 的名称以及最长期限。以下示例定义了 CookieLocaleResolver：\n\n<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">\n\n    <property name="cookieName" value="clientlanguage"/>\n\n    \x3c!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --\x3e\n    <property name="cookieMaxAge" value="100000"/>\n\n</bean>\n\n\n下表描述了 CookieLocaleResolver 的属性：\n\n属性             默认值                         DESCRIPTION\ncookieName     类名 + LOCALE                 cookie 名\ncookieMaxAge   Servlet container default   cookie 在客户端上保留的最长时间。如果指定了“-1”，则不会保留 cookie。它仅在客户端关闭浏览器之前可用。\ncookiePath     /                           将 cookie 的可见性限制在您网站的特定部分。当指定 cookiePath 时，cookie\n                                           仅对该路径及其下方的路径可见。\n\n# SessionLocaleResolver\n\nSessionLocaleResolver 允许您从可能与用户请求相关联的会话中检索 Locale 和 TimeZone。与 CookieLocaleResolver 相比，此策略将本地选择的 locale 设置存储在 Servlet 容器的 HttpSession 中。因此，这些设置对于每个会话都是临时的，因此会在每个会话结束时丢失。\n\n注意，这与外部会话管理机制（例如 Spring Session 项目）没有直接关系。此 SessionLocaleResolver 根据当前 HttpServletRequest 评估和修改相应的 HttpSession 属性。\n\n# LocaleChangeInterceptor\n\n可以通过将 LocaleChangeInterceptor 添加到一个 HandlerMapping 定义来启用区域设置更改。它检测请求中的参数并相应地更改 Locale 环境，在调度程序的应用程序上下文中调用 LocaleResolver 上的 setLocale 方法。下面的示例显示调用所有包含名为 siteLanguage 的参数的 *.view 资源，以更改语言环境。因此，例如，对 URL https://www.sf.net/home.view?siteLanguage=nl 的请求将站点语言更改为荷兰语。以下示例显示了如何拦截语言环境：\n\n<bean id="localeChangeInterceptor"\n        class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">\n    <property name="paramName" value="siteLanguage"/>\n</bean>\n\n<bean id="localeResolver"\n        class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/>\n\n<bean id="urlMapping"\n        class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">\n    <property name="interceptors">\n        <list>\n            <ref bean="localeChangeInterceptor"/>\n        </list>\n    </property>\n    <property name="mappings">\n        <value>/**/*.view=someController</value>\n    </property>\n</bean>\n\n\n\n# ThemeResolver\n\n您可以应用 Spring Web MVC 框架主题来设置应用程序的整体外观，从而增强用户体验。主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉风格。\n\n要在 Web 应用程序中使用主题，必须设置 org.springframework.ui.context.ThemeSource 接口的实现。WebApplicationContext 接口扩展了 ThemeSource 但将其职责委托给了专门的实现。默认情况下，委托是 org.springframework.ui.context.support.ResourceBundleThemeSource ，它从类的根路径加载属性文件。要使用自定义的 ThemeSource 实现或配置 ResourceBundleThemeSource 的基本名称前缀，您可以在应用程序上下文中使用保留名称 themeSource 注册一个 bean。Web 应用程序上下文自动检测具有该名称的 bean 并使用它。\n\n当使用 ResourceBundleThemeSource 时，主题是在一个简单的属性文件中定义的。属性文件列出了构成主题的资源，如以下示例所示：\n\nstyleSheet=/themes/cool/style.css\nbackground=/themes/cool/img/coolBg.jpg\n\n\n属性的键是从视图代码中引用主题元素的名称。对于 JSP，通常使用 spring:theme 自定义标签来执行此操作，它与 spring:message 标签非常相似。以下 JSP 片段使用前面示例中定义的主题来自定义外观：\n\n<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>\n<html>\n    <head>\n        <link rel="stylesheet" href="<spring:theme code=\'styleSheet\'/>" type="text/css"/>\n    </head>\n    <body style="background=<spring:theme code=\'background\'/>">\n        ...\n    </body>\n</html>\n\n\n默认情况下， ResourceBundleThemeSource 使用空的基本名称前缀。因此，属性文件是从类路径的根加载的。因此，可以将 cool.properties 主题定义放在类路径根目录中（例如，在 /WEB-INF/classes 中）。ResourceBundleThemeSource 使用标准的 Java 资源包加载机制，允许主题完全国际化。例如，我们可以有一个 /WEB-INF/classes/cool_nl.properties，它引用一个带有荷兰语文本的特殊背景图像。\n\n定义主题后，可以决定使用哪个要使用的主题。DispatcherServlet 查找名为 themeResolver 的 bean 以找出要使用的 ThemeResolver 实现。主题解析器的工作方式与 LocaleResolver 大致相同。它检测用于特定请求的主题，也可以更改请求的主题。下表描述了 Spring 提供的主题解析器：\n\nCLASS                  DESCRIPTION\nFixedThemeResolver     选择一个固定的主题，使用 defaultThemeName 属性设置。\nSessionThemeResolver   主题在用户的 HTTP 会话中维护。 它只需要为每个会话设置一次，但不会在会话之间持续存在。\nCookieThemeResolver    所选主题存储在客户端的 cookie 中。\n\nSpring 还提供了一个 ThemeChangeInterceptor，它允许使用一个简单的请求参数在每个请求上更改主题。\n\n\n# MultipartResolver\n\norg.springframework.web.multipart 包中的 MultipartResolver 是一种解析 multipart 请求（包括文件上传）的策略。 有一个基于容器的 StandardServletMultipartResolver 实现，用于 Servlet 多部分请求解析。 请注意，从具有新 Servlet 5.0+ 基线的 Spring Framework 6.0 开始，基于 Apache Commons FileUpload 的过时的 CommonsMultipartResolver 不再可用。\n\n要启用 multipart 处理，需要在 DispatcherServlet Spring 配置中声明一个名为 multipartResolver 的 MultipartResolver。 DispatcherServlet 检测到它并将其应用于传入请求。 当接收到内容类型为 multipart/form-data 的 POST 时，解析器解析将当前 HttpServletRequest 包装为 MultipartHttpServletRequest 的内容，以提供对已解析文件的访问以及将部分作为请求参数公开。\n\nServlet 多部分解析需要通过 Servlet 容器配置启用。 为此：\n\n * 在 Java 中，在 Servlet 注册上设置一个 MultipartConfigElement。\n\n * 在 web.xml 中，将 <multipart-config> 部分添加到 servlet 声明。\n\n以下示例显示如何在 Servlet 注册上设置 MultipartConfigElement：\n\npublic class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    // ...\n\n    @Override\n    protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n\n        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n        registration.setMultipartConfig(new MultipartConfigElement("/tmp"));\n    }\n\n}\n\n\n一旦 Servlet multipart 配置好，就可以添加一个名为 multipartResolver 的 StandardServletMultipartResolver 类型的 bean。\n\n\n# 参考资料\n\n * Spring Framework 官方文档\n * Spring Framework 官方文档之 Web',normalizedContent:'# spring mvc 之 dispatcherservlet\n\n\n# 简介\n\ndispatcherservlet 是 spring mvc 框架的核心组件，负责将客户端请求映射到相应的控制器，然后调用控制器处理请求并返回响应结果。\n\n\n# dispatcherservlet 工作原理\n\n# dispatcherservlet 工作流程\n\ndispatcherservlet 的工作流程大致如下图所示：\n\n\n\n 1. 接收 http 请求：当客户端发送 http 请求时，dispatcherservlet 接收该请求并将其传递给 spring mvc 框架。\n 2. 选择 handler：dispatcherservlet 会根据请求的 url 找到对应的处理器映射器 handlermapping，该映射器会根据配置文件中的 url 映射规则找到合适的处理器 handler。\n    * 绑定属性：dispatcherservlet 会根据程序的 web 初始化策略关联各种 resolver，如：localeresolver、themeresolver 等。\n    * dispatcherservlet 根据 <servlet-name>-servlet.xml 中的配置对请求的 url 进行解析，得到请求资源标识符（uri）。然后根据该 uri，调用 handlermapping 获得该 handler 配置的所有相关的对象（包括 handler 对象以及 handler 对象对应的拦截器），最后以handlerexecutionchain 对象的形式返回。\n      * 将请求映射到处理程序以及用于预处理和后处理的拦截器列表。映射基于一些标准，其细节因 handlermapping 实现而异。\n      * 两个主要的 handlermapping 实现是 requestmappinghandlermapping（支持 @requestmapping 注释方法）和 simpleurlhandlermapping（维护 uri 路径模式到处理程序的显式注册）。\n 3. 选择 handleradapter： dispatcherservlet 根据获得的 handler，选择一个合适的 handleradapter。\n    * handleradapter 帮助 dispatcherservlet 调用映射到请求的 handler，而不管实际调用 handler 的方式如何。例如，调用带注解的控制器需要解析注解。handleradapter 的主要目的是保护 dispatcherservlet 免受此类细节的影响。\n 4. handler 处理请求：dispatcherservlet 提取 request 中的模型数据，填充 handler 入参，由 handleradapter 负责调用 handler（controller)。 在填充 handler 的入参过程中，根据你的配置，spring 将帮你做一些额外的工作：\n    * httpmessageconverter： 将请求消息（如 json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。\n    * 数据转换：对请求消息进行数据转换。如 string 转换成 integer、double等。\n    * 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。\n    * 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 bindingresult 或 error 中。\n 5. 返回 modelandview 对象：handler 处理完请求后，会返回一个 modelandview 对象，其中包含了处理结果（model）和视图（view）信息。\n 6. 选择 viewresolver 渲染 modelandview：根据返回的 modelandview，选择一个适合的 viewresolver，并将 modelandview 传递给 viewresolver 进行渲染，最后将渲染后的结果返回给客户端。\n\n# dispatcherservlet 源码解读\n\n前面介绍了 dispatcherservlet 的工作流程，下面通过核心源码解读，来加深对 dispatcherservlet 工作原理的理解\n\n（1）onrefresh 方法\n\n\t@override\n\tprotected void onrefresh(applicationcontext context) {\n\t\tinitstrategies(context);\n\t}\n\n\t/**\n\t * 初始化此 servlet 使用的策略对象\n\t * 可以在子类中重写以初始化更多策略对象\n\t */\n\tprotected void initstrategies(applicationcontext context) {\n\t\tinitmultipartresolver(context);\n\t\tinitlocaleresolver(context);\n\t\tinitthemeresolver(context);\n\t\tinithandlermappings(context);\n\t\tinithandleradapters(context);\n\t\tinithandlerexceptionresolvers(context);\n\t\tinitrequesttoviewnametranslator(context);\n\t\tinitviewresolvers(context);\n\t\tinitflashmapmanager(context);\n\t}\n\n\n（2）doservice 方法\n\ndispatcherservlet 的核心方法 doservice 源码如下：\n\n\t@override\n\tprotected void doservice(httpservletrequest request, httpservletresponse response) throws exception {\n\t\tlogrequest(request);\n\n\t\t// 在包含的情况下保留请求属性的快照，以便能够在包含后恢复原始属性\n\t\tmap<string, object> attributessnapshot = null;\n\t\tif (webutils.isincluderequest(request)) {\n\t\t\tattributessnapshot = new hashmap<>();\n\t\t\tenumeration<?> attrnames = request.getattributenames();\n\t\t\twhile (attrnames.hasmoreelements()) {\n\t\t\t\tstring attrname = (string) attrnames.nextelement();\n\t\t\t\tif (this.cleanupafterinclude || attrname.startswith(default_strategies_prefix)) {\n\t\t\t\t\tattributessnapshot.put(attrname, request.getattribute(attrname));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 设置请求属性（绑定各种 resolver），使框架对象可用于处理程序和视图对象\n\t\trequest.setattribute(web_application_context_attribute, getwebapplicationcontext());\n\t\trequest.setattribute(locale_resolver_attribute, this.localeresolver);\n\t\trequest.setattribute(theme_resolver_attribute, this.themeresolver);\n\t\trequest.setattribute(theme_source_attribute, getthemesource());\n\n\t\tif (this.flashmapmanager != null) {\n\t\t\tflashmap inputflashmap = this.flashmapmanager.retrieveandupdate(request, response);\n\t\t\tif (inputflashmap != null) {\n\t\t\t\trequest.setattribute(input_flash_map_attribute, collections.unmodifiablemap(inputflashmap));\n\t\t\t}\n\t\t\trequest.setattribute(output_flash_map_attribute, new flashmap());\n\t\t\trequest.setattribute(flash_map_manager_attribute, this.flashmapmanager);\n\t\t}\n\n\t\trequestpath previousrequestpath = null;\n\t\tif (this.parserequestpath) {\n\t\t\tpreviousrequestpath = (requestpath) request.getattribute(servletrequestpathutils.path_attribute);\n\t\t\tservletrequestpathutils.parseandcache(request);\n\t\t}\n\n\t\ttry {\n            // 请求分发\n\t\t\tdodispatch(request, response);\n\t\t}\n\t\tfinally {\n\t\t\tif (!webasyncutils.getasyncmanager(request).isconcurrenthandlingstarted()) {\n\t\t\t\t// 恢复原始属性快照，以防包含\n\t\t\t\tif (attributessnapshot != null) {\n\t\t\t\t\trestoreattributesafterinclude(request, attributessnapshot);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.parserequestpath) {\n\t\t\t\tservletrequestpathutils.setparsedrequestpath(previousrequestpath, request);\n\t\t\t}\n\t\t}\n\t}\n\n\n（3）dodispatch 方法\n\ndoservice 中的核心方法是 dodispatch，负责分发请求。\n\nprotected void dodispatch(httpservletrequest request, httpservletresponse response) throws exception {\n   httpservletrequest processedrequest = request;\n   handlerexecutionchain mappedhandler = null;\n   boolean multipartrequestparsed = false;\n\n   webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n\n   try {\n      modelandview mv = null;\n      exception dispatchexception = null;\n\n      try {\n         // 检查是否为multipart请求，如果是，则解析参数\n         processedrequest = checkmultipart(request);\n         multipartrequestparsed = (processedrequest != request);\n\n         // 确定适配当前请求的 handler\n         mappedhandler = gethandler(processedrequest);\n         if (mappedhandler == null) {\n            nohandlerfound(processedrequest, response);\n            return;\n         }\n\n         // 确定适配当前请求的 handleradapter\n         handleradapter ha = gethandleradapter(mappedhandler.gethandler());\n\n         // 如果 handler 支持，则处理 last-modified 头\n         string method = request.getmethod();\n         boolean isget = httpmethod.get.matches(method);\n         if (isget || httpmethod.head.matches(method)) {\n            long lastmodified = ha.getlastmodified(request, mappedhandler.gethandler());\n            if (new servletwebrequest(request, response).checknotmodified(lastmodified) && isget) {\n               return;\n            }\n         }\n\n         // 请求的前置处理\n         if (!mappedhandler.applyprehandle(processedrequest, response)) {\n            return;\n         }\n\n         // 调用实际的 handler 处理请求并返回 modelandview（有可能为 null）\n         mv = ha.handle(processedrequest, response, mappedhandler.gethandler());\n\n         if (asyncmanager.isconcurrenthandlingstarted()) {\n            return;\n         }\n\n         applydefaultviewname(processedrequest, mv);\n         // 请求的后置处理\n         mappedhandler.applyposthandle(processedrequest, response, mv);\n      }\n      catch (exception ex) {\n         dispatchexception = ex;\n      }\n      catch (throwable err) {\n         // as of 4.3, we\'re processing errors thrown from handler methods as well,\n         // making them available for @exceptionhandler methods and other scenarios.\n         dispatchexception = new nestedservletexception("handler dispatch failed", err);\n      }\n       // 处理响应结果\n      processdispatchresult(processedrequest, response, mappedhandler, mv, dispatchexception);\n   }\n   catch (exception ex) {\n      triggeraftercompletion(processedrequest, response, mappedhandler, ex);\n   }\n   catch (throwable err) {\n      triggeraftercompletion(processedrequest, response, mappedhandler,\n            new nestedservletexception("handler processing failed", err));\n   }\n   finally {\n      if (asyncmanager.isconcurrenthandlingstarted()) {\n         // 替代 posthandle 和 aftercompletion\n         if (mappedhandler != null) {\n            mappedhandler.applyafterconcurrenthandlingstarted(processedrequest, response);\n         }\n      }\n      else {\n         // 清理 multipart 请求所使用的资源\n         if (multipartrequestparsed) {\n            cleanupmultipart(processedrequest);\n         }\n      }\n   }\n}\n\n\n# 上下文层次结构\n\ndispatcherservlet 需要一个 webapplicationcontext（applicationcontext 的扩展类）用于它自己的配置。webapplicationcontext 有一个指向 servletcontext 和与之关联的 servlet 的链接。它还绑定到 servletcontext，以便应用程序可以在 requestcontextutils 上使用静态方法来查找 webapplicationcontext。\n\n对于多数应用程序来说，拥有一个 webapplicationcontext 单例就足够。也可以有一个上下文层次结构，其中有一个根 webapplicationcontext 在多个 dispatcherservlet（或其他 servlet）实例之间共享，每个实例都有自己的子 webapplicationcontext 配置。\n\n根 webapplicationcontext 通常包含基础结构 bean，例如需要跨多个 servlet 实例共享的数据存储和业务服务。这些 bean 是有效继承的，并且可以在特定 servlet 的子 webapplicationcontext 中被覆盖（即重新声明），它通常包含指定 servlet 的本地 bean。下图显示了这种关系：\n\n\n\n【示例】配置 webapplicationcontext 层次结构：\n\npublic class mywebappinitializer extends abstractannotationconfigdispatcherservletinitializer {\n\n    @override\n    protected class<?>[] getrootconfigclasses() {\n        return new class<?>[] { rootconfig.class };\n    }\n\n    @override\n    protected class<?>[] getservletconfigclasses() {\n        return new class<?>[] { app1config.class };\n    }\n\n    @override\n    protected string[] getservletmappings() {\n        return new string[] { "/app1/*" };\n    }\n}\n\n\n【示例】web.xml 方式配置 webapplicationcontext 层次结构：\n\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextconfiglocation</param-name>\n        <param-value>/web-inf/root-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app1</servlet-name>\n        <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n        <init-param>\n            <param-name>contextconfiglocation</param-name>\n            <param-value>/web-inf/app1-context.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app1</servlet-name>\n        <url-pattern>/app1/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n\n\n\n# 配置\n\ndispatcherservlet 与其他 servlet 一样，需要使用 java 配置或在 web.xml 中根据 servlet 规范进行声明和映射。也就是说，dispatcherservlet 使用 spring 配置来发现请求映射、视图解析、异常处理等所需的委托组件。\n\n可以通过将 servlet 初始化参数（init-param 元素）添加到 web.xml 文件中的 servlet 声明来自定义各个 dispatcherservlet 实例。下表列出了支持的参数：\n\n参数                               说明\ncontextclass                     实现 configurablewebapplicationcontext 的类，将由此 servlet\n                                 实例化和本地配置。默认情况下，使用 xmlwebapplicationcontext。\ncontextconfiglocation            传递给上下文实例（由 contextclass\n                                 指定）以指示可以在何处找到上下文的字符串。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。在具有两次定义的\n                                 bean 的多个上下文位置的情况下，最新的位置优先。\nnamespace                        webapplicationcontext 的命名空间。默认为 [servlet-name]-servlet。\nthrowexceptionifnohandlerfound   当找不到请求的处理程序时是否抛出 nohandlerfoundexception。然后可以使用\n                                 handlerexceptionresolver（例如，通过使用 @exceptionhandler\n                                 控制器方法）捕获异常并像其他任何方法一样处理。默认情况下，它设置为\n                                 false，在这种情况下，dispatcherservlet 设置响应状态为 404 (not_found)\n                                 而不会引发异常。请注意，如果 [默认 servlet\n                                 处理](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc\n                                 -default-servlet-handler) 也被配置，未解决的请求总是转发到默认的 servlet\n                                 并且永远不会引发 404。\n\n应用程序可以声明处理请求所需的特殊 bean 类型中列出的基础结构 bean。dispatcherservlet 检查每个特殊 bean 的 webapplicationcontext。如果没有匹配的 bean 类型，它将回退到 dispatcherservlet.properties 中列出的默认类型。\n\n在大多数情况下，mvc 配置是最好的起点。它以 java 或 xml 声明所需的 bean，并提供更高级别的配置回调 api 来对其进行自定义。\n\n> 注意：spring boot 依赖于 mvc java 配置来配置 spring mvc，并提供了许多额外的方便选项。\n\n在 servlet 环境中，您可以选择以编程方式配置 servlet 容器作为替代方案或与 web.xml 文件结合使用。\n\nimport org.springframework.web.webapplicationinitializer;\n\npublic class mywebapplicationinitializer implements webapplicationinitializer {\n\n    @override\n    public void onstartup(servletcontext container) {\n        xmlwebapplicationcontext appcontext = new xmlwebapplicationcontext();\n        appcontext.setconfiglocation("/web-inf/spring/dispatcher-config.xml");\n\n        servletregistration.dynamic registration = container.addservlet("dispatcher", new dispatcherservlet(appcontext));\n        registration.setloadonstartup(1);\n        registration.addmapping("/");\n    }\n}\n\n\nwebapplicationinitializer 是 spring mvc 提供的接口，可确保检测到自定义的实现并自动用于初始化任何 servlet 3 容器。名为 abstractdispatcherservletinitializer 的 webapplicationinitializer 的抽象基类实现通过覆盖方法来指定 servlet 映射和 dispatcherservlet 配置的位置，使得注册 dispatcherservlet 变得更加容易。\n\n对于使用基于 java 的 spring 配置的应用程序，建议这样做，如以下示例所示：\n\npublic class mywebappinitializer extends abstractannotationconfigdispatcherservletinitializer {\n\n    @override\n    protected class<?>[] getrootconfigclasses() {\n        return null;\n    }\n\n    @override\n    protected class<?>[] getservletconfigclasses() {\n        return new class<?>[] { mywebconfig.class };\n    }\n\n    @override\n    protected string[] getservletmappings() {\n        return new string[] { "/" };\n    }\n}\n\n\n如果使用基于 xml 的 spring 配置，则应直接从 abstractdispatcherservletinitializer 扩展，如以下示例所示：\n\npublic class mywebappinitializer extends abstractdispatcherservletinitializer {\n\n    @override\n    protected webapplicationcontext createrootapplicationcontext() {\n        return null;\n    }\n\n    @override\n    protected webapplicationcontext createservletapplicationcontext() {\n        xmlwebapplicationcontext cxt = new xmlwebapplicationcontext();\n        cxt.setconfiglocation("/web-inf/spring/dispatcher-config.xml");\n        return cxt;\n    }\n\n    @override\n    protected string[] getservletmappings() {\n        return new string[] { "/" };\n    }\n}\n\n\nabstractdispatcherservletinitializer 还提供了一种方便的方法来添加 filter 实例并将它们自动映射到 dispatcherservlet，如以下示例所示：\n\npublic class mywebappinitializer extends abstractdispatcherservletinitializer {\n\n    // ...\n\n    @override\n    protected filter[] getservletfilters() {\n        return new filter[] {\n            new hiddenhttpmethodfilter(), new characterencodingfilter() };\n    }\n}\n\n\n每个过滤器都根据其具体类型添加一个默认名称，并自动映射到 dispatcherservlet。\n\nabstractdispatcherservletinitializer 的 isasyncsupported 保护方法提供了一个单独的位置来启用 dispatcherservlet 和映射到它的所有过滤器的异步支持。默认情况下，此标志设置为 true。\n\n最后，如果需要进一步自定义 dispatcherservlet 本身，可以重写 createdispatcherservlet 方法。\n\n【示例】java 方式注册并初始化 dispatcherservlet，它由 servlet 容器自动检测（请参阅 servlet config）：\n\npublic class mywebapplicationinitializer implements webapplicationinitializer {\n\n    @override\n    public void onstartup(servletcontext servletcontext) {\n\n        // load spring web application configuration\n        annotationconfigwebapplicationcontext context = new annotationconfigwebapplicationcontext();\n        context.register(appconfig.class);\n\n        // create and register the dispatcherservlet\n        dispatcherservlet servlet = new dispatcherservlet(context);\n        servletregistration.dynamic registration = servletcontext.addservlet("app", servlet);\n        registration.setloadonstartup(1);\n        registration.addmapping("/app/*");\n    }\n}\n\n\n【示例】web.xml 方式注册并初始化 dispatcherservlet\n\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextconfiglocation</param-name>\n        <param-value>/web-inf/app-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app</servlet-name>\n        <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n        <init-param>\n            <param-name>contextconfiglocation</param-name>\n            <param-value></param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app</servlet-name>\n        <url-pattern>/app/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n\n\n\n# 路径匹配\n\nservlet api 将完整的请求路径公开为 requesturi，并将其进一步细分为 contextpath、servletpath 和 pathinfo，它们的值因 servlet 的映射方式而异。从这些输入中，spring mvc 需要确定用于映射处理程序的查找路径，如果适用，它应该排除 contextpath 和任何 servletmapping 前缀。\n\nservletpath 和 pathinfo 已解码，这使得它们无法直接与完整的 requesturi 进行比较以派生 lookuppath，因此有必要对 requesturi 进行解码。然而，这引入了它自己的问题，因为路径可能包含编码的保留字符，例如 "/" 或 ";" 这反过来又会在解码后改变路径的结构，这也可能导致安全问题。此外，servlet 容器可能会在不同程度上规范化 servletpath，这使得进一步无法对 requesturi 执行 startswith 比较。\n\n这就是为什么最好避免依赖基于前缀的 servletpath 映射类型附带的 servletpath。如果 dispatcherservlet 被映射为带有 "/" 的默认 servlet，或者没有带 "/*" 的前缀，并且 servlet 容器是 4.0+，则 spring mvc 能够检测 servlet 映射类型，并避免使用 servletpath 和 pathinfo。在 3.1 servlet 容器上，假设相同的 servlet 映射类型，可以通过在 mvc 配置中通过路径匹配提供一个带有 alwaysusefullpath=true 的 urlpathhelper 来实现等效。\n\n幸运的是，默认的 servlet 映射 "/" 是一个不错的选择。但是，仍然存在一个问题，即需要对 requesturi 进行解码才能与控制器映射进行比较。这也是不可取的，因为可能会解码改变路径结构的保留字。如果不需要这样的字符，那么您可以拒绝它们（如 spring security http 防火墙），或者您可以使用 urldecode=false 配置 urlpathhelper，但控制器映射需要与编码路径匹配，这可能并不总是有效。此外，有时 dispatcherservlet 需要与另一个 servlet 共享 url 空间，并且可能需要通过前缀进行映射。\n\n在使用 pathpatternparser 和解析模式时解决了上述问题，作为使用 antpathmatcher 进行字符串路径匹配的替代方法。pathpatternparser 从 5.3 版本开始就可以在 spring mvc 中使用，并且从 6.0 版本开始默认启用。与需要解码查找路径或编码控制器映射的 antpathmatcher 不同，解析的 pathpattern 与称为 requestpath 的路径的解析表示匹配，一次一个路径段。这允许单独解码和清理路径段值，而没有改变路径结构的风险。解析的 pathpattern 也支持使用 servletpath 前缀映射，只要使用 servlet 路径映射并且前缀保持简单，即它没有编码字符。\n\n\n# 拦截器\n\n所有 handlermapping 实现都支持处理拦截器，当想要将特定功能应用于某些请求时，这些拦截器很有用——例如，检查主体。拦截器必须使用 org.springframework.web.servlet 包中的三个方法实现 handlerinterceptor，这三个方法应该提供足够的灵活性来进行各种预处理和后处理：\n\n * prehandle(..)：在实际 handler 之前执行\n * posthandle(..)：handler 之后执行\n * aftercompletion(..)：完成请求后执行\n\nprehandle(..) 方法返回一个布尔值。可以使用此方法中断或继续执行链的处理。当此方法返回 true 时，处理程序执行链将继续。当它返回 false 时，dispatcherservlet 假定拦截器本身已经处理请求（并且，例如，呈现适当的视图）并且不会继续执行其他拦截器和执行链中的实际处理程序。\n\n有关如何配置拦截器的示例，请参阅 mvc 配置部分中的拦截器。还可以通过在各个 handlermapping 实现上使用 setter 来直接注册它们。\n\nposthandle 方法对于 @responsebody 和 responseentity 的方法不太有用，它们的响应是在 handleradapter 中和 posthandle 之前编写和提交的。这意味着对响应进行任何更改都为时已晚，例如添加额外的标头。对于此类场景，您可以实现 responsebodyadvice 并将其声明为 controller advice bean 或直接在 requestmappinghandleradapter 上进行配置。\n\n\n# 解析器\n\ndispatcherservlet 会加载多种解析器来处理请求，比较常见的有以下几个：\n\n * handlerexceptionresolver - 解决异常的策略，可能将它们映射到处理程序、html 错误视图或其他目标。\n * viewresolver - 将从处理程序返回的基于字符串的逻辑视图名称解析为用于呈现响应的实际视图。\n * localeresolver, localecontextresolver - 解析用户正在使用的本地化设置，可能还有他们的时区，以便能够提供国际化的视图。\n * themeresolver - 解析 web 应用程序可以使用的主题——例如，提供个性化布局。\n * multipartresolver - 通过一些 multipart 解析库的帮助解析 multipart 请求（例如，通过浏览器上传文件）。\n\n\n# handlerexceptionresolver\n\n在 webapplicationcontext 中声明的 handlerexceptionresolver 用于解决请求处理期间抛出的异常。这些异常解析器允许自定义逻辑来解决异常。\n\n对于 http 缓存支持，处理程序可以使用 webrequest 的 checknotmodified 方法，以及用于控制器的 http 缓存中所述的带注释控制器的更多选项。\n\n如果在请求映射期间发生异常或从请求处理程序（例如 @controller）抛出异常，则 dispatcherservlet 委托 handlerexceptionresolver 链来解决异常并提供替代处理，这通常是错误响应。\n\n下表列出了可用的 handlerexceptionresolver 实现：\n\nhandlerexceptionresolver            说明\nsimplemappingexceptionresolver      异常类名称和错误视图名称之间的映射。用于在浏览器应用程序中呈现错误页面。\ndefaulthandlerexceptionresolver     解决由 spring mvc 引发的异常并将它们映射到 http 状态代码。\nresponsestatusexceptionresolver     使用 @responsestatus 注解解决异常，并根据注解中的值将它们映射到 http 状态代码。\nexceptionhandlerexceptionresolver   通过在 @controller 或 @controlleradvice 类中调用 @exceptionhandler\n                                    方法来解决异常。\n\n# 解析器链\n\n您可以通过在 spring 配置中声明多个 handlerexceptionresolver bean 并根据需要设置它们的顺序属性来构成异常解析器链。order 属性越高，异常解析器的位置就越靠后。\n\nhandlerexceptionresolver 的约定使它可以返回以下内容：\n\n * 指向错误视图的 modelandview。\n\n * 如果异常是在解析器中处理的，则为空的 modelandview。\n\n * 如果异常仍未解决，则为 null，供后续解析器尝试，如果异常仍然存在，则允许向上冒泡到 servlet 容器。\n\nmvc config 自动为默认的 spring mvc 异常、@responsestatus 注释的异常和对 @exceptionhandler 方法的支持声明内置解析器。您可以自定义该列表或替换它。\n\n# 错误页面\n\n如果异常仍未被任何 handlerexceptionresolver 处理并因此继续传播，或者如果响应状态设置为错误状态（即 4xx、5xx），servlet 容器可以在 html 中呈现默认错误页面。要自定义容器的默认错误页面，您可以在 web.xml 中声明一个错误页面映射。以下示例显示了如何执行此操作：\n\n<error-page>\n    <location>/error</location>\n</error-page>\n\n\n在前面的示例中，当出现异常或响应具有错误状态时，servlet 容器会在容器内将 error 分派到配置的 url（例如，/error）。然后由 dispatcherservlet 处理，可能将其映射到 @controller，后者可以返回带有模型的错误视图名称或呈现 json 响应，如以下示例所示：\n\n@restcontroller\npublic class errorcontroller {\n\n    @requestmapping(path = "/error")\n    public map<string, object> handle(httpservletrequest request) {\n        map<string, object> map = new hashmap<string, object>();\n        map.put("status", request.getattribute("jakarta.servlet.error.status_code"));\n        map.put("reason", request.getattribute("jakarta.servlet.error.message"));\n        return map;\n    }\n}\n\n\n> 提示：servlet api 不提供在 java 中创建错误页面映射的方法。但是，您可以同时使用 webapplicationinitializer 和最小的 web.xml。\n\n\n# viewresolver\n\nspring mvc 定义了 viewresolver 和 view 接口，让用户可以在浏览器中渲染模型，而无需限定于特定的视图技术。viewresolver 提供视图名称和实际视图之间的映射。view 解决了在移交给特定视图技术之前准备数据的问题。\n\n下表提供了有关 viewresolver 一些子类：\n\nviewresolver                     description\nabstractcachingviewresolver      abstractcachingviewresolver\n                                 的子类缓存它们解析的视图实例。缓存提高了某些视图技术的性能。您可以通过将 cache 属性设置为 false\n                                 来关闭缓存。此外，如果您必须在运行时刷新某个视图（例如，修改 freemarker 模板时），您可以使用\n                                 removefromcache(string viewname, locale loc) 方法。\nurlbasedviewresolver             viewresolver 接口的简单实现，无需显式映射定义即可将逻辑视图名称直接解析为\n                                 url。如果您的逻辑名称以直接的方式匹配您的视图资源的名称，而不需要任意映射，那么这是合适的。\ninternalresourceviewresolver     urlbasedviewresolver 的子类，支持 internalresourceview（实际上是\n                                 servlet 和 jsp）以及 jstlview 和 tilesview 等子类。可以使用\n                                 setviewclass(..) 为该解析器生成的所有视图指定视图类。\nfreemarkerviewresolver           urlbasedviewresolver 的子类，支持 freemarkerview 和它们的自定义子类。\ncontentnegotiatingviewresolver   viewresolver 接口的实现，该接口根据请求文件名或 accept 标头解析视图。\nbeannameviewresolver             将视图名称解释为当前应用程序上下文中的 bean 名称的 viewresolver\n                                 接口的实现。这是一个非常灵活的变体，允许根据不同的视图名称混合和匹配不同的视图类型。每个这样的“视图”都可以定义为一个\n                                 bean，例如 在 xml 或配置类中。\n\n# 处理\n\n可以通过声明多个解析器来构成视图解析器链，如果需要，还可以通过设置 order 属性来指定顺序。顺序属性越高，视图解析器在链中的位置就越靠后。\n\nviewresolver 的约定指定它可以返回 null 以指示找不到视图。但是，对于 jsp 和 internalresourceviewresolver，确定 jsp 是否存在的唯一方法是通过 requestdispatcher 执行分派。因此，您必须始终将 internalresourceviewresolver 配置为在视图解析器的整体顺序中排在最后。\n\n配置视图解析就像将 viewresolver 添加到 spring 配置中一样简单。mvc config 为视图解析器和添加无逻辑视图控制器提供了专用的配置 api，这对于没有控制器逻辑的 html 模板渲染很有用。\n\n# 重定向\n\n视图名称中的特殊前缀 redirect: 可以实现一个重定向。urlbasedviewresolver（及其子类）将此识别为需要重定向的指令。视图名称的其余部分是重定向 url。\n\n最终效果与控制器返回 redirectview 相同，但现在控制器本身可以根据逻辑视图名称进行操作。逻辑视图名称（例如 redirect:/myapp/some/resource）相对于当前 servlet 上下文重定向，而名称（例如 redirect:https://myhost.com/some/arbitrary/path）重定向到绝对 url。\n\n请注意，如果使用 @responsestatus 注解标记控制器方法，则注解值优先于 redirectview 设置的响应状态。\n\n# 转发\n\n视图名称中的特殊前缀 forward: 可以实现一个转发。这将创建一个 internalresourceview，它执行 requestdispatcher.forward()。因此，此前缀对 internalresourceviewresolver 和 internalresourceview（对于 jsp）没有用，但如果您使用另一种视图技术但仍想强制转发由 servlet/jsp 引擎处理的资源，它可能会有所帮助。\n\n# 内容协商\n\ncontentnegotiatingviewresolver 本身不解析视图，而是委托给其他视图解析器并选择类似于客户端请求的表示的视图。可以从 accept 头或查询参数（例如，"/path?format=pdf"）确定表示形式。\n\ncontentnegotiatingviewresolver 通过将请求媒体类型与其每个 viewresolver 关联的 view 支持的媒体类型（也称为 content-type）进行比较，来选择合适的 view 来处理请求。列表中第一个具有兼容 content-type 的视图将处理结果返回给客户端。如果 viewresolver 链无法提供兼容的视图，则会查阅通过 defaultviews 属性指定的视图列表。后一个选项适用于单例视图，它可以呈现当前资源的适当表示，而不管逻辑视图名称如何。accept 标头可以包含通配符（例如 text/*），在这种情况下，content-type 为 text/xml 的 view 是兼容的匹配项。\n\n\n# localeresolver\n\n大部分的 spring 架构都支持国际化，就像 spring web mvc 框架所做的那样。dispatcherservlet 允许您使用客户端的语言环境自动解析消息。这是通过 localeresolver 对象完成的。\n\n当收到请求时，dispatcherservlet 会寻找语言环境解析器，如果找到，它会尝试使用它来设置 locale 环境。通过使用 requestcontext.getlocale() 方法，您始终可以检索由 locale 解析器解析的语言环境。\n\n除了自动识别 locale 环境之外，您还可以为 handle 映射附加拦截器，在特定情况下更改 locale 环境设置（例如，基于请求中的参数）。\n\nlocale 解析器和拦截器在 org.springframework.web.servlet.i18n 包中定义，并以正常方式在您的应用程序上下文中配置。spring 中有以下 locale 解析器可供选择。\n\n * time zone\n * header resolver\n * cookie resolver\n * session resolver\n * locale interceptor\n\n# localeresolver\n\n除了获取客户端的区域设置外，了解其时区通常也很有用。localecontextresolver 接口提供了 localeresolver 的扩展，让解析器提供更丰富的 localecontext，其中可能包括时区信息。\n\n如果可用，可以使用 requestcontext.gettimezone() 方法获取用户的 timezone。在 spring 的 conversionservice 中注册的任何日期/时间 converter 和 formatter 对象会自动使用时区信息。\n\n# 标头解析器\n\n此 locale 解析器检查客户端（例如网络浏览器）发送的请求中的 accept-language 头。通常，此头字段包含客户端操作系统的区域信息。请注意，此解析器不支持时区信息。\n\n# cookielocaleresolver\n\nthis locale resolver inspects a cookie that might exist on the client to see if a locale or timezone is specified. if so, it uses the specified details. by using the properties of this locale resolver, you can specify the name of the cookie as well as the maximum age. the following example defines a cookielocaleresolver:\n\n此 locale 解析器检查客户端上是否存在 cookie，以查看是否指定了 locale 或 timezone。如果是，它会使用指定的详细信息。通过使用此 locale 解析器的属性，可以指定 cookie 的名称以及最长期限。以下示例定义了 cookielocaleresolver：\n\n<bean id="localeresolver" class="org.springframework.web.servlet.i18n.cookielocaleresolver">\n\n    <property name="cookiename" value="clientlanguage"/>\n\n    \x3c!-- in seconds. if set to -1, the cookie is not persisted (deleted when browser shuts down) --\x3e\n    <property name="cookiemaxage" value="100000"/>\n\n</bean>\n\n\n下表描述了 cookielocaleresolver 的属性：\n\n属性             默认值                         description\ncookiename     类名 + locale                 cookie 名\ncookiemaxage   servlet container default   cookie 在客户端上保留的最长时间。如果指定了“-1”，则不会保留 cookie。它仅在客户端关闭浏览器之前可用。\ncookiepath     /                           将 cookie 的可见性限制在您网站的特定部分。当指定 cookiepath 时，cookie\n                                           仅对该路径及其下方的路径可见。\n\n# sessionlocaleresolver\n\nsessionlocaleresolver 允许您从可能与用户请求相关联的会话中检索 locale 和 timezone。与 cookielocaleresolver 相比，此策略将本地选择的 locale 设置存储在 servlet 容器的 httpsession 中。因此，这些设置对于每个会话都是临时的，因此会在每个会话结束时丢失。\n\n注意，这与外部会话管理机制（例如 spring session 项目）没有直接关系。此 sessionlocaleresolver 根据当前 httpservletrequest 评估和修改相应的 httpsession 属性。\n\n# localechangeinterceptor\n\n可以通过将 localechangeinterceptor 添加到一个 handlermapping 定义来启用区域设置更改。它检测请求中的参数并相应地更改 locale 环境，在调度程序的应用程序上下文中调用 localeresolver 上的 setlocale 方法。下面的示例显示调用所有包含名为 sitelanguage 的参数的 *.view 资源，以更改语言环境。因此，例如，对 url https://www.sf.net/home.view?sitelanguage=nl 的请求将站点语言更改为荷兰语。以下示例显示了如何拦截语言环境：\n\n<bean id="localechangeinterceptor"\n        class="org.springframework.web.servlet.i18n.localechangeinterceptor">\n    <property name="paramname" value="sitelanguage"/>\n</bean>\n\n<bean id="localeresolver"\n        class="org.springframework.web.servlet.i18n.cookielocaleresolver"/>\n\n<bean id="urlmapping"\n        class="org.springframework.web.servlet.handler.simpleurlhandlermapping">\n    <property name="interceptors">\n        <list>\n            <ref bean="localechangeinterceptor"/>\n        </list>\n    </property>\n    <property name="mappings">\n        <value>/**/*.view=somecontroller</value>\n    </property>\n</bean>\n\n\n\n# themeresolver\n\n您可以应用 spring web mvc 框架主题来设置应用程序的整体外观，从而增强用户体验。主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉风格。\n\n要在 web 应用程序中使用主题，必须设置 org.springframework.ui.context.themesource 接口的实现。webapplicationcontext 接口扩展了 themesource 但将其职责委托给了专门的实现。默认情况下，委托是 org.springframework.ui.context.support.resourcebundlethemesource ，它从类的根路径加载属性文件。要使用自定义的 themesource 实现或配置 resourcebundlethemesource 的基本名称前缀，您可以在应用程序上下文中使用保留名称 themesource 注册一个 bean。web 应用程序上下文自动检测具有该名称的 bean 并使用它。\n\n当使用 resourcebundlethemesource 时，主题是在一个简单的属性文件中定义的。属性文件列出了构成主题的资源，如以下示例所示：\n\nstylesheet=/themes/cool/style.css\nbackground=/themes/cool/img/coolbg.jpg\n\n\n属性的键是从视图代码中引用主题元素的名称。对于 jsp，通常使用 spring:theme 自定义标签来执行此操作，它与 spring:message 标签非常相似。以下 jsp 片段使用前面示例中定义的主题来自定义外观：\n\n<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>\n<html>\n    <head>\n        <link rel="stylesheet" href="<spring:theme code=\'stylesheet\'/>" type="text/css"/>\n    </head>\n    <body style="background=<spring:theme code=\'background\'/>">\n        ...\n    </body>\n</html>\n\n\n默认情况下， resourcebundlethemesource 使用空的基本名称前缀。因此，属性文件是从类路径的根加载的。因此，可以将 cool.properties 主题定义放在类路径根目录中（例如，在 /web-inf/classes 中）。resourcebundlethemesource 使用标准的 java 资源包加载机制，允许主题完全国际化。例如，我们可以有一个 /web-inf/classes/cool_nl.properties，它引用一个带有荷兰语文本的特殊背景图像。\n\n定义主题后，可以决定使用哪个要使用的主题。dispatcherservlet 查找名为 themeresolver 的 bean 以找出要使用的 themeresolver 实现。主题解析器的工作方式与 localeresolver 大致相同。它检测用于特定请求的主题，也可以更改请求的主题。下表描述了 spring 提供的主题解析器：\n\nclass                  description\nfixedthemeresolver     选择一个固定的主题，使用 defaultthemename 属性设置。\nsessionthemeresolver   主题在用户的 http 会话中维护。 它只需要为每个会话设置一次，但不会在会话之间持续存在。\ncookiethemeresolver    所选主题存储在客户端的 cookie 中。\n\nspring 还提供了一个 themechangeinterceptor，它允许使用一个简单的请求参数在每个请求上更改主题。\n\n\n# multipartresolver\n\norg.springframework.web.multipart 包中的 multipartresolver 是一种解析 multipart 请求（包括文件上传）的策略。 有一个基于容器的 standardservletmultipartresolver 实现，用于 servlet 多部分请求解析。 请注意，从具有新 servlet 5.0+ 基线的 spring framework 6.0 开始，基于 apache commons fileupload 的过时的 commonsmultipartresolver 不再可用。\n\n要启用 multipart 处理，需要在 dispatcherservlet spring 配置中声明一个名为 multipartresolver 的 multipartresolver。 dispatcherservlet 检测到它并将其应用于传入请求。 当接收到内容类型为 multipart/form-data 的 post 时，解析器解析将当前 httpservletrequest 包装为 multiparthttpservletrequest 的内容，以提供对已解析文件的访问以及将部分作为请求参数公开。\n\nservlet 多部分解析需要通过 servlet 容器配置启用。 为此：\n\n * 在 java 中，在 servlet 注册上设置一个 multipartconfigelement。\n\n * 在 web.xml 中，将 <multipart-config> 部分添加到 servlet 声明。\n\n以下示例显示如何在 servlet 注册上设置 multipartconfigelement：\n\npublic class appinitializer extends abstractannotationconfigdispatcherservletinitializer {\n\n    // ...\n\n    @override\n    protected void customizeregistration(servletregistration.dynamic registration) {\n\n        // optionally also set maxfilesize, maxrequestsize, filesizethreshold\n        registration.setmultipartconfig(new multipartconfigelement("/tmp"));\n    }\n\n}\n\n\n一旦 servlet multipart 配置好，就可以添加一个名为 multipartresolver 的 standardservletmultipartresolver 类型的 bean。\n\n\n# 参考资料\n\n * spring framework 官方文档\n * spring framework 官方文档之 web',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring MVC 之过滤器",frontmatter:{title:"Spring MVC 之过滤器",date:"2023-02-14T17:44:09.000Z",categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","Web","Filter"],permalink:"/pages/4a164d/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/04.Spring%E8%BF%87%E6%BB%A4%E5%99%A8.html",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/04.Spring过滤器.md",key:"v-059d2e9c",path:"/pages/4a164d/",headers:[{level:2,title:"表单内容过滤器",slug:"表单内容过滤器",normalizedTitle:"表单内容过滤器",charIndex:112},{level:2,title:"转发过滤器",slug:"转发过滤器",normalizedTitle:"转发过滤器",charIndex:457},{level:2,title:"ETag 过滤器",slug:"etag-过滤器",normalizedTitle:"etag 过滤器",charIndex:1352},{level:2,title:"跨域过滤器",slug:"跨域过滤器",normalizedTitle:"跨域过滤器",charIndex:1952},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2079}],headersStr:"表单内容过滤器 转发过滤器 ETag 过滤器 跨域过滤器 参考资料",content:'# Spring MVC 之过滤器\n\nspring-web 模块提供了一些有用的 Filter：\n\n * Form Data\n * Forwarded Headers\n * Shallow ETag\n * CORS\n\n\n# 表单内容过滤器\n\n浏览器只能通过 HTTP GET 或 HTTP POST 提交表单数据，但非浏览器客户端也可以使用 HTTP PUT、PATCH 和 DELETE。 Servlet API 需要 ServletRequest.getParameter*() 系列方法来支持仅对 HTTP POST 的表单字段访问。\n\nspring-web 模块提供了 FormContentFilter 来拦截内容类型为 applicationx-www-form-urlencoded 的 HTTP PUT、PATCH、DELETE 请求，从请求体中读取表单数据，并包装 ServletRequest 通过 ServletRequest.getParameter() 系列方法使表单数据可用。\n\n\n# 转发过滤器\n\n当请求通过代理（如负载均衡器）时，主机、端口和方案可能会发生变化，这使得从客户端角度创建指向正确主机、端口和方案的链接成为一项挑战。\n\nRFC 7239 定义了 Forwarded HTTP 头，代理可以使用它来提供有关原始请求的信息。还有其他非标准头，包括 X-Forwarded-Host、X-Forwarded-Port、X-Forwarded-Proto、X-Forwarded-Ssl 和 X-Forwarded-Prefix。\n\nForwardedHeaderFilter 是一个 Servlet 过滤器，它修改请求以便 a) 根据 Forwarded 头更改主机、端口和 scheme；b) 删除这些头以消除进一步的影响。该过滤器依赖于包装请求，因此它必须排在其他过滤器之前，例如 RequestContextFilter，它应该与修改后的请求一起使用，而不是原始请求。\n\nForwarded 头有安全考量，因为应用程序无法知道头是由代理按预期添加的，还是由恶意客户端添加的。这就是为什么应将信任边界处的代理配置为删除来自外部的不受信任的 Forwarded 头。还可以使用 removeOnly=true 配置 ForwardedHeaderFilter，在这种情况下它会删除但不使用头。\n\n为了支持异步请求和错误分派，此过滤器应使用 DispatcherType.ASYNC 和 DispatcherType.ERROR 进行映射。如果使用 Spring Framework 的 AbstractAnnotationConfigDispatcherServletInitializer（参见 Servlet Config），所有过滤器都会自动为所有调度类型注册。但是，如果通过 web.xml 或在 Spring Boot 中通过 FilterRegistrationBean 注册过滤器，请确保除了 DispatcherType.REQUEST 之外还包括 DispatcherType.ASYNC 和 DispatcherType.ERROR。\n\n\n# ETag 过滤器\n\nShallowEtagHeaderFilter 过滤器通过缓存写入响应的内容并从中计算 MD5 哈希来创建“浅”ETag。下次客户端发送时，它会做同样的事情，但它还会将计算值与 If-None-Match 请求标头进行比较，如果两者相等，则返回 304 (NOT_MODIFIED)。\n\n此策略节省网络带宽但不节省 CPU，因为必须为每个请求计算完整响应。前面描述的控制器级别的其他策略可以避免计算。\n\n此过滤器有一个 writeWeakETag 参数，该参数将过滤器配置为写入类似于以下内容的弱 ETag：W"02a2d595e6ed9a0b24f027f2b63b134d6"（如 RFC 7232 Section 2.3 中所定义）。\n\n为了支持异步请求，这个过滤器必须用 DispatcherType.ASYNC 映射，这样过滤器才能延迟并成功生成一个 ETag 到最后最后一次异步调度。如果使用 Spring Framework 的 AbstractAnnotationConfigDispatcherServletInitializer，所有过滤器都会自动为所有调度类型注册。但是，如果通过 web.xml 或在 Spring Boot 中通过 FilterRegistrationBean 注册过滤器，请确保包含 DispatcherType.ASYNC。\n\n\n# 跨域过滤器\n\nSpring MVC 通过控制器上的注解为 CORS 配置提供细粒度支持。但是，当与 Spring Security 一起使用时，建议依赖内置的 CorsFilter，它必须在 Spring Security 的过滤器链之前订阅。\n\n\n# 参考资料\n\n * Spring Framework 官方文档\n * Spring Framework 官方文档之 Web',normalizedContent:'# spring mvc 之过滤器\n\nspring-web 模块提供了一些有用的 filter：\n\n * form data\n * forwarded headers\n * shallow etag\n * cors\n\n\n# 表单内容过滤器\n\n浏览器只能通过 http get 或 http post 提交表单数据，但非浏览器客户端也可以使用 http put、patch 和 delete。 servlet api 需要 servletrequest.getparameter*() 系列方法来支持仅对 http post 的表单字段访问。\n\nspring-web 模块提供了 formcontentfilter 来拦截内容类型为 applicationx-www-form-urlencoded 的 http put、patch、delete 请求，从请求体中读取表单数据，并包装 servletrequest 通过 servletrequest.getparameter() 系列方法使表单数据可用。\n\n\n# 转发过滤器\n\n当请求通过代理（如负载均衡器）时，主机、端口和方案可能会发生变化，这使得从客户端角度创建指向正确主机、端口和方案的链接成为一项挑战。\n\nrfc 7239 定义了 forwarded http 头，代理可以使用它来提供有关原始请求的信息。还有其他非标准头，包括 x-forwarded-host、x-forwarded-port、x-forwarded-proto、x-forwarded-ssl 和 x-forwarded-prefix。\n\nforwardedheaderfilter 是一个 servlet 过滤器，它修改请求以便 a) 根据 forwarded 头更改主机、端口和 scheme；b) 删除这些头以消除进一步的影响。该过滤器依赖于包装请求，因此它必须排在其他过滤器之前，例如 requestcontextfilter，它应该与修改后的请求一起使用，而不是原始请求。\n\nforwarded 头有安全考量，因为应用程序无法知道头是由代理按预期添加的，还是由恶意客户端添加的。这就是为什么应将信任边界处的代理配置为删除来自外部的不受信任的 forwarded 头。还可以使用 removeonly=true 配置 forwardedheaderfilter，在这种情况下它会删除但不使用头。\n\n为了支持异步请求和错误分派，此过滤器应使用 dispatchertype.async 和 dispatchertype.error 进行映射。如果使用 spring framework 的 abstractannotationconfigdispatcherservletinitializer（参见 servlet config），所有过滤器都会自动为所有调度类型注册。但是，如果通过 web.xml 或在 spring boot 中通过 filterregistrationbean 注册过滤器，请确保除了 dispatchertype.request 之外还包括 dispatchertype.async 和 dispatchertype.error。\n\n\n# etag 过滤器\n\nshallowetagheaderfilter 过滤器通过缓存写入响应的内容并从中计算 md5 哈希来创建“浅”etag。下次客户端发送时，它会做同样的事情，但它还会将计算值与 if-none-match 请求标头进行比较，如果两者相等，则返回 304 (not_modified)。\n\n此策略节省网络带宽但不节省 cpu，因为必须为每个请求计算完整响应。前面描述的控制器级别的其他策略可以避免计算。\n\n此过滤器有一个 writeweaketag 参数，该参数将过滤器配置为写入类似于以下内容的弱 etag：w"02a2d595e6ed9a0b24f027f2b63b134d6"（如 rfc 7232 section 2.3 中所定义）。\n\n为了支持异步请求，这个过滤器必须用 dispatchertype.async 映射，这样过滤器才能延迟并成功生成一个 etag 到最后最后一次异步调度。如果使用 spring framework 的 abstractannotationconfigdispatcherservletinitializer，所有过滤器都会自动为所有调度类型注册。但是，如果通过 web.xml 或在 spring boot 中通过 filterregistrationbean 注册过滤器，请确保包含 dispatchertype.async。\n\n\n# 跨域过滤器\n\nspring mvc 通过控制器上的注解为 cors 配置提供细粒度支持。但是，当与 spring security 一起使用时，建议依赖内置的 corsfilter，它必须在 spring security 的过滤器链之前订阅。\n\n\n# 参考资料\n\n * spring framework 官方文档\n * spring framework 官方文档之 web',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring MVC 之跨域",frontmatter:{title:"Spring MVC 之跨域",date:"2023-02-16T20:33:26.000Z",categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","Web","CORS"],permalink:"/pages/1d2954/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/05.Spring%E8%B7%A8%E5%9F%9F.html",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/05.Spring跨域.md",key:"v-3cee8b95",path:"/pages/1d2954/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:47},{level:2,title:"处理",slug:"处理",normalizedTitle:"处理",charIndex:33},{level:2,title:"@CrossOrigin",slug:"crossorigin",normalizedTitle:"@crossorigin",charIndex:1053},{level:2,title:"全局配置",slug:"全局配置",normalizedTitle:"全局配置",charIndex:2852},{level:3,title:"Java 配置",slug:"java-配置",normalizedTitle:"java 配置",charIndex:911},{level:3,title:"XML 配置",slug:"xml-配置",normalizedTitle:"xml 配置",charIndex:3818},{level:2,title:"CORS 过滤器",slug:"cors-过滤器",normalizedTitle:"cors 过滤器",charIndex:4272},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4801}],headersStr:"简介 处理 @CrossOrigin 全局配置 Java 配置 XML 配置 CORS 过滤器 参考资料",content:'# Spring MVC 之跨域\n\nSpring MVC 支持跨域处理（CORS）。\n\n\n# 简介\n\n出于安全原因，浏览器禁止对当前源之外的资源进行 AJAX 调用。例如，可以在一个选项卡中使用您的银行帐户，而在另一个选项卡中使用 evil.com。来自 evil.com 的脚本不应该能够使用您的凭据向您的银行 API 发出 AJAX 请求——例如从您的账户中取款！\n\n跨域（CORS）是由 大多数浏览器 实施的 W3C 规范，可让您指定哪种跨域请求是授权，而不是使用基于 IFRAME 或 JSONP 的不太安全和不太强大的解决方法。\n\n\n# 处理\n\nCORS 规范分为预检请求、简单请求和实际请求。要了解 CORS 的工作原理，可以阅读 Cross-Origin Resource Sharing (CORS) 等，或者查看规范了解更多详细信息。\n\nSpring MVC HandlerMapping 实现提供了对 CORS 的内置支持。成功将请求映射到处理程序后，HandlerMapping 实现检查给定请求和处理程序的 CORS 配置并采取进一步的操作。预检请求被直接处理，而简单和实际的 CORS 请求被拦截、验证，并设置了所需的 CORS 响应标头。\n\n为了启用跨源请求（即存在 Origin 标头并且与请求的主机不同），您需要有一些明确声明的 CORS 配置。如果未找到匹配的 CORS 配置，预检请求将被拒绝。没有 CORS 标头添加到简单和实际 CORS 请求的响应中，因此浏览器会拒绝它们。\n\n每个 HandlerMapping 都可以[配置](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations- java.util.Map-) 单独使用基于 URL 模式的 CorsConfiguration 映射。 在大多数情况下，应用程序使用 MVC Java 配置或 XML 命名空间来声明此类映射，这会导致将单个全局映射传递给所有 HandlerMapping 实例。\n\n可以将 HandlerMapping 级别的全局 CORS 配置与更细粒度的处理程序级别的 CORS 配置相结合。 例如，带注释的控制器可以使用类级或方法级的 @CrossOrigin 注释（其他处理程序可以实现 CorsConfigurationSource）。\n\nThe rules for combining global and local configuration are generally additive — for example, all global and all local origins. For those attributes where only a single value can be accepted, e.g. allowCredentials and maxAge, the local overrides the global value.\n\n结合全局和局部配置的规则通常是附加的⟩——例如，所有全局和所有局部起源。 对于那些只能接受单个值的属性，例如 allowCredentials 和 maxAge，局部覆盖全局值。\n\n\n# @CrossOrigin\n\n@CrossOrigin 注解在带注解的 Controller 方法上启用跨源请求，如以下示例所示：\n\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @CrossOrigin\n    @GetMapping("/{id}")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping("/{id}")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}\n\n\n默认，@CrossOrigin 允许访问：\n\n * 所以 origin\n * 所以 header\n * 所以 Controller 方法映射到的 HTTP 方法\n\nallowCredentials 默认情况下不启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息（例如 cookie 和 CSRF 令牌），并且只应在适当的情况下使用。启用时，必须将 allowOrigins 设置为一个或多个特定域（但不是特殊值 "*"），或者 allowOriginPatterns 属性可用于匹配一组动态来源。\n\nmaxAge 单位为分钟\n\n@CrossOrigin 也支持类级别，并且被所有方继承，如下所示：\n\n@CrossOrigin(origins = "https://domain2.com", maxAge = 3600)\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @GetMapping("/{id}")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping("/{id}")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}\n\n\n可以同时在类级别和方法级别上使用 @CrossOrigin\n\n@CrossOrigin(maxAge = 3600)\n@RestController\n@RequestMapping("/account")\npublic class AccountController {\n\n    @CrossOrigin("https://domain2.com")\n    @GetMapping("/{id}")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping("/{id}")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}\n\n\n\n# 全局配置\n\n除了细粒度的控制器方法级别配置之外，您可能还想定义一些全局 CORS 配置。您可以在任何 HandlerMapping 上单独设置基于 URL 的 CorsConfiguration 映射。但是，大多数应用程序使用 MVC Java 配置或 MVC XML 命名空间来执行此操作。\n\n默认情况下，全局配置启用以下功能：\n\n * 所以 origin\n * 所以 header\n * GET、HEAD 和 POST 方法\n\nallowCredentials 默认情况下不启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息（例如 cookie 和 CSRF 令牌），并且只应在适当的情况下使用。启用时，必须将 allowOrigins 设置为一个或多个特定域（但不是特殊值 "*"），或者 allowOriginPatterns 属性可用于匹配一组动态来源。\n\nmaxAge 单位为分钟\n\n\n# Java 配置\n\n要在 MVC Java 配置中启用 CORS，您可以使用 CorsRegistry 回调，如以下示例所示：\n\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n\n        registry.addMapping("/api/**")\n            .allowedOrigins("https://domain2.com")\n            .allowedMethods("PUT", "DELETE")\n            .allowedHeaders("header1", "header2", "header3")\n            .exposedHeaders("header1", "header2")\n            .allowCredentials(true).maxAge(3600);\n\n        // Add more mappings...\n    }\n}\n\n\n\n# XML 配置\n\n要在 XML 命名空间中启用 CORS，可以使用 <mvc:cors> 元素，如以下示例所示：\n\n<mvc:cors>\n\n    <mvc:mapping path="/api/**"\n        allowed-origins="https://domain1.com, https://domain2.com"\n        allowed-methods="GET, PUT"\n        allowed-headers="header1, header2, header3"\n        exposed-headers="header1, header2" allow-credentials="true"\n        max-age="123" />\n\n    <mvc:mapping path="/resources/**"\n        allowed-origins="https://domain1.com" />\n\n</mvc:cors>\n\n\n\n# CORS 过滤器\n\n可以通过 Spring 内置的 CorsFilter 支持 CORS。\n\n要配置过滤器，请将 CorsConfigurationSource 传递给它的构造函数，如以下示例所示：\n\nCorsConfiguration config = new CorsConfiguration();\n\n// Possibly...\n// config.applyPermitDefaultValues()\n\nconfig.setAllowCredentials(true);\nconfig.addAllowedOrigin("https://domain1.com");\nconfig.addAllowedHeader("*");\nconfig.addAllowedMethod("*");\n\nUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\nsource.registerCorsConfiguration("/**", config);\n\nCorsFilter filter = new CorsFilter(source);\n\n\n\n# 参考资料\n\n * Spring Framework 官方文档\n * Spring Framework 官方文档之 Web',normalizedContent:'# spring mvc 之跨域\n\nspring mvc 支持跨域处理（cors）。\n\n\n# 简介\n\n出于安全原因，浏览器禁止对当前源之外的资源进行 ajax 调用。例如，可以在一个选项卡中使用您的银行帐户，而在另一个选项卡中使用 evil.com。来自 evil.com 的脚本不应该能够使用您的凭据向您的银行 api 发出 ajax 请求——例如从您的账户中取款！\n\n跨域（cors）是由 大多数浏览器 实施的 w3c 规范，可让您指定哪种跨域请求是授权，而不是使用基于 iframe 或 jsonp 的不太安全和不太强大的解决方法。\n\n\n# 处理\n\ncors 规范分为预检请求、简单请求和实际请求。要了解 cors 的工作原理，可以阅读 cross-origin resource sharing (cors) 等，或者查看规范了解更多详细信息。\n\nspring mvc handlermapping 实现提供了对 cors 的内置支持。成功将请求映射到处理程序后，handlermapping 实现检查给定请求和处理程序的 cors 配置并采取进一步的操作。预检请求被直接处理，而简单和实际的 cors 请求被拦截、验证，并设置了所需的 cors 响应标头。\n\n为了启用跨源请求（即存在 origin 标头并且与请求的主机不同），您需要有一些明确声明的 cors 配置。如果未找到匹配的 cors 配置，预检请求将被拒绝。没有 cors 标头添加到简单和实际 cors 请求的响应中，因此浏览器会拒绝它们。\n\n每个 handlermapping 都可以[配置](https://docs.spring.io/spring-framework/docs/6.0.4/javadoc-api/org/springframework/web/servlet/handler/abstracthandlermapping.html#setcorsconfigurations- java.util.map-) 单独使用基于 url 模式的 corsconfiguration 映射。 在大多数情况下，应用程序使用 mvc java 配置或 xml 命名空间来声明此类映射，这会导致将单个全局映射传递给所有 handlermapping 实例。\n\n可以将 handlermapping 级别的全局 cors 配置与更细粒度的处理程序级别的 cors 配置相结合。 例如，带注释的控制器可以使用类级或方法级的 @crossorigin 注释（其他处理程序可以实现 corsconfigurationsource）。\n\nthe rules for combining global and local configuration are generally additive — for example, all global and all local origins. for those attributes where only a single value can be accepted, e.g. allowcredentials and maxage, the local overrides the global value.\n\n结合全局和局部配置的规则通常是附加的⟩——例如，所有全局和所有局部起源。 对于那些只能接受单个值的属性，例如 allowcredentials 和 maxage，局部覆盖全局值。\n\n\n# @crossorigin\n\n@crossorigin 注解在带注解的 controller 方法上启用跨源请求，如以下示例所示：\n\n@restcontroller\n@requestmapping("/account")\npublic class accountcontroller {\n\n    @crossorigin\n    @getmapping("/{id}")\n    public account retrieve(@pathvariable long id) {\n        // ...\n    }\n\n    @deletemapping("/{id}")\n    public void remove(@pathvariable long id) {\n        // ...\n    }\n}\n\n\n默认，@crossorigin 允许访问：\n\n * 所以 origin\n * 所以 header\n * 所以 controller 方法映射到的 http 方法\n\nallowcredentials 默认情况下不启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息（例如 cookie 和 csrf 令牌），并且只应在适当的情况下使用。启用时，必须将 alloworigins 设置为一个或多个特定域（但不是特殊值 "*"），或者 alloworiginpatterns 属性可用于匹配一组动态来源。\n\nmaxage 单位为分钟\n\n@crossorigin 也支持类级别，并且被所有方继承，如下所示：\n\n@crossorigin(origins = "https://domain2.com", maxage = 3600)\n@restcontroller\n@requestmapping("/account")\npublic class accountcontroller {\n\n    @getmapping("/{id}")\n    public account retrieve(@pathvariable long id) {\n        // ...\n    }\n\n    @deletemapping("/{id}")\n    public void remove(@pathvariable long id) {\n        // ...\n    }\n}\n\n\n可以同时在类级别和方法级别上使用 @crossorigin\n\n@crossorigin(maxage = 3600)\n@restcontroller\n@requestmapping("/account")\npublic class accountcontroller {\n\n    @crossorigin("https://domain2.com")\n    @getmapping("/{id}")\n    public account retrieve(@pathvariable long id) {\n        // ...\n    }\n\n    @deletemapping("/{id}")\n    public void remove(@pathvariable long id) {\n        // ...\n    }\n}\n\n\n\n# 全局配置\n\n除了细粒度的控制器方法级别配置之外，您可能还想定义一些全局 cors 配置。您可以在任何 handlermapping 上单独设置基于 url 的 corsconfiguration 映射。但是，大多数应用程序使用 mvc java 配置或 mvc xml 命名空间来执行此操作。\n\n默认情况下，全局配置启用以下功能：\n\n * 所以 origin\n * 所以 header\n * get、head 和 post 方法\n\nallowcredentials 默认情况下不启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息（例如 cookie 和 csrf 令牌），并且只应在适当的情况下使用。启用时，必须将 alloworigins 设置为一个或多个特定域（但不是特殊值 "*"），或者 alloworiginpatterns 属性可用于匹配一组动态来源。\n\nmaxage 单位为分钟\n\n\n# java 配置\n\n要在 mvc java 配置中启用 cors，您可以使用 corsregistry 回调，如以下示例所示：\n\n@configuration\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    @override\n    public void addcorsmappings(corsregistry registry) {\n\n        registry.addmapping("/api/**")\n            .allowedorigins("https://domain2.com")\n            .allowedmethods("put", "delete")\n            .allowedheaders("header1", "header2", "header3")\n            .exposedheaders("header1", "header2")\n            .allowcredentials(true).maxage(3600);\n\n        // add more mappings...\n    }\n}\n\n\n\n# xml 配置\n\n要在 xml 命名空间中启用 cors，可以使用 <mvc:cors> 元素，如以下示例所示：\n\n<mvc:cors>\n\n    <mvc:mapping path="/api/**"\n        allowed-origins="https://domain1.com, https://domain2.com"\n        allowed-methods="get, put"\n        allowed-headers="header1, header2, header3"\n        exposed-headers="header1, header2" allow-credentials="true"\n        max-age="123" />\n\n    <mvc:mapping path="/resources/**"\n        allowed-origins="https://domain1.com" />\n\n</mvc:cors>\n\n\n\n# cors 过滤器\n\n可以通过 spring 内置的 corsfilter 支持 cors。\n\n要配置过滤器，请将 corsconfigurationsource 传递给它的构造函数，如以下示例所示：\n\ncorsconfiguration config = new corsconfiguration();\n\n// possibly...\n// config.applypermitdefaultvalues()\n\nconfig.setallowcredentials(true);\nconfig.addallowedorigin("https://domain1.com");\nconfig.addallowedheader("*");\nconfig.addallowedmethod("*");\n\nurlbasedcorsconfigurationsource source = new urlbasedcorsconfigurationsource();\nsource.registercorsconfiguration("/**", config);\n\ncorsfilter filter = new corsfilter(source);\n\n\n\n# 参考资料\n\n * spring framework 官方文档\n * spring framework 官方文档之 web',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring MVC 之视图技术",frontmatter:{title:"Spring MVC 之视图技术",date:"2023-02-17T11:21:25.000Z",categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","Web","View"],permalink:"/pages/251e31/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/06.Spring%E8%A7%86%E5%9B%BE.html",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/06.Spring视图.md",key:"v-63e74542",path:"/pages/251e31/",headers:[{level:2,title:"Thymeleaf",slug:"thymeleaf",normalizedTitle:"thymeleaf",charIndex:52},{level:2,title:"FreeMarker",slug:"freemarker",normalizedTitle:"freemarker",charIndex:495},{level:3,title:"视图配置",slug:"视图配置",normalizedTitle:"视图配置",charIndex:613},{level:3,title:"FreeMarker 配置",slug:"freemarker-配置",normalizedTitle:"freemarker 配置",charIndex:630},{level:3,title:"表单处理",slug:"表单处理",normalizedTitle:"表单处理",charIndex:2504},{level:4,title:"绑定宏",slug:"绑定宏",normalizedTitle:"绑定宏",charIndex:2664},{level:4,title:"简单绑定",slug:"简单绑定",normalizedTitle:"简单绑定",charIndex:2910},{level:4,title:"输入宏",slug:"输入宏",normalizedTitle:"输入宏",charIndex:3964},{level:4,title:"HTML 转义",slug:"html-转义",normalizedTitle:"html 转义",charIndex:3812},{level:2,title:"Groovy",slug:"groovy",normalizedTitle:"groovy",charIndex:62},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:91},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:621},{level:2,title:"脚本视图",slug:"脚本视图",normalizedTitle:"脚本视图",charIndex:10626},{level:3,title:"要求",slug:"要求",normalizedTitle:"要求",charIndex:11001},{level:3,title:"脚本模板",slug:"脚本模板",normalizedTitle:"脚本模板",charIndex:11372},{level:2,title:"JSP 和 JSTL",slug:"jsp-和-jstl",normalizedTitle:"jsp 和 jstl",charIndex:14063},{level:2,title:"RSS and Atom",slug:"rss-and-atom",normalizedTitle:"rss and atom",charIndex:14171},{level:2,title:"PDF and Excel",slug:"pdf-and-excel",normalizedTitle:"pdf and excel",charIndex:15583},{level:3,title:"文档视图简介",slug:"文档视图简介",normalizedTitle:"文档视图简介",charIndex:15650},{level:3,title:"PDF 视图",slug:"pdf-视图",normalizedTitle:"pdf 视图",charIndex:15863},{level:3,title:"Excel 视图",slug:"excel-视图",normalizedTitle:"excel 视图",charIndex:15794},{level:2,title:"Jackson",slug:"jackson",normalizedTitle:"jackson",charIndex:16755},{level:3,title:"基于 Jackson 的 JSON MVC 视图",slug:"基于-jackson-的-json-mvc-视图",normalizedTitle:"基于 jackson 的 json mvc 视图",charIndex:16798},{level:3,title:"基于 Jackson 的 XML 视图",slug:"基于-jackson-的-xml-视图",normalizedTitle:"基于 jackson 的 xml 视图",charIndex:17177},{level:2,title:"XML",slug:"xml",normalizedTitle:"xml",charIndex:1140},{level:2,title:"XSLT",slug:"xslt",normalizedTitle:"xslt",charIndex:17708},{level:3,title:"Beans",slug:"beans",normalizedTitle:"beans",charIndex:18073},{level:3,title:"Controller",slug:"controller",normalizedTitle:"controller",charIndex:12460},{level:3,title:"Transformation",slug:"transformation",normalizedTitle:"transformation",charIndex:19506},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:20560}],headersStr:"Thymeleaf FreeMarker 视图配置 FreeMarker 配置 表单处理 绑定宏 简单绑定 输入宏 HTML 转义 Groovy 配置 示例 脚本视图 要求 脚本模板 JSP 和 JSTL RSS and Atom PDF and Excel 文档视图简介 PDF 视图 Excel 视图 Jackson 基于 Jackson 的 JSON MVC 视图 基于 Jackson 的 XML 视图 XML XSLT Beans Controller Transformation 参考资料",content:'# Spring MVC 之视图技术\n\nSpring MVC 中视图技术的使用是可插拔的。无论决定使用 Thymeleaf、Groovy 等模板引擎、JSP 还是其他技术，都可以通过配置来更改。\n\nSpring MVC 的视图位于该应用程序的内部信任边界内。 视图可以访问应用程序上下文的所有 bean。 因此，不建议在模板可由外部源编辑的应用程序中使用 Spring MVC 的模板支持，因为这可能会产生安全隐患。\n\n\n# Thymeleaf\n\nThymeleaf 是一个现代服务器端 Java 模板引擎，它强调自然的 HTML 模板，可以通过双击在浏览器中预览，而无需运行服务器，这对于 UI 模板的独立工作（例如，由设计师）非常有帮助。\n\nThymeleaf 与 Spring MVC 的集成由 Thymeleaf 项目管理。 配置涉及一些 bean 声明，例如 ServletContextTemplateResolver、SpringTemplateEngine 和 ThymeleafViewResolver。 有关详细信息，请参阅 Thymeleaf+Spring。\n\n\n# FreeMarker\n\nApache FreeMarker 是一个模板引擎，用于生成从 HTML 到电子邮件等任何类型的文本内容。 Spring 框架内置了 Spring MVC 与 FreeMarker 模板结合使用的集成。\n\n\n# 视图配置\n\n以下示例显示了如何将 FreeMarker 配置为视图技术：\n\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.freeMarker();\n    }\n\n    // Configure FreeMarker...\n\n    @Bean\n    public FreeMarkerConfigurer freeMarkerConfigurer() {\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n        configurer.setTemplateLoaderPath("/WEB-INF/freemarker");\n        return configurer;\n    }\n}\n\n\n以下示例显示了如何在 XML 中配置相同的内容：\n\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:freemarker/>\n</mvc:view-resolvers>\n\n\x3c!-- Configure FreeMarker... --\x3e\n<mvc:freemarker-configurer>\n    <mvc:template-loader-path location="/WEB-INF/freemarker"/>\n</mvc:freemarker-configurer>\n\n\n或者，您也可以声明 FreeMarkerConfigurer 以完全控制所有属性，如以下示例所示：\n\n<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">\n    <property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>\n</bean>\n\n\n您的模板需要存储在前面示例中所示的 FreeMarkerConfigurer 指定的目录中。鉴于前面的配置，如果您的控制器返回视图名称 welcome，解析器将查找 /WEB-INF/freemarker/welcome.ftl 模板。\n\n\n# FreeMarker 配置\n\n可以通过在 FreeMarkerConfigurer 上设置适当的 bean 属性，将 FreeMarker \'Settings\' 和 \'SharedVariables\' 直接传递给 FreeMarker Configuration 对象（由 Spring 管理）。 freemarkerSettings 属性需要一个 java.util.Properties 对象，freemarkerVariables 属性需要一个 java.util.Map。 以下示例显示了如何使用 FreeMarkerConfigurer：\n\n<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">\n    <property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>\n    <property name="freemarkerVariables">\n        <map>\n            <entry key="xml_escape" value-ref="fmXmlEscape"/>\n        </map>\n    </property>\n</bean>\n\n<bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/>\n\n\n有关应用于 Configuration 对象的设置和变量的详细信息，请参阅 FreeMarker 文档。\n\n\n# 表单处理\n\nSpring 提供了一个用于 JSP 的标记库，其中包含一个 <spring:bind/> 元素。 此元素主要让表单显示来自表单支持对象的值，并显示来自 Web 或业务层中的“验证器”的验证失败的结果。 Spring 还支持 FreeMarker 中的相同功能，以及用于生成表单输入元素的额外便利宏。\n\n# 绑定宏\n\n在 FreeMarker 的 spring-webmvc.jar 文件中维护了一组标准宏，因此它们始终可用于适当配置的应用程序。\n\nSpring 模板库中定义的一些宏被认为是内部的（私有的），但宏定义中不存在这样的范围，这使得所有宏对调用代码和用户模板都是可见的。以下部分仅关注您需要从模板中直接调用的宏。如果您想直接查看宏代码，该文件名为 spring.ftl ，位于 org.springframework.web.servlet.view.freemarker 包中。\n\n# 简单绑定\n\n在基于充当 Spring MVC 控制器表单视图的 FreeMarker 模板的 HTML 表单中，您可以使用类似于下一个示例的代码来绑定到字段值，并以类似于 JSP 等价物的方式为每个输入字段显示错误消息。以下示例显示了一个 personForm 视图：\n\n\x3c!-- FreeMarker macros have to be imported into a namespace.\n    We strongly recommend sticking to \'spring\'. --\x3e\n<#import "/spring.ftl" as spring/>\n<html>\n    ...\n    <form action="" method="POST">\n        Name:\n        <@spring.bind "personForm.name"/>\n        <input type="text"\n            name="${spring.status.expression}"\n            value="${spring.status.value?html}"/><br />\n        <#list spring.status.errorMessages as error> <b>${error}</b> <br /> </#list>\n        <br />\n        ...\n        <input type="submit" value="submit"/>\n    </form>\n    ...\n</html>\n\n\n<@spring.bind> 需要一个 \'path\' 参数，它由命令对象的名称（它是 \'command\'，除非您在控制器配置中更改它）组成，在您希望绑定的命令对象后跟一个句点和字段名称。 您还可以使用嵌套字段，例如 command.address.street。 bind 宏采用 web.xml 中的 ServletContext 参数 defaultHtmlEscape 指定的默认 HTML 转义行为。\n\n称为 <@spring.bindEscaped> 的宏的另一种形式采用第二个参数，该参数明确指定是否应在状态错误消息或值中使用 HTML 转义。 您可以根据需要将其设置为 true 或 false 。 附加的表单处理宏简化了 HTML 转义的使用，您应该尽可能使用这些宏。\n\n# 输入宏\n\nFreeMarker 的附加便利宏简化了绑定和表单生成（包括验证错误显示）。 永远不需要使用这些宏来生成表单输入字段，您可以将它们与简单的 HTML 混合搭配，或者直接调用我们之前强调的 Spring 绑定宏。\n\n下表中的可用宏显示了 FreeMarker 模板 (FTL) 定义和每个采用的参数列表：\n\nMACRO                                                          FTL DEFINITION\nmessage (output a string from a resource bundle based on the   <@spring.message code/>\ncode parameter)\nmessageText (output a string from a resource bundle based on   <@spring.messageText code, text/>\nthe code parameter, falling back to the value of the default\nparameter)\nurl (prefix a relative URL with the application’s context      <@spring.url relativeUrl/>\nroot)\nformInput (standard input field for gathering user input)      <@spring.formInput path, attributes, fieldType/>\nformHiddenInput (hidden input field for submitting non-user    <@spring.formHiddenInput path, attributes/>\ninput)\nformPasswordInput (standard input field for gathering          <@spring.formPasswordInput path, attributes/>\npasswords. Note that no value is ever populated in fields of\nthis type.)\nformTextarea (large text field for gathering long, freeform    <@spring.formTextarea path, attributes/>\ntext input)\nformSingleSelect (drop down box of options that let a single   <@spring.formSingleSelect path, options, attributes/>\nrequired value be selected)\nformMultiSelect (a list box of options that let the user       <@spring.formMultiSelect path, options, attributes/>\nselect 0 or more values)\nformRadioButtons (a set of radio buttons that let a single     <@spring.formRadioButtons path, options separator,\nselection be made from the available choices)                  attributes/>\nformCheckboxes (a set of checkboxes that let 0 or more         <@spring.formCheckboxes path, options, separator,\nvalues be selected)                                            attributes/>\nformCheckbox (a single checkbox)                               <@spring.formCheckbox path, attributes/>\nshowErrors (simplify display of validation errors for the      <@spring.showErrors separator, classOrStyle/>\nbound field)\n\n上述任何宏的参数具有一致的含义：\n\n * path: 要绑定到的字段的名称（例如，“command.name”）\n * options: 可在输入字段中选择的所有可用值的 Map。映射的键表示从表单回传并绑定到命令对象的值。针对键存储的 map 对象是在表单上显示给用户的标签，可能与表单回传的相应值不同。通常，这样的地图由控制器提供作为参考数据。您可以使用任何 Map 实现，具体取决于所需的行为。对于严格排序的映射，您可以使用带有合适的“比较器”的 SortedMap（例如 TreeMap），对于应按插入顺序返回值的任意映射，使用“LinkedHashMap”或“LinkedMap” 公共收藏。\n * separator: 在多个选项可用作离散元素（单选按钮或复选框）的情况下，用于分隔列表中每个选项的字符序列（例如 <br>）。\n * attributes: 要包含在 HTML 标记本身中的任意标记或文本的附加字符串。该字符串按字面意思由宏回显。例如，在 textarea 字段中，您可以提供属性（例如“rows="5" cols="60"\'），或者您可以传递样式信息，例如 \'style="border:1px solid silver"\'。\n * classOrStyle: 对于 showErrors 宏，包装每个错误的 span 元素使用的 CSS 类的名称。如果未提供任何信息（或值为空），错误将包含在 <b></b> 标签中。\n\n以下部分概述了宏的示例。\n\n输入字段\n\nformInput 宏采用 path 参数 (command.name) 和一个额外的 attributes 参数（在接下来的示例中为空）。该宏与所有其他表单生成宏一起对路径参数执行隐式 Spring 绑定。绑定在新绑定发生之前一直有效，因此 showErrors 宏不需要再次传递路径参数——它对上次创建绑定的字段进行操作。\n\nshowErrors 宏接受一个分隔符参数（用于分隔给定字段上的多个错误的字符），还接受第二个参数——这次是类名或样式属性。请注意，FreeMarker 可以为 attributes 参数指定默认值。以下示例显示了如何使用 formInput 和 showErrors 宏：\n\n<@spring.formInput "command.name"/>\n<@spring.showErrors "<br>"/>\n\n\n下一个示例显示表单片段的输出，生成名称字段并在表单提交后显示验证错误，该字段中没有任何值。验证通过 Spring 的验证框架进行。\n\n生成的 HTML 类似于以下示例：\n\nName:\n<input type="text" name="name" value="">\n<br>\n    <b>required</b>\n<br>\n<br>\n\n\nformTextarea 宏的工作方式与 formInput 宏相同，并且接受相同的参数列表。通常，第二个参数 (attributes) 用于传递样式信息或 textarea 的 rows 和 cols 属性。\n\n选中字段\n\n您可以使用四个选择字段宏在 HTML 表单中生成常见的 UI 值选择输入：\n\n * formSingleSelect\n * formMultiSelect\n * formRadioButtons\n * formCheckboxes\n\n四个宏中的每一个都接受一个“Map”选项，其中包含表单字段的值和与该值对应的标签。值和标签可以相同。\n\n下一个例子是 FTL 中的单选按钮。表单支持对象为此字段指定默认值“伦敦”，因此无需验证。渲染表单时，整个可供选择的城市列表作为参考数据提供在模型中，名称为 cityMap。以下清单显示了示例：\n\n...\nTown:\n<@spring.formRadioButtons "command.address.town", cityMap, ""/><br><br>\n\n\n前面的清单呈现一行单选按钮，一个用于 cityMap 中的每个值，并使用分隔符 ""。没有提供额外的属性（缺少宏的最后一个参数）。 cityMap 对地图中的每个键值对使用相同的 String。地图的键是表单实际作为 POST 请求参数提交的内容。地图值是用户看到的标签。在前面的示例中，给定三个知名城市的列表和表单支持对象中的默认值，HTML 类似于以下内容：\n\nTown:\n<input type="radio" name="address.town" value="London">London</input>\n<input type="radio" name="address.town" value="Paris" checked="checked">Paris</input>\n<input type="radio" name="address.town" value="New York">New York</input>\n\n\n如果您的应用程序希望通过内部代码处理城市（例如），您可以使用合适的键创建代码映射，如以下示例所示：\n\nprotected Map<String, ?> referenceData(HttpServletRequest request) throws Exception {\n    Map<String, String> cityMap = new LinkedHashMap<>();\n    cityMap.put("LDN", "London");\n    cityMap.put("PRS", "Paris");\n    cityMap.put("NYC", "New York");\n\n    Map<String, Object> model = new HashMap<>();\n    model.put("cityMap", cityMap);\n    return model;\n}\n\n\n代码现在生成输出，其中无线电值是相关代码，但用户仍然看到更用户友好的城市名称，如下所示：\n\nTown:\n<input type="radio" name="address.town" value="LDN">London</input>\n<input type="radio" name="address.town" value="PRS" checked="checked">Paris</input>\n<input type="radio" name="address.town" value="NYC">New York</input>\n\n\n# HTML 转义\n\n前面描述的表单宏的默认使用导致 HTML 元素符合 HTML 4.01，并且使用 web.xml 文件中定义的 HTML 转义的默认值，如 Spring 的绑定支持所使用的那样。 要使元素符合 XHTML 或覆盖默认的 HTML 转义值，您可以在模板中指定两个变量（或在模型中，它们对模板可见）。 在模板中指定它们的好处是它们可以在稍后的模板处理中更改为不同的值，以便为表单中的不同字段提供不同的行为。\n\n要为您的标签切换到 XHTML 合规性，请为名为 xhtmlCompliant 的模型或上下文变量指定 true 值，如以下示例所示：\n\n<#-- for FreeMarker --\x3e\n<#assign xhtmlCompliant = true>\n\n\n处理此指令后，Spring 宏生成的任何元素现在都符合 XHTML。\n\n以类似的方式，您可以为每个字段指定 HTML 转义，如以下示例所示：\n\n<#-- until this point, default HTML escaping is used --\x3e\n\n<#assign htmlEscape = true>\n<#-- next field will use HTML escaping --\x3e\n<@spring.formInput "command.name"/>\n\n<#assign htmlEscape = false in spring>\n<#-- all future fields will be bound with HTML escaping off --\x3e\n\n\n\n# Groovy\n\nGroovy 标记模板引擎 主要用于生成类似 XML 的标记（XML、XHTML、HTML5 等），但可以使用它来生成任何基于文本的内容。 Spring Framework 具有将 Spring MVC 与 Groovy 标记结合使用的内置集成。\n\n\n# 配置\n\n以下示例显示如何配置 Groovy 标记模板引擎：\n\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.groovy();\n    }\n\n    // Configure the Groovy Markup Template Engine...\n\n    @Bean\n    public GroovyMarkupConfigurer groovyMarkupConfigurer() {\n        GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer();\n        configurer.setResourceLoaderPath("/WEB-INF/");\n        return configurer;\n    }\n}\n\n\n以下示例显示了如何在 XML 中配置相同的内容：\n\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:groovy/>\n</mvc:view-resolvers>\n\n\x3c!-- Configure the Groovy Markup Template Engine... --\x3e\n<mvc:groovy-configurer resource-loader-path="/WEB-INF/"/>\n\n\n\n# 示例\n\n与传统的模板引擎不同，Groovy 标记依赖于使用构建器语法的 DSL。以下示例显示了 HTML 页面的示例模板：\n\nyieldUnescaped \'<!DOCTYPE html>\'\nhtml(lang:\'en\') {\n    head {\n        meta(\'http-equiv\':\'"Content-Type" content="text/html; charset=utf-8"\')\n        title(\'My page\')\n    }\n    body {\n        p(\'This is an example of HTML contents\')\n    }\n}\n\n\n\n# 脚本视图\n\nSpring 有一个内置的集成，可以将 Spring MVC 与任何可以在 JSR-223 之上运行的模板库一起使用 Java 脚本引擎。 我们在不同的脚本引擎上测试了以下模板库：\n\n脚本库                        脚本引擎\nHandlebars                 Nashorn\nMustache                   Nashorn\nReact                      Nashorn\nEJS                        Nashorn\nERB                        JRuby\nString templates           Jython\nKotlin Script templating   Kotlin\n\n\n# 要求\n\n需要在类路径中包含脚本引擎，具体细节因脚本引擎而异：\n\n * The Nashorn Java 8+ 提供了 JavaScript 引擎。强烈建议使用可用的最新更新版本。\n * JRuby 应该作为 Ruby 支持的依赖项添加。\n * Jython 应该作为 Python 支持的依赖项添加。\n * org.jetbrains.kotlin:kotlin-script-util 依赖项和包含 org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory 行的 META-INF/services/javax.script.ScriptEngineFactory 文件应该被添加 Kotlin 脚本支持。 有关详细信息，请参阅此示例。\n\n您需要有脚本模板库。 为 JavaScript 做到这一点的一种方法是通过 WebJars。\n\n\n# 脚本模板\n\n可以声明一个 ScriptTemplateConfigurer 来指定要使用的脚本引擎、要加载的脚本文件、调用什么函数来渲染模板等等。 以下示例使用 Mustache 模板和 Nashorn JavaScript 引擎：\n\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.scriptTemplate();\n    }\n\n    @Bean\n    public ScriptTemplateConfigurer configurer() {\n        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n        configurer.setEngineName("nashorn");\n        configurer.setScripts("mustache.js");\n        configurer.setRenderObject("Mustache");\n        configurer.setRenderFunction("render");\n        return configurer;\n    }\n}\n\n\n以下示例显示了 XML 中的相同配置：\n\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:script-template/>\n</mvc:view-resolvers>\n\n<mvc:script-template-configurer engine-name="nashorn" render-object="Mustache" render-function="render">\n    <mvc:script location="mustache.js"/>\n</mvc:script-template-configurer>\n\n\n对于 Java 和 XML 配置，controller 看起来没有什么不同，如以下示例所示：\n\n@Controller\npublic class SampleController {\n\n    @GetMapping("/sample")\n    public String test(Model model) {\n        model.addAttribute("title", "Sample title");\n        model.addAttribute("body", "Sample body");\n        return "template";\n    }\n}\n\n\n以下示例显示了 Mustache 模板：\n\n<html>\n  <head>\n    <title>{{title}}</title>\n  </head>\n  <body>\n    <p>{{body}}</p>\n  </body>\n</html>\n\n\n使用以下参数调用渲染函数：\n\n * String template: 模板内容\n * 地图模型：视图模型\n * RenderingContext renderingContext： RenderingContext 允许访问应用上下文、语言环境、模板加载器和 URL（自 5.0 起）\n\n如果您的模板技术需要一些自定义，您可以提供一个实现自定义渲染功能的脚本。 例如，Handlerbars 需要在使用之前编译模板，并且需要一个 polyfill 来模拟一些浏览器工具，但在服务器端脚本引擎中不可用。\n\n以下示例显示了如何执行此操作：\n\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        registry.scriptTemplate();\n    }\n\n    @Bean\n    public ScriptTemplateConfigurer configurer() {\n        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n        configurer.setEngineName("nashorn");\n        configurer.setScripts("polyfill.js", "handlebars.js", "render.js");\n        configurer.setRenderFunction("render");\n        configurer.setSharedEngine(false);\n        return configurer;\n    }\n}\n\n\npolyfill.js 只定义了 Handlebars 正常运行所需的 window 对象，如下：\n\nvar window = {}\n\n\n这个基本的 render.js 实现在使用之前编译模板。 生产就绪的实现还应该存储任何重复使用的缓存模板或预编译模板。 您可以在脚本端这样做（并处理您需要的任何定制——管理模板引擎配置，例如）。 以下示例显示了如何执行此操作：\n\nfunction render(template, model) {\n  var compiledTemplate = Handlebars.compile(template)\n  return compiledTemplate(model)\n}\n\n\n查看 Spring Framework 单元测试，Java 和资源，以获取更多配置示例。\n\n\n# JSP 和 JSTL\n\nSpring Framework 具有将 Spring MVC 与 JSP 和 JSTL 结合使用的内置集成。\n\n> 更多内容详见：Spring 官方文档之 JSP and JSTL\n\n\n# RSS and Atom\n\nAbstractAtomFeedView 和 AbstractRssFeedView 都继承自 AbstractFeedView 基类，分别用于提供 Atom 和 RSS Feed 视图。 它们基于 ROME 项目，位于 org.springframework.web.servlet.view.feed 包中。\n\nAbstractAtomFeedView 要求您实现 buildFeedEntries() 方法并可选择覆盖 buildFeedMetadata() 方法（默认实现为空）。 以下示例显示了如何执行此操作：\n\npublic class SampleContentAtomView extends AbstractAtomFeedView {\n\n    @Override\n    protected void buildFeedMetadata(Map<String, Object> model,\n            Feed feed, HttpServletRequest request) {\n        // implementation omitted\n    }\n\n    @Override\n    protected List<Entry> buildFeedEntries(Map<String, Object> model,\n            HttpServletRequest request, HttpServletResponse response) throws Exception {\n        // implementation omitted\n    }\n}\n\n\n类似的要求适用于实现 AbstractRssFeedView，如以下示例所示：\n\npublic class SampleContentRssView extends AbstractRssFeedView {\n\n    @Override\n    protected void buildFeedMetadata(Map<String, Object> model,\n            Channel feed, HttpServletRequest request) {\n        // implementation omitted\n    }\n\n    @Override\n    protected List<Item> buildFeedItems(Map<String, Object> model,\n            HttpServletRequest request, HttpServletResponse response) throws Exception {\n        // implementation omitted\n    }\n}\n\n\nbuildFeedItems() 和 buildFeedEntries() 方法传入 HTTP 请求，以防您需要访问 Locale。 传入 HTTP 响应仅用于设置 cookie 或其他 HTTP 标头。 方法返回后，提要会自动写入响应对象。\n\n有关创建 Atom 视图的示例，请参阅 Alef Arendsen 的 Spring Team 博客 entry。\n\n\n# PDF and Excel\n\nSpring 提供了返回 HTML 以外的输出的方法，包括 PDF 和 Excel 电子表格。\n\n\n# 文档视图简介\n\nHTML 页面并不总是用户查看模型输出的最佳方式，Spring 使从模型数据动态生成 PDF 文档或 Excel 电子表格变得简单。 该文档是视图，从服务器流出正确的内容类型，（希望）使客户端 PC 能够运行他们的电子表格或 PDF 查看器应用程序作为响应。\n\n为了使用 Excel 视图，您需要将 Apache POI 库添加到类路径中。 对于 PDF 生成，您需要添加（最好）OpenPDF 库。\n\n\n# PDF 视图\n\n单词列表的简单 PDF 视图可以扩展 org.springframework.web.servlet.view.document.AbstractPdfView 并实现 buildPdfDocument() 方法，如以下示例所示：\n\npublic class PdfWordList extends AbstractPdfView {\n\n    protected void buildPdfDocument(Map<String, Object> model, Document doc, PdfWriter writer,\n            HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        List<String> words = (List<String>) model.get("wordList");\n        for (String word : words) {\n            doc.add(new Paragraph(word));\n        }\n    }\n}\n\n\n控制器可以从外部视图定义（按名称引用它）或作为处理程序方法的 View 实例返回此类视图。\n\n\n# Excel 视图\n\n从 Spring Framework 4.2 开始，org.springframework.web.servlet.view.document.AbstractXlsView 作为 Excel 视图的基类提供。 它基于 Apache POI，具有专门的子类（AbstractXlsxView 和 AbstractXlsxStreamingView），取代了过时的 AbstractExcelView 类。\n\n编程模型类似于 AbstractPdfView，以 buildExcelDocument() 作为核心模板方法，控制器能够从外部定义（按名称）或作为处理程序方法的 View 实例返回此类视图。\n\n\n# Jackson\n\nSpring 提供对 Jackson JSON 库的支持。\n\n\n# 基于 Jackson 的 JSON MVC 视图\n\nMappingJackson2JsonView 使用 Jackson 库的 ObjectMapper 将响应内容渲染为 JSON。 默认情况下，模型映射的全部内容（特定于框架的类除外）都编码为 JSON。 对于需要过滤 map 内容的情况，您可以使用 modelKeys 属性指定一组特定的模型属性进行编码。 您还可以使用 extractValueFromSingleKeyModel 属性直接提取和序列化单键模型中的值，而不是作为模型属性的映射。\n\n您可以根据需要使用 Jackson 提供的注释自定义 JSON 映射。 当您需要进一步控制时，您可以通过 ObjectMapper 属性注入自定义 ObjectMapper，适用于需要为特定类型提供自定义 JSON 序列化器和反序列化器的情况。\n\n\n# 基于 Jackson 的 XML 视图\n\nMappingJackson2XmlView 使用 Jackson XML 扩展 XmlMapper 将响应内容渲染为 XML。 如果模型包含多个条目，您应该使用 modelKey bean 属性显式设置要序列化的对象。 如果模型包含单个条目，它会自动序列化。\n\n您可以根据需要使用 JAXB 或 Jackson 提供的注释自定义 XML 映射。当您需要进一步控制时，您可以通过 ObjectMapper 属性注入自定义 XmlMapper，对于需要为特定类型提供序列化器和反序列化器的自定义 XML 的情况\n\n\n# XML\n\nMarshallingView 使用 XML Marshaller（在 org.springframework.oxm 包中定义）将响应内容渲染为 XML。 您可以使用 MarshallingView 实例的 modelKey 属性显式设置要编组的对象。 或者，视图遍历所有模型属性并编组 Marshaller 支持的第一个类型。 有关 org.springframework.oxm 包中功能的更多信息，请参阅 Marshalling XML using O/X Mappers。\n\n\n# XSLT\n\nXSLT 是 XML 的一种转换语言，作为 Web 应用程序中的一种视图技术很受欢迎。 如果您的应用程序自然地处理 XML，或者如果您的模型可以很容易地转换为 XML，那么 XSLT 作为一种视图技术是一个不错的选择。 以下部分展示了如何生成 XML 文档作为模型数据，并在 Spring Web MVC 应用程序中使用 XSLT 对其进行转换。\n\n此示例是一个简单的 Spring 应用程序，它在 Controller 中创建关键字列表并将它们添加到模型映射中。 返回映射以及我们的 XSLT 视图的视图名称。 有关 Spring Web MVC 的 Controller 接口的详细信息，请参阅 Annotated Controllers。 XSLT 控制器将单词列表转换为准备转换的简单 XML 文档。\n\n\n# Beans\n\n配置是一个简单的 Spring Web 应用程序的标准配置：MVC 配置必须定义一个 XsltViewResolver 和常规 MVC 注释配置。以下示例显示了如何执行此操作：\n\n@EnableWebMvc\n@ComponentScan\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Bean\n    public XsltViewResolver xsltViewResolver() {\n        XsltViewResolver viewResolver = new XsltViewResolver();\n        viewResolver.setPrefix("/WEB-INF/xsl/");\n        viewResolver.setSuffix(".xslt");\n        return viewResolver;\n    }\n}\n\n\n\n# Controller\n\n我们还需要一个控制器来封装我们的单词生成逻辑。\n\n控制器逻辑封装在一个 @Controller 类中，处理方法定义如下：\n\n@Controller\npublic class XsltController {\n\n    @RequestMapping("/")\n    public String home(Model model) throws Exception {\n        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n        Element root = document.createElement("wordList");\n\n        List<String> words = Arrays.asList("Hello", "Spring", "Framework");\n        for (String word : words) {\n            Element wordNode = document.createElement("word");\n            Text textNode = document.createTextNode(word);\n            wordNode.appendChild(textNode);\n            root.appendChild(wordNode);\n        }\n\n        model.addAttribute("wordList", root);\n        return "home";\n    }\n}\n\n\n到目前为止，我们只创建了一个 DOM 文档并将其添加到模型映射中。请注意，您还可以将 XML 文件作为 Resource 加载并使用它来代替自定义 DOM 文档。\n\n有可用的软件包可以自动 \'domify\' 一个对象图，但是在 Spring 中，您可以完全灵活地以您选择的任何方式从您的模型创建 DOM。这可以防止 XML 的转换在模型数据的结构中发挥太大作用，这在使用工具管理 DOMification 过程时是一种危险。\n\n\n# Transformation\n\n最后，XsltViewResolver 解析 “home” XSLT 模板文件并将 DOM 文档合并到其中以生成我们的视图。如 XsltViewResolver 配置所示，XSLT 模板位于 WEB-INF/xsl 目录下的 war 文件中，并以 xslt 文件扩展名结尾。\n\n以下示例显示了 XSLT 转换：\n\n<?xml version="1.0" encoding="utf-8"?>\n<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">\n\n    <xsl:output method="html" omit-xml-declaration="yes"/>\n\n    <xsl:template match="/">\n        <html>\n            <head><title>Hello!</title></head>\n            <body>\n                <h1>My First Words</h1>\n                <ul>\n                    <xsl:apply-templates/>\n                </ul>\n            </body>\n        </html>\n    </xsl:template>\n\n    <xsl:template match="word">\n        <li><xsl:value-of select="."/></li>\n    </xsl:template>\n\n</xsl:stylesheet>\n\n\n前面的转换渲染为以下 HTML：\n\n<html>\n  <head>\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>My First Words</h1>\n    <ul>\n      <li>Hello</li>\n      <li>Spring</li>\n      <li>Framework</li>\n    </ul>\n  </body>\n</html>\n\n\n\n# 参考资料\n\n * Spring Framework 官方文档\n * Spring Framework 官方文档之 Web',normalizedContent:'# spring mvc 之视图技术\n\nspring mvc 中视图技术的使用是可插拔的。无论决定使用 thymeleaf、groovy 等模板引擎、jsp 还是其他技术，都可以通过配置来更改。\n\nspring mvc 的视图位于该应用程序的内部信任边界内。 视图可以访问应用程序上下文的所有 bean。 因此，不建议在模板可由外部源编辑的应用程序中使用 spring mvc 的模板支持，因为这可能会产生安全隐患。\n\n\n# thymeleaf\n\nthymeleaf 是一个现代服务器端 java 模板引擎，它强调自然的 html 模板，可以通过双击在浏览器中预览，而无需运行服务器，这对于 ui 模板的独立工作（例如，由设计师）非常有帮助。\n\nthymeleaf 与 spring mvc 的集成由 thymeleaf 项目管理。 配置涉及一些 bean 声明，例如 servletcontexttemplateresolver、springtemplateengine 和 thymeleafviewresolver。 有关详细信息，请参阅 thymeleaf+spring。\n\n\n# freemarker\n\napache freemarker 是一个模板引擎，用于生成从 html 到电子邮件等任何类型的文本内容。 spring 框架内置了 spring mvc 与 freemarker 模板结合使用的集成。\n\n\n# 视图配置\n\n以下示例显示了如何将 freemarker 配置为视图技术：\n\n@configuration\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    @override\n    public void configureviewresolvers(viewresolverregistry registry) {\n        registry.freemarker();\n    }\n\n    // configure freemarker...\n\n    @bean\n    public freemarkerconfigurer freemarkerconfigurer() {\n        freemarkerconfigurer configurer = new freemarkerconfigurer();\n        configurer.settemplateloaderpath("/web-inf/freemarker");\n        return configurer;\n    }\n}\n\n\n以下示例显示了如何在 xml 中配置相同的内容：\n\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:freemarker/>\n</mvc:view-resolvers>\n\n\x3c!-- configure freemarker... --\x3e\n<mvc:freemarker-configurer>\n    <mvc:template-loader-path location="/web-inf/freemarker"/>\n</mvc:freemarker-configurer>\n\n\n或者，您也可以声明 freemarkerconfigurer 以完全控制所有属性，如以下示例所示：\n\n<bean id="freemarkerconfig" class="org.springframework.web.servlet.view.freemarker.freemarkerconfigurer">\n    <property name="templateloaderpath" value="/web-inf/freemarker/"/>\n</bean>\n\n\n您的模板需要存储在前面示例中所示的 freemarkerconfigurer 指定的目录中。鉴于前面的配置，如果您的控制器返回视图名称 welcome，解析器将查找 /web-inf/freemarker/welcome.ftl 模板。\n\n\n# freemarker 配置\n\n可以通过在 freemarkerconfigurer 上设置适当的 bean 属性，将 freemarker \'settings\' 和 \'sharedvariables\' 直接传递给 freemarker configuration 对象（由 spring 管理）。 freemarkersettings 属性需要一个 java.util.properties 对象，freemarkervariables 属性需要一个 java.util.map。 以下示例显示了如何使用 freemarkerconfigurer：\n\n<bean id="freemarkerconfig" class="org.springframework.web.servlet.view.freemarker.freemarkerconfigurer">\n    <property name="templateloaderpath" value="/web-inf/freemarker/"/>\n    <property name="freemarkervariables">\n        <map>\n            <entry key="xml_escape" value-ref="fmxmlescape"/>\n        </map>\n    </property>\n</bean>\n\n<bean id="fmxmlescape" class="freemarker.template.utility.xmlescape"/>\n\n\n有关应用于 configuration 对象的设置和变量的详细信息，请参阅 freemarker 文档。\n\n\n# 表单处理\n\nspring 提供了一个用于 jsp 的标记库，其中包含一个 <spring:bind/> 元素。 此元素主要让表单显示来自表单支持对象的值，并显示来自 web 或业务层中的“验证器”的验证失败的结果。 spring 还支持 freemarker 中的相同功能，以及用于生成表单输入元素的额外便利宏。\n\n# 绑定宏\n\n在 freemarker 的 spring-webmvc.jar 文件中维护了一组标准宏，因此它们始终可用于适当配置的应用程序。\n\nspring 模板库中定义的一些宏被认为是内部的（私有的），但宏定义中不存在这样的范围，这使得所有宏对调用代码和用户模板都是可见的。以下部分仅关注您需要从模板中直接调用的宏。如果您想直接查看宏代码，该文件名为 spring.ftl ，位于 org.springframework.web.servlet.view.freemarker 包中。\n\n# 简单绑定\n\n在基于充当 spring mvc 控制器表单视图的 freemarker 模板的 html 表单中，您可以使用类似于下一个示例的代码来绑定到字段值，并以类似于 jsp 等价物的方式为每个输入字段显示错误消息。以下示例显示了一个 personform 视图：\n\n\x3c!-- freemarker macros have to be imported into a namespace.\n    we strongly recommend sticking to \'spring\'. --\x3e\n<#import "/spring.ftl" as spring/>\n<html>\n    ...\n    <form action="" method="post">\n        name:\n        <@spring.bind "personform.name"/>\n        <input type="text"\n            name="${spring.status.expression}"\n            value="${spring.status.value?html}"/><br />\n        <#list spring.status.errormessages as error> <b>${error}</b> <br /> </#list>\n        <br />\n        ...\n        <input type="submit" value="submit"/>\n    </form>\n    ...\n</html>\n\n\n<@spring.bind> 需要一个 \'path\' 参数，它由命令对象的名称（它是 \'command\'，除非您在控制器配置中更改它）组成，在您希望绑定的命令对象后跟一个句点和字段名称。 您还可以使用嵌套字段，例如 command.address.street。 bind 宏采用 web.xml 中的 servletcontext 参数 defaulthtmlescape 指定的默认 html 转义行为。\n\n称为 <@spring.bindescaped> 的宏的另一种形式采用第二个参数，该参数明确指定是否应在状态错误消息或值中使用 html 转义。 您可以根据需要将其设置为 true 或 false 。 附加的表单处理宏简化了 html 转义的使用，您应该尽可能使用这些宏。\n\n# 输入宏\n\nfreemarker 的附加便利宏简化了绑定和表单生成（包括验证错误显示）。 永远不需要使用这些宏来生成表单输入字段，您可以将它们与简单的 html 混合搭配，或者直接调用我们之前强调的 spring 绑定宏。\n\n下表中的可用宏显示了 freemarker 模板 (ftl) 定义和每个采用的参数列表：\n\nmacro                                                          ftl definition\nmessage (output a string from a resource bundle based on the   <@spring.message code/>\ncode parameter)\nmessagetext (output a string from a resource bundle based on   <@spring.messagetext code, text/>\nthe code parameter, falling back to the value of the default\nparameter)\nurl (prefix a relative url with the application’s context      <@spring.url relativeurl/>\nroot)\nforminput (standard input field for gathering user input)      <@spring.forminput path, attributes, fieldtype/>\nformhiddeninput (hidden input field for submitting non-user    <@spring.formhiddeninput path, attributes/>\ninput)\nformpasswordinput (standard input field for gathering          <@spring.formpasswordinput path, attributes/>\npasswords. note that no value is ever populated in fields of\nthis type.)\nformtextarea (large text field for gathering long, freeform    <@spring.formtextarea path, attributes/>\ntext input)\nformsingleselect (drop down box of options that let a single   <@spring.formsingleselect path, options, attributes/>\nrequired value be selected)\nformmultiselect (a list box of options that let the user       <@spring.formmultiselect path, options, attributes/>\nselect 0 or more values)\nformradiobuttons (a set of radio buttons that let a single     <@spring.formradiobuttons path, options separator,\nselection be made from the available choices)                  attributes/>\nformcheckboxes (a set of checkboxes that let 0 or more         <@spring.formcheckboxes path, options, separator,\nvalues be selected)                                            attributes/>\nformcheckbox (a single checkbox)                               <@spring.formcheckbox path, attributes/>\nshowerrors (simplify display of validation errors for the      <@spring.showerrors separator, classorstyle/>\nbound field)\n\n上述任何宏的参数具有一致的含义：\n\n * path: 要绑定到的字段的名称（例如，“command.name”）\n * options: 可在输入字段中选择的所有可用值的 map。映射的键表示从表单回传并绑定到命令对象的值。针对键存储的 map 对象是在表单上显示给用户的标签，可能与表单回传的相应值不同。通常，这样的地图由控制器提供作为参考数据。您可以使用任何 map 实现，具体取决于所需的行为。对于严格排序的映射，您可以使用带有合适的“比较器”的 sortedmap（例如 treemap），对于应按插入顺序返回值的任意映射，使用“linkedhashmap”或“linkedmap” 公共收藏。\n * separator: 在多个选项可用作离散元素（单选按钮或复选框）的情况下，用于分隔列表中每个选项的字符序列（例如 <br>）。\n * attributes: 要包含在 html 标记本身中的任意标记或文本的附加字符串。该字符串按字面意思由宏回显。例如，在 textarea 字段中，您可以提供属性（例如“rows="5" cols="60"\'），或者您可以传递样式信息，例如 \'style="border:1px solid silver"\'。\n * classorstyle: 对于 showerrors 宏，包装每个错误的 span 元素使用的 css 类的名称。如果未提供任何信息（或值为空），错误将包含在 <b></b> 标签中。\n\n以下部分概述了宏的示例。\n\n输入字段\n\nforminput 宏采用 path 参数 (command.name) 和一个额外的 attributes 参数（在接下来的示例中为空）。该宏与所有其他表单生成宏一起对路径参数执行隐式 spring 绑定。绑定在新绑定发生之前一直有效，因此 showerrors 宏不需要再次传递路径参数——它对上次创建绑定的字段进行操作。\n\nshowerrors 宏接受一个分隔符参数（用于分隔给定字段上的多个错误的字符），还接受第二个参数——这次是类名或样式属性。请注意，freemarker 可以为 attributes 参数指定默认值。以下示例显示了如何使用 forminput 和 showerrors 宏：\n\n<@spring.forminput "command.name"/>\n<@spring.showerrors "<br>"/>\n\n\n下一个示例显示表单片段的输出，生成名称字段并在表单提交后显示验证错误，该字段中没有任何值。验证通过 spring 的验证框架进行。\n\n生成的 html 类似于以下示例：\n\nname:\n<input type="text" name="name" value="">\n<br>\n    <b>required</b>\n<br>\n<br>\n\n\nformtextarea 宏的工作方式与 forminput 宏相同，并且接受相同的参数列表。通常，第二个参数 (attributes) 用于传递样式信息或 textarea 的 rows 和 cols 属性。\n\n选中字段\n\n您可以使用四个选择字段宏在 html 表单中生成常见的 ui 值选择输入：\n\n * formsingleselect\n * formmultiselect\n * formradiobuttons\n * formcheckboxes\n\n四个宏中的每一个都接受一个“map”选项，其中包含表单字段的值和与该值对应的标签。值和标签可以相同。\n\n下一个例子是 ftl 中的单选按钮。表单支持对象为此字段指定默认值“伦敦”，因此无需验证。渲染表单时，整个可供选择的城市列表作为参考数据提供在模型中，名称为 citymap。以下清单显示了示例：\n\n...\ntown:\n<@spring.formradiobuttons "command.address.town", citymap, ""/><br><br>\n\n\n前面的清单呈现一行单选按钮，一个用于 citymap 中的每个值，并使用分隔符 ""。没有提供额外的属性（缺少宏的最后一个参数）。 citymap 对地图中的每个键值对使用相同的 string。地图的键是表单实际作为 post 请求参数提交的内容。地图值是用户看到的标签。在前面的示例中，给定三个知名城市的列表和表单支持对象中的默认值，html 类似于以下内容：\n\ntown:\n<input type="radio" name="address.town" value="london">london</input>\n<input type="radio" name="address.town" value="paris" checked="checked">paris</input>\n<input type="radio" name="address.town" value="new york">new york</input>\n\n\n如果您的应用程序希望通过内部代码处理城市（例如），您可以使用合适的键创建代码映射，如以下示例所示：\n\nprotected map<string, ?> referencedata(httpservletrequest request) throws exception {\n    map<string, string> citymap = new linkedhashmap<>();\n    citymap.put("ldn", "london");\n    citymap.put("prs", "paris");\n    citymap.put("nyc", "new york");\n\n    map<string, object> model = new hashmap<>();\n    model.put("citymap", citymap);\n    return model;\n}\n\n\n代码现在生成输出，其中无线电值是相关代码，但用户仍然看到更用户友好的城市名称，如下所示：\n\ntown:\n<input type="radio" name="address.town" value="ldn">london</input>\n<input type="radio" name="address.town" value="prs" checked="checked">paris</input>\n<input type="radio" name="address.town" value="nyc">new york</input>\n\n\n# html 转义\n\n前面描述的表单宏的默认使用导致 html 元素符合 html 4.01，并且使用 web.xml 文件中定义的 html 转义的默认值，如 spring 的绑定支持所使用的那样。 要使元素符合 xhtml 或覆盖默认的 html 转义值，您可以在模板中指定两个变量（或在模型中，它们对模板可见）。 在模板中指定它们的好处是它们可以在稍后的模板处理中更改为不同的值，以便为表单中的不同字段提供不同的行为。\n\n要为您的标签切换到 xhtml 合规性，请为名为 xhtmlcompliant 的模型或上下文变量指定 true 值，如以下示例所示：\n\n<#-- for freemarker --\x3e\n<#assign xhtmlcompliant = true>\n\n\n处理此指令后，spring 宏生成的任何元素现在都符合 xhtml。\n\n以类似的方式，您可以为每个字段指定 html 转义，如以下示例所示：\n\n<#-- until this point, default html escaping is used --\x3e\n\n<#assign htmlescape = true>\n<#-- next field will use html escaping --\x3e\n<@spring.forminput "command.name"/>\n\n<#assign htmlescape = false in spring>\n<#-- all future fields will be bound with html escaping off --\x3e\n\n\n\n# groovy\n\ngroovy 标记模板引擎 主要用于生成类似 xml 的标记（xml、xhtml、html5 等），但可以使用它来生成任何基于文本的内容。 spring framework 具有将 spring mvc 与 groovy 标记结合使用的内置集成。\n\n\n# 配置\n\n以下示例显示如何配置 groovy 标记模板引擎：\n\n@configuration\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    @override\n    public void configureviewresolvers(viewresolverregistry registry) {\n        registry.groovy();\n    }\n\n    // configure the groovy markup template engine...\n\n    @bean\n    public groovymarkupconfigurer groovymarkupconfigurer() {\n        groovymarkupconfigurer configurer = new groovymarkupconfigurer();\n        configurer.setresourceloaderpath("/web-inf/");\n        return configurer;\n    }\n}\n\n\n以下示例显示了如何在 xml 中配置相同的内容：\n\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:groovy/>\n</mvc:view-resolvers>\n\n\x3c!-- configure the groovy markup template engine... --\x3e\n<mvc:groovy-configurer resource-loader-path="/web-inf/"/>\n\n\n\n# 示例\n\n与传统的模板引擎不同，groovy 标记依赖于使用构建器语法的 dsl。以下示例显示了 html 页面的示例模板：\n\nyieldunescaped \'<!doctype html>\'\nhtml(lang:\'en\') {\n    head {\n        meta(\'http-equiv\':\'"content-type" content="text/html; charset=utf-8"\')\n        title(\'my page\')\n    }\n    body {\n        p(\'this is an example of html contents\')\n    }\n}\n\n\n\n# 脚本视图\n\nspring 有一个内置的集成，可以将 spring mvc 与任何可以在 jsr-223 之上运行的模板库一起使用 java 脚本引擎。 我们在不同的脚本引擎上测试了以下模板库：\n\n脚本库                        脚本引擎\nhandlebars                 nashorn\nmustache                   nashorn\nreact                      nashorn\nejs                        nashorn\nerb                        jruby\nstring templates           jython\nkotlin script templating   kotlin\n\n\n# 要求\n\n需要在类路径中包含脚本引擎，具体细节因脚本引擎而异：\n\n * the nashorn java 8+ 提供了 javascript 引擎。强烈建议使用可用的最新更新版本。\n * jruby 应该作为 ruby 支持的依赖项添加。\n * jython 应该作为 python 支持的依赖项添加。\n * org.jetbrains.kotlin:kotlin-script-util 依赖项和包含 org.jetbrains.kotlin.script.jsr223.kotlinjsr223jvmlocalscriptenginefactory 行的 meta-inf/services/javax.script.scriptenginefactory 文件应该被添加 kotlin 脚本支持。 有关详细信息，请参阅此示例。\n\n您需要有脚本模板库。 为 javascript 做到这一点的一种方法是通过 webjars。\n\n\n# 脚本模板\n\n可以声明一个 scripttemplateconfigurer 来指定要使用的脚本引擎、要加载的脚本文件、调用什么函数来渲染模板等等。 以下示例使用 mustache 模板和 nashorn javascript 引擎：\n\n@configuration\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    @override\n    public void configureviewresolvers(viewresolverregistry registry) {\n        registry.scripttemplate();\n    }\n\n    @bean\n    public scripttemplateconfigurer configurer() {\n        scripttemplateconfigurer configurer = new scripttemplateconfigurer();\n        configurer.setenginename("nashorn");\n        configurer.setscripts("mustache.js");\n        configurer.setrenderobject("mustache");\n        configurer.setrenderfunction("render");\n        return configurer;\n    }\n}\n\n\n以下示例显示了 xml 中的相同配置：\n\n<mvc:annotation-driven/>\n\n<mvc:view-resolvers>\n    <mvc:script-template/>\n</mvc:view-resolvers>\n\n<mvc:script-template-configurer engine-name="nashorn" render-object="mustache" render-function="render">\n    <mvc:script location="mustache.js"/>\n</mvc:script-template-configurer>\n\n\n对于 java 和 xml 配置，controller 看起来没有什么不同，如以下示例所示：\n\n@controller\npublic class samplecontroller {\n\n    @getmapping("/sample")\n    public string test(model model) {\n        model.addattribute("title", "sample title");\n        model.addattribute("body", "sample body");\n        return "template";\n    }\n}\n\n\n以下示例显示了 mustache 模板：\n\n<html>\n  <head>\n    <title>{{title}}</title>\n  </head>\n  <body>\n    <p>{{body}}</p>\n  </body>\n</html>\n\n\n使用以下参数调用渲染函数：\n\n * string template: 模板内容\n * 地图模型：视图模型\n * renderingcontext renderingcontext： renderingcontext 允许访问应用上下文、语言环境、模板加载器和 url（自 5.0 起）\n\n如果您的模板技术需要一些自定义，您可以提供一个实现自定义渲染功能的脚本。 例如，handlerbars 需要在使用之前编译模板，并且需要一个 polyfill 来模拟一些浏览器工具，但在服务器端脚本引擎中不可用。\n\n以下示例显示了如何执行此操作：\n\n@configuration\n@enablewebmvc\npublic class webconfig implements webmvcconfigurer {\n\n    @override\n    public void configureviewresolvers(viewresolverregistry registry) {\n        registry.scripttemplate();\n    }\n\n    @bean\n    public scripttemplateconfigurer configurer() {\n        scripttemplateconfigurer configurer = new scripttemplateconfigurer();\n        configurer.setenginename("nashorn");\n        configurer.setscripts("polyfill.js", "handlebars.js", "render.js");\n        configurer.setrenderfunction("render");\n        configurer.setsharedengine(false);\n        return configurer;\n    }\n}\n\n\npolyfill.js 只定义了 handlebars 正常运行所需的 window 对象，如下：\n\nvar window = {}\n\n\n这个基本的 render.js 实现在使用之前编译模板。 生产就绪的实现还应该存储任何重复使用的缓存模板或预编译模板。 您可以在脚本端这样做（并处理您需要的任何定制——管理模板引擎配置，例如）。 以下示例显示了如何执行此操作：\n\nfunction render(template, model) {\n  var compiledtemplate = handlebars.compile(template)\n  return compiledtemplate(model)\n}\n\n\n查看 spring framework 单元测试，java 和资源，以获取更多配置示例。\n\n\n# jsp 和 jstl\n\nspring framework 具有将 spring mvc 与 jsp 和 jstl 结合使用的内置集成。\n\n> 更多内容详见：spring 官方文档之 jsp and jstl\n\n\n# rss and atom\n\nabstractatomfeedview 和 abstractrssfeedview 都继承自 abstractfeedview 基类，分别用于提供 atom 和 rss feed 视图。 它们基于 rome 项目，位于 org.springframework.web.servlet.view.feed 包中。\n\nabstractatomfeedview 要求您实现 buildfeedentries() 方法并可选择覆盖 buildfeedmetadata() 方法（默认实现为空）。 以下示例显示了如何执行此操作：\n\npublic class samplecontentatomview extends abstractatomfeedview {\n\n    @override\n    protected void buildfeedmetadata(map<string, object> model,\n            feed feed, httpservletrequest request) {\n        // implementation omitted\n    }\n\n    @override\n    protected list<entry> buildfeedentries(map<string, object> model,\n            httpservletrequest request, httpservletresponse response) throws exception {\n        // implementation omitted\n    }\n}\n\n\n类似的要求适用于实现 abstractrssfeedview，如以下示例所示：\n\npublic class samplecontentrssview extends abstractrssfeedview {\n\n    @override\n    protected void buildfeedmetadata(map<string, object> model,\n            channel feed, httpservletrequest request) {\n        // implementation omitted\n    }\n\n    @override\n    protected list<item> buildfeeditems(map<string, object> model,\n            httpservletrequest request, httpservletresponse response) throws exception {\n        // implementation omitted\n    }\n}\n\n\nbuildfeeditems() 和 buildfeedentries() 方法传入 http 请求，以防您需要访问 locale。 传入 http 响应仅用于设置 cookie 或其他 http 标头。 方法返回后，提要会自动写入响应对象。\n\n有关创建 atom 视图的示例，请参阅 alef arendsen 的 spring team 博客 entry。\n\n\n# pdf and excel\n\nspring 提供了返回 html 以外的输出的方法，包括 pdf 和 excel 电子表格。\n\n\n# 文档视图简介\n\nhtml 页面并不总是用户查看模型输出的最佳方式，spring 使从模型数据动态生成 pdf 文档或 excel 电子表格变得简单。 该文档是视图，从服务器流出正确的内容类型，（希望）使客户端 pc 能够运行他们的电子表格或 pdf 查看器应用程序作为响应。\n\n为了使用 excel 视图，您需要将 apache poi 库添加到类路径中。 对于 pdf 生成，您需要添加（最好）openpdf 库。\n\n\n# pdf 视图\n\n单词列表的简单 pdf 视图可以扩展 org.springframework.web.servlet.view.document.abstractpdfview 并实现 buildpdfdocument() 方法，如以下示例所示：\n\npublic class pdfwordlist extends abstractpdfview {\n\n    protected void buildpdfdocument(map<string, object> model, document doc, pdfwriter writer,\n            httpservletrequest request, httpservletresponse response) throws exception {\n\n        list<string> words = (list<string>) model.get("wordlist");\n        for (string word : words) {\n            doc.add(new paragraph(word));\n        }\n    }\n}\n\n\n控制器可以从外部视图定义（按名称引用它）或作为处理程序方法的 view 实例返回此类视图。\n\n\n# excel 视图\n\n从 spring framework 4.2 开始，org.springframework.web.servlet.view.document.abstractxlsview 作为 excel 视图的基类提供。 它基于 apache poi，具有专门的子类（abstractxlsxview 和 abstractxlsxstreamingview），取代了过时的 abstractexcelview 类。\n\n编程模型类似于 abstractpdfview，以 buildexceldocument() 作为核心模板方法，控制器能够从外部定义（按名称）或作为处理程序方法的 view 实例返回此类视图。\n\n\n# jackson\n\nspring 提供对 jackson json 库的支持。\n\n\n# 基于 jackson 的 json mvc 视图\n\nmappingjackson2jsonview 使用 jackson 库的 objectmapper 将响应内容渲染为 json。 默认情况下，模型映射的全部内容（特定于框架的类除外）都编码为 json。 对于需要过滤 map 内容的情况，您可以使用 modelkeys 属性指定一组特定的模型属性进行编码。 您还可以使用 extractvaluefromsinglekeymodel 属性直接提取和序列化单键模型中的值，而不是作为模型属性的映射。\n\n您可以根据需要使用 jackson 提供的注释自定义 json 映射。 当您需要进一步控制时，您可以通过 objectmapper 属性注入自定义 objectmapper，适用于需要为特定类型提供自定义 json 序列化器和反序列化器的情况。\n\n\n# 基于 jackson 的 xml 视图\n\nmappingjackson2xmlview 使用 jackson xml 扩展 xmlmapper 将响应内容渲染为 xml。 如果模型包含多个条目，您应该使用 modelkey bean 属性显式设置要序列化的对象。 如果模型包含单个条目，它会自动序列化。\n\n您可以根据需要使用 jaxb 或 jackson 提供的注释自定义 xml 映射。当您需要进一步控制时，您可以通过 objectmapper 属性注入自定义 xmlmapper，对于需要为特定类型提供序列化器和反序列化器的自定义 xml 的情况\n\n\n# xml\n\nmarshallingview 使用 xml marshaller（在 org.springframework.oxm 包中定义）将响应内容渲染为 xml。 您可以使用 marshallingview 实例的 modelkey 属性显式设置要编组的对象。 或者，视图遍历所有模型属性并编组 marshaller 支持的第一个类型。 有关 org.springframework.oxm 包中功能的更多信息，请参阅 marshalling xml using o/x mappers。\n\n\n# xslt\n\nxslt 是 xml 的一种转换语言，作为 web 应用程序中的一种视图技术很受欢迎。 如果您的应用程序自然地处理 xml，或者如果您的模型可以很容易地转换为 xml，那么 xslt 作为一种视图技术是一个不错的选择。 以下部分展示了如何生成 xml 文档作为模型数据，并在 spring web mvc 应用程序中使用 xslt 对其进行转换。\n\n此示例是一个简单的 spring 应用程序，它在 controller 中创建关键字列表并将它们添加到模型映射中。 返回映射以及我们的 xslt 视图的视图名称。 有关 spring web mvc 的 controller 接口的详细信息，请参阅 annotated controllers。 xslt 控制器将单词列表转换为准备转换的简单 xml 文档。\n\n\n# beans\n\n配置是一个简单的 spring web 应用程序的标准配置：mvc 配置必须定义一个 xsltviewresolver 和常规 mvc 注释配置。以下示例显示了如何执行此操作：\n\n@enablewebmvc\n@componentscan\n@configuration\npublic class webconfig implements webmvcconfigurer {\n\n    @bean\n    public xsltviewresolver xsltviewresolver() {\n        xsltviewresolver viewresolver = new xsltviewresolver();\n        viewresolver.setprefix("/web-inf/xsl/");\n        viewresolver.setsuffix(".xslt");\n        return viewresolver;\n    }\n}\n\n\n\n# controller\n\n我们还需要一个控制器来封装我们的单词生成逻辑。\n\n控制器逻辑封装在一个 @controller 类中，处理方法定义如下：\n\n@controller\npublic class xsltcontroller {\n\n    @requestmapping("/")\n    public string home(model model) throws exception {\n        document document = documentbuilderfactory.newinstance().newdocumentbuilder().newdocument();\n        element root = document.createelement("wordlist");\n\n        list<string> words = arrays.aslist("hello", "spring", "framework");\n        for (string word : words) {\n            element wordnode = document.createelement("word");\n            text textnode = document.createtextnode(word);\n            wordnode.appendchild(textnode);\n            root.appendchild(wordnode);\n        }\n\n        model.addattribute("wordlist", root);\n        return "home";\n    }\n}\n\n\n到目前为止，我们只创建了一个 dom 文档并将其添加到模型映射中。请注意，您还可以将 xml 文件作为 resource 加载并使用它来代替自定义 dom 文档。\n\n有可用的软件包可以自动 \'domify\' 一个对象图，但是在 spring 中，您可以完全灵活地以您选择的任何方式从您的模型创建 dom。这可以防止 xml 的转换在模型数据的结构中发挥太大作用，这在使用工具管理 domification 过程时是一种危险。\n\n\n# transformation\n\n最后，xsltviewresolver 解析 “home” xslt 模板文件并将 dom 文档合并到其中以生成我们的视图。如 xsltviewresolver 配置所示，xslt 模板位于 web-inf/xsl 目录下的 war 文件中，并以 xslt 文件扩展名结尾。\n\n以下示例显示了 xslt 转换：\n\n<?xml version="1.0" encoding="utf-8"?>\n<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/xsl/transform">\n\n    <xsl:output method="html" omit-xml-declaration="yes"/>\n\n    <xsl:template match="/">\n        <html>\n            <head><title>hello!</title></head>\n            <body>\n                <h1>my first words</h1>\n                <ul>\n                    <xsl:apply-templates/>\n                </ul>\n            </body>\n        </html>\n    </xsl:template>\n\n    <xsl:template match="word">\n        <li><xsl:value-of select="."/></li>\n    </xsl:template>\n\n</xsl:stylesheet>\n\n\n前面的转换渲染为以下 html：\n\n<html>\n  <head>\n    <meta http-equiv="content-type" content="text/html; charset=utf-8" />\n    <title>hello!</title>\n  </head>\n  <body>\n    <h1>my first words</h1>\n    <ul>\n      <li>hello</li>\n      <li>spring</li>\n      <li>framework</li>\n    </ul>\n  </body>\n</html>\n\n\n\n# 参考资料\n\n * spring framework 官方文档\n * spring framework 官方文档之 web',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring Web",frontmatter:{title:"Spring Web",date:"2020-02-26T23:48:06.000Z",categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","SpringBoot","Web"],permalink:"/pages/e2586a/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/README.md",key:"v-27e9310e",path:"/pages/e2586a/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:72},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:201},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:380}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring Web\n\n> 章节主要针对：Spring 在 web 领域的应用。如：Spring MVC、WebSocket 等。\n\n\n# 📖 内容\n\n * SpringWeb 综述\n * SpringWeb 应用\n * DispatcherServlet\n * Spring 过滤器\n * Spring 跨域\n * Spring 视图\n * SpringBoot 之应用 EasyUI\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring web\n\n> 章节主要针对：spring 在 web 领域的应用。如：spring mvc、websocket 等。\n\n\n# 📖 内容\n\n * springweb 综述\n * springweb 应用\n * dispatcherservlet\n * spring 过滤器\n * spring 跨域\n * spring 视图\n * springboot 之应用 easyui\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 之应用 EasyUI",frontmatter:{title:"SpringBoot 之应用 EasyUI",date:"2019-01-08T17:19:34.000Z",order:21,categories:["Java","框架","Spring","SpringWeb"],tags:["Java","框架","Spring","SpringBoot","Web"],permalink:"/pages/ad0516/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/03.SpringWeb/21.SpringBoot%E4%B9%8B%E5%BA%94%E7%94%A8EasyUI.html",relativePath:"01.Java/13.框架/01.Spring/03.SpringWeb/21.SpringBoot之应用EasyUI.md",key:"v-3caac053",path:"/pages/ad0516/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:288},{level:3,title:"什么是 EasyUI？",slug:"什么是-easyui",normalizedTitle:"什么是 easyui？",charIndex:295},{level:2,title:"Spring Boot 整合 EasyUI",slug:"spring-boot-整合-easyui",normalizedTitle:"spring boot 整合 easyui",charIndex:549},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:575},{level:3,title:"引入 easyui",slug:"引入-easyui",normalizedTitle:"引入 easyui",charIndex:676},{level:2,title:"实战",slug:"实战",normalizedTitle:"实战",charIndex:1583},{level:3,title:"引入 maven 依赖",slug:"引入-maven-依赖",normalizedTitle:"引入 maven 依赖",charIndex:1590},{level:3,title:"使用 JPA",slug:"使用-jpa",normalizedTitle:"使用 jpa",charIndex:2677},{level:3,title:"使用 Web",slug:"使用-web",normalizedTitle:"使用 web",charIndex:3374},{level:3,title:"使用 EasyUI",slug:"使用-easyui",normalizedTitle:"使用 easyui",charIndex:4980},{level:2,title:"完整示例",slug:"完整示例",normalizedTitle:"完整示例",charIndex:11229},{level:2,title:"引用和引申",slug:"引用和引申",normalizedTitle:"引用和引申",charIndex:11340}],headersStr:"简介 什么是 EasyUI？ Spring Boot 整合 EasyUI 配置 引入 easyui 实战 引入 maven 依赖 使用 JPA 使用 Web 使用 EasyUI 完整示例 引用和引申",content:'# SpringBoot 之应用 EasyUI\n\n> EasyUI 是一个简单的用户界面组件的集合。由于 EasyUI 已经封装好大部分 UI 基本功能，能帮用户减少大量的 js 和 css 代码。所以，EasyUI 非常适合用于开发简单的系统或原型系统。\n> \n> 本文示例使用技术点：\n> \n>  * Spring Boot：主要使用了 spring-boot-starter-web、spring-boot-starter-data-jpa\n>  * EasyUI：按需加载，并没有引入所有的 EasyUI 特性\n>  * 数据库：为了测试方便，使用 H2\n\n\n\n\n# 简介\n\n\n# 什么是 EasyUI？\n\n * easyui 是基于 jQuery、Angular.、Vue 和 React 的用户界面组件的集合。\n * easyui 提供了构建现代交互式 javascript 应用程序的基本功能。\n * 使用 easyui，您不需要编写许多 javascript 代码，通常通过编写一些 HTML 标记来定义用户界面。\n * 完整的 HTML5 网页框架。\n * 使用 easyui 开发你的产品时可以大量节省你的时间和规模。\n * easyui 使用非常简单但功能非常强大。\n\n\n# Spring Boot 整合 EasyUI\n\n\n# 配置\n\napplication.properties 修改：\n\nspring.mvc.view.prefix = /views/\nspring.mvc.view.suffix = .html\n\n\n\n# 引入 easyui\n\nEasyUI 下载地址：http://www.jeasyui.cn/download.html\n\n在 src/main/resources/static 目录下引入 easyui。\n\n然后在 html 中引用：\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="UTF-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_CN.js"\n    ><\/script>\n  </head>\n  <body>\n    \x3c!-- 省略 --\x3e\n  </body>\n</html>\n\n\n引入 easyui 后，需要使用哪种组件，可以查看相关文档或 API，十分简单，此处不一一赘述。\n\n\n# 实战\n\n\n# 引入 maven 依赖\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-tomcat</artifactId>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupId>com.h2database</groupId>\n      <artifactId>h2</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-devtools</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>commons-collections</groupId>\n      <artifactId>commons-collections</artifactId>\n      <version>3.2.2</version>\n    </dependency>\n  </dependencies>\n\n\n\n# 使用 JPA\n\n为了使用 JPA 技术访问数据，我们需要定义 Entity 和 Repository\n\n定义一个 Entity：\n\n@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String firstName;\n    private String lastName;\n    private String phone;\n    private String email;\n\n    protected User() {}\n\n    public User(String firstName, String lastName, String phone, String email) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.phone = phone;\n        this.email = email;\n    }\n\n    // 略 getter/setter\n}\n\n\n定义一个 Repository：\n\npublic interface UserRepository extends CrudRepository<User, Long> {\n\n    List<User> findByLastName(String lastName);\n}\n\n\n\n# 使用 Web\n\n首页 Controller，将 web 请求定向到指定页面（下面的例子定向到 index.html）\n\n@Controller\npublic class IndexController {\n\n    @RequestMapping(value = {"", "/", "index"})\n    public String index() {\n        return "index";\n    }\n\n}\n\n\n此外，需要定义一个 Controller，提供后台的 API 接口\n\n@Controller\npublic class UserController {\n\n    @Autowired\n    private UserRepository customerRepository;\n\n    @RequestMapping(value = "/user", method = RequestMethod.GET)\n    public String user() {\n        return "user";\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/list")\n    public ResponseDTO<User> list() {\n        Iterable<User> all = customerRepository.findAll();\n        List<User> list = IteratorUtils.toList(all.iterator());\n        return new ResponseDTO<>(true, list.size(), list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/add")\n    public ResponseDTO<User> add(User user) {\n        User result = customerRepository.save(user);\n        List<User> list = new ArrayList<>();\n        list.add(result);\n        return new ResponseDTO<>(true, 1, list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/save")\n    public ResponseDTO<User> save(@RequestParam("id") Long id, User user) {\n        user.setId(id);\n        customerRepository.save(user);\n        List<User> list = new ArrayList<>();\n        list.add(user);\n        return new ResponseDTO<>(true, 1, list);\n    }\n\n    @ResponseBody\n    @RequestMapping(value = "/user/delete")\n    public ResponseDTO delete(@RequestParam("id") Long id) {\n        customerRepository.deleteById(id);\n        return new ResponseDTO<>(true, null, null);\n    }\n\n}\n\n\n\n# 使用 EasyUI\n\n接下来，我们要使用前面定义的后台接口，仅需要在 EasyUI API 中指定 url 即可。\n\n请留意下面示例中的 url 字段，和实际接口是一一对应的。\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Complex Layout - jQuery EasyUI Demo</title>\n    <meta charset="UTF-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_CN.js"\n    ><\/script>\n    <style type="text/css">\n      body {\n        font-family: microsoft yahei;\n      }\n    </style>\n  </head>\n  <body>\n    <div style="width:100%">\n      <h2>基本的 CRUD 应用</h2>\n      <p>数据来源于后台系统</p>\n\n      <table\n        id="dg"\n        title="Custom List"\n        class="easyui-datagrid"\n        url="/user/list"\n        toolbar="#toolbar"\n        pagination="true"\n        rownumbers="true"\n        fitColumns="true"\n        singleSelect="true"\n      >\n        <thead>\n          <tr>\n            <th field="id" width="50">ID</th>\n            <th field="firstName" width="50">First Name</th>\n            <th field="lastName" width="50">Last Name</th>\n            <th field="phone" width="50">Phone</th>\n            <th field="email" width="50">Email</th>\n          </tr>\n        </thead>\n      </table>\n      <div id="toolbar">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-add"\n          plain="true"\n          onclick="newUser()"\n          >添加</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-edit"\n          plain="true"\n          onclick="editUser()"\n          >修改</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-remove"\n          plain="true"\n          onclick="destroyUser()"\n          >删除</a\n        >\n      </div>\n\n      <div\n        id="dlg"\n        class="easyui-dialog"\n        style="width:400px"\n        data-options="closed:true,modal:true,border:\'thin\',buttons:\'#dlg-buttons\'"\n      >\n        <form\n          id="fm"\n          method="post"\n          novalidate\n          style="margin:0;padding:20px 50px"\n        >\n          <h3>User Information</h3>\n          <div style="margin-bottom:10px">\n            <input\n              name="firstName"\n              class="easyui-textbox"\n              required="true"\n              label="First Name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="lastName"\n              class="easyui-textbox"\n              required="true"\n              label="Last Name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="phone"\n              class="easyui-textbox"\n              required="true"\n              label="Phone:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="email"\n              class="easyui-textbox"\n              required="true"\n              validType="email"\n              label="Email:"\n              style="width:100%"\n            />\n          </div>\n        </form>\n      </div>\n      <div id="dlg-buttons">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton c6"\n          iconCls="icon-ok"\n          onclick="saveUser()"\n          style="width:90px"\n          >Save</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconCls="icon-cancel"\n          onclick="javascript:$(\'#dlg\').dialog(\'close\')"\n          style="width:90px"\n          >Cancel</a\n        >\n      </div>\n    </div>\n\n    <script type="text/javascript">\n      var url\n\n      function newUser() {\n        $(\'#dlg\')\n          .dialog(\'open\')\n          .dialog(\'center\')\n          .dialog(\'setTitle\', \'New User\')\n        $(\'#fm\').form(\'clear\')\n        url = \'/user/add\'\n      }\n\n      function editUser() {\n        var row = $(\'#dg\').datagrid(\'getSelected\')\n        if (row) {\n          $(\'#dlg\')\n            .dialog(\'open\')\n            .dialog(\'center\')\n            .dialog(\'setTitle\', \'Edit User\')\n          $(\'#fm\').form(\'load\', row)\n          url = \'/user/save\'\n        }\n      }\n\n      function saveUser() {\n        $(\'#fm\').form(\'submit\', {\n          url: url,\n          onSubmit: function() {\n            return $(this).form(\'validate\')\n          },\n          success: function(result) {\n            var result = eval(\'(\' + result + \')\')\n            if (result.errorMsg) {\n              $.messager.show({\n                title: \'Error\',\n                msg: result.errorMsg\n              })\n            } else {\n              $(\'#dlg\').dialog(\'close\') // close the dialog\n              $(\'#dg\').datagrid(\'reload\') // reload the user data\n            }\n          }\n        })\n      }\n\n      function destroyUser() {\n        var row = $(\'#dg\').datagrid(\'getSelected\')\n        if (row) {\n          $.messager.confirm(\n            \'Confirm\',\n            \'Are you sure you want to destroy this user?\',\n            function(r) {\n              if (r) {\n                $.post(\n                  \'/user/delete\',\n                  { id: row.id },\n                  function(result) {\n                    if (result.success) {\n                      $(\'#dg\').datagrid(\'reload\') // reload the user data\n                    } else {\n                      $.messager.show({\n                        // show error message\n                        title: \'Error\',\n                        msg: result.errorMsg\n                      })\n                    }\n                  },\n                  \'json\'\n                )\n              }\n            }\n          )\n        }\n      }\n    <\/script>\n  </body>\n</html>\n\n\n\n# 完整示例\n\n请参考 源码\n\n运行方式：\n\nmvn clean package -DskipTests=true\njava -jar target/\n\n\n在浏览器中访问：http://localhost:8080/\n\n\n# 引用和引申\n\n * EasyUI 官网\n * EasyUI 中文网',normalizedContent:'# springboot 之应用 easyui\n\n> easyui 是一个简单的用户界面组件的集合。由于 easyui 已经封装好大部分 ui 基本功能，能帮用户减少大量的 js 和 css 代码。所以，easyui 非常适合用于开发简单的系统或原型系统。\n> \n> 本文示例使用技术点：\n> \n>  * spring boot：主要使用了 spring-boot-starter-web、spring-boot-starter-data-jpa\n>  * easyui：按需加载，并没有引入所有的 easyui 特性\n>  * 数据库：为了测试方便，使用 h2\n\n\n\n\n# 简介\n\n\n# 什么是 easyui？\n\n * easyui 是基于 jquery、angular.、vue 和 react 的用户界面组件的集合。\n * easyui 提供了构建现代交互式 javascript 应用程序的基本功能。\n * 使用 easyui，您不需要编写许多 javascript 代码，通常通过编写一些 html 标记来定义用户界面。\n * 完整的 html5 网页框架。\n * 使用 easyui 开发你的产品时可以大量节省你的时间和规模。\n * easyui 使用非常简单但功能非常强大。\n\n\n# spring boot 整合 easyui\n\n\n# 配置\n\napplication.properties 修改：\n\nspring.mvc.view.prefix = /views/\nspring.mvc.view.suffix = .html\n\n\n\n# 引入 easyui\n\neasyui 下载地址：http://www.jeasyui.cn/download.html\n\n在 src/main/resources/static 目录下引入 easyui。\n\n然后在 html 中引用：\n\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_cn.js"\n    ><\/script>\n  </head>\n  <body>\n    \x3c!-- 省略 --\x3e\n  </body>\n</html>\n\n\n引入 easyui 后，需要使用哪种组件，可以查看相关文档或 api，十分简单，此处不一一赘述。\n\n\n# 实战\n\n\n# 引入 maven 依赖\n\n  <dependencies>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-data-jpa</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-tomcat</artifactid>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-test</artifactid>\n      <scope>test</scope>\n    </dependency>\n\n    <dependency>\n      <groupid>com.h2database</groupid>\n      <artifactid>h2</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-devtools</artifactid>\n    </dependency>\n    <dependency>\n      <groupid>commons-collections</groupid>\n      <artifactid>commons-collections</artifactid>\n      <version>3.2.2</version>\n    </dependency>\n  </dependencies>\n\n\n\n# 使用 jpa\n\n为了使用 jpa 技术访问数据，我们需要定义 entity 和 repository\n\n定义一个 entity：\n\n@entity\npublic class user {\n\n    @id\n    @generatedvalue(strategy = generationtype.auto)\n    private long id;\n    private string firstname;\n    private string lastname;\n    private string phone;\n    private string email;\n\n    protected user() {}\n\n    public user(string firstname, string lastname, string phone, string email) {\n        this.firstname = firstname;\n        this.lastname = lastname;\n        this.phone = phone;\n        this.email = email;\n    }\n\n    // 略 getter/setter\n}\n\n\n定义一个 repository：\n\npublic interface userrepository extends crudrepository<user, long> {\n\n    list<user> findbylastname(string lastname);\n}\n\n\n\n# 使用 web\n\n首页 controller，将 web 请求定向到指定页面（下面的例子定向到 index.html）\n\n@controller\npublic class indexcontroller {\n\n    @requestmapping(value = {"", "/", "index"})\n    public string index() {\n        return "index";\n    }\n\n}\n\n\n此外，需要定义一个 controller，提供后台的 api 接口\n\n@controller\npublic class usercontroller {\n\n    @autowired\n    private userrepository customerrepository;\n\n    @requestmapping(value = "/user", method = requestmethod.get)\n    public string user() {\n        return "user";\n    }\n\n    @responsebody\n    @requestmapping(value = "/user/list")\n    public responsedto<user> list() {\n        iterable<user> all = customerrepository.findall();\n        list<user> list = iteratorutils.tolist(all.iterator());\n        return new responsedto<>(true, list.size(), list);\n    }\n\n    @responsebody\n    @requestmapping(value = "/user/add")\n    public responsedto<user> add(user user) {\n        user result = customerrepository.save(user);\n        list<user> list = new arraylist<>();\n        list.add(result);\n        return new responsedto<>(true, 1, list);\n    }\n\n    @responsebody\n    @requestmapping(value = "/user/save")\n    public responsedto<user> save(@requestparam("id") long id, user user) {\n        user.setid(id);\n        customerrepository.save(user);\n        list<user> list = new arraylist<>();\n        list.add(user);\n        return new responsedto<>(true, 1, list);\n    }\n\n    @responsebody\n    @requestmapping(value = "/user/delete")\n    public responsedto delete(@requestparam("id") long id) {\n        customerrepository.deletebyid(id);\n        return new responsedto<>(true, null, null);\n    }\n\n}\n\n\n\n# 使用 easyui\n\n接下来，我们要使用前面定义的后台接口，仅需要在 easyui api 中指定 url 即可。\n\n请留意下面示例中的 url 字段，和实际接口是一一对应的。\n\n<!doctype html>\n<html>\n  <head>\n    <title>complex layout - jquery easyui demo</title>\n    <meta charset="utf-8" />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/bootstrap/easyui.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/icon.css"\n    />\n    <link\n      rel="stylesheet"\n      type="text/css"\n      href="../lib/easyui/themes/color.css"\n    />\n    <script type="text/javascript" src="../lib/easyui/jquery.min.js"><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/jquery.easyui.min.js"\n    ><\/script>\n    <script\n      type="text/javascript"\n      src="../lib/easyui/locale/easyui-lang-zh_cn.js"\n    ><\/script>\n    <style type="text/css">\n      body {\n        font-family: microsoft yahei;\n      }\n    </style>\n  </head>\n  <body>\n    <div style="width:100%">\n      <h2>基本的 crud 应用</h2>\n      <p>数据来源于后台系统</p>\n\n      <table\n        id="dg"\n        title="custom list"\n        class="easyui-datagrid"\n        url="/user/list"\n        toolbar="#toolbar"\n        pagination="true"\n        rownumbers="true"\n        fitcolumns="true"\n        singleselect="true"\n      >\n        <thead>\n          <tr>\n            <th field="id" width="50">id</th>\n            <th field="firstname" width="50">first name</th>\n            <th field="lastname" width="50">last name</th>\n            <th field="phone" width="50">phone</th>\n            <th field="email" width="50">email</th>\n          </tr>\n        </thead>\n      </table>\n      <div id="toolbar">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconcls="icon-add"\n          plain="true"\n          onclick="newuser()"\n          >添加</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconcls="icon-edit"\n          plain="true"\n          onclick="edituser()"\n          >修改</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconcls="icon-remove"\n          plain="true"\n          onclick="destroyuser()"\n          >删除</a\n        >\n      </div>\n\n      <div\n        id="dlg"\n        class="easyui-dialog"\n        style="width:400px"\n        data-options="closed:true,modal:true,border:\'thin\',buttons:\'#dlg-buttons\'"\n      >\n        <form\n          id="fm"\n          method="post"\n          novalidate\n          style="margin:0;padding:20px 50px"\n        >\n          <h3>user information</h3>\n          <div style="margin-bottom:10px">\n            <input\n              name="firstname"\n              class="easyui-textbox"\n              required="true"\n              label="first name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="lastname"\n              class="easyui-textbox"\n              required="true"\n              label="last name:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="phone"\n              class="easyui-textbox"\n              required="true"\n              label="phone:"\n              style="width:100%"\n            />\n          </div>\n          <div style="margin-bottom:10px">\n            <input\n              name="email"\n              class="easyui-textbox"\n              required="true"\n              validtype="email"\n              label="email:"\n              style="width:100%"\n            />\n          </div>\n        </form>\n      </div>\n      <div id="dlg-buttons">\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton c6"\n          iconcls="icon-ok"\n          onclick="saveuser()"\n          style="width:90px"\n          >save</a\n        >\n        <a\n          href="javascript:void(0)"\n          class="easyui-linkbutton"\n          iconcls="icon-cancel"\n          onclick="javascript:$(\'#dlg\').dialog(\'close\')"\n          style="width:90px"\n          >cancel</a\n        >\n      </div>\n    </div>\n\n    <script type="text/javascript">\n      var url\n\n      function newuser() {\n        $(\'#dlg\')\n          .dialog(\'open\')\n          .dialog(\'center\')\n          .dialog(\'settitle\', \'new user\')\n        $(\'#fm\').form(\'clear\')\n        url = \'/user/add\'\n      }\n\n      function edituser() {\n        var row = $(\'#dg\').datagrid(\'getselected\')\n        if (row) {\n          $(\'#dlg\')\n            .dialog(\'open\')\n            .dialog(\'center\')\n            .dialog(\'settitle\', \'edit user\')\n          $(\'#fm\').form(\'load\', row)\n          url = \'/user/save\'\n        }\n      }\n\n      function saveuser() {\n        $(\'#fm\').form(\'submit\', {\n          url: url,\n          onsubmit: function() {\n            return $(this).form(\'validate\')\n          },\n          success: function(result) {\n            var result = eval(\'(\' + result + \')\')\n            if (result.errormsg) {\n              $.messager.show({\n                title: \'error\',\n                msg: result.errormsg\n              })\n            } else {\n              $(\'#dlg\').dialog(\'close\') // close the dialog\n              $(\'#dg\').datagrid(\'reload\') // reload the user data\n            }\n          }\n        })\n      }\n\n      function destroyuser() {\n        var row = $(\'#dg\').datagrid(\'getselected\')\n        if (row) {\n          $.messager.confirm(\n            \'confirm\',\n            \'are you sure you want to destroy this user?\',\n            function(r) {\n              if (r) {\n                $.post(\n                  \'/user/delete\',\n                  { id: row.id },\n                  function(result) {\n                    if (result.success) {\n                      $(\'#dg\').datagrid(\'reload\') // reload the user data\n                    } else {\n                      $.messager.show({\n                        // show error message\n                        title: \'error\',\n                        msg: result.errormsg\n                      })\n                    }\n                  },\n                  \'json\'\n                )\n              }\n            }\n          )\n        }\n      }\n    <\/script>\n  </body>\n</html>\n\n\n\n# 完整示例\n\n请参考 源码\n\n运行方式：\n\nmvn clean package -dskiptests=true\njava -jar target/\n\n\n在浏览器中访问：http://localhost:8080/\n\n\n# 引用和引申\n\n * easyui 官网\n * easyui 中文网',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"spring-boot-async",frontmatter:{title:"spring-boot-async",date:"2019-11-18T14:55:01.000Z",order:1,categories:["Java","框架","Spring","SpringIO"],tags:["Java","框架","Spring","SpringBoot","异步"],permalink:"/pages/92add2/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/04.SpringIO/01.SpringBoot%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.html",relativePath:"01.Java/13.框架/01.Spring/04.SpringIO/01.SpringBoot之异步请求.md",key:"v-515c830f",path:"/pages/92add2/",headers:[{level:2,title:"@EnableAsync 注解",slug:"enableasync-注解",normalizedTitle:"@enableasync 注解",charIndex:27},{level:2,title:"@Async 注解",slug:"async-注解",normalizedTitle:"@async 注解",charIndex:192},{level:3,title:"支持的用法",slug:"支持的用法",normalizedTitle:"支持的用法",charIndex:206},{level:3,title:"不支持的用法",slug:"不支持的用法",normalizedTitle:"不支持的用法",charIndex:866},{level:2,title:"明确指定执行器",slug:"明确指定执行器",normalizedTitle:"明确指定执行器",charIndex:1355},{level:2,title:"管理 @Async 的异常",slug:"管理-async-的异常",normalizedTitle:"管理 @async 的异常",charIndex:1800},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:2318},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2353}],headersStr:"@EnableAsync 注解 @Async 注解 支持的用法 不支持的用法 明确指定执行器 管理 @Async 的异常 示例源码 参考资料",content:'# SpringBoot 教程之处理异步请求\n\n\n# @EnableAsync 注解\n\n要使用 @Async，首先需要使用 @EnableAsync 注解开启 Spring Boot 中的异步特性。\n\n@Configuration\n@EnableAsync\npublic class AppConfig {\n}\n\n\n更详细的配置说明，可以参考：AsyncConfigurer\n\n\n# @Async 注解\n\n\n# 支持的用法\n\n（1）无入参无返回值方法\n\n您可以用 @Async 注解修饰方法，这表明这个方法是异步方式调用。换句话说，程序在调用此方法时会立即返回，而方法的实际执行发生在已提交给 Spring TaskExecutor 的任务中。在最简单的情况下，您可以将注解应用于返回 void 的方法，如以下示例所示：\n\n@Async\nvoid doSomething() {\n    // this will be executed asynchronously\n}\n\n\n（2）有入参无返回值方法\n\n与使用 @Scheduled 注释注释的方法不同，这些方法可以指定参数，因为它们在运行时由调用者以“正常”方式调用，而不是由容器管理的调度任务调用。例如，以下代码是 @Async 注解的合法应用：\n\n@Async\nvoid doSomething(String s) {\n    // this will be executed asynchronously\n}\n\n\n（3）有入参有返回值方法\n\n甚至可以异步调用返回值的方法。但是，这些方法需要具有 Future 类型的返回值。这仍然提供了异步执行的好处，以便调用者可以在调用 Future 上的 get() 之前执行其他任务。以下示例显示如何在返回值的方法上使用@Async：\n\n@Async\nFuture<String> returnSomething(int i) {\n    // this will be executed asynchronously\n}\n\n\n\n# 不支持的用法\n\n@Async 不能与生命周期回调一起使用，例如 @PostConstruct。\n\n要异步初始化 Spring bean，必须使用单独的初始化 Spring bean，然后在目标上调用 @Async 带注释的方法，如以下示例所示：\n\npublic class SampleBeanImpl implements SampleBean {\n\n    @Async\n    void doSomething() {\n        // ...\n    }\n\n}\n\npublic class SampleBeanInitializer {\n\n    private final SampleBean bean;\n\n    public SampleBeanInitializer(SampleBean bean) {\n        this.bean = bean;\n    }\n\n    @PostConstruct\n    public void initialize() {\n        bean.doSomething();\n    }\n\n}\n\n\n\n# 明确指定执行器\n\n默认情况下，在方法上指定 @Async 时，使用的执行器是在启用异步支持时配置的执行器，即如果使用 XML 或 AsyncConfigurer 实现（如果有），则为 annotation-driven 元素。但是，如果需要指示在执行给定方法时应使用默认值以外的执行器，则可以使用 @Async 注解的 value 属性。以下示例显示了如何执行此操作：\n\n@Async("otherExecutor")\nvoid doSomething(String s) {\n    // this will be executed asynchronously by "otherExecutor"\n}\n\n\n在这种情况下，“otherExecutor”可以是 Spring 容器中任何 Executor bean 的名称，也可以是与任何 Executor 关联的限定符的名称（例如，使用 <qualifier> 元素或 Spring 的 @Qualifier 注释指定） ）。\n\n\n# 管理 @Async 的异常\n\n当 @Async 方法的返回值类型为 Future 型时，很容易管理在方法执行期间抛出的异常，因为在调用 get 结果时会抛出此异常。但是，对于返回值类型为 void 型的方法，异常不会被捕获且无法传输。您可以提供 AsyncUncaughtExceptionHandler 来处理此类异常。以下示例显示了如何执行此操作：\n\npublic class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {\n\n    @Override\n    public void handleUncaughtException(Throwable ex, Method method, Object... params) {\n        // handle exception\n    }\n}\n\n\n默认情况下，仅记录异常。您可以使用 AsyncConfigurer 或 <task：annotation-driven /> XML 元素定义自定义 AsyncUncaughtExceptionHandler。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-async\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 boot-features-external-config\n * Spring Boot 官方文档之 scheduling-annotation-support',normalizedContent:'# springboot 教程之处理异步请求\n\n\n# @enableasync 注解\n\n要使用 @async，首先需要使用 @enableasync 注解开启 spring boot 中的异步特性。\n\n@configuration\n@enableasync\npublic class appconfig {\n}\n\n\n更详细的配置说明，可以参考：asyncconfigurer\n\n\n# @async 注解\n\n\n# 支持的用法\n\n（1）无入参无返回值方法\n\n您可以用 @async 注解修饰方法，这表明这个方法是异步方式调用。换句话说，程序在调用此方法时会立即返回，而方法的实际执行发生在已提交给 spring taskexecutor 的任务中。在最简单的情况下，您可以将注解应用于返回 void 的方法，如以下示例所示：\n\n@async\nvoid dosomething() {\n    // this will be executed asynchronously\n}\n\n\n（2）有入参无返回值方法\n\n与使用 @scheduled 注释注释的方法不同，这些方法可以指定参数，因为它们在运行时由调用者以“正常”方式调用，而不是由容器管理的调度任务调用。例如，以下代码是 @async 注解的合法应用：\n\n@async\nvoid dosomething(string s) {\n    // this will be executed asynchronously\n}\n\n\n（3）有入参有返回值方法\n\n甚至可以异步调用返回值的方法。但是，这些方法需要具有 future 类型的返回值。这仍然提供了异步执行的好处，以便调用者可以在调用 future 上的 get() 之前执行其他任务。以下示例显示如何在返回值的方法上使用@async：\n\n@async\nfuture<string> returnsomething(int i) {\n    // this will be executed asynchronously\n}\n\n\n\n# 不支持的用法\n\n@async 不能与生命周期回调一起使用，例如 @postconstruct。\n\n要异步初始化 spring bean，必须使用单独的初始化 spring bean，然后在目标上调用 @async 带注释的方法，如以下示例所示：\n\npublic class samplebeanimpl implements samplebean {\n\n    @async\n    void dosomething() {\n        // ...\n    }\n\n}\n\npublic class samplebeaninitializer {\n\n    private final samplebean bean;\n\n    public samplebeaninitializer(samplebean bean) {\n        this.bean = bean;\n    }\n\n    @postconstruct\n    public void initialize() {\n        bean.dosomething();\n    }\n\n}\n\n\n\n# 明确指定执行器\n\n默认情况下，在方法上指定 @async 时，使用的执行器是在启用异步支持时配置的执行器，即如果使用 xml 或 asyncconfigurer 实现（如果有），则为 annotation-driven 元素。但是，如果需要指示在执行给定方法时应使用默认值以外的执行器，则可以使用 @async 注解的 value 属性。以下示例显示了如何执行此操作：\n\n@async("otherexecutor")\nvoid dosomething(string s) {\n    // this will be executed asynchronously by "otherexecutor"\n}\n\n\n在这种情况下，“otherexecutor”可以是 spring 容器中任何 executor bean 的名称，也可以是与任何 executor 关联的限定符的名称（例如，使用 <qualifier> 元素或 spring 的 @qualifier 注释指定） ）。\n\n\n# 管理 @async 的异常\n\n当 @async 方法的返回值类型为 future 型时，很容易管理在方法执行期间抛出的异常，因为在调用 get 结果时会抛出此异常。但是，对于返回值类型为 void 型的方法，异常不会被捕获且无法传输。您可以提供 asyncuncaughtexceptionhandler 来处理此类异常。以下示例显示了如何执行此操作：\n\npublic class myasyncuncaughtexceptionhandler implements asyncuncaughtexceptionhandler {\n\n    @override\n    public void handleuncaughtexception(throwable ex, method method, object... params) {\n        // handle exception\n    }\n}\n\n\n默认情况下，仅记录异常。您可以使用 asyncconfigurer 或 <task：annotation-driven /> xml 元素定义自定义 asyncuncaughtexceptionhandler。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-async\n\n\n# 参考资料\n\n * spring boot 官方文档之 boot-features-external-config\n * spring boot 官方文档之 scheduling-annotation-support',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 之集成 Json",frontmatter:{title:"SpringBoot 之集成 Json",date:"2018-12-30T22:24:16.000Z",order:2,categories:["Java","框架","Spring","SpringIO"],tags:["Java","框架","Spring","SpringBoot","JSON"],permalink:"/pages/676725/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/04.SpringIO/02.SpringBoot%E4%B9%8BJson.html",relativePath:"01.Java/13.框架/01.Spring/04.SpringIO/02.SpringBoot之Json.md",key:"v-2460a6bd",path:"/pages/676725/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:26},{level:3,title:"Spring Boot 支持的 Json 库",slug:"spring-boot-支持的-json-库",normalizedTitle:"spring boot 支持的 json 库",charIndex:33},{level:3,title:"Spring Web 中的序列化、反序列化",slug:"spring-web-中的序列化、反序列化",normalizedTitle:"spring web 中的序列化、反序列化",charIndex:523},{level:4,title:"@ResponseBody",slug:"responsebody",normalizedTitle:"@responsebody",charIndex:575},{level:4,title:"@RequestBody",slug:"requestbody",normalizedTitle:"@requestbody",charIndex:939},{level:4,title:"@RestController",slug:"restcontroller",normalizedTitle:"@restcontroller",charIndex:1306},{level:2,title:"指定类的 Json 序列化、反序列化",slug:"指定类的-json-序列化、反序列化",normalizedTitle:"指定类的 json 序列化、反序列化",charIndex:1675},{level:2,title:"@JsonTest",slug:"jsontest",normalizedTitle:"@jsontest",charIndex:2609},{level:2,title:"Spring Boot 中的 json 配置",slug:"spring-boot-中的-json-配置",normalizedTitle:"spring boot 中的 json 配置",charIndex:4531},{level:3,title:"Jackson 配置",slug:"jackson-配置",normalizedTitle:"jackson 配置",charIndex:4558},{level:3,title:"GSON 配置",slug:"gson-配置",normalizedTitle:"gson 配置",charIndex:6030},{level:2,title:"Spring Boot 中使用 Fastjson",slug:"spring-boot-中使用-fastjson",normalizedTitle:"spring boot 中使用 fastjson",charIndex:7330},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:9154},{level:2,title:"引申和引用",slug:"引申和引用",normalizedTitle:"引申和引用",charIndex:9172}],headersStr:"简介 Spring Boot 支持的 Json 库 Spring Web 中的序列化、反序列化 @ResponseBody @RequestBody @RestController 指定类的 Json 序列化、反序列化 @JsonTest Spring Boot 中的 json 配置 Jackson 配置 GSON 配置 Spring Boot 中使用 Fastjson 示例源码 引申和引用",content:'# SpringBoot 之集成 Json\n\n\n# 简介\n\n\n# Spring Boot 支持的 Json 库\n\nSpring Boot 支持三种 Json 库：\n\n * Gson\n * Jackson\n * JSON-B\n\nJackson 是 Spring Boot 官方推荐的默认库。\n\nSpring Boot 提供了 Jackson 的自动配置，Jackson 是 spring-boot-starter-json 的一部分。当 Jackson 在类路径上时，会自动配置 ObjectMapper bean。\n\nSpring Boot 提供了 Gson 的自动配置。当 Gson 在 classpath 上时，会自动配置 Gson bean。提供了几个 spring.gson.* 配置属性来自定义配置。为了获得更多控制，可以使用一个或多个 GsonBuilderCustomizer bean。\n\nSpring Boot 提供了 JSON-B 的自动配置。当 JSON-B API 在 classpath 上时，将自动配置 Jsonb bean。首选的 JSON-B 实现是 Apache Johnzon，它提供了依赖关系管理。\n\n\n# Spring Web 中的序列化、反序列化\n\n以下注解都是 spring-web 中提供的支持。\n\n# @ResponseBody\n\n@Responsebody 注解用于将 Controller 的方法返回的对象，通过适当的 HttpMessageConverter 转换为指定格式后，写入到 HTTP Response 对象的 body 数据区。一般在异步获取数据时使用。通常是在使用 @RequestMapping 后，返回值通常解析为跳转路径，加上 @Responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP 响应正文中。\n\n示例：\n\n@ResponseBody\n@RequestMapping(name = "/getInfo", method = RequestMethod.GET)\npublic InfoDTO getInfo() {\n\treturn new InfoDTO();\n}\n\n\n# @RequestBody\n\n@RequestBody 注解用于读取 HTTP Request 请求的 body 部分数据，使用系统默认配置的 HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上；再把 HttpMessageConverter 返回的对象数据绑定到 controller 中方法的参数上。\n\nrequest 的 body 部分的数据编码格式由 header 部分的 Content-Type 指定。\n\n示例：\n\n@RequestMapping(name = "/postInfo", method = RequestMethod.POST)\npublic void postInfo(@RequestBody InfoDTO infoDTO) {\n    // ...\n}\n\n\n# @RestController\n\nSpring 4 以前：\n\n如果需要返回到指定页面，则需要用 @Controller 配合视图解析器 InternalResourceViewResolver 。\n\n如果需要返回 JSON，XML 或自定义 mediaType 内容到页面，则需要在对应的方法上加上 @ResponseBody 注解。\n\nSpring 4 以后，新增了 @RestController 注解：\n\n它相当于 @Controller + @RequestBody 。\n\n如果使用 @RestController 注解 Controller，则 Controller 中的方法无法返回 jsp 页面，或者 html，配置的视图解析器 InternalResourceViewResolver 将不起作用，直接返回内容。\n\n\n# 指定类的 Json 序列化、反序列化\n\n如果使用 Jackson 序列化和反序列化 JSON 数据，您可能需要编写自己的 JsonSerializer 和 JsonDeserializer 类。自定义序列化程序通常通过模块向 Jackson 注册，但 Spring Boot 提供了另一种 @JsonComponent 注释，可以更容易地直接注册 Spring Beans。\n\n您可以直接在 JsonSerializer 或 JsonDeserializer 实现上使用 @JsonComponent 注释。您还可以在包含序列化程序/反序列化程序作为内部类的类上使用它，如以下示例所示：\n\nimport java.io.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport org.springframework.boot.jackson.*;\n\n@JsonComponent\npublic class Example {\n\n\tpublic static class Serializer extends JsonSerializer<SomeObject> {\n\t\t// ...\n\t}\n\n\tpublic static class Deserializer extends JsonDeserializer<SomeObject> {\n\t\t// ...\n\t}\n\n}\n\n\nApplicationContext 中的所有 @JsonComponent bean 都会自动注册到 Jackson。因为 @JsonComponent 是使用 @Component 进行元注释的，所以通常的组件扫描规则适用。\n\nSpring Boot 还提供了 JsonObjectSerializer 和 JsonObjectDeserializer 基类，它们在序列化对象时提供了标准 Jackson 版本的有用替代方法。有关详细信息，请参阅 Javadoc 中的 JsonObjectSerializer 和 JsonObjectDeserializer。\n\n\n# @JsonTest\n\n使用 @JsonTest 可以很方便的在 Spring Boot 中测试序列化、反序列化。\n\n使用 @JsonTest 相当于使用以下自动配置：\n\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration org.springframework.boot.test.autoconfigure.json.JsonTestersAutoConfiguration\n\n\n@JsonTest 使用示例：\n\n想试试完整示例，可以参考：源码\n\n@JsonTest\n@RunWith(SpringRunner.class)\npublic class SimpleJsonTest {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private JacksonTester<InfoDTO> json;\n\n    @Test\n    public void testSerialize() throws Exception {\n        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n        InfoDTO infoDTO = new InfoDTO("JSON测试应用", "1.0.0", sdf.parse("2019-01-01 12:00:00"));\n        JsonContent<InfoDTO> jsonContent = json.write(infoDTO);\n        log.info("json content: {}", jsonContent.getJson());\n        // 或者使用基于JSON path的校验\n        assertThat(jsonContent).hasJsonPathStringValue("@.appName");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.appName").isEqualTo("JSON测试应用");\n        assertThat(jsonContent).hasJsonPathStringValue("@.version");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.version").isEqualTo("1.0.0");\n        assertThat(jsonContent).hasJsonPathStringValue("@.date");\n        assertThat(jsonContent).extractingJsonPathStringValue("@.date").isEqualTo("2019-01-01 12:00:00");\n    }\n\n    @Test\n    public void testDeserialize() throws Exception {\n        String content = "{\\"appName\\":\\"JSON测试应用\\",\\"version\\":\\"1.0.0\\",\\"date\\":\\"2019-01-01\\"}";\n        InfoDTO actual = json.parseObject(content);\n        assertThat(actual.getAppName()).isEqualTo("JSON测试应用");\n        assertThat(actual.getVersion()).isEqualTo("1.0.0");\n    }\n}\n\n\n\n# Spring Boot 中的 json 配置\n\n\n# Jackson 配置\n\n当 Spring Boot 的 json 库为 jackson 时，可以使用以下配置属性（对应 JacksonProperties 类）：\n\nspring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.\nspring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization. Configured with one of the values in Jackson\'s JsonInclude.Include enumeration.\nspring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.\nspring.jackson.generator.*= # Jackson on/off features for generators.\nspring.jackson.joda-date-time-format= # Joda date time format string. If not configured, "date-format" is used as a fallback if it is configured with a format string.\nspring.jackson.locale= # Locale used for formatting.\nspring.jackson.mapper.*= # Jackson general purpose on/off features.\nspring.jackson.parser.*= # Jackson on/off features for parsers.\nspring.jackson.property-naming-strategy= # One of the constants on Jackson\'s PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.\nspring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.\nspring.jackson.time-zone= #  Time zone used when formatting dates. For instance, "America/Los_Angeles" or "GMT+10".\nspring.jackson.visibility.*= # Jackson visibility thresholds that can be used to limit which methods (and fields) are auto-detected.\n\n\n\n# GSON 配置\n\n当 Spring Boot 的 json 库为 gson 时，可以使用以下配置属性（对应 GsonProperties 类）：\n\nspring.gson.date-format= # Format to use when serializing Date objects.\nspring.gson.disable-html-escaping= # Whether to disable the escaping of HTML characters such as \'<\', \'>\', etc.\nspring.gson.disable-inner-class-serialization= # Whether to exclude inner classes during serialization.\nspring.gson.enable-complex-map-key-serialization= # Whether to enable serialization of complex map keys (i.e. non-primitives).\nspring.gson.exclude-fields-without-expose-annotation= # Whether to exclude all fields from consideration for serialization or deserialization that do not have the "Expose" annotation.\nspring.gson.field-naming-policy= # Naming policy that should be applied to an object\'s field during serialization and deserialization.\nspring.gson.generate-non-executable-json= # Whether to generate non executable JSON by prefixing the output with some special text.\nspring.gson.lenient= # Whether to be lenient about parsing JSON that doesn\'t conform to RFC 4627.\nspring.gson.long-serialization-policy= # Serialization policy for Long and long types.\nspring.gson.pretty-printing= # Whether to output serialized JSON that fits in a page for pretty printing.\nspring.gson.serialize-nulls= # Whether to serialize null fields.\n\n\n\n# Spring Boot 中使用 Fastjson\n\n国内很多的 Java 程序员更喜欢使用阿里的 fastjson 作为 json lib。那么，如何在 Spring Boot 中将其替换默认的 jackson 库呢？\n\n你需要做如下处理：\n\n（1）引入 fastjson jar 包：\n\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>fastjson</artifactId>\n\t<version>1.2.54</version>\n</dependency>\n\n\n（2）实现 WebMvcConfigurer 接口，自定义 configureMessageConverters 接口。如下所示：\n\n@Configuration\npublic class WebMvcConfig implements WebMvcConfigurer {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 自定义消息转换器\n     * @param converters\n     */\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        // 清除默认 Json 转换器\n        converters.removeIf(converter -> converter instanceof MappingJackson2HttpMessageConverter);\n\n        // 配置 FastJson\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(SerializerFeature.QuoteFieldNames, SerializerFeature.WriteEnumUsingToString,\n            SerializerFeature.WriteMapNullValue, SerializerFeature.WriteDateUseDateFormat,\n            SerializerFeature.DisableCircularReferenceDetect);\n\n        // 添加 FastJsonHttpMessageConverter\n        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();\n        fastJsonHttpMessageConverter.setFastJsonConfig(config);\n        List<MediaType> fastMediaTypes = new ArrayList<>();\n        fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);\n        fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes);\n        converters.add(fastJsonHttpMessageConverter);\n\n        // 添加 StringHttpMessageConverter，解决中文乱码问题\n        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter(Charset.forName("UTF-8"));\n        converters.add(stringHttpMessageConverter);\n    }\n\n    // ...\n}\n\n\n\n# 示例源码\n\n完整示例：源码\n\n\n# 引申和引用\n\n引申\n\n * Spring Boot 教程\n\n引用\n\n * Spring Boot 官方文档之 boot-features-json',normalizedContent:'# springboot 之集成 json\n\n\n# 简介\n\n\n# spring boot 支持的 json 库\n\nspring boot 支持三种 json 库：\n\n * gson\n * jackson\n * json-b\n\njackson 是 spring boot 官方推荐的默认库。\n\nspring boot 提供了 jackson 的自动配置，jackson 是 spring-boot-starter-json 的一部分。当 jackson 在类路径上时，会自动配置 objectmapper bean。\n\nspring boot 提供了 gson 的自动配置。当 gson 在 classpath 上时，会自动配置 gson bean。提供了几个 spring.gson.* 配置属性来自定义配置。为了获得更多控制，可以使用一个或多个 gsonbuildercustomizer bean。\n\nspring boot 提供了 json-b 的自动配置。当 json-b api 在 classpath 上时，将自动配置 jsonb bean。首选的 json-b 实现是 apache johnzon，它提供了依赖关系管理。\n\n\n# spring web 中的序列化、反序列化\n\n以下注解都是 spring-web 中提供的支持。\n\n# @responsebody\n\n@responsebody 注解用于将 controller 的方法返回的对象，通过适当的 httpmessageconverter 转换为指定格式后，写入到 http response 对象的 body 数据区。一般在异步获取数据时使用。通常是在使用 @requestmapping 后，返回值通常解析为跳转路径，加上 @responsebody 后返回结果不会被解析为跳转路径，而是直接写入 http 响应正文中。\n\n示例：\n\n@responsebody\n@requestmapping(name = "/getinfo", method = requestmethod.get)\npublic infodto getinfo() {\n\treturn new infodto();\n}\n\n\n# @requestbody\n\n@requestbody 注解用于读取 http request 请求的 body 部分数据，使用系统默认配置的 httpmessageconverter 进行解析，然后把相应的数据绑定到要返回的对象上；再把 httpmessageconverter 返回的对象数据绑定到 controller 中方法的参数上。\n\nrequest 的 body 部分的数据编码格式由 header 部分的 content-type 指定。\n\n示例：\n\n@requestmapping(name = "/postinfo", method = requestmethod.post)\npublic void postinfo(@requestbody infodto infodto) {\n    // ...\n}\n\n\n# @restcontroller\n\nspring 4 以前：\n\n如果需要返回到指定页面，则需要用 @controller 配合视图解析器 internalresourceviewresolver 。\n\n如果需要返回 json，xml 或自定义 mediatype 内容到页面，则需要在对应的方法上加上 @responsebody 注解。\n\nspring 4 以后，新增了 @restcontroller 注解：\n\n它相当于 @controller + @requestbody 。\n\n如果使用 @restcontroller 注解 controller，则 controller 中的方法无法返回 jsp 页面，或者 html，配置的视图解析器 internalresourceviewresolver 将不起作用，直接返回内容。\n\n\n# 指定类的 json 序列化、反序列化\n\n如果使用 jackson 序列化和反序列化 json 数据，您可能需要编写自己的 jsonserializer 和 jsondeserializer 类。自定义序列化程序通常通过模块向 jackson 注册，但 spring boot 提供了另一种 @jsoncomponent 注释，可以更容易地直接注册 spring beans。\n\n您可以直接在 jsonserializer 或 jsondeserializer 实现上使用 @jsoncomponent 注释。您还可以在包含序列化程序/反序列化程序作为内部类的类上使用它，如以下示例所示：\n\nimport java.io.*;\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.*;\nimport org.springframework.boot.jackson.*;\n\n@jsoncomponent\npublic class example {\n\n\tpublic static class serializer extends jsonserializer<someobject> {\n\t\t// ...\n\t}\n\n\tpublic static class deserializer extends jsondeserializer<someobject> {\n\t\t// ...\n\t}\n\n}\n\n\napplicationcontext 中的所有 @jsoncomponent bean 都会自动注册到 jackson。因为 @jsoncomponent 是使用 @component 进行元注释的，所以通常的组件扫描规则适用。\n\nspring boot 还提供了 jsonobjectserializer 和 jsonobjectdeserializer 基类，它们在序列化对象时提供了标准 jackson 版本的有用替代方法。有关详细信息，请参阅 javadoc 中的 jsonobjectserializer 和 jsonobjectdeserializer。\n\n\n# @jsontest\n\n使用 @jsontest 可以很方便的在 spring boot 中测试序列化、反序列化。\n\n使用 @jsontest 相当于使用以下自动配置：\n\norg.springframework.boot.autoconfigure.cache.cacheautoconfiguration org.springframework.boot.autoconfigure.gson.gsonautoconfiguration org.springframework.boot.autoconfigure.jackson.jacksonautoconfiguration org.springframework.boot.autoconfigure.jsonb.jsonbautoconfiguration org.springframework.boot.test.autoconfigure.json.jsontestersautoconfiguration\n\n\n@jsontest 使用示例：\n\n想试试完整示例，可以参考：源码\n\n@jsontest\n@runwith(springrunner.class)\npublic class simplejsontest {\n\n    private final logger log = loggerfactory.getlogger(this.getclass());\n\n    @autowired\n    private jacksontester<infodto> json;\n\n    @test\n    public void testserialize() throws exception {\n        simpledateformat sdf = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n        infodto infodto = new infodto("json测试应用", "1.0.0", sdf.parse("2019-01-01 12:00:00"));\n        jsoncontent<infodto> jsoncontent = json.write(infodto);\n        log.info("json content: {}", jsoncontent.getjson());\n        // 或者使用基于json path的校验\n        assertthat(jsoncontent).hasjsonpathstringvalue("@.appname");\n        assertthat(jsoncontent).extractingjsonpathstringvalue("@.appname").isequalto("json测试应用");\n        assertthat(jsoncontent).hasjsonpathstringvalue("@.version");\n        assertthat(jsoncontent).extractingjsonpathstringvalue("@.version").isequalto("1.0.0");\n        assertthat(jsoncontent).hasjsonpathstringvalue("@.date");\n        assertthat(jsoncontent).extractingjsonpathstringvalue("@.date").isequalto("2019-01-01 12:00:00");\n    }\n\n    @test\n    public void testdeserialize() throws exception {\n        string content = "{\\"appname\\":\\"json测试应用\\",\\"version\\":\\"1.0.0\\",\\"date\\":\\"2019-01-01\\"}";\n        infodto actual = json.parseobject(content);\n        assertthat(actual.getappname()).isequalto("json测试应用");\n        assertthat(actual.getversion()).isequalto("1.0.0");\n    }\n}\n\n\n\n# spring boot 中的 json 配置\n\n\n# jackson 配置\n\n当 spring boot 的 json 库为 jackson 时，可以使用以下配置属性（对应 jacksonproperties 类）：\n\nspring.jackson.date-format= # date format string or a fully-qualified date format class name. for instance, `yyyy-mm-dd hh:mm:ss`.\nspring.jackson.default-property-inclusion= # controls the inclusion of properties during serialization. configured with one of the values in jackson\'s jsoninclude.include enumeration.\nspring.jackson.deserialization.*= # jackson on/off features that affect the way java objects are deserialized.\nspring.jackson.generator.*= # jackson on/off features for generators.\nspring.jackson.joda-date-time-format= # joda date time format string. if not configured, "date-format" is used as a fallback if it is configured with a format string.\nspring.jackson.locale= # locale used for formatting.\nspring.jackson.mapper.*= # jackson general purpose on/off features.\nspring.jackson.parser.*= # jackson on/off features for parsers.\nspring.jackson.property-naming-strategy= # one of the constants on jackson\'s propertynamingstrategy. can also be a fully-qualified class name of a propertynamingstrategy subclass.\nspring.jackson.serialization.*= # jackson on/off features that affect the way java objects are serialized.\nspring.jackson.time-zone= #  time zone used when formatting dates. for instance, "america/los_angeles" or "gmt+10".\nspring.jackson.visibility.*= # jackson visibility thresholds that can be used to limit which methods (and fields) are auto-detected.\n\n\n\n# gson 配置\n\n当 spring boot 的 json 库为 gson 时，可以使用以下配置属性（对应 gsonproperties 类）：\n\nspring.gson.date-format= # format to use when serializing date objects.\nspring.gson.disable-html-escaping= # whether to disable the escaping of html characters such as \'<\', \'>\', etc.\nspring.gson.disable-inner-class-serialization= # whether to exclude inner classes during serialization.\nspring.gson.enable-complex-map-key-serialization= # whether to enable serialization of complex map keys (i.e. non-primitives).\nspring.gson.exclude-fields-without-expose-annotation= # whether to exclude all fields from consideration for serialization or deserialization that do not have the "expose" annotation.\nspring.gson.field-naming-policy= # naming policy that should be applied to an object\'s field during serialization and deserialization.\nspring.gson.generate-non-executable-json= # whether to generate non executable json by prefixing the output with some special text.\nspring.gson.lenient= # whether to be lenient about parsing json that doesn\'t conform to rfc 4627.\nspring.gson.long-serialization-policy= # serialization policy for long and long types.\nspring.gson.pretty-printing= # whether to output serialized json that fits in a page for pretty printing.\nspring.gson.serialize-nulls= # whether to serialize null fields.\n\n\n\n# spring boot 中使用 fastjson\n\n国内很多的 java 程序员更喜欢使用阿里的 fastjson 作为 json lib。那么，如何在 spring boot 中将其替换默认的 jackson 库呢？\n\n你需要做如下处理：\n\n（1）引入 fastjson jar 包：\n\n<dependency>\n\t<groupid>com.alibaba</groupid>\n\t<artifactid>fastjson</artifactid>\n\t<version>1.2.54</version>\n</dependency>\n\n\n（2）实现 webmvcconfigurer 接口，自定义 configuremessageconverters 接口。如下所示：\n\n@configuration\npublic class webmvcconfig implements webmvcconfigurer {\n\n    private final logger log = loggerfactory.getlogger(this.getclass());\n\n    /**\n     * 自定义消息转换器\n     * @param converters\n     */\n    @override\n    public void configuremessageconverters(list<httpmessageconverter<?>> converters) {\n        // 清除默认 json 转换器\n        converters.removeif(converter -> converter instanceof mappingjackson2httpmessageconverter);\n\n        // 配置 fastjson\n        fastjsonconfig config = new fastjsonconfig();\n        config.setserializerfeatures(serializerfeature.quotefieldnames, serializerfeature.writeenumusingtostring,\n            serializerfeature.writemapnullvalue, serializerfeature.writedateusedateformat,\n            serializerfeature.disablecircularreferencedetect);\n\n        // 添加 fastjsonhttpmessageconverter\n        fastjsonhttpmessageconverter fastjsonhttpmessageconverter = new fastjsonhttpmessageconverter();\n        fastjsonhttpmessageconverter.setfastjsonconfig(config);\n        list<mediatype> fastmediatypes = new arraylist<>();\n        fastmediatypes.add(mediatype.application_json_utf8);\n        fastjsonhttpmessageconverter.setsupportedmediatypes(fastmediatypes);\n        converters.add(fastjsonhttpmessageconverter);\n\n        // 添加 stringhttpmessageconverter，解决中文乱码问题\n        stringhttpmessageconverter stringhttpmessageconverter = new stringhttpmessageconverter(charset.forname("utf-8"));\n        converters.add(stringhttpmessageconverter);\n    }\n\n    // ...\n}\n\n\n\n# 示例源码\n\n完整示例：源码\n\n\n# 引申和引用\n\n引申\n\n * spring boot 教程\n\n引用\n\n * spring boot 官方文档之 boot-features-json',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 之发送邮件",frontmatter:{title:"SpringBoot 之发送邮件",date:"2019-11-20T15:20:44.000Z",order:3,categories:["Java","框架","Spring","SpringIO"],tags:["Java","框架","Spring","SpringBoot","邮件"],permalink:"/pages/2586f1/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/04.SpringIO/03.SpringBoot%E4%B9%8B%E9%82%AE%E4%BB%B6.html",relativePath:"01.Java/13.框架/01.Spring/04.SpringIO/03.SpringBoot之邮件.md",key:"v-72547bfe",path:"/pages/2586f1/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:23},{level:2,title:"API",slug:"api",normalizedTitle:"api",charIndex:304},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:414},{level:2,title:"实战",slug:"实战",normalizedTitle:"实战",charIndex:1591},{level:3,title:"引入依赖",slug:"引入依赖",normalizedTitle:"引入依赖",charIndex:1598},{level:3,title:"配置邮件属性",slug:"配置邮件属性",normalizedTitle:"配置邮件属性",charIndex:2200},{level:3,title:"Java 代码",slug:"java-代码",normalizedTitle:"java 代码",charIndex:2882},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:6562},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6596}],headersStr:"简介 API 配置 实战 引入依赖 配置邮件属性 Java 代码 示例源码 参考资料",content:'# SpringBoot 之发送邮件\n\n\n# 简介\n\nSpring Boot 收发邮件最简便方式是通过 spring-boot-starter-mail。\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n\n\nspring-boot-starter-mail 本质上是使用 JavaMail(javax.mail)。如果想对 JavaMail 有进一步了解，可以参考： JavaMail 使用指南\n\n\n# API\n\nSpring Framework 提供了一个使用 JavaMailSender 接口发送电子邮件的简单抽象，这是发送邮件的核心 API。\n\nJavaMailSender 接口提供的 API 如下：\n\n\n\n\n# 配置\n\nSpring Boot 为 JavaMailSender 提供了自动配置以及启动器模块。\n\n如果 spring.mail.host 和相关库（由 spring-boot-starter-mail 定义）可用，则 Spring Boot 会创建默认 JavaMailSender（如果不存在）。可以通过 spring.mail 命名空间中的配置项进一步自定义发件人。 特别是，某些默认超时值是无限的，您可能希望更改它以避免线程被无响应的邮件服务器阻塞，如以下示例所示：\n\nspring.mail.properties.mail.smtp.connectiontimeout=5000\nspring.mail.properties.mail.smtp.timeout=3000\nspring.mail.properties.mail.smtp.writetimeout=5000\n\n\n也可以使用 JNDI 中的现有会话配置 JavaMailSender：\n\nspring.mail.jndi-name=mail/Session\n\n\n以下为 Spring Boot 关于 Mail 的配置：\n\n有关更多详细信息，请参阅 MailProperties。\n\n# Email (MailProperties)\nspring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.\nspring.mail.host= # SMTP server host. For instance, `smtp.example.com`.\nspring.mail.jndi-name= # Session JNDI name. When set, takes precedence over other Session settings.\nspring.mail.password= # Login password of the SMTP server.\nspring.mail.port= # SMTP server port.\nspring.mail.properties.*= # Additional JavaMail Session properties.\nspring.mail.protocol=smtp # Protocol used by the SMTP server.\nspring.mail.test-connection=false # Whether to test that the mail server is available on startup.\nspring.mail.username= # Login user of the SMTP server.\n\n\n\n# 实战\n\n\n# 引入依赖\n\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n  </dependency>\n\n  <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n  </dependency>\n  <dependency>\n    <groupId>com.github.dozermapper</groupId>\n    <artifactId>dozer-spring-boot-starter</artifactId>\n    <version>6.4.0</version>\n  </dependency>\n</dependencies>\n\n\n\n# 配置邮件属性\n\n在 src/main/resources 目录下添加 application-163.properties 配置文件，内容如下：\n\nspring.mail.host = smtp.163.com\nspring.mail.username = xxxxxx\nspring.mail.password = xxxxxx\nspring.mail.properties.mail.smtp.auth = true\nspring.mail.properties.mail.smtp.starttls.enable = true\nspring.mail.properties.mail.smtp.starttls.required = true\nspring.mail.default-encoding = UTF-8\n\nmail.domain = 163.com\nmail.from = ${spring.mail.username}@${mail.domain}\n\n\n注：需替换有效的 spring.mail.username、spring.mail.password。\n\napplication-163.properties 配置文件表示使用 163 邮箱时的配置，为了使之生效，需要通过 spring.profiles.active = 163 来激活它。\n\n在 src/main/resources 目录下添加 application.properties 配置文件，内容如下：\n\nspring.profiles.active = 163\n\n\n\n# Java 代码\n\n首先，需要读取部分配置属性，方法如下：\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\nimport org.springframework.validation.annotation.Validated;\n\n@Validated\n@Component\n@ConfigurationProperties(prefix = "mail")\npublic class MailProperties {\n    private String domain;\n    private String from;\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    public String getFrom() {\n        return from;\n    }\n\n    public void setFrom(String from) {\n        this.from = from;\n    }\n}\n\n\n接着，定义一个邮件参数实体类（使用 lombok 简化了 getter、setter）：\n\nimport lombok.Data;\nimport java.util.Date;\n\n@Data\npublic class MailDTO {\n    private String from;\n    private String replyTo;\n    private String[] to;\n    private String[] cc;\n    private String[] bcc;\n    private Date sentDate;\n    private String subject;\n    private String text;\n    private String[] filenames;\n}\n\n\n接着，实现发送邮件的功能接口：\n\nimport com.github.dozermapper.core.Mapper;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.mail.javamail.MimeMessageHelper;\nimport org.springframework.stereotype.Service;\n\nimport javax.mail.MessagingException;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\nimport java.io.IOException;\n\n@Service\npublic class MailService {\n\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private MailProperties mailProperties;\n\n    @Autowired\n    private JavaMailSender javaMailSender;\n\n    @Autowired\n    private Mapper mapper;\n\n    public void sendSimpleMailMessage(MailDTO mailDTO) {\n        SimpleMailMessage simpleMailMessage = mapper.map(mailDTO, SimpleMailMessage.class);\n        if (StringUtils.isEmpty(mailDTO.getFrom())) {\n            mailDTO.setFrom(mailProperties.getFrom());\n        }\n        javaMailSender.send(simpleMailMessage);\n    }\n\n    public void sendMimeMessage(MailDTO mailDTO) {\n\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage();\n        MimeMessageHelper messageHelper;\n        try {\n            messageHelper = new MimeMessageHelper(mimeMessage, true);\n\n            if (StringUtils.isEmpty(mailDTO.getFrom())) {\n                messageHelper.setFrom(mailProperties.getFrom());\n            }\n            messageHelper.setTo(mailDTO.getTo());\n            messageHelper.setSubject(mailDTO.getSubject());\n\n            mimeMessage = messageHelper.getMimeMessage();\n            MimeBodyPart mimeBodyPart = new MimeBodyPart();\n            mimeBodyPart.setContent(mailDTO.getText(), "text/html;charset=UTF-8");\n\n            // 描述数据关系\n            MimeMultipart mm = new MimeMultipart();\n            mm.setSubType("related");\n            mm.addBodyPart(mimeBodyPart);\n\n            // 添加邮件附件\n            for (String filename : mailDTO.getFilenames()) {\n                MimeBodyPart attachPart = new MimeBodyPart();\n                try {\n                    attachPart.attachFile(filename);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                mm.addBodyPart(attachPart);\n            }\n            mimeMessage.setContent(mm);\n            mimeMessage.saveChanges();\n\n        } catch (MessagingException e) {\n            e.printStackTrace();\n        }\n\n        javaMailSender.send(mimeMessage);\n    }\n}\n\n\n\n# 示例源码\n\n> 示例源码：spring-boot-mail\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 Sending Email',normalizedContent:'# springboot 之发送邮件\n\n\n# 简介\n\nspring boot 收发邮件最简便方式是通过 spring-boot-starter-mail。\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-mail</artifactid>\n</dependency>\n\n\nspring-boot-starter-mail 本质上是使用 javamail(javax.mail)。如果想对 javamail 有进一步了解，可以参考： javamail 使用指南\n\n\n# api\n\nspring framework 提供了一个使用 javamailsender 接口发送电子邮件的简单抽象，这是发送邮件的核心 api。\n\njavamailsender 接口提供的 api 如下：\n\n\n\n\n# 配置\n\nspring boot 为 javamailsender 提供了自动配置以及启动器模块。\n\n如果 spring.mail.host 和相关库（由 spring-boot-starter-mail 定义）可用，则 spring boot 会创建默认 javamailsender（如果不存在）。可以通过 spring.mail 命名空间中的配置项进一步自定义发件人。 特别是，某些默认超时值是无限的，您可能希望更改它以避免线程被无响应的邮件服务器阻塞，如以下示例所示：\n\nspring.mail.properties.mail.smtp.connectiontimeout=5000\nspring.mail.properties.mail.smtp.timeout=3000\nspring.mail.properties.mail.smtp.writetimeout=5000\n\n\n也可以使用 jndi 中的现有会话配置 javamailsender：\n\nspring.mail.jndi-name=mail/session\n\n\n以下为 spring boot 关于 mail 的配置：\n\n有关更多详细信息，请参阅 mailproperties。\n\n# email (mailproperties)\nspring.mail.default-encoding=utf-8 # default mimemessage encoding.\nspring.mail.host= # smtp server host. for instance, `smtp.example.com`.\nspring.mail.jndi-name= # session jndi name. when set, takes precedence over other session settings.\nspring.mail.password= # login password of the smtp server.\nspring.mail.port= # smtp server port.\nspring.mail.properties.*= # additional javamail session properties.\nspring.mail.protocol=smtp # protocol used by the smtp server.\nspring.mail.test-connection=false # whether to test that the mail server is available on startup.\nspring.mail.username= # login user of the smtp server.\n\n\n\n# 实战\n\n\n# 引入依赖\n\n<dependencies>\n  <dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-mail</artifactid>\n  </dependency>\n  <dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-test</artifactid>\n    <scope>test</scope>\n  </dependency>\n\n  <dependency>\n    <groupid>org.projectlombok</groupid>\n    <artifactid>lombok</artifactid>\n  </dependency>\n  <dependency>\n    <groupid>com.github.dozermapper</groupid>\n    <artifactid>dozer-spring-boot-starter</artifactid>\n    <version>6.4.0</version>\n  </dependency>\n</dependencies>\n\n\n\n# 配置邮件属性\n\n在 src/main/resources 目录下添加 application-163.properties 配置文件，内容如下：\n\nspring.mail.host = smtp.163.com\nspring.mail.username = xxxxxx\nspring.mail.password = xxxxxx\nspring.mail.properties.mail.smtp.auth = true\nspring.mail.properties.mail.smtp.starttls.enable = true\nspring.mail.properties.mail.smtp.starttls.required = true\nspring.mail.default-encoding = utf-8\n\nmail.domain = 163.com\nmail.from = ${spring.mail.username}@${mail.domain}\n\n\n注：需替换有效的 spring.mail.username、spring.mail.password。\n\napplication-163.properties 配置文件表示使用 163 邮箱时的配置，为了使之生效，需要通过 spring.profiles.active = 163 来激活它。\n\n在 src/main/resources 目录下添加 application.properties 配置文件，内容如下：\n\nspring.profiles.active = 163\n\n\n\n# java 代码\n\n首先，需要读取部分配置属性，方法如下：\n\nimport org.springframework.boot.context.properties.configurationproperties;\nimport org.springframework.stereotype.component;\nimport org.springframework.validation.annotation.validated;\n\n@validated\n@component\n@configurationproperties(prefix = "mail")\npublic class mailproperties {\n    private string domain;\n    private string from;\n\n    public string getdomain() {\n        return domain;\n    }\n\n    public void setdomain(string domain) {\n        this.domain = domain;\n    }\n\n    public string getfrom() {\n        return from;\n    }\n\n    public void setfrom(string from) {\n        this.from = from;\n    }\n}\n\n\n接着，定义一个邮件参数实体类（使用 lombok 简化了 getter、setter）：\n\nimport lombok.data;\nimport java.util.date;\n\n@data\npublic class maildto {\n    private string from;\n    private string replyto;\n    private string[] to;\n    private string[] cc;\n    private string[] bcc;\n    private date sentdate;\n    private string subject;\n    private string text;\n    private string[] filenames;\n}\n\n\n接着，实现发送邮件的功能接口：\n\nimport com.github.dozermapper.core.mapper;\nimport org.apache.commons.lang3.stringutils;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.mail.simplemailmessage;\nimport org.springframework.mail.javamail.javamailsender;\nimport org.springframework.mail.javamail.mimemessagehelper;\nimport org.springframework.stereotype.service;\n\nimport javax.mail.messagingexception;\nimport javax.mail.internet.mimebodypart;\nimport javax.mail.internet.mimemessage;\nimport javax.mail.internet.mimemultipart;\nimport java.io.ioexception;\n\n@service\npublic class mailservice {\n\n    private final logger log = loggerfactory.getlogger(this.getclass());\n\n    @autowired\n    private mailproperties mailproperties;\n\n    @autowired\n    private javamailsender javamailsender;\n\n    @autowired\n    private mapper mapper;\n\n    public void sendsimplemailmessage(maildto maildto) {\n        simplemailmessage simplemailmessage = mapper.map(maildto, simplemailmessage.class);\n        if (stringutils.isempty(maildto.getfrom())) {\n            maildto.setfrom(mailproperties.getfrom());\n        }\n        javamailsender.send(simplemailmessage);\n    }\n\n    public void sendmimemessage(maildto maildto) {\n\n        mimemessage mimemessage = javamailsender.createmimemessage();\n        mimemessagehelper messagehelper;\n        try {\n            messagehelper = new mimemessagehelper(mimemessage, true);\n\n            if (stringutils.isempty(maildto.getfrom())) {\n                messagehelper.setfrom(mailproperties.getfrom());\n            }\n            messagehelper.setto(maildto.getto());\n            messagehelper.setsubject(maildto.getsubject());\n\n            mimemessage = messagehelper.getmimemessage();\n            mimebodypart mimebodypart = new mimebodypart();\n            mimebodypart.setcontent(maildto.gettext(), "text/html;charset=utf-8");\n\n            // 描述数据关系\n            mimemultipart mm = new mimemultipart();\n            mm.setsubtype("related");\n            mm.addbodypart(mimebodypart);\n\n            // 添加邮件附件\n            for (string filename : maildto.getfilenames()) {\n                mimebodypart attachpart = new mimebodypart();\n                try {\n                    attachpart.attachfile(filename);\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n                mm.addbodypart(attachpart);\n            }\n            mimemessage.setcontent(mm);\n            mimemessage.savechanges();\n\n        } catch (messagingexception e) {\n            e.printstacktrace();\n        }\n\n        javamailsender.send(mimemessage);\n    }\n}\n\n\n\n# 示例源码\n\n> 示例源码：spring-boot-mail\n\n\n# 参考资料\n\n * spring boot 官方文档之 sending email',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring集成缓存",frontmatter:{title:"Spring集成缓存",date:"2017-11-08T16:53:27.000Z",order:1,categories:["Java","框架","Spring","Spring集成"],tags:["Java","框架","Spring","集成","缓存"],permalink:"/pages/a311cb/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/05.Spring%E9%9B%86%E6%88%90/01.Spring%E9%9B%86%E6%88%90%E7%BC%93%E5%AD%98.html",relativePath:"01.Java/13.框架/01.Spring/05.Spring集成/01.Spring集成缓存.md",key:"v-3a1ac617",path:"/pages/a311cb/",headers:[{level:2,title:"缓存接口",slug:"缓存接口",normalizedTitle:"缓存接口",charIndex:64},{level:3,title:"开启注解",slug:"开启注解",normalizedTitle:"开启注解",charIndex:108},{level:3,title:"缓存注解使用",slug:"缓存注解使用",normalizedTitle:"缓存注解使用",charIndex:398},{level:4,title:"@Cacheable",slug:"cacheable",normalizedTitle:"@cacheable",charIndex:515},{level:4,title:"@CachePut",slug:"cacheput",normalizedTitle:"@cacheput",charIndex:682},{level:4,title:"@CacheEvict",slug:"cacheevict",normalizedTitle:"@cacheevict",charIndex:767},{level:4,title:"@Caching",slug:"caching",normalizedTitle:"@caching",charIndex:1641},{level:4,title:"@CacheConfig",slug:"cacheconfig",normalizedTitle:"@cacheconfig",charIndex:1871},{level:2,title:"缓存存储",slug:"缓存存储",normalizedTitle:"缓存存储",charIndex:2094},{level:3,title:"使用 ConcurrentHashMap 作为缓存",slug:"使用-concurrenthashmap-作为缓存",normalizedTitle:"使用 concurrenthashmap 作为缓存",charIndex:2197},{level:3,title:"使用 Ehcache 作为缓存",slug:"使用-ehcache-作为缓存",normalizedTitle:"使用 ehcache 作为缓存",charIndex:3676},{level:3,title:"使用 Caffeine 作为缓存",slug:"使用-caffeine-作为缓存",normalizedTitle:"使用 caffeine 作为缓存",charIndex:5072},{level:2,title:"示例代码",slug:"示例代码",normalizedTitle:"示例代码",charIndex:6197},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6250}],headersStr:"缓存接口 开启注解 缓存注解使用 @Cacheable @CachePut @CacheEvict @Caching @CacheConfig 缓存存储 使用 ConcurrentHashMap 作为缓存 使用 Ehcache 作为缓存 使用 Caffeine 作为缓存 示例代码 参考资料",content:'# Spring 集成缓存中间件\n\n> Spring 中提供了缓存功能的抽象，允许你在底层灵活的替换缓存实现，而对上层暴露相同的缓存接口。\n\n\n# 缓存接口\n\nSpring 的缓存 API 以注解方式提供。\n\n\n# 开启注解\n\nSpring 为缓存功能提供了注解功能，但是你必须启动注解。 你有两个选择： (1) 在 xml 中声明 像上一节 spring-ehcache.xml 中的做法一样，使用<cache:annotation-driven/>\n\n<cache:annotation-driven cache-manager="cacheManager"/>\n\n\n(2) 使用标记注解 你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。 范例如下：\n\n@Configuration\n@EnableCaching\npublic class AppConfig {\n}\n\n\n\n# 缓存注解使用\n\nSpring 对缓存的支持类似于对事务的支持。 首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 下面三个注解都是方法级别：\n\n# @Cacheable\n\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定 key 的生成规则。\n\n# @CachePut\n\n与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。 它支持的属性和用法都与@Cacheable一致。\n\n# @CacheEvict\n\n与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。 下面是@Cacheable、@CacheEvict和@CachePut基本使用方法的一个集中展示：\n\n@Service\npublic class UserService {\n    // @Cacheable可以设置多个缓存，形式如：@Cacheable({"books", "isbns"})\n    @Cacheable(value={"users"}, key="#user.id")\n    public User findUser(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @Cacheable(value = "users", condition = "#user.getId() <= 2")\n    public User findUserInLimit(User user) {\n        return findUserInDB(user.getId());\n    }\n\n    @CachePut(value = "users", key = "#user.getId()")\n    public void updateUser(User user) {\n        updateUserInDB(user);\n    }\n\n    @CacheEvict(value = "users")\n    public void removeUser(User user) {\n        removeUserInDB(user.getId());\n    }\n\n    @CacheEvict(value = "users", allEntries = true)\n    public void clear() {\n        removeAllInDB();\n    }\n}\n\n\n# @Caching\n\n如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。\n\n@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })\npublic Book importBooks(String deposit, Date date)\n\n\n# @CacheConfig\n\n与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。\n\n@CacheConfig("books")\npublic class BookRepositoryImpl implements BookRepository {\n\t@Cacheable\n\tpublic Book findBook(ISBN isbn) {...}\n}\n\n\n\n# 缓存存储\n\nSpring 允许通过配置方式接入多种不同的缓存存储。用户可以根据实际需要选择。\n\n不同的缓存存储，具有不同的性能和特性，如果想了解具体原理，可以参考：全面理解缓存原理。这里不再赘述。\n\n\n# 使用 ConcurrentHashMap 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache" xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 ConcurrentHashMap 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="simpleCacheManager" class="org.springframework.cache.support.SimpleCacheManager">\n    <property name="caches">\n      <set>\n        <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/>\n        <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="users"/>\n      </set>\n    </property>\n  </bean>\n\n  <cache:annotation-driven cache-manager="simpleCacheManager"/>\n</beans>\n\n\n\n# 使用 Ehcache 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 EhCache 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">\n    <property name="configLocation" value="classpath:ehcache/ehcache.xml"/>\n  </bean>\n\n  <bean id="ehcacheCacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">\n    <property name="cacheManager" ref="ehcache"/>\n  </bean>\n\n  <cache:annotation-driven cache-manager="ehcacheCacheManager"/>\n</beans>\n\n\nehcache.xml 中的配置内容完全符合 Ehcache 的官方配置标准。\n\n\n# 使用 Caffeine 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 Caffeine 作为 Spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="caffeineCacheManager" class="org.springframework.cache.caffeine.CaffeineCacheManager"/>\n\n  <cache:annotation-driven cache-manager="caffeineCacheManager"/>\n</beans>\n\n\n\n# 示例代码\n\n我的示例代码地址：spring-tutorial-integration-cache\n\n\n# 参考资料\n\n * Spring 官方文档之缓存抽象\n * 注释驱动的 Spring cache 缓存介绍',normalizedContent:'# spring 集成缓存中间件\n\n> spring 中提供了缓存功能的抽象，允许你在底层灵活的替换缓存实现，而对上层暴露相同的缓存接口。\n\n\n# 缓存接口\n\nspring 的缓存 api 以注解方式提供。\n\n\n# 开启注解\n\nspring 为缓存功能提供了注解功能，但是你必须启动注解。 你有两个选择： (1) 在 xml 中声明 像上一节 spring-ehcache.xml 中的做法一样，使用<cache:annotation-driven/>\n\n<cache:annotation-driven cache-manager="cachemanager"/>\n\n\n(2) 使用标记注解 你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。 范例如下：\n\n@configuration\n@enablecaching\npublic class appconfig {\n}\n\n\n\n# 缓存注解使用\n\nspring 对缓存的支持类似于对事务的支持。 首先使用注解标记方法，相当于定义了切点，然后使用 aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 下面三个注解都是方法级别：\n\n# @cacheable\n\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定 key 的生成规则。\n\n# @cacheput\n\n与@cacheable不同，@cacheput不仅会缓存方法的结果，还会执行方法的代码段。 它支持的属性和用法都与@cacheable一致。\n\n# @cacheevict\n\n与@cacheable功能相反，@cacheevict表明所修饰的方法是用来删除失效或无用的缓存数据。 下面是@cacheable、@cacheevict和@cacheput基本使用方法的一个集中展示：\n\n@service\npublic class userservice {\n    // @cacheable可以设置多个缓存，形式如：@cacheable({"books", "isbns"})\n    @cacheable(value={"users"}, key="#user.id")\n    public user finduser(user user) {\n        return finduserindb(user.getid());\n    }\n\n    @cacheable(value = "users", condition = "#user.getid() <= 2")\n    public user finduserinlimit(user user) {\n        return finduserindb(user.getid());\n    }\n\n    @cacheput(value = "users", key = "#user.getid()")\n    public void updateuser(user user) {\n        updateuserindb(user);\n    }\n\n    @cacheevict(value = "users")\n    public void removeuser(user user) {\n        removeuserindb(user.getid());\n    }\n\n    @cacheevict(value = "users", allentries = true)\n    public void clear() {\n        removeallindb();\n    }\n}\n\n\n# @caching\n\n如果需要使用同一个缓存注解（@cacheable、@cacheevict或@cacheput）多次修饰一个方法，就需要用到@caching。\n\n@caching(evict = { @cacheevict("primary"), @cacheevict(cachenames="secondary", key="#p0") })\npublic book importbooks(string deposit, date date)\n\n\n# @cacheconfig\n\n与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@cacheconfig来指定类，省去一些配置。\n\n@cacheconfig("books")\npublic class bookrepositoryimpl implements bookrepository {\n\t@cacheable\n\tpublic book findbook(isbn isbn) {...}\n}\n\n\n\n# 缓存存储\n\nspring 允许通过配置方式接入多种不同的缓存存储。用户可以根据实际需要选择。\n\n不同的缓存存储，具有不同的性能和特性，如果想了解具体原理，可以参考：全面理解缓存原理。这里不再赘述。\n\n\n# 使用 concurrenthashmap 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache" xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 concurrenthashmap 作为 spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="simplecachemanager" class="org.springframework.cache.support.simplecachemanager">\n    <property name="caches">\n      <set>\n        <bean class="org.springframework.cache.concurrent.concurrentmapcachefactorybean" p:name="default"/>\n        <bean class="org.springframework.cache.concurrent.concurrentmapcachefactorybean" p:name="users"/>\n      </set>\n    </property>\n  </bean>\n\n  <cache:annotation-driven cache-manager="simplecachemanager"/>\n</beans>\n\n\n\n# 使用 ehcache 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 ehcache 作为 spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="ehcache" class="org.springframework.cache.ehcache.ehcachemanagerfactorybean">\n    <property name="configlocation" value="classpath:ehcache/ehcache.xml"/>\n  </bean>\n\n  <bean id="ehcachecachemanager" class="org.springframework.cache.ehcache.ehcachecachemanager">\n    <property name="cachemanager" ref="ehcache"/>\n  </bean>\n\n  <cache:annotation-driven cache-manager="ehcachecachemanager"/>\n</beans>\n\n\nehcache.xml 中的配置内容完全符合 ehcache 的官方配置标准。\n\n\n# 使用 caffeine 作为缓存\n\n参考配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:cache="http://www.springframework.org/schema/cache"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\n         http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">\n\n  <description>使用 caffeine 作为 spring 缓存</description>\n\n  \x3c!--配置参考：https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache-store-configuration--\x3e\n\n  <context:component-scan base-package="io.github.dunwu.spring.cache"/>\n\n  <bean id="caffeinecachemanager" class="org.springframework.cache.caffeine.caffeinecachemanager"/>\n\n  <cache:annotation-driven cache-manager="caffeinecachemanager"/>\n</beans>\n\n\n\n# 示例代码\n\n我的示例代码地址：spring-tutorial-integration-cache\n\n\n# 参考资料\n\n * spring 官方文档之缓存抽象\n * 注释驱动的 spring cache 缓存介绍',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring IO",frontmatter:{title:"Spring IO",date:"2022-09-18T11:34:00.000Z",categories:["Java","框架","Spring","SpringIO"],tags:["Java","框架","Spring","SpringBoot","IO"],permalink:"/pages/56581b/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/04.SpringIO/",relativePath:"01.Java/13.框架/01.Spring/04.SpringIO/README.md",key:"v-30e174be",path:"/pages/56581b/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:16},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:86},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:265}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring IO\n\n\n# 📖 内容\n\n * SpringBoot 之异步请求\n * SpringBoot 之 Json\n * SpringBoot 之邮件\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring io\n\n\n# 📖 内容\n\n * springboot 之异步请求\n * springboot 之 json\n * springboot 之邮件\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 集成",frontmatter:{title:"Spring 集成",date:"2020-02-26T23:47:47.000Z",categories:["Java","框架","Spring","Spring集成"],tags:["Java","框架","Spring","SpringBoot","集成"],permalink:"/pages/d6025b/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/05.Spring%E9%9B%86%E6%88%90/",relativePath:"01.Java/13.框架/01.Spring/05.Spring集成/README.md",key:"v-9761e2fa",path:"/pages/d6025b/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:74},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:142},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:321}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring 集成\n\n> 章节主要针对：Spring 与第三方框架、库集成。如：Cache、Scheduling、JMS、JMX 等。\n\n\n# 📖 内容\n\n * Spring 集成缓存中间件\n * Spring 集成定时任务中间件\n * Spring 集成 Dubbo\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring 集成\n\n> 章节主要针对：spring 与第三方框架、库集成。如：cache、scheduling、jms、jmx 等。\n\n\n# 📖 内容\n\n * spring 集成缓存中间件\n * spring 集成定时任务中间件\n * spring 集成 dubbo\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 集成调度器",frontmatter:{title:"Spring 集成调度器",date:"2017-11-08T16:53:27.000Z",order:2,categories:["Java","框架","Spring","Spring集成"],tags:["Java","框架","Spring","集成","调度器"],permalink:"/pages/a187f0/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/05.Spring%E9%9B%86%E6%88%90/02.Spring%E9%9B%86%E6%88%90%E8%B0%83%E5%BA%A6%E5%99%A8.html",relativePath:"01.Java/13.框架/01.Spring/05.Spring集成/02.Spring集成调度器.md",key:"v-94543dd8",path:"/pages/a187f0/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:19},{level:2,title:"实时触发调度任务",slug:"实时触发调度任务",normalizedTitle:"实时触发调度任务",charIndex:140},{level:3,title:"TaskScheduler 接口",slug:"taskscheduler-接口",normalizedTitle:"taskscheduler 接口",charIndex:153},{level:4,title:"Trigger 接口",slug:"trigger-接口",normalizedTitle:"trigger 接口",charIndex:1106},{level:4,title:"完整范例",slug:"完整范例",normalizedTitle:"完整范例",charIndex:1368},{level:3,title:"@Scheduler 的使用方法",slug:"scheduler-的使用方法",normalizedTitle:"@scheduler 的使用方法",charIndex:3844},{level:4,title:"启动注解",slug:"启动注解",normalizedTitle:"启动注解",charIndex:3912},{level:4,title:"@Scheduler 定义触发条件",slug:"scheduler-定义触发条件",normalizedTitle:"@scheduler 定义触发条件",charIndex:4853},{level:4,title:"完整范例",slug:"完整范例-2",normalizedTitle:"完整范例",charIndex:1368},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:10462}],headersStr:"概述 实时触发调度任务 TaskScheduler 接口 Trigger 接口 完整范例 @Scheduler 的使用方法 启动注解 @Scheduler 定义触发条件 完整范例 参考",content:'# Spring 集成调度器\n\n\n# 概述\n\n如果想在 Spring 中使用任务调度功能，除了集成调度框架 Quartz 这种方式，也可以使用 Spring 自己的调度任务框架。 使用 Spring 的调度框架，优点是：支持注解@Scheduler，可以省去大量的配置。\n\n\n# 实时触发调度任务\n\n\n# TaskScheduler 接口\n\nSpring3 引入了TaskScheduler接口，这个接口定义了调度任务的抽象方法。 TaskScheduler 接口的声明：\n\npublic interface TaskScheduler {\n\n    ScheduledFuture schedule(Runnable task, Trigger trigger);\n\n    ScheduledFuture schedule(Runnable task, Date startTime);\n\n    ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);\n\n    ScheduledFuture scheduleAtFixedRate(Runnable task, long period);\n\n    ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);\n\n    ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);\n\n}\n\n\n从以上方法可以看出 TaskScheduler 有两类重要参数：\n\n * 一个是要调度的方法，即一个实现了 Runnable 接口的线程类的 run()方法；\n * 另一个就是触发条件。\n\nTaskScheduler 接口的实现类 它有三个实现类：DefaultManagedTaskScheduler、ThreadPoolTaskScheduler、TimerManagerTaskScheduler。 DefaultManagedTaskScheduler：基于 JNDI 的调度器。 TimerManagerTaskScheduler：托管commonj.timers.TimerManager实例的调度器。 ThreadPoolTaskScheduler：提供线程池管理的调度器，它也实现了TaskExecutor接口，从而使的单一的实例可以尽可能快地异步执行。\n\n# Trigger 接口\n\nTrigger 接口抽象了触发条件的方法。 Trigger 接口的声明：\n\npublic interface Trigger {\n    Date nextExecutionTime(TriggerContext triggerContext);\n}\n\n\nTrigger 接口的实现类 CronTrigger：实现了 cron 规则的触发器类（和 Quartz 的 cron 规则相同）。 PeriodicTrigger：实现了一个周期性规则的触发器类（例如：定义触发起始时间、间隔时间等）。\n\n# 完整范例\n\n实现一个调度任务的功能有以下几个关键点： (1) 定义调度器 在 spring-bean.xml 中进行配置 使用task:scheduler标签定义一个大小为 10 的线程池调度器，spring 会实例化一个ThreadPoolTaskScheduler。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>\n\n\n注：不要忘记引入 xsd：\n\nhttp://www.springframework.org/schema/task\nhttp://www.springframework.org/schema/task/spring-task-3.1.xsd\n\n\n(2) 定义调度任务 定义实现Runnable接口的线程类。\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DemoTask implements Runnable {\n    final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public void run() {\n        logger.info("call DemoTask.run");\n    }\n}\n\n\n(3) 装配调度器，并执行调度任务 在一个Controller类中用@Autowired注解装配TaskScheduler。 然后调动 TaskScheduler 对象的 schedule 方法启动调度器，就可以执行调度任务了。\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.scheduling.TaskScheduler;\nimport org.springframework.scheduling.support.CronTrigger;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller\n@RequestMapping("/scheduler")\npublic class SchedulerController {\n    @Autowired\n    TaskScheduler scheduler;\n\n    @RequestMapping(value = "/start", method = RequestMethod.POST)\n    public void start() {\n        scheduler.schedule(new DemoTask(), new CronTrigger("0/5 * * * * *"));\n    }\n}\n\n\n访问/scheduler/start 接口，启动调度器，可以看到如下日志内容：\n\n13:53:15.010 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:20.003 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:25.004 myScheduler-2 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n13:53:30.005 myScheduler-1 o.zp.notes.spring.scheduler.DemoTask.run - call DemoTask.run\n\n\n\n# @Scheduler 的使用方法\n\nSpring 的调度器一个很大的亮点在于@Scheduler注解，这可以省去很多繁琐的配置。\n\n# 启动注解\n\n使用@Scheduler 注解先要使用<task:annotation-driven>启动注解开关。 例：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>\n  <task:executor id="myExecutor" pool-size="5"/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>\n\n\n# @Scheduler 定义触发条件\n\n例：使用fixedDelay指定触发条件为每 5000 毫秒执行一次。注意：必须在上一次调度成功后的 5000 秒才能执行。\n\n@Scheduled(fixedDelay=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}\n\n\n例：使用fixedRate指定触发条件为每 5000 毫秒执行一次。注意：无论上一次调度是否成功，5000 秒后必然执行。\n\n@Scheduled(fixedRate=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}\n\n\n例：使用initialDelay指定方法在初始化 1000 毫秒后才开始调度。\n\n@Scheduled(initialDelay=1000, fixedRate=5000)\npublic void doSomething() {\n    // something that should execute periodically\n}\n\n\n例：使用cron表达式指定触发条件为每 5000 毫秒执行一次。cron 规则和 Quartz 中的 cron 规则一致。\n\n@Scheduled(cron="*/5 * * * * MON-FRI")\npublic void doSomething() {\n    // something that should execute on weekdays only\n}\n\n\n# 完整范例\n\n(1) 启动注解开关，并定义调度器和执行器\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>\n  <task:executor id="myExecutor" pool-size="5"/>\n  <task:scheduler id="myScheduler" pool-size="10"/>\n</beans>\n\n\n(2) 使用@Scheduler 注解来修饰一个要调度的方法 下面的例子展示了@Scheduler 注解定义触发条件的不同方式。\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * @description 使用@Scheduler注解调度任务范例\n * @author Vicotr Zhang\n * @date 2016年8月31日\n */\n@Component\npublic class ScheduledMgr {\n    private final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n\n    final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 构造函数中打印初始化时间\n     */\n    public ScheduledMgr() {\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * fixedDelay属性定义调度间隔时间。调度需要等待上一次调度执行完成。\n     */\n    @Scheduled(fixedDelay = 5000)\n    public void testFixedDelay() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * fixedRate属性定义调度间隔时间。调度不等待上一次调度执行完成。\n     */\n    @Scheduled(fixedRate = 5000)\n    public void testFixedRate() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * initialDelay属性定义初始化后的启动延迟时间\n     */\n    @Scheduled(initialDelay = 1000, fixedRate = 5000)\n    public void testInitialDelay() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n\n    /**\n     * cron属性支持使用cron表达式定义触发条件\n     */\n    @Scheduled(cron = "0/5 * * * * ?")\n    public void testCron() throws Exception {\n        Thread.sleep(6000);\n        logger.info("Current time: {}", dateFormat.format(new Date()));\n    }\n}\n\n\n我刻意设置触发方式的间隔都是 5s，且方法中均有 Thread.sleep(6000);语句。从而确保方法在下一次调度触发时间点前无法完成执行，来看一看各种方式的表现吧。 启动 spring 项目后，spring 会扫描@Component注解，然后初始化 ScheduledMgr。 接着，spring 会扫描@Scheduler注解，初始化调度器。调度器在触发条件匹配的情况下开始工作，输出日志。 截取部分打印日志来进行分析。\n\n10:58:46.479 localhost-startStop-1 o.z.n.s.scheduler.ScheduledTasks.<init> - Current time: 2016-08-31 10:58:46\n10:58:52.523 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:58:52\n10:58:52.523 myScheduler-3 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:58:52\n10:58:53.524 myScheduler-2 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:58:53\n10:58:55.993 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:58:55\n10:58:58.507 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:58:58\n10:58:59.525 myScheduler-5 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:58:59\n10:59:03.536 myScheduler-3 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:59:03\n10:59:04.527 myScheduler-1 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:59:04\n10:59:05.527 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:59:05\n10:59:06.032 myScheduler-2 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:59:06\n10:59:10.534 myScheduler-9 o.z.n.s.scheduler.ScheduledTasks.testFixedRate - Current time: 2016-08-31 10:59:10\n10:59:11.527 myScheduler-10 o.z.n.s.scheduler.ScheduledTasks.testInitialDelay - Current time: 2016-08-31 10:59:11\n10:59:14.524 myScheduler-4 o.z.n.s.scheduler.ScheduledTasks.testFixedDelay - Current time: 2016-08-31 10:59:14\n10:59:15.987 myScheduler-6 o.z.n.s.scheduler.ScheduledTasks.testCron - Current time: 2016-08-31 10:59:15\n\n\n构造方法打印一次，时间点在 10:58:46。 testFixedRate 打印四次，每次间隔 6 秒。说明，fixedRate 不等待上一次调度执行完成，在间隔时间达到时立即执行。 testFixedDelay 打印三次，每次间隔大于 6 秒，且时间不固定。说明，fixedDelay 等待上一次调度执行成功后，开始计算间隔时间，再执行。 testInitialDelay 第一次调度时间和构造方法调度时间相隔 7 秒。说明，initialDelay 在初始化后等待指定的延迟时间才开始调度。 testCron 打印三次，时间间隔并非 5 秒或 6 秒，显然，cron 等待上一次调度执行成功后，开始计算间隔时间，再执行。 此外，可以从日志中看出，打印日志的线程最多只有 10 个，说明 2.1 中的调度器线程池配置生效。\n\n\n# 参考\n\nSpring Framework 官方文档',normalizedContent:'# spring 集成调度器\n\n\n# 概述\n\n如果想在 spring 中使用任务调度功能，除了集成调度框架 quartz 这种方式，也可以使用 spring 自己的调度任务框架。 使用 spring 的调度框架，优点是：支持注解@scheduler，可以省去大量的配置。\n\n\n# 实时触发调度任务\n\n\n# taskscheduler 接口\n\nspring3 引入了taskscheduler接口，这个接口定义了调度任务的抽象方法。 taskscheduler 接口的声明：\n\npublic interface taskscheduler {\n\n    scheduledfuture schedule(runnable task, trigger trigger);\n\n    scheduledfuture schedule(runnable task, date starttime);\n\n    scheduledfuture scheduleatfixedrate(runnable task, date starttime, long period);\n\n    scheduledfuture scheduleatfixedrate(runnable task, long period);\n\n    scheduledfuture schedulewithfixeddelay(runnable task, date starttime, long delay);\n\n    scheduledfuture schedulewithfixeddelay(runnable task, long delay);\n\n}\n\n\n从以上方法可以看出 taskscheduler 有两类重要参数：\n\n * 一个是要调度的方法，即一个实现了 runnable 接口的线程类的 run()方法；\n * 另一个就是触发条件。\n\ntaskscheduler 接口的实现类 它有三个实现类：defaultmanagedtaskscheduler、threadpooltaskscheduler、timermanagertaskscheduler。 defaultmanagedtaskscheduler：基于 jndi 的调度器。 timermanagertaskscheduler：托管commonj.timers.timermanager实例的调度器。 threadpooltaskscheduler：提供线程池管理的调度器，它也实现了taskexecutor接口，从而使的单一的实例可以尽可能快地异步执行。\n\n# trigger 接口\n\ntrigger 接口抽象了触发条件的方法。 trigger 接口的声明：\n\npublic interface trigger {\n    date nextexecutiontime(triggercontext triggercontext);\n}\n\n\ntrigger 接口的实现类 crontrigger：实现了 cron 规则的触发器类（和 quartz 的 cron 规则相同）。 periodictrigger：实现了一个周期性规则的触发器类（例如：定义触发起始时间、间隔时间等）。\n\n# 完整范例\n\n实现一个调度任务的功能有以下几个关键点： (1) 定义调度器 在 spring-bean.xml 中进行配置 使用task:scheduler标签定义一个大小为 10 的线程池调度器，spring 会实例化一个threadpooltaskscheduler。\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:scheduler id="myscheduler" pool-size="10"/>\n</beans>\n\n\n注：不要忘记引入 xsd：\n\nhttp://www.springframework.org/schema/task\nhttp://www.springframework.org/schema/task/spring-task-3.1.xsd\n\n\n(2) 定义调度任务 定义实现runnable接口的线程类。\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\n\npublic class demotask implements runnable {\n    final logger logger = loggerfactory.getlogger(this.getclass());\n\n    @override\n    public void run() {\n        logger.info("call demotask.run");\n    }\n}\n\n\n(3) 装配调度器，并执行调度任务 在一个controller类中用@autowired注解装配taskscheduler。 然后调动 taskscheduler 对象的 schedule 方法启动调度器，就可以执行调度任务了。\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.scheduling.taskscheduler;\nimport org.springframework.scheduling.support.crontrigger;\nimport org.springframework.stereotype.controller;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.requestmethod;\n\n@controller\n@requestmapping("/scheduler")\npublic class schedulercontroller {\n    @autowired\n    taskscheduler scheduler;\n\n    @requestmapping(value = "/start", method = requestmethod.post)\n    public void start() {\n        scheduler.schedule(new demotask(), new crontrigger("0/5 * * * * *"));\n    }\n}\n\n\n访问/scheduler/start 接口，启动调度器，可以看到如下日志内容：\n\n13:53:15.010 myscheduler-1 o.zp.notes.spring.scheduler.demotask.run - call demotask.run\n13:53:20.003 myscheduler-1 o.zp.notes.spring.scheduler.demotask.run - call demotask.run\n13:53:25.004 myscheduler-2 o.zp.notes.spring.scheduler.demotask.run - call demotask.run\n13:53:30.005 myscheduler-1 o.zp.notes.spring.scheduler.demotask.run - call demotask.run\n\n\n\n# @scheduler 的使用方法\n\nspring 的调度器一个很大的亮点在于@scheduler注解，这可以省去很多繁琐的配置。\n\n# 启动注解\n\n使用@scheduler 注解先要使用<task:annotation-driven>启动注解开关。 例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myexecutor" scheduler="myscheduler"/>\n  <task:executor id="myexecutor" pool-size="5"/>\n  <task:scheduler id="myscheduler" pool-size="10"/>\n</beans>\n\n\n# @scheduler 定义触发条件\n\n例：使用fixeddelay指定触发条件为每 5000 毫秒执行一次。注意：必须在上一次调度成功后的 5000 秒才能执行。\n\n@scheduled(fixeddelay=5000)\npublic void dosomething() {\n    // something that should execute periodically\n}\n\n\n例：使用fixedrate指定触发条件为每 5000 毫秒执行一次。注意：无论上一次调度是否成功，5000 秒后必然执行。\n\n@scheduled(fixedrate=5000)\npublic void dosomething() {\n    // something that should execute periodically\n}\n\n\n例：使用initialdelay指定方法在初始化 1000 毫秒后才开始调度。\n\n@scheduled(initialdelay=1000, fixedrate=5000)\npublic void dosomething() {\n    // something that should execute periodically\n}\n\n\n例：使用cron表达式指定触发条件为每 5000 毫秒执行一次。cron 规则和 quartz 中的 cron 规则一致。\n\n@scheduled(cron="*/5 * * * * mon-fri")\npublic void dosomething() {\n    // something that should execute on weekdays only\n}\n\n\n# 完整范例\n\n(1) 启动注解开关，并定义调度器和执行器\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:task="http://www.springframework.org/schema/task"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n       http://www.springframework.org/schema/task\n       http://www.springframework.org/schema/task/spring-task-3.1.xsd">\n\n  <mvc:annotation-driven/>\n  <task:annotation-driven executor="myexecutor" scheduler="myscheduler"/>\n  <task:executor id="myexecutor" pool-size="5"/>\n  <task:scheduler id="myscheduler" pool-size="10"/>\n</beans>\n\n\n(2) 使用@scheduler 注解来修饰一个要调度的方法 下面的例子展示了@scheduler 注解定义触发条件的不同方式。\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.scheduling.annotation.scheduled;\nimport org.springframework.stereotype.component;\n\nimport java.text.simpledateformat;\nimport java.util.date;\n\n/**\n * @description 使用@scheduler注解调度任务范例\n * @author vicotr zhang\n * @date 2016年8月31日\n */\n@component\npublic class scheduledmgr {\n    private final simpledateformat dateformat = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n\n    final logger logger = loggerfactory.getlogger(this.getclass());\n\n    /**\n     * 构造函数中打印初始化时间\n     */\n    public scheduledmgr() {\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n\n    /**\n     * fixeddelay属性定义调度间隔时间。调度需要等待上一次调度执行完成。\n     */\n    @scheduled(fixeddelay = 5000)\n    public void testfixeddelay() throws exception {\n        thread.sleep(6000);\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n\n    /**\n     * fixedrate属性定义调度间隔时间。调度不等待上一次调度执行完成。\n     */\n    @scheduled(fixedrate = 5000)\n    public void testfixedrate() throws exception {\n        thread.sleep(6000);\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n\n    /**\n     * initialdelay属性定义初始化后的启动延迟时间\n     */\n    @scheduled(initialdelay = 1000, fixedrate = 5000)\n    public void testinitialdelay() throws exception {\n        thread.sleep(6000);\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n\n    /**\n     * cron属性支持使用cron表达式定义触发条件\n     */\n    @scheduled(cron = "0/5 * * * * ?")\n    public void testcron() throws exception {\n        thread.sleep(6000);\n        logger.info("current time: {}", dateformat.format(new date()));\n    }\n}\n\n\n我刻意设置触发方式的间隔都是 5s，且方法中均有 thread.sleep(6000);语句。从而确保方法在下一次调度触发时间点前无法完成执行，来看一看各种方式的表现吧。 启动 spring 项目后，spring 会扫描@component注解，然后初始化 scheduledmgr。 接着，spring 会扫描@scheduler注解，初始化调度器。调度器在触发条件匹配的情况下开始工作，输出日志。 截取部分打印日志来进行分析。\n\n10:58:46.479 localhost-startstop-1 o.z.n.s.scheduler.scheduledtasks.<init> - current time: 2016-08-31 10:58:46\n10:58:52.523 myscheduler-1 o.z.n.s.scheduler.scheduledtasks.testfixedrate - current time: 2016-08-31 10:58:52\n10:58:52.523 myscheduler-3 o.z.n.s.scheduler.scheduledtasks.testfixeddelay - current time: 2016-08-31 10:58:52\n10:58:53.524 myscheduler-2 o.z.n.s.scheduler.scheduledtasks.testinitialdelay - current time: 2016-08-31 10:58:53\n10:58:55.993 myscheduler-4 o.z.n.s.scheduler.scheduledtasks.testcron - current time: 2016-08-31 10:58:55\n10:58:58.507 myscheduler-1 o.z.n.s.scheduler.scheduledtasks.testfixedrate - current time: 2016-08-31 10:58:58\n10:58:59.525 myscheduler-5 o.z.n.s.scheduler.scheduledtasks.testinitialdelay - current time: 2016-08-31 10:58:59\n10:59:03.536 myscheduler-3 o.z.n.s.scheduler.scheduledtasks.testfixeddelay - current time: 2016-08-31 10:59:03\n10:59:04.527 myscheduler-1 o.z.n.s.scheduler.scheduledtasks.testfixedrate - current time: 2016-08-31 10:59:04\n10:59:05.527 myscheduler-4 o.z.n.s.scheduler.scheduledtasks.testinitialdelay - current time: 2016-08-31 10:59:05\n10:59:06.032 myscheduler-2 o.z.n.s.scheduler.scheduledtasks.testcron - current time: 2016-08-31 10:59:06\n10:59:10.534 myscheduler-9 o.z.n.s.scheduler.scheduledtasks.testfixedrate - current time: 2016-08-31 10:59:10\n10:59:11.527 myscheduler-10 o.z.n.s.scheduler.scheduledtasks.testinitialdelay - current time: 2016-08-31 10:59:11\n10:59:14.524 myscheduler-4 o.z.n.s.scheduler.scheduledtasks.testfixeddelay - current time: 2016-08-31 10:59:14\n10:59:15.987 myscheduler-6 o.z.n.s.scheduler.scheduledtasks.testcron - current time: 2016-08-31 10:59:15\n\n\n构造方法打印一次，时间点在 10:58:46。 testfixedrate 打印四次，每次间隔 6 秒。说明，fixedrate 不等待上一次调度执行完成，在间隔时间达到时立即执行。 testfixeddelay 打印三次，每次间隔大于 6 秒，且时间不固定。说明，fixeddelay 等待上一次调度执行成功后，开始计算间隔时间，再执行。 testinitialdelay 第一次调度时间和构造方法调度时间相隔 7 秒。说明，initialdelay 在初始化后等待指定的延迟时间才开始调度。 testcron 打印三次，时间间隔并非 5 秒或 6 秒，显然，cron 等待上一次调度执行成功后，开始计算间隔时间，再执行。 此外，可以从日志中看出，打印日志的线程最多只有 10 个，说明 2.1 中的调度器线程池配置生效。\n\n\n# 参考\n\nspring framework 官方文档',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring集成Dubbo",frontmatter:{title:"Spring集成Dubbo",date:"2017-10-27T17:30:41.000Z",order:3,categories:["Java","框架","Spring","Spring集成"],tags:["Java","框架","Spring","集成","Dubbo"],permalink:"/pages/274fd7/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/05.Spring%E9%9B%86%E6%88%90/03.Spring%E9%9B%86%E6%88%90Dubbo.html",relativePath:"01.Java/13.框架/01.Spring/05.Spring集成/03.Spring集成Dubbo.md",key:"v-6078057e",path:"/pages/274fd7/",headers:[{level:2,title:"ZooKeeper",slug:"zookeeper",normalizedTitle:"zookeeper",charIndex:22},{level:2,title:"Dubbo",slug:"dubbo",normalizedTitle:"dubbo",charIndex:12},{level:2,title:"服务提供者",slug:"服务提供者",normalizedTitle:"服务提供者",charIndex:1347},{level:3,title:"定义服务接口",slug:"定义服务接口",normalizedTitle:"定义服务接口",charIndex:1377},{level:3,title:"在服务提供方实现接口",slug:"在服务提供方实现接口",normalizedTitle:"在服务提供方实现接口",charIndex:1511},{level:3,title:"用 Spring 配置声明暴露服务",slug:"用-spring-配置声明暴露服务",normalizedTitle:"用 spring 配置声明暴露服务",charIndex:1775},{level:3,title:"加载 Spring 配置",slug:"加载-spring-配置",normalizedTitle:"加载 spring 配置",charIndex:2841},{level:2,title:"服务消费者",slug:"服务消费者",normalizedTitle:"服务消费者",charIndex:3263},{level:3,title:"通过 Spring 配置引用远程服务",slug:"通过-spring-配置引用远程服务",normalizedTitle:"通过 spring 配置引用远程服务",charIndex:3293},{level:3,title:"加载 Spring 配置，并调用远程服务",slug:"加载-spring-配置-并调用远程服务",normalizedTitle:"加载 spring 配置，并调用远程服务",charIndex:4213},{level:2,title:"FAQ",slug:"faq",normalizedTitle:"faq",charIndex:4919},{level:2,title:"资料",slug:"资料",normalizedTitle:"资料",charIndex:4970}],headersStr:"ZooKeeper Dubbo 服务提供者 定义服务接口 在服务提供方实现接口 用 Spring 配置声明暴露服务 加载 Spring 配置 服务消费者 通过 Spring 配置引用远程服务 加载 Spring 配置，并调用远程服务 FAQ 资料",content:'# Spring 集成 Dubbo\n\n\n# ZooKeeper\n\nZooKeeper 可以作为 Dubbo 的注册中心。\n\nDubbo 未对 Zookeeper 服务器端做任何侵入修改，只需安装原生的 Zookeeper 服务器即可，所有注册中心逻辑适配都在调用 Zookeeper 客户端时完成。\n\n安装\n\n在 ZooKeeper 发布中心 选择需要的版本，下载后解压到本地。\n\n配置\n\nvi conf/zoo.cfg\n\n\n\n如果不需要集群，zoo.cfg 的内容如下 2：\n\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/home/dubbo/zookeeper-3.3.3/data\nclientPort=2181\n\n\n如果需要集群，zoo.cfg 的内容如下 3：\n\ntickTime=2000\ninitLimit=10\nsyncLimit=5\ndataDir=/home/dubbo/zookeeper-3.3.3/data\nclientPort=2181\nserver.1=10.20.153.10:2555:3555\nserver.2=10.20.153.11:2555:3555\n\n\n\n并在 data 目录 4 下放置 myid 文件：\n\nmkdir data\nvi myid\n\n\n\nmyid 指明自己的 id，对应上面 zoo.cfg 中 server. 后的数字，第一台的内容为 1，第二台的内容为 2，内容如下：\n\n1\n\n\n\n启动\n\nLinux 下执行 bin/zkServer.sh ；Windows bin/zkServer.cmd 启动 ZooKeeper 。\n\n命令行\n\ntelnet 127.0.0.1 2181\ndump\n\n\n或者:\n\necho dump | nc 127.0.0.1 2181\n\n\n用法:\n\ndubbo.registry.address=zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181\n\n\n\n或者:\n\n<dubbo:registry protocol="zookeeper" address="10.20.153.10:2181,10.20.153.11:2181" />\n\n\n\n>  1. Zookeeper 是 Apache Hadoop 的子项目，强度相对较好，建议生产环境使用该注册中心\n>  2. 其中 data 目录需改成你真实输出目录\n>  3. 其中 data 目录和 server 地址需改成你真实部署机器的信息\n>  4. 上面 zoo.cfg 中的 dataDir\n>  5. http://zookeeper.apache.org/doc/r3.3.3/zookeeperAdmin.html\n\n\n# Dubbo\n\nDubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展进行加载。\n\n如果不想使用 Spring 配置，可以通过 API 的方式 进行调用。\n\n\n# 服务提供者\n\n完整安装步骤，请参见：示例提供者安装\n\n\n# 定义服务接口\n\nDemoService.java 1：\n\npackage com.alibaba.dubbo.demo;\n\npublic interface DemoService {\n    String sayHello(String name);\n}\n\n\n\n# 在服务提供方实现接口\n\nDemoServiceImpl.java 2：\n\npackage com.alibaba.dubbo.demo.provider;\n\nimport com.alibaba.dubbo.demo.DemoService;\n\npublic class DemoServiceImpl implements DemoService {\n    public String sayHello(String name) {\n        return "Hello " + name;\n    }\n}\n\n\n\n# 用 Spring 配置声明暴露服务\n\nprovider.xml：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 提供方应用信息，用于计算依赖关系 --\x3e\n    <dubbo:application name="hello-world-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 用dubbo协议在20880端口暴露服务 --\x3e\n    <dubbo:protocol name="dubbo" port="20880" />\n\n    \x3c!-- 声明需要暴露的服务接口 --\x3e\n    <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" />\n\n    \x3c!-- 和本地bean一样实现服务 --\x3e\n    <bean id="demoService" class="com.alibaba.dubbo.demo.provider.DemoServiceImpl" />\n</beans>\n\n\n如果注册中心使用 ZooKeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n\n# 加载 Spring 配置\n\nProvider.java：\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Provider {\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"http://10.20.160.198/wiki/display/dubbo/provider.xml"});\n        context.start();\n        System.in.read(); // 按任意键退出\n    }\n}\n\n\n\n# 服务消费者\n\n完整安装步骤，请参见：示例消费者安装\n\n\n# 通过 Spring 配置引用远程服务\n\nconsumer.xml：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --\x3e\n    <dubbo:application name="consumer-of-helloworld-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露发现服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 生成远程服务代理，可以和本地bean一样使用demoService --\x3e\n    <dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService" />\n</beans>\n\n\n如果注册中心使用 ZooKeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n\n# 加载 Spring 配置，并调用远程服务\n\nConsumer.java 3：\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport com.alibaba.dubbo.demo.DemoService;\n\npublic class Consumer {\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"http://10.20.160.198/wiki/display/dubbo/consumer.xml"});\n        context.start();\n        DemoService demoService = (DemoService)context.getBean("demoService"); // 获取远程服务代理\n        String hello = demoService.sayHello("world"); // 执行远程方法\n        System.out.println( hello ); // 显示调用结果\n    }\n}\n\n\n>  1. 该接口需单独打包，在服务提供方和消费方共享\n>  2. 对服务消费方隐藏实现\n>  3. 也可以使用 IoC 注入\n\n\n# FAQ\n\n建议使用 dubbo-2.3.3 以上版本的 zookeeper 注册中心客户端。\n\n\n# 资料\n\nDubbo\n\nGithub | 用户手册 | 开发手册 | 管理员手册\n\nZooKeeper\n\n官网 | 官方文档',normalizedContent:'# spring 集成 dubbo\n\n\n# zookeeper\n\nzookeeper 可以作为 dubbo 的注册中心。\n\ndubbo 未对 zookeeper 服务器端做任何侵入修改，只需安装原生的 zookeeper 服务器即可，所有注册中心逻辑适配都在调用 zookeeper 客户端时完成。\n\n安装\n\n在 zookeeper 发布中心 选择需要的版本，下载后解压到本地。\n\n配置\n\nvi conf/zoo.cfg\n\n\n\n如果不需要集群，zoo.cfg 的内容如下 2：\n\nticktime=2000\ninitlimit=10\nsynclimit=5\ndatadir=/home/dubbo/zookeeper-3.3.3/data\nclientport=2181\n\n\n如果需要集群，zoo.cfg 的内容如下 3：\n\nticktime=2000\ninitlimit=10\nsynclimit=5\ndatadir=/home/dubbo/zookeeper-3.3.3/data\nclientport=2181\nserver.1=10.20.153.10:2555:3555\nserver.2=10.20.153.11:2555:3555\n\n\n\n并在 data 目录 4 下放置 myid 文件：\n\nmkdir data\nvi myid\n\n\n\nmyid 指明自己的 id，对应上面 zoo.cfg 中 server. 后的数字，第一台的内容为 1，第二台的内容为 2，内容如下：\n\n1\n\n\n\n启动\n\nlinux 下执行 bin/zkserver.sh ；windows bin/zkserver.cmd 启动 zookeeper 。\n\n命令行\n\ntelnet 127.0.0.1 2181\ndump\n\n\n或者:\n\necho dump | nc 127.0.0.1 2181\n\n\n用法:\n\ndubbo.registry.address=zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181\n\n\n\n或者:\n\n<dubbo:registry protocol="zookeeper" address="10.20.153.10:2181,10.20.153.11:2181" />\n\n\n\n>  1. zookeeper 是 apache hadoop 的子项目，强度相对较好，建议生产环境使用该注册中心\n>  2. 其中 data 目录需改成你真实输出目录\n>  3. 其中 data 目录和 server 地址需改成你真实部署机器的信息\n>  4. 上面 zoo.cfg 中的 datadir\n>  5. http://zookeeper.apache.org/doc/r3.3.3/zookeeperadmin.html\n\n\n# dubbo\n\ndubbo 采用全 spring 配置方式，透明化接入应用，对应用没有任何 api 侵入，只需用 spring 加载 dubbo 的配置即可，dubbo 基于 spring 的 schema 扩展进行加载。\n\n如果不想使用 spring 配置，可以通过 api 的方式 进行调用。\n\n\n# 服务提供者\n\n完整安装步骤，请参见：示例提供者安装\n\n\n# 定义服务接口\n\ndemoservice.java 1：\n\npackage com.alibaba.dubbo.demo;\n\npublic interface demoservice {\n    string sayhello(string name);\n}\n\n\n\n# 在服务提供方实现接口\n\ndemoserviceimpl.java 2：\n\npackage com.alibaba.dubbo.demo.provider;\n\nimport com.alibaba.dubbo.demo.demoservice;\n\npublic class demoserviceimpl implements demoservice {\n    public string sayhello(string name) {\n        return "hello " + name;\n    }\n}\n\n\n\n# 用 spring 配置声明暴露服务\n\nprovider.xml：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemalocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 提供方应用信息，用于计算依赖关系 --\x3e\n    <dubbo:application name="hello-world-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 用dubbo协议在20880端口暴露服务 --\x3e\n    <dubbo:protocol name="dubbo" port="20880" />\n\n    \x3c!-- 声明需要暴露的服务接口 --\x3e\n    <dubbo:service interface="com.alibaba.dubbo.demo.demoservice" ref="demoservice" />\n\n    \x3c!-- 和本地bean一样实现服务 --\x3e\n    <bean id="demoservice" class="com.alibaba.dubbo.demo.provider.demoserviceimpl" />\n</beans>\n\n\n如果注册中心使用 zookeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n\n# 加载 spring 配置\n\nprovider.java：\n\nimport org.springframework.context.support.classpathxmlapplicationcontext;\n\npublic class provider {\n    public static void main(string[] args) throws exception {\n        classpathxmlapplicationcontext context = new classpathxmlapplicationcontext(new string[] {"http://10.20.160.198/wiki/display/dubbo/provider.xml"});\n        context.start();\n        system.in.read(); // 按任意键退出\n    }\n}\n\n\n\n# 服务消费者\n\n完整安装步骤，请参见：示例消费者安装\n\n\n# 通过 spring 配置引用远程服务\n\nconsumer.xml：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n    xsi:schemalocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd">\n\n    \x3c!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --\x3e\n    <dubbo:application name="consumer-of-helloworld-app"  />\n\n    \x3c!-- 使用multicast广播注册中心暴露发现服务地址 --\x3e\n    <dubbo:registry address="multicast://224.5.6.7:1234" />\n\n    \x3c!-- 生成远程服务代理，可以和本地bean一样使用demoservice --\x3e\n    <dubbo:reference id="demoservice" interface="com.alibaba.dubbo.demo.demoservice" />\n</beans>\n\n\n如果注册中心使用 zookeeper，可以将 dubbo:registry 改为 zookeeper://127.0.0.1:2181\n\n\n# 加载 spring 配置，并调用远程服务\n\nconsumer.java 3：\n\nimport org.springframework.context.support.classpathxmlapplicationcontext;\nimport com.alibaba.dubbo.demo.demoservice;\n\npublic class consumer {\n    public static void main(string[] args) throws exception {\n        classpathxmlapplicationcontext context = new classpathxmlapplicationcontext(new string[] {"http://10.20.160.198/wiki/display/dubbo/consumer.xml"});\n        context.start();\n        demoservice demoservice = (demoservice)context.getbean("demoservice"); // 获取远程服务代理\n        string hello = demoservice.sayhello("world"); // 执行远程方法\n        system.out.println( hello ); // 显示调用结果\n    }\n}\n\n\n>  1. 该接口需单独打包，在服务提供方和消费方共享\n>  2. 对服务消费方隐藏实现\n>  3. 也可以使用 ioc 注入\n\n\n# faq\n\n建议使用 dubbo-2.3.3 以上版本的 zookeeper 注册中心客户端。\n\n\n# 资料\n\ndubbo\n\ngithub | 用户手册 | 开发手册 | 管理员手册\n\nzookeeper\n\n官网 | 官方文档',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 之安全快速入门",frontmatter:{title:"SpringBoot 之安全快速入门",date:"2021-05-13T18:21:56.000Z",order:1,categories:["Java","框架","Spring","Spring安全"],tags:["Java","框架","Spring","SpringBoot","安全"],permalink:"/pages/568352/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/10.Spring%E5%AE%89%E5%85%A8/01.SpringBoot%E4%B9%8B%E5%AE%89%E5%85%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"01.Java/13.框架/01.Spring/10.Spring安全/01.SpringBoot之安全快速入门.md",key:"v-a6563758",path:"/pages/568352/",headers:[{level:2,title:"QuickStart",slug:"quickstart",normalizedTitle:"quickstart",charIndex:25}],headersStr:"QuickStart",content:"# SpringBoot 之安全快速入门\n\n\n# QuickStart\n\n（1）添加依赖\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-security</artifactId>\n\t\t</dependency>\n\n\n（2）添加配置\n\nspring.security.user.name = root\nspring.security.user.password = root\nspring.security.user.roles = USER\n\n\n（3）启动应用后，访问任意路径，都会出现以下页面，提示你先执行登录操作。输入配置的用户名、密码（root/root）即可访问应用页面。\n\n",normalizedContent:"# springboot 之安全快速入门\n\n\n# quickstart\n\n（1）添加依赖\n\n\t\t<dependency>\n\t\t\t<groupid>org.springframework.boot</groupid>\n\t\t\t<artifactid>spring-boot-starter-web</artifactid>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupid>org.springframework.boot</groupid>\n\t\t\t<artifactid>spring-boot-starter-security</artifactid>\n\t\t</dependency>\n\n\n（2）添加配置\n\nspring.security.user.name = root\nspring.security.user.password = root\nspring.security.user.roles = user\n\n\n（3）启动应用后，访问任意路径，都会出现以下页面，提示你先执行登录操作。输入配置的用户名、密码（root/root）即可访问应用页面。\n\n",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 4 升级踩雷指南",frontmatter:{title:"Spring 4 升级踩雷指南",date:"2017-12-15T15:10:32.000Z",order:1,categories:["Java","框架","Spring","Spring其他"],tags:["Java","框架","Spring"],permalink:"/pages/752c6a/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/99.Spring%E5%85%B6%E4%BB%96/01.Spring4%E5%8D%87%E7%BA%A7.html",relativePath:"01.Java/13.框架/01.Spring/99.Spring其他/01.Spring4升级.md",key:"v-2541fab0",path:"/pages/752c6a/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:22},{level:2,title:"为什么升级 spring4",slug:"为什么升级-spring4",normalizedTitle:"为什么升级 spring4",charIndex:186},{level:2,title:"spring 4 重要新特性",slug:"spring-4-重要新特性",normalizedTitle:"spring 4 重要新特性",charIndex:471},{level:2,title:"升级 spring 4 步骤",slug:"升级-spring-4-步骤",normalizedTitle:"升级 spring 4 步骤",charIndex:873},{level:3,title:"修改 spring 版本",slug:"修改-spring-版本",normalizedTitle:"修改 spring 版本",charIndex:1090},{level:3,title:"修改 spring xml 文件的 xsd",slug:"修改-spring-xml-文件的-xsd",normalizedTitle:"修改 spring xml 文件的 xsd",charIndex:1435},{level:3,title:"修改 spring xml 文件",slug:"修改-spring-xml-文件",normalizedTitle:"修改 spring xml 文件",charIndex:1435},{level:4,title:"ref local",slug:"ref-local",normalizedTitle:"ref local",charIndex:3727},{level:3,title:"加入 spring support",slug:"加入-spring-support",normalizedTitle:"加入 spring support",charIndex:4390},{level:3,title:"更换 spring-mvc jackson",slug:"更换-spring-mvc-jackson",normalizedTitle:"更换 spring-mvc jackson",charIndex:4653},{level:3,title:"解决 ibatis 兼容问题",slug:"解决-ibatis-兼容问题",normalizedTitle:"解决 ibatis 兼容问题",charIndex:5669},{level:3,title:"升级 Dubbo",slug:"升级-dubbo",normalizedTitle:"升级 dubbo",charIndex:6055},{level:3,title:"升级 Jedis",slug:"升级-jedis",normalizedTitle:"升级 jedis",charIndex:6767},{level:2,title:"资料",slug:"资料",normalizedTitle:"资料",charIndex:8114}],headersStr:"前言 为什么升级 spring4 spring 4 重要新特性 升级 spring 4 步骤 修改 spring 版本 修改 spring xml 文件的 xsd 修改 spring xml 文件 ref local 加入 spring support 更换 spring-mvc jackson 解决 ibatis 兼容问题 升级 Dubbo 升级 Jedis 资料",content:'# Spring 4 升级踩雷指南\n\n\n# 前言\n\n最近，一直在为公司老项目做核心库升级工作。本来只是想升级一下 JDK8 ，却因为兼容性问题而不得不升级一些其他的库，而其他库本身依赖的一些库可能也要同步升级。这是一系列连锁问题，你很难一一识别，往往只有在编译时、运行时才能发现问题。\n\n总之，这是个费劲的活啊。\n\n本文小结一下升级 Spring4 的连锁问题。\n\n\n# 为什么升级 spring4\n\n升级 Spring4 的原因是：Spring 4 以前的版本不兼容 JDK8。当你的项目同时使用 Spring3 和 JDK8，如果代码中有使用 JDK8 字节码或 Lambada 表达式，那么会出问题。\n\n也许你会问，为什么不使用最新的 Spring 5 呢？因为作为企业软件，一般更倾向使用稳定的版本（bug 少），而不是最新的版本，尤其是一些核心库。\n\n更多细节可以参考：\n\nhttps://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n\n\n# spring 4 重要新特性\n\nSpring 4 相比 Spring 3，引入许多新特性，这里列举几条较为重要的：\n\n 1. 支持 JDK8 （这个是最主要的）。\n 2. Groovy Bean Definition DSL 风格配置。\n 3. 支持 WebSocket、SockJS、STOMP 消息\n 4. 移除 Deprecated 包和方法\n 5. 一些功能加强，如：核心容器、Web、Test 等等，不一一列举。\n\n更多 Spring 4 新特性可以参考：\n\nhttps://docs.spring.io/spring/docs/4.3.14.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#spring-whats-new\n\nhttp://jinnianshilongnian.iteye.com/blog/1995111\n\n\n# 升级 spring 4 步骤\n\n了解了前面内容，我们知道了升级 Spring 4 带来的好处。现在开始真刀真枪的升级了。\n\n不要以为升级一下 Spring 4，仅仅是改一下版本号，那么简单，细节处多着呢。\n\n下面，结合我在公司项目升级 Spring4 时遇到的一系列坑，希望能帮助各位少走弯路。\n\n> 注\n> \n> 下文内容基于假设你的项目是用 maven 管理这一前提。如果不满足这一前提，那么这篇文章对你没什么太大帮助。\n\n\n# 修改 spring 版本\n\n第一步，当然是修改 pom.xml 中的 spring 版本。\n\n3.x.x.RELEASE > 4.x.x.RELEASE\n\n实例：升级 spring-core\n\n其它 spring 库的升级也如此：\n\n<properties>\n  <spring.version>4.3.13.RELEASE</spring.version>\n</properties>\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-core</artifactId>\n  <version>${spring.version}</version>\n</dependency>\n\n\n\n# 修改 spring xml 文件的 xsd\n\n用过 spring 的都知道，spring 通常依赖于大量的 xml 配置。\n\nspring 的 xml 解析器在解析 xml 时，需要读取 xml schema，schema 定义了 xml 的命名空间。它的好处在于可以避免命名冲突，有点像 Java 中的 package。\n\n实例：一个 spring xml 的 schema\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:context="http://www.springframework.org/schema/context"\n\txmlns:mvc="http://www.springframework.org/schema/mvc"\n\txsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">\n\n\n> 说明\n> \n>  * xmlns="http://www.springframework.org/schema/beans" 声明 xml 文件默认的命名空间，表示未使用其他命名空间的所有标签的默认命名空间。\n> \n>  * xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 声明 XML Schema 实例，声明后就可以使用 schemaLocation 属性了。\n> \n>  * xmlns:mvc="http://www.springframework.org/schema/mvc" 声明前缀为 mvc 的命名空间，后面的 URL 用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。 其它的类似 xmlns:context 、xmlns:jdbc 等等同样如此。\n> \n>  * xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n>    ..."\n>    \n>    \n>    这个从命名可以看出个大概，指定 schema 位置这个属性必须结合命名空间使用。这个属性有两个值，第一个值表示需要使用的命名空间。第二个值表示供命名空间使用的 xml schema 的位置。\n\n上面示例中的 xsd 版本是 3.1.xsd ，表示 spring 的 xml 解析器会将其视为 3.1 版本的 xml 文件来处理。\n\n现在，我们使用了 Spring 4，3.1.xsd 版本显然就不正确了，我们可以根据自己引入的 Spring 4 的子版本号将其改为 4.x.xsd 。\n\n但是，还有一种更好的做法：把这个指定 xsd 版本的关键字干掉，类似这样：http://www.springframework.org/schema/tx/spring-tx.xsd 。\n\n这么做的原因如下：\n\n * Spring 默认在启动时要加载 xsd 文件来验证 xml 文件。\n * 如果没有提供 schemaLocation，那么 spring 的 xml 解析器会从 namespace 的 uri 里加载 xsd 文件。\n * schemaLocation 提供了一个 xml namespace 到对应的 xsd 文件的一个映射。\n * 如果不指定 spring xsd 的版本号，spring 取的就是当前本地 jar 里的 xsd 文件，减少了各种风险（比如 xsd 与实际 spring jar 版本不一致）。\n\n更多详细内容可以参考这篇文章：为什么在 Spring 的配置里，最好不要配置 xsd 文件的版本号\n\n\n# 修改 spring xml 文件\n\nspring 4 对 xml 做了一些改动。这里说一个最常用的改动：\n\n# ref local\n\nspring 不再支持 ref 元素的 local 属性，如果你的项目中使用了，需要改为 bean。\n\nshi\n\nspring 4 以前：\n\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource">\n    <ref local="dataSource" />\n  </property>\n</bean>\n\n\nspring 4 以后：\n\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n  <property name="dataSource">\n    <ref bean="dataSource" />\n  </property>\n</bean>\n\n\n如果不改启动会报错：\n\nCaused by: org.xml.sax.SAXParseException: cvc-complex-type.3.2.2: Attribute \'local\' is not allowed to appear in element \'ref\'.\n\n\n当然，可能还有一些其他配置改动，这个只能说兵来将挡水来土掩，遇到了再去查官方文档吧。\n\n\n# 加入 spring support\n\nspring 3 中很多的扩展内容不需要引入 support 。但是 spring 4 中分离的更彻底了，如果不分离，会有很多ClassNotFound 。\n\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n    <version>4.2.3.RELEASE</version>\n</dependency>\n\n\n\n# 更换 spring-mvc jackson\n\nspring mvc 中如果返回结果为 json 需要依赖 jackson 的 jar 包，但是他升级到了 2, 以前是 codehaus.jackson，现在换成了 fasterxml.jackson\n\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n    <version>2.7.0</version>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.7.0</version>\n</dependency>\n\n\n同时修改 spring mvc 的配置文件：\n\n<bean\n\tclass="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">\n\t<property name="messageConverters">\n\t\t<list>\n\t\t\t <ref bean="stringHttpMessageConverter" />\n\t\t\t<bean\n\t\t\t\tclass="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">\n\t\t\t</bean>\n\t\t</list>\n\t</property>\n</bean>\n\n<bean id="stringHttpMessageConverter"\n\tclass="org.springframework.http.converter.StringHttpMessageConverter">\n\t<property name="supportedMediaTypes">\n\t\t<list>\n\t\t\t<value>text/plain;charset=UTF-8</value>\n\t\t</list>\n\t</property>\n</bean>\n\n\n\n# 解决 ibatis 兼容问题\n\n问题\n\n如果你的项目中使用了 ibatis (mybatis 的前身)这个 orm 框架，当 spring3 升级 spring4 后，会出现兼容性问题，编译都不能通过。\n\n这是因为 Spring4 官方已经不再支持 ibatis。\n\n解决方案\n\n添加兼容性 jar 包\n\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-2-spring</artifactId>\n    <version>1.0.1</version>\n</dependency>\n\n\n更多内容可参考：https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0\n\n\n# 升级 Dubbo\n\n我们的项目中使用了 soa 框架 Dubbo 。由于 Dubbo 是老版本的，具体来说是（2013 年的 2.4.10），而老版本中使用的 spirng 版本为 2.x，有兼容性问题。\n\nDubbo 项目从今年开始恢复维护了，首先把一些落后的库升级到较新版本，比如 jdk8，spring4 等，并修复了一些 bug。所以，我们可以通过升级一下 Dubbo 版本来解决问题。\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>dubbo</artifactId>\n  <version>2.5.8</version>\n  <exclusions>\n    <exclusion>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n    </exclusion>\n    <exclusion>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-web</artifactId>\n    </exclusion>\n    <exclusion>\n      <groupId>org.javassist</groupId>\n      <artifactId>javassist</artifactId>\n    </exclusion>\n  </exclusions>\n</dependency>\n\n\n\n# 升级 Jedis\n\n升级 Dubbo 为当前最新的 2.5.8 版本后，运行时报错：\n\n * JedisPoolConfig 配置错误\n\nCaused by: java.lang.ClassNotFoundException: org.apache.commons.pool2.impl.GenericObjectPoolConfig\n\n\n由于项目中使用了 redis，版本为 2.0.0 ，这个问题是由于 jedis 需要升级：\n\n<dependency>\n  <groupId>redis.clients</groupId>\n  <artifactId>jedis</artifactId>\n  <version>2.9.0</version>\n</dependency>\n\n\njedis 2.4.1 以上版本的 JedisPoolConfig 已经没有了maxActive 和 maxWait 属性。\n\n修改方法如下：\n\nmaxActive > maxTotal\n\nmaxWait > maxWaitMillis\n\n<bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">\n  <property name="maxTotal" value="200" />\n  <property name="maxIdle" value="10" />\n  <property name="maxWaitMillis" value="1000" />\n  <property name="testOnBorrow" value="true" />\n</bean>\n\n\nJedisPool 配置错误\n\nInvalidURIException: Cannot open Redis connection due invalid URI\n\n\n原来的配置如下：\n\n<bean id="jedisPool" class="redis.clients.jedis.JedisPool" destroy-method="destroy" depends-on="jedisPoolConfig">\n  <constructor-arg ref="jedisPoolConfig" />\n  <constructor-arg type="java.lang.String" value="${redis.host}" />\n  <constructor-arg type="int" value="${redis.port}" />\n</bean>\n\n\n查看源码可以发现，初始化 JedisPool 时未指定结构方法参数的类型，导致 host 字符串值被视为 URI 类型，当然类型不匹配。\n\n解决方法是修改上面的 host 配置，为：<constructor-arg type="java.lang.String" value="${redis.host}" />\n\n----------------------------------------\n\n至此，spring 4 升级结束。后面如果遇到其他升级问题再补充。\n\n\n# 资料\n\n * https://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n * https://docs.spring.io/spring/docs/4.3.14.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#spring-whats-new\n * Spring 3.x 升级到 Spring 4.x 注意事项和步骤，错误解决方法\n * http://jinnianshilongnian.iteye.com/blog/1995111\n * 为什么在 Spring 的配置里，最好不要配置 xsd 文件的版本号\n * https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0',normalizedContent:'# spring 4 升级踩雷指南\n\n\n# 前言\n\n最近，一直在为公司老项目做核心库升级工作。本来只是想升级一下 jdk8 ，却因为兼容性问题而不得不升级一些其他的库，而其他库本身依赖的一些库可能也要同步升级。这是一系列连锁问题，你很难一一识别，往往只有在编译时、运行时才能发现问题。\n\n总之，这是个费劲的活啊。\n\n本文小结一下升级 spring4 的连锁问题。\n\n\n# 为什么升级 spring4\n\n升级 spring4 的原因是：spring 4 以前的版本不兼容 jdk8。当你的项目同时使用 spring3 和 jdk8，如果代码中有使用 jdk8 字节码或 lambada 表达式，那么会出问题。\n\n也许你会问，为什么不使用最新的 spring 5 呢？因为作为企业软件，一般更倾向使用稳定的版本（bug 少），而不是最新的版本，尤其是一些核心库。\n\n更多细节可以参考：\n\nhttps://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n\n\n# spring 4 重要新特性\n\nspring 4 相比 spring 3，引入许多新特性，这里列举几条较为重要的：\n\n 1. 支持 jdk8 （这个是最主要的）。\n 2. groovy bean definition dsl 风格配置。\n 3. 支持 websocket、sockjs、stomp 消息\n 4. 移除 deprecated 包和方法\n 5. 一些功能加强，如：核心容器、web、test 等等，不一一列举。\n\n更多 spring 4 新特性可以参考：\n\nhttps://docs.spring.io/spring/docs/4.3.14.build-snapshot/spring-framework-reference/htmlsingle/#spring-whats-new\n\nhttp://jinnianshilongnian.iteye.com/blog/1995111\n\n\n# 升级 spring 4 步骤\n\n了解了前面内容，我们知道了升级 spring 4 带来的好处。现在开始真刀真枪的升级了。\n\n不要以为升级一下 spring 4，仅仅是改一下版本号，那么简单，细节处多着呢。\n\n下面，结合我在公司项目升级 spring4 时遇到的一系列坑，希望能帮助各位少走弯路。\n\n> 注\n> \n> 下文内容基于假设你的项目是用 maven 管理这一前提。如果不满足这一前提，那么这篇文章对你没什么太大帮助。\n\n\n# 修改 spring 版本\n\n第一步，当然是修改 pom.xml 中的 spring 版本。\n\n3.x.x.release > 4.x.x.release\n\n实例：升级 spring-core\n\n其它 spring 库的升级也如此：\n\n<properties>\n  <spring.version>4.3.13.release</spring.version>\n</properties>\n<dependency>\n  <groupid>org.springframework</groupid>\n  <artifactid>spring-core</artifactid>\n  <version>${spring.version}</version>\n</dependency>\n\n\n\n# 修改 spring xml 文件的 xsd\n\n用过 spring 的都知道，spring 通常依赖于大量的 xml 配置。\n\nspring 的 xml 解析器在解析 xml 时，需要读取 xml schema，schema 定义了 xml 的命名空间。它的好处在于可以避免命名冲突，有点像 java 中的 package。\n\n实例：一个 spring xml 的 schema\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance" xmlns:util="http://www.springframework.org/schema/util" xmlns:context="http://www.springframework.org/schema/context"\n\txmlns:mvc="http://www.springframework.org/schema/mvc"\n\txsi:schemalocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\n\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">\n\n\n> 说明\n> \n>  * xmlns="http://www.springframework.org/schema/beans" 声明 xml 文件默认的命名空间，表示未使用其他命名空间的所有标签的默认命名空间。\n> \n>  * xmlns:xsi="http://www.w3.org/2001/xmlschema-instance" 声明 xml schema 实例，声明后就可以使用 schemalocation 属性了。\n> \n>  * xmlns:mvc="http://www.springframework.org/schema/mvc" 声明前缀为 mvc 的命名空间，后面的 url 用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。 其它的类似 xmlns:context 、xmlns:jdbc 等等同样如此。\n> \n>  * xsi:schemalocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\n>    ..."\n>    \n>    \n>    这个从命名可以看出个大概，指定 schema 位置这个属性必须结合命名空间使用。这个属性有两个值，第一个值表示需要使用的命名空间。第二个值表示供命名空间使用的 xml schema 的位置。\n\n上面示例中的 xsd 版本是 3.1.xsd ，表示 spring 的 xml 解析器会将其视为 3.1 版本的 xml 文件来处理。\n\n现在，我们使用了 spring 4，3.1.xsd 版本显然就不正确了，我们可以根据自己引入的 spring 4 的子版本号将其改为 4.x.xsd 。\n\n但是，还有一种更好的做法：把这个指定 xsd 版本的关键字干掉，类似这样：http://www.springframework.org/schema/tx/spring-tx.xsd 。\n\n这么做的原因如下：\n\n * spring 默认在启动时要加载 xsd 文件来验证 xml 文件。\n * 如果没有提供 schemalocation，那么 spring 的 xml 解析器会从 namespace 的 uri 里加载 xsd 文件。\n * schemalocation 提供了一个 xml namespace 到对应的 xsd 文件的一个映射。\n * 如果不指定 spring xsd 的版本号，spring 取的就是当前本地 jar 里的 xsd 文件，减少了各种风险（比如 xsd 与实际 spring jar 版本不一致）。\n\n更多详细内容可以参考这篇文章：为什么在 spring 的配置里，最好不要配置 xsd 文件的版本号\n\n\n# 修改 spring xml 文件\n\nspring 4 对 xml 做了一些改动。这里说一个最常用的改动：\n\n# ref local\n\nspring 不再支持 ref 元素的 local 属性，如果你的项目中使用了，需要改为 bean。\n\nshi\n\nspring 4 以前：\n\n<bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n  <property name="datasource">\n    <ref local="datasource" />\n  </property>\n</bean>\n\n\nspring 4 以后：\n\n<bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n  <property name="datasource">\n    <ref bean="datasource" />\n  </property>\n</bean>\n\n\n如果不改启动会报错：\n\ncaused by: org.xml.sax.saxparseexception: cvc-complex-type.3.2.2: attribute \'local\' is not allowed to appear in element \'ref\'.\n\n\n当然，可能还有一些其他配置改动，这个只能说兵来将挡水来土掩，遇到了再去查官方文档吧。\n\n\n# 加入 spring support\n\nspring 3 中很多的扩展内容不需要引入 support 。但是 spring 4 中分离的更彻底了，如果不分离，会有很多classnotfound 。\n\n<dependency>\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-context-support</artifactid>\n    <version>4.2.3.release</version>\n</dependency>\n\n\n\n# 更换 spring-mvc jackson\n\nspring mvc 中如果返回结果为 json 需要依赖 jackson 的 jar 包，但是他升级到了 2, 以前是 codehaus.jackson，现在换成了 fasterxml.jackson\n\n<dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-core</artifactid>\n    <version>2.7.0</version>\n</dependency>\n<dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-databind</artifactid>\n    <version>2.7.0</version>\n</dependency>\n\n\n同时修改 spring mvc 的配置文件：\n\n<bean\n\tclass="org.springframework.web.servlet.mvc.annotation.annotationmethodhandleradapter">\n\t<property name="messageconverters">\n\t\t<list>\n\t\t\t <ref bean="stringhttpmessageconverter" />\n\t\t\t<bean\n\t\t\t\tclass="org.springframework.http.converter.json.mappingjackson2httpmessageconverter">\n\t\t\t</bean>\n\t\t</list>\n\t</property>\n</bean>\n\n<bean id="stringhttpmessageconverter"\n\tclass="org.springframework.http.converter.stringhttpmessageconverter">\n\t<property name="supportedmediatypes">\n\t\t<list>\n\t\t\t<value>text/plain;charset=utf-8</value>\n\t\t</list>\n\t</property>\n</bean>\n\n\n\n# 解决 ibatis 兼容问题\n\n问题\n\n如果你的项目中使用了 ibatis (mybatis 的前身)这个 orm 框架，当 spring3 升级 spring4 后，会出现兼容性问题，编译都不能通过。\n\n这是因为 spring4 官方已经不再支持 ibatis。\n\n解决方案\n\n添加兼容性 jar 包\n\n<dependency>\n    <groupid>org.mybatis</groupid>\n    <artifactid>mybatis-2-spring</artifactid>\n    <version>1.0.1</version>\n</dependency>\n\n\n更多内容可参考：https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0\n\n\n# 升级 dubbo\n\n我们的项目中使用了 soa 框架 dubbo 。由于 dubbo 是老版本的，具体来说是（2013 年的 2.4.10），而老版本中使用的 spirng 版本为 2.x，有兼容性问题。\n\ndubbo 项目从今年开始恢复维护了，首先把一些落后的库升级到较新版本，比如 jdk8，spring4 等，并修复了一些 bug。所以，我们可以通过升级一下 dubbo 版本来解决问题。\n\n<dependency>\n  <groupid>com.alibaba</groupid>\n  <artifactid>dubbo</artifactid>\n  <version>2.5.8</version>\n  <exclusions>\n    <exclusion>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-context</artifactid>\n    </exclusion>\n    <exclusion>\n      <groupid>org.springframework</groupid>\n      <artifactid>spring-web</artifactid>\n    </exclusion>\n    <exclusion>\n      <groupid>org.javassist</groupid>\n      <artifactid>javassist</artifactid>\n    </exclusion>\n  </exclusions>\n</dependency>\n\n\n\n# 升级 jedis\n\n升级 dubbo 为当前最新的 2.5.8 版本后，运行时报错：\n\n * jedispoolconfig 配置错误\n\ncaused by: java.lang.classnotfoundexception: org.apache.commons.pool2.impl.genericobjectpoolconfig\n\n\n由于项目中使用了 redis，版本为 2.0.0 ，这个问题是由于 jedis 需要升级：\n\n<dependency>\n  <groupid>redis.clients</groupid>\n  <artifactid>jedis</artifactid>\n  <version>2.9.0</version>\n</dependency>\n\n\njedis 2.4.1 以上版本的 jedispoolconfig 已经没有了maxactive 和 maxwait 属性。\n\n修改方法如下：\n\nmaxactive > maxtotal\n\nmaxwait > maxwaitmillis\n\n<bean id="jedispoolconfig" class="redis.clients.jedis.jedispoolconfig">\n  <property name="maxtotal" value="200" />\n  <property name="maxidle" value="10" />\n  <property name="maxwaitmillis" value="1000" />\n  <property name="testonborrow" value="true" />\n</bean>\n\n\njedispool 配置错误\n\ninvaliduriexception: cannot open redis connection due invalid uri\n\n\n原来的配置如下：\n\n<bean id="jedispool" class="redis.clients.jedis.jedispool" destroy-method="destroy" depends-on="jedispoolconfig">\n  <constructor-arg ref="jedispoolconfig" />\n  <constructor-arg type="java.lang.string" value="${redis.host}" />\n  <constructor-arg type="int" value="${redis.port}" />\n</bean>\n\n\n查看源码可以发现，初始化 jedispool 时未指定结构方法参数的类型，导致 host 字符串值被视为 uri 类型，当然类型不匹配。\n\n解决方法是修改上面的 host 配置，为：<constructor-arg type="java.lang.string" value="${redis.host}" />\n\n----------------------------------------\n\n至此，spring 4 升级结束。后面如果遇到其他升级问题再补充。\n\n\n# 资料\n\n * https://spring.io/blog/2013/05/21/spring-framework-4-0-m1-3-2-3-available/\n * https://docs.spring.io/spring/docs/4.3.14.build-snapshot/spring-framework-reference/htmlsingle/#spring-whats-new\n * spring 3.x 升级到 spring 4.x 注意事项和步骤，错误解决方法\n * http://jinnianshilongnian.iteye.com/blog/1995111\n * 为什么在 spring 的配置里，最好不要配置 xsd 文件的版本号\n * https://stackoverflow.com/questions/32353286/no-support-for-ibatis-in-spring4-2-0',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot Actuator 快速入门",frontmatter:{title:"SpringBoot Actuator 快速入门",date:"2022-06-14T20:51:22.000Z",order:22,categories:["Java","框架","Spring","Spring其他"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/c013cc/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/99.Spring%E5%85%B6%E4%BB%96/22.SpringBoot%E4%B9%8BActuator.html",relativePath:"01.Java/13.框架/01.Spring/99.Spring其他/22.SpringBoot之Actuator.md",key:"v-033e2880",path:"/pages/c013cc/",headers:[{level:2,title:"端点（Endpoint）",slug:"端点-endpoint",normalizedTitle:"端点（endpoint）",charIndex:450},{level:3,title:"启用端点",slug:"启用端点",normalizedTitle:"启用端点",charIndex:718},{level:3,title:"暴露端点",slug:"暴露端点",normalizedTitle:"暴露端点",charIndex:1051},{level:3,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:2328},{level:3,title:"配置端点",slug:"配置端点",normalizedTitle:"配置端点",charIndex:755},{level:3,title:"Actuator Web 端点的超媒体",slug:"actuator-web-端点的超媒体",normalizedTitle:"actuator web 端点的超媒体",charIndex:4222},{level:3,title:"跨域支持",slug:"跨域支持",normalizedTitle:"跨域支持",charIndex:4548},{level:3,title:"自定义端点",slug:"自定义端点",normalizedTitle:"自定义端点",charIndex:540},{level:2,title:"通过 HTTP 进行监控和管理",slug:"通过-http-进行监控和管理",normalizedTitle:"通过 http 进行监控和管理",charIndex:5542},{level:3,title:"自定义管理端点路径",slug:"自定义管理端点路径",normalizedTitle:"自定义管理端点路径",charIndex:5562},{level:3,title:"自定义管理服务器端口",slug:"自定义管理服务器端口",normalizedTitle:"自定义管理服务器端口",charIndex:5916},{level:3,title:"配置 SSL",slug:"配置-ssl",normalizedTitle:"配置 ssl",charIndex:5961},{level:3,title:"自定义管理服务器地址",slug:"自定义管理服务器地址",normalizedTitle:"自定义管理服务器地址",charIndex:6584},{level:3,title:"禁用 HTTP 端点",slug:"禁用-http-端点",normalizedTitle:"禁用 http 端点",charIndex:6665},{level:2,title:"通过 JMX 进行监控和管理",slug:"通过-jmx-进行监控和管理",normalizedTitle:"通过 jmx 进行监控和管理",charIndex:6867},{level:3,title:"定制化 MBean Names",slug:"定制化-mbean-names",normalizedTitle:"定制化 mbean names",charIndex:7393},{level:3,title:"禁用 JMX 端点",slug:"禁用-jmx-端点",normalizedTitle:"禁用 jmx 端点",charIndex:7714},{level:3,title:"将 Jolokia 用于基于 HTTP 的 JMX",slug:"将-jolokia-用于基于-http-的-jmx",normalizedTitle:"将 jolokia 用于基于 http 的 jmx",charIndex:7795},{level:2,title:"日志",slug:"日志",normalizedTitle:"日志",charIndex:8133},{level:2,title:"指标",slug:"指标",normalizedTitle:"指标",charIndex:8274},{level:2,title:"审计",slug:"审计",normalizedTitle:"审计",charIndex:8281},{level:2,title:"HTTP 追踪",slug:"http-追踪",normalizedTitle:"http 追踪",charIndex:8814},{level:2,title:"处理监控",slug:"处理监控",normalizedTitle:"处理监控",charIndex:9090},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9328}],headersStr:"端点（Endpoint） 启用端点 暴露端点 安全 配置端点 Actuator Web 端点的超媒体 跨域支持 自定义端点 通过 HTTP 进行监控和管理 自定义管理端点路径 自定义管理服务器端口 配置 SSL 自定义管理服务器地址 禁用 HTTP 端点 通过 JMX 进行监控和管理 定制化 MBean Names 禁用 JMX 端点 将 Jolokia 用于基于 HTTP 的 JMX 日志 指标 审计 HTTP 追踪 处理监控 参考资料",content:'# SpringBoot Actuator 快速入门\n\nspring-boot-actuator 模块提供了 Spring Boot 的所有生产就绪功能。启用这些功能的推荐方法是添加 spring-boot-starter-actuator 依赖。\n\n如果是 Maven 项目，添加以下依赖：\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n</dependencies>\n\n\n如果是 Gradle 项目，添加以下声明：\n\ndependencies {\n    implementation \'org.springframework.boot:spring-boot-starter-actuator\'\n}\n\n\n\n# 端点（Endpoint）\n\nActuator Endpoint 使 Spring Boot 用户可以监控应用，并和应用进行交互。Spring Boot 内置了许多 端点，并允许用户自定义端点。例如，health 端点提供基本的应用健康信息。\n\n用户可以启用或禁用每个单独的端点并通过 HTTP 或 JMX 暴露它们（使它们可远程访问）。当端点被启用和公开时，它被认为是可用的。内置端点仅在可用时才会自动配置。大多数应用程序选择通过 HTTP 公开。例如，默认情况下，health 端点映射到 /actuator/health。\n\n\n# 启用端点\n\n默认情况下，除了 shutdown 之外的所有端点都已启用。要配置端点的启用，请使用 management.endpoint.<id>.enabled 属性。以下示例启用 shutdown 端点：\n\nmanagement.endpoint.shutdown.enabled=true\n\n\n如果您希望端点是明确指定才启用，请将 management.endpoints.enabled-by-default 属性设置为 false 并根据需要明确指定启用的端点，以下为示例：\n\nmanagement.endpoints.enabled-by-default=false\nmanagement.endpoint.info.enabled=true\n\n\n\n# 暴露端点\n\n由于端点可能包含敏感信息，您应该仔细考虑何时暴露它们。下表显示了内置端点的默认曝光：\n\nID                 JMX   WEB\nauditevents        Yes   No\nbeans              Yes   No\ncaches             Yes   No\nconditions         Yes   No\nconfigprops        Yes   No\nenv                Yes   No\nflyway             Yes   No\nhealth             Yes   Yes\nheapdump           N/A   No\nhttptrace          Yes   No\ninfo               Yes   No\nintegrationgraph   Yes   No\njolokia            N/A   No\nlogfile            N/A   No\nloggers            Yes   No\nliquibase          Yes   No\nmetrics            Yes   No\nmappings           Yes   No\nprometheus         N/A   No\nquartz             Yes   No\nscheduledtasks     Yes   No\nsessions           Yes   No\nshutdown           Yes   No\nstartup            Yes   No\nthreaddump         Yes   No\n\n要更改暴露的端点，请使用以下特定于技术的包含和排除属性：\n\nPROPERTY                                    DEFAULT\nmanagement.endpoints.jmx.exposure.exclude   \nmanagement.endpoints.jmx.exposure.include   *\nmanagement.endpoints.web.exposure.exclude   \nmanagement.endpoints.web.exposure.include   health\n\ninclude 属性列出了暴露的端点的 ID。 exclude 属性列出了不应暴露的端点的 ID。 exclude 属性优先于 include 属性。您可以使用端点 ID 列表配置包含和排除属性。\n\n例如，仅暴露 health 和 info 端点，其他端点都不通过 JMX 暴露，可以按如下配置：\n\nmanagement.endpoints.jmx.exposure.include=health,info\n\n\n注意：* 可用于选择所有端点。\n\n\n# 安全\n\n出于安全考虑，只有 /health 端点会通过 HTTP 方式暴露。用户可以通过 management.endpoints.web.exposure.include 决定哪些端点可以通过 HTTP 方式暴露。\n\n如果 Spring Security 在类路径上并且不存在其他 WebSecurityConfigurerAdapter 或 SecurityFilterChain bean，则除 /health 之外的所有 actuator 都由 Spring Boot 自动启用安全控制。如果用户自定义了 WebSecurityConfigurerAdapter 或 SecurityFilterChain bean，Spring Boot 不再启用安全控制，由用户自行控制访问规则。\n\n如果您希望为 HTTP 端点定义安全控制（例如，只允许具有特定角色的用户访问它们），Spring Boot 提供了一些方便的 RequestMatcher 对象，您可以将它们与 Spring Security 结合使用。\n\n下面是一个典型的 Spring Security 配置示例：\n\n@Configuration(proxyBeanMethods = false)\npublic class MySecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint())\n                .authorizeRequests((requests) -> requests.anyRequest().hasRole("ENDPOINT_ADMIN"));\n        http.httpBasic();\n        return http.build();\n    }\n\n}\n\n\n前面的示例使用 EndpointRequest.toAnyEndpoint() 将请求匹配到任何端点，然后确保所有端点都具有 ENDPOINT_ADMIN 角色。 EndpointRequest 上还提供了其他几种匹配器方法。\n\n如果希望无需身份验证即可访问所有执行器端点。可以通过更改 management.endpoints.web.exposure.include 属性来做到这一点，如下所示：\n\nmanagement.endpoints.web.exposure.include=*\n\n\n此外，如果存在 Spring Security，您将需要添加自定义安全配置，以允许未经身份验证的访问端点，如以下示例所示：\n\n@Configuration(proxyBeanMethods = false)\npublic class MySecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.requestMatcher(EndpointRequest.toAnyEndpoint())\n                .authorizeRequests((requests) -> requests.anyRequest().permitAll());\n        return http.build();\n    }\n\n}\n\n\n由于 Spring Boot 依赖于 Spring Security 的默认设置，因此 CSRF 保护默认开启。这意味着在使用默认安全配置时，需要 POST（关闭和记录器端点）、PUT 或 DELETE 的执行器端点会收到 403（禁止）错误。\n\n> 建议仅在创建非浏览器客户端使用的服务时完全禁用 CSRF 保护。\n\n\n# 配置端点\n\n端点会自动缓存对不带任何参数的读操作的响应数据。要配置端点缓存响应的时间量，请使用其 cache.time-to-live 属性。以下示例将 bean 端点缓存的生存时间设置为 10 秒：\n\nmanagement.endpoint.beans.cache.time-to-live=10s\n\n\n\n# Actuator Web 端点的超媒体\n\nSpring Boot Actuator 中内置了一个“发现页面”端点，其中包含了所有端点的链接。默认情况下，“发现页面”在 /actuator 上可用。\n\n要禁用“发现页面”，请将以下属性添加到您的应用程序属性中：\n\nmanagement.endpoints.web.discovery.enabled=false\n\n\n配置自定义管理上下文路径后，“发现页面”会自动从 /actuator 移动到应用管理上下文的根目录。例如，如果管理上下文路径是 /management，则发现页面可从 /management 获得。当管理上下文路径设置为 / 时，发现页面被禁用以防止与其他映射发生冲突的可能性。\n\n\n# 跨域支持\n\nCORS 是一种 W3C 规范，可让用户以灵活的方式指定授权哪种跨域请求。如果使用 Spring MVC 或 Spring WebFlux，则可以配置 Actuator 的 Web 端点以支持此类场景。\n\nCORS 支持默认是禁用的，只有在设置 management.endpoints.web.cors.allowed-origins 属性后才会启用。以下配置允许来自 example.com 域的 GET 和 POST 调用：\n\nmanagement.endpoints.web.cors.allowed-origins=https://example.com\nmanagement.endpoints.web.cors.allowed-methods=GET,POST\n\n\n\n# 自定义端点\n\n如果添加带有 @Endpoint 注释的 @Bean，则任何带有 @ReadOperation、@WriteOperation 或 @DeleteOperation 注释的方法都会自动通过 JMX 公开，并且在 Web 应用程序中，也可以通过 HTTP 公开。可以使用 Jersey、Spring MVC 或 Spring WebFlux 通过 HTTP 公开端点。如果 Jersey 和 Spring MVC 都可用，则使用 Spring MVC。\n\n以下示例公开了一个返回自定义对象的读取操作：\n\n@ReadOperation\npublic CustomData getData() {\n    return new CustomData("test", 5);\n}\n\n\n您还可以使用 @JmxEndpoint 或 @WebEndpoint 编写特定技术的端点。这些端点仅限于各自的技术。例如，@WebEndpoint 仅通过 HTTP 而不是通过 JMX 公开。\n\n您可以使用 @EndpointWebExtension 和 @EndpointJmxExtension 编写特定技术的扩展。这些注释让您可以提供特定技术的操作来扩充现有端点。\n\n最后，如果您需要访问 Web 框架的功能，您可以实现 servlet 或 Spring @Controller 和 @RestController 端点，但代价是它们无法通过 JMX 或使用不同的 Web 框架获得。\n\n\n# 通过 HTTP 进行监控和管理\n\n\n# 自定义管理端点路径\n\n如果是 Web 应用，Spring Boot Actuator 会自动将所有启用的端点通过 HTTP 方式暴露。默认约定是使用前缀为 /actuator 的端点的 id 作为 URL 路径。例如，健康被暴露为 /actuator/health。\n\n有时，自定义管理端点的前缀很有用。例如，您的应用程序可能已经将 /actuator 用于其他目的。您可以使用 management.endpoints.web.base-path 属性更改管理端点的前缀，如以下示例所示：\n\nmanagement.endpoints.web.base-path=/manage\n\n\n该示例将端点从 /actuator/{id} 更改为 /manage/{id}（例如，/manage/info）。\n\n\n# 自定义管理服务器端口\n\nmanagement.server.port=8081\n\n\n\n# 配置 SSL\n\n当配置为使用自定义端口时，还可以使用各种 management.server.ssl.* 属性为管理服务器配置自己的 SSL。例如，这样做可以让管理服务器在主应用程序使用 HTTPS 时通过 HTTP 可用，如以下属性设置所示：\n\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:store.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=false\n\n\n或者，主服务器和管理服务器都可以使用 SSL，但使用不同的密钥存储，如下所示：\n\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:main.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=true\nmanagement.server.ssl.key-store=classpath:management.jks\nmanagement.server.ssl.key-password=secret\n\n\n\n# 自定义管理服务器地址\n\nmanagement.server.port=8081\nmanagement.server.address=127.0.0.1\n\n\n\n# 禁用 HTTP 端点\n\n如果您不想通过 HTTP 方式暴露端点，可以将管理端口设置为 -1，如以下示例所示：\n\nmanagement.server.port=-1\n\n\n也可以通过使用 management.endpoints.web.exposure.exclude 属性来实现这一点，如以下示例所示：\n\nmanagement.endpoints.web.exposure.exclude=*\n\n\n\n# 通过 JMX 进行监控和管理\n\nJava 管理扩展 (JMX) 提供了一种标准机制来监视和管理应用程序。默认情况下，此功能未启用。您可以通过将 spring.jmx.enabled 配置属性设置为 true 来打开它。 Spring Boot 将最合适的 MBeanServer 暴露为 ID 为 mbeanServer 的 bean。使用 Spring JMX 注释（@ManagedResource、@ManagedAttribute 或 @ManagedOperation）注释的任何 bean 都会暴露给它。\n\n如果您的平台提供标准 MBeanServer，则 Spring Boot 会使用该标准并在必要时默认使用 VM MBeanServer。如果一切都失败了，则创建一个新的 MBeanServer。\n\n有关更多详细信息，请参阅 JmxAutoConfiguration 类。\n\n默认情况下，Spring Boot 还将管理端点公开为 org.springframework.boot 域下的 JMX MBean。要完全控制 JMX 域中的端点注册，请考虑注册您自己的 EndpointObjectNameFactory 实现。\n\n\n# 定制化 MBean Names\n\nMBean 的名称通常由端点的 id 生成。例如，健康端点公开为 org.springframework.boot:type=Endpoint,name=Health。\n\n如果您的应用程序包含多个 Spring ApplicationContext，您可能会发现名称冲突。要解决此问题，您可以将 spring.jmx.unique-names 属性设置为 true，以便 MBean 名称始终是唯一的。\n\n如果需要定制，跨域按如下配置：\n\nspring.jmx.unique-names=true\nmanagement.endpoints.jmx.domain=com.example.myapp\n\n\n\n# 禁用 JMX 端点\n\n想禁用 JMX 端点，可以按如下配置：\n\nmanagement.endpoints.jmx.exposure.exclude=*\n\n\n\n# 将 Jolokia 用于基于 HTTP 的 JMX\n\nJolokia 是一个 JMX-HTTP 的桥接工具，它提供了另一种访问 JMX bean 的方法。要使用 Jolokia，需要先添加依赖：\n\n<dependency>\n    <groupId>org.jolokia</groupId>\n    <artifactId>jolokia-core</artifactId>\n</dependency\n\n\n然后，您可以通过将 jolokia 或 * 添加到 Management.Endpoints.web.exposure.include 属性来暴露 Jolokia 端点。然后，您可以在管理 HTTP 服务器上使用 /actuator/jolokia 访问它。\n\n\n# 日志\n\nSpring Boot Actuator 支持查看和配置应用日志级别。\n\n日志级别的可选值如下：\n\n * TRACE\n * DEBUG\n * INFO\n * WARN\n * ERROR\n * FATAL\n * OFF\n * null\n\nnull 表示没有显式配置。\n\n\n# 指标\n\n\n# 审计\n\nSpring Boot Actuator 支持简单的审计功能。如果应用中启用了 Spring Security，Spring Boot Actuator 就会发布安全事件（如：“身份验证成功”、“失败”和“访问被拒绝”异常）。\n\n可以通过在应用的配置中提供 AuditEventRepository 类型的 bean 来启用审计。为方便起见，Spring Boot 提供了一个 InMemoryAuditEventRepository。 InMemoryAuditEventRepository 的功能有限，建议仅将其用于开发环境。\n\n如果要自定义安全事件，可以提供 AbstractAuthenticationAuditListener 和 AbstractAuthorizationAuditListener 实现。\n\n此外，还可以将审计服务用于业务活动。为此，要么将 AuditEventRepository bean 注入组件并直接使用它，要么使用 Spring ApplicationEventPublisher 发布 AuditApplicationEvent（通过实现 ApplicationEventPublisherAware）。\n\n\n# HTTP 追踪\n\n用户可以通过在应用中提供 HttpTraceRepository 类型的 bean 来启用 HTTP 跟踪。Spring Boot 提供了内置的 InMemoryHttpTraceRepository，它可以存储最近 100 次（默认）请求-响应的追踪数据。与其他 HTTP 追踪解决方案相比，InMemoryHttpTraceRepository 比较受限，建议仅用于开发环境。对于生产环境，建议使用 Zipkin 或 Spring Cloud Sleuth。\n\n或者，可以自定义 HttpTraceRepository。\n\n\n# 处理监控\n\n在 spring-boot 模块中，您可以找到两个类来创建对进程监控有用的文件：\n\n * ApplicationPidFileWriter 创建一个包含应用程序 PID 的文件（默认情况下，在应用程序目录中，文件名为 application.pid）。\n * WebServerPortFileWriter 创建一个文件（或多个文件），其中包含正在运行的 Web 服务器的端口（默认情况下，在应用程序目录中，文件名为 application.port）。\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 Production-ready Features',normalizedContent:'# springboot actuator 快速入门\n\nspring-boot-actuator 模块提供了 spring boot 的所有生产就绪功能。启用这些功能的推荐方法是添加 spring-boot-starter-actuator 依赖。\n\n如果是 maven 项目，添加以下依赖：\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-actuator</artifactid>\n    </dependency>\n</dependencies>\n\n\n如果是 gradle 项目，添加以下声明：\n\ndependencies {\n    implementation \'org.springframework.boot:spring-boot-starter-actuator\'\n}\n\n\n\n# 端点（endpoint）\n\nactuator endpoint 使 spring boot 用户可以监控应用，并和应用进行交互。spring boot 内置了许多 端点，并允许用户自定义端点。例如，health 端点提供基本的应用健康信息。\n\n用户可以启用或禁用每个单独的端点并通过 http 或 jmx 暴露它们（使它们可远程访问）。当端点被启用和公开时，它被认为是可用的。内置端点仅在可用时才会自动配置。大多数应用程序选择通过 http 公开。例如，默认情况下，health 端点映射到 /actuator/health。\n\n\n# 启用端点\n\n默认情况下，除了 shutdown 之外的所有端点都已启用。要配置端点的启用，请使用 management.endpoint.<id>.enabled 属性。以下示例启用 shutdown 端点：\n\nmanagement.endpoint.shutdown.enabled=true\n\n\n如果您希望端点是明确指定才启用，请将 management.endpoints.enabled-by-default 属性设置为 false 并根据需要明确指定启用的端点，以下为示例：\n\nmanagement.endpoints.enabled-by-default=false\nmanagement.endpoint.info.enabled=true\n\n\n\n# 暴露端点\n\n由于端点可能包含敏感信息，您应该仔细考虑何时暴露它们。下表显示了内置端点的默认曝光：\n\nid                 jmx   web\nauditevents        yes   no\nbeans              yes   no\ncaches             yes   no\nconditions         yes   no\nconfigprops        yes   no\nenv                yes   no\nflyway             yes   no\nhealth             yes   yes\nheapdump           n/a   no\nhttptrace          yes   no\ninfo               yes   no\nintegrationgraph   yes   no\njolokia            n/a   no\nlogfile            n/a   no\nloggers            yes   no\nliquibase          yes   no\nmetrics            yes   no\nmappings           yes   no\nprometheus         n/a   no\nquartz             yes   no\nscheduledtasks     yes   no\nsessions           yes   no\nshutdown           yes   no\nstartup            yes   no\nthreaddump         yes   no\n\n要更改暴露的端点，请使用以下特定于技术的包含和排除属性：\n\nproperty                                    default\nmanagement.endpoints.jmx.exposure.exclude   \nmanagement.endpoints.jmx.exposure.include   *\nmanagement.endpoints.web.exposure.exclude   \nmanagement.endpoints.web.exposure.include   health\n\ninclude 属性列出了暴露的端点的 id。 exclude 属性列出了不应暴露的端点的 id。 exclude 属性优先于 include 属性。您可以使用端点 id 列表配置包含和排除属性。\n\n例如，仅暴露 health 和 info 端点，其他端点都不通过 jmx 暴露，可以按如下配置：\n\nmanagement.endpoints.jmx.exposure.include=health,info\n\n\n注意：* 可用于选择所有端点。\n\n\n# 安全\n\n出于安全考虑，只有 /health 端点会通过 http 方式暴露。用户可以通过 management.endpoints.web.exposure.include 决定哪些端点可以通过 http 方式暴露。\n\n如果 spring security 在类路径上并且不存在其他 websecurityconfigureradapter 或 securityfilterchain bean，则除 /health 之外的所有 actuator 都由 spring boot 自动启用安全控制。如果用户自定义了 websecurityconfigureradapter 或 securityfilterchain bean，spring boot 不再启用安全控制，由用户自行控制访问规则。\n\n如果您希望为 http 端点定义安全控制（例如，只允许具有特定角色的用户访问它们），spring boot 提供了一些方便的 requestmatcher 对象，您可以将它们与 spring security 结合使用。\n\n下面是一个典型的 spring security 配置示例：\n\n@configuration(proxybeanmethods = false)\npublic class mysecurityconfiguration {\n\n    @bean\n    public securityfilterchain securityfilterchain(httpsecurity http) throws exception {\n        http.requestmatcher(endpointrequest.toanyendpoint())\n                .authorizerequests((requests) -> requests.anyrequest().hasrole("endpoint_admin"));\n        http.httpbasic();\n        return http.build();\n    }\n\n}\n\n\n前面的示例使用 endpointrequest.toanyendpoint() 将请求匹配到任何端点，然后确保所有端点都具有 endpoint_admin 角色。 endpointrequest 上还提供了其他几种匹配器方法。\n\n如果希望无需身份验证即可访问所有执行器端点。可以通过更改 management.endpoints.web.exposure.include 属性来做到这一点，如下所示：\n\nmanagement.endpoints.web.exposure.include=*\n\n\n此外，如果存在 spring security，您将需要添加自定义安全配置，以允许未经身份验证的访问端点，如以下示例所示：\n\n@configuration(proxybeanmethods = false)\npublic class mysecurityconfiguration {\n\n    @bean\n    public securityfilterchain securityfilterchain(httpsecurity http) throws exception {\n        http.requestmatcher(endpointrequest.toanyendpoint())\n                .authorizerequests((requests) -> requests.anyrequest().permitall());\n        return http.build();\n    }\n\n}\n\n\n由于 spring boot 依赖于 spring security 的默认设置，因此 csrf 保护默认开启。这意味着在使用默认安全配置时，需要 post（关闭和记录器端点）、put 或 delete 的执行器端点会收到 403（禁止）错误。\n\n> 建议仅在创建非浏览器客户端使用的服务时完全禁用 csrf 保护。\n\n\n# 配置端点\n\n端点会自动缓存对不带任何参数的读操作的响应数据。要配置端点缓存响应的时间量，请使用其 cache.time-to-live 属性。以下示例将 bean 端点缓存的生存时间设置为 10 秒：\n\nmanagement.endpoint.beans.cache.time-to-live=10s\n\n\n\n# actuator web 端点的超媒体\n\nspring boot actuator 中内置了一个“发现页面”端点，其中包含了所有端点的链接。默认情况下，“发现页面”在 /actuator 上可用。\n\n要禁用“发现页面”，请将以下属性添加到您的应用程序属性中：\n\nmanagement.endpoints.web.discovery.enabled=false\n\n\n配置自定义管理上下文路径后，“发现页面”会自动从 /actuator 移动到应用管理上下文的根目录。例如，如果管理上下文路径是 /management，则发现页面可从 /management 获得。当管理上下文路径设置为 / 时，发现页面被禁用以防止与其他映射发生冲突的可能性。\n\n\n# 跨域支持\n\ncors 是一种 w3c 规范，可让用户以灵活的方式指定授权哪种跨域请求。如果使用 spring mvc 或 spring webflux，则可以配置 actuator 的 web 端点以支持此类场景。\n\ncors 支持默认是禁用的，只有在设置 management.endpoints.web.cors.allowed-origins 属性后才会启用。以下配置允许来自 example.com 域的 get 和 post 调用：\n\nmanagement.endpoints.web.cors.allowed-origins=https://example.com\nmanagement.endpoints.web.cors.allowed-methods=get,post\n\n\n\n# 自定义端点\n\n如果添加带有 @endpoint 注释的 @bean，则任何带有 @readoperation、@writeoperation 或 @deleteoperation 注释的方法都会自动通过 jmx 公开，并且在 web 应用程序中，也可以通过 http 公开。可以使用 jersey、spring mvc 或 spring webflux 通过 http 公开端点。如果 jersey 和 spring mvc 都可用，则使用 spring mvc。\n\n以下示例公开了一个返回自定义对象的读取操作：\n\n@readoperation\npublic customdata getdata() {\n    return new customdata("test", 5);\n}\n\n\n您还可以使用 @jmxendpoint 或 @webendpoint 编写特定技术的端点。这些端点仅限于各自的技术。例如，@webendpoint 仅通过 http 而不是通过 jmx 公开。\n\n您可以使用 @endpointwebextension 和 @endpointjmxextension 编写特定技术的扩展。这些注释让您可以提供特定技术的操作来扩充现有端点。\n\n最后，如果您需要访问 web 框架的功能，您可以实现 servlet 或 spring @controller 和 @restcontroller 端点，但代价是它们无法通过 jmx 或使用不同的 web 框架获得。\n\n\n# 通过 http 进行监控和管理\n\n\n# 自定义管理端点路径\n\n如果是 web 应用，spring boot actuator 会自动将所有启用的端点通过 http 方式暴露。默认约定是使用前缀为 /actuator 的端点的 id 作为 url 路径。例如，健康被暴露为 /actuator/health。\n\n有时，自定义管理端点的前缀很有用。例如，您的应用程序可能已经将 /actuator 用于其他目的。您可以使用 management.endpoints.web.base-path 属性更改管理端点的前缀，如以下示例所示：\n\nmanagement.endpoints.web.base-path=/manage\n\n\n该示例将端点从 /actuator/{id} 更改为 /manage/{id}（例如，/manage/info）。\n\n\n# 自定义管理服务器端口\n\nmanagement.server.port=8081\n\n\n\n# 配置 ssl\n\n当配置为使用自定义端口时，还可以使用各种 management.server.ssl.* 属性为管理服务器配置自己的 ssl。例如，这样做可以让管理服务器在主应用程序使用 https 时通过 http 可用，如以下属性设置所示：\n\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:store.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=false\n\n\n或者，主服务器和管理服务器都可以使用 ssl，但使用不同的密钥存储，如下所示：\n\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:main.jks\nserver.ssl.key-password=secret\nmanagement.server.port=8080\nmanagement.server.ssl.enabled=true\nmanagement.server.ssl.key-store=classpath:management.jks\nmanagement.server.ssl.key-password=secret\n\n\n\n# 自定义管理服务器地址\n\nmanagement.server.port=8081\nmanagement.server.address=127.0.0.1\n\n\n\n# 禁用 http 端点\n\n如果您不想通过 http 方式暴露端点，可以将管理端口设置为 -1，如以下示例所示：\n\nmanagement.server.port=-1\n\n\n也可以通过使用 management.endpoints.web.exposure.exclude 属性来实现这一点，如以下示例所示：\n\nmanagement.endpoints.web.exposure.exclude=*\n\n\n\n# 通过 jmx 进行监控和管理\n\njava 管理扩展 (jmx) 提供了一种标准机制来监视和管理应用程序。默认情况下，此功能未启用。您可以通过将 spring.jmx.enabled 配置属性设置为 true 来打开它。 spring boot 将最合适的 mbeanserver 暴露为 id 为 mbeanserver 的 bean。使用 spring jmx 注释（@managedresource、@managedattribute 或 @managedoperation）注释的任何 bean 都会暴露给它。\n\n如果您的平台提供标准 mbeanserver，则 spring boot 会使用该标准并在必要时默认使用 vm mbeanserver。如果一切都失败了，则创建一个新的 mbeanserver。\n\n有关更多详细信息，请参阅 jmxautoconfiguration 类。\n\n默认情况下，spring boot 还将管理端点公开为 org.springframework.boot 域下的 jmx mbean。要完全控制 jmx 域中的端点注册，请考虑注册您自己的 endpointobjectnamefactory 实现。\n\n\n# 定制化 mbean names\n\nmbean 的名称通常由端点的 id 生成。例如，健康端点公开为 org.springframework.boot:type=endpoint,name=health。\n\n如果您的应用程序包含多个 spring applicationcontext，您可能会发现名称冲突。要解决此问题，您可以将 spring.jmx.unique-names 属性设置为 true，以便 mbean 名称始终是唯一的。\n\n如果需要定制，跨域按如下配置：\n\nspring.jmx.unique-names=true\nmanagement.endpoints.jmx.domain=com.example.myapp\n\n\n\n# 禁用 jmx 端点\n\n想禁用 jmx 端点，可以按如下配置：\n\nmanagement.endpoints.jmx.exposure.exclude=*\n\n\n\n# 将 jolokia 用于基于 http 的 jmx\n\njolokia 是一个 jmx-http 的桥接工具，它提供了另一种访问 jmx bean 的方法。要使用 jolokia，需要先添加依赖：\n\n<dependency>\n    <groupid>org.jolokia</groupid>\n    <artifactid>jolokia-core</artifactid>\n</dependency\n\n\n然后，您可以通过将 jolokia 或 * 添加到 management.endpoints.web.exposure.include 属性来暴露 jolokia 端点。然后，您可以在管理 http 服务器上使用 /actuator/jolokia 访问它。\n\n\n# 日志\n\nspring boot actuator 支持查看和配置应用日志级别。\n\n日志级别的可选值如下：\n\n * trace\n * debug\n * info\n * warn\n * error\n * fatal\n * off\n * null\n\nnull 表示没有显式配置。\n\n\n# 指标\n\n\n# 审计\n\nspring boot actuator 支持简单的审计功能。如果应用中启用了 spring security，spring boot actuator 就会发布安全事件（如：“身份验证成功”、“失败”和“访问被拒绝”异常）。\n\n可以通过在应用的配置中提供 auditeventrepository 类型的 bean 来启用审计。为方便起见，spring boot 提供了一个 inmemoryauditeventrepository。 inmemoryauditeventrepository 的功能有限，建议仅将其用于开发环境。\n\n如果要自定义安全事件，可以提供 abstractauthenticationauditlistener 和 abstractauthorizationauditlistener 实现。\n\n此外，还可以将审计服务用于业务活动。为此，要么将 auditeventrepository bean 注入组件并直接使用它，要么使用 spring applicationeventpublisher 发布 auditapplicationevent（通过实现 applicationeventpublisheraware）。\n\n\n# http 追踪\n\n用户可以通过在应用中提供 httptracerepository 类型的 bean 来启用 http 跟踪。spring boot 提供了内置的 inmemoryhttptracerepository，它可以存储最近 100 次（默认）请求-响应的追踪数据。与其他 http 追踪解决方案相比，inmemoryhttptracerepository 比较受限，建议仅用于开发环境。对于生产环境，建议使用 zipkin 或 spring cloud sleuth。\n\n或者，可以自定义 httptracerepository。\n\n\n# 处理监控\n\n在 spring-boot 模块中，您可以找到两个类来创建对进程监控有用的文件：\n\n * applicationpidfilewriter 创建一个包含应用程序 pid 的文件（默认情况下，在应用程序目录中，文件名为 application.pid）。\n * webserverportfilewriter 创建一个文件（或多个文件），其中包含正在运行的 web 服务器的端口（默认情况下，在应用程序目录中，文件名为 application.port）。\n\n\n# 参考资料\n\n * spring boot 官方文档之 production-ready features',charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SpringBoot 之 banner 定制",frontmatter:{title:"SpringBoot 之 banner 定制",date:"2018-12-21T23:22:44.000Z",order:21,categories:["Java","框架","Spring","Spring其他"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/bac2ce/"},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/99.Spring%E5%85%B6%E4%BB%96/21.SpringBoot%E4%B9%8Bbanner.html",relativePath:"01.Java/13.框架/01.Spring/99.Spring其他/21.SpringBoot之banner.md",key:"v-65fa0e1c",path:"/pages/bac2ce/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:29},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:632},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:2202},{level:2,title:"编程",slug:"编程",normalizedTitle:"编程",charIndex:2849},{level:2,title:"示例源码",slug:"示例源码",normalizedTitle:"示例源码",charIndex:3070},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3106}],headersStr:"简介 变量 配置 编程 示例源码 参考资料",content:"# SpringBoot 之 banner 定制\n\n\n# 简介\n\nSpring Boot 启动时默认会显示以下 LOGO：\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.1.1.RELEASE)\n\n\n实际上，Spring Boot 支持自定义 logo 的功能。\n\n让我们来看看如何实现的。\n\n只要你在 resources 目录下放置名为 banner.txt、banner.gif 、banner.jpg 或 banner.png 的文件，Spring Boot 会自动加载，将其作为启动时打印的 logo。\n\n * 对于文本文件，Spring Boot 会将其直接输出。\n * 对于图像文件（ banner.gif 、banner.jpg 或 banner.png ），Spring Boot 会将图像转为 ASCII 字符，然后输出。\n\n\n# 变量\n\nbanner.txt 文件中还可以使用变量来设置字体、颜色、版本号。\n\n变量                                                            描述\n${application.version}                                        MANIFEST.MF 中定义的版本。如：1.0\n${application.formatted-version}                              MANIFEST.MF 中定义的版本，并添加一个 v 前缀。如：v1.0\n${spring-boot.version}                                        Spring Boot 版本。如：2.1.1.RELEASE.\n${spring-boot.formatted-version}                              Spring Boot 版本，并添加一个 v 前缀。如：v2.1.1.RELEASE\n${Ansi.NAME} (or ${AnsiColor.NAME}, ${AnsiBackground.NAME},   ANSI 颜色、字体。更多细节，参考：AnsiPropertySource。\n${AnsiStyle.NAME})\n${application.title}                                          MANIFEST.MF 中定义的应用名。\n\n示例：\n\n在 Spring Boot 项目中的 resources 目录下添加一个名为 banner.txt 的文件，内容如下：\n\n${AnsiColor.BRIGHT_YELLOW}${AnsiStyle.BOLD}\n ________  ___  ___  ________   ___       __   ___  ___\n|\\   ___ \\|\\  \\|\\  \\|\\   ___  \\|\\  \\     |\\  \\|\\  \\|\\  \\\n\\ \\  \\_|\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\    \\ \\  \\ \\  \\\\\\  \\\n \\ \\  \\ \\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\  __\\ \\  \\ \\  \\\\\\  \\\n  \\ \\  \\_\\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\|\\__\\_\\  \\ \\  \\\\\\  \\\n   \\ \\_______\\ \\_______\\ \\__\\\\ \\__\\ \\____________\\ \\_______\\\n    \\|_______|\\|_______|\\|__| \\|__|\\|____________|\\|_______|\n${AnsiBackground.WHITE}${AnsiColor.RED}${AnsiStyle.UNDERLINE}\n:: Spring Boot ::             (v${spring-boot.version})\n:: Spring Boot Tutorial ::    (v1.0.0)\n\n\n> 注：${} 设置字体颜色的变量之间不能换行或空格分隔，否则会导致除最后一个变量外，都不生效。\n\n启动应用后，控制台将打印如下 logo：\n\n推荐两个生成字符画的网站，可以将生成的字符串放入这个banner.txt 文件：\n\n * http://www.network-science.de/ascii/\n * http://patorjk.com/software/taag/\n\n\n# 配置\n\napplication.properties 中与 Banner 相关的配置：\n\n# banner 模式。有三种模式：console/log/off\n# console 打印到控制台（通过 System.out）\n# log - 打印到日志中\n# off - 关闭打印\nspring.main.banner-mode = off\n# banner 文件编码\nspring.banner.charset = UTF-8\n# banner 文本文件路径\nspring.banner.location = classpath:banner.txt\n# banner 图像文件路径（可以选择 png,jpg,gif 文件）\nspring.banner.image.location = classpath:banner.gif\nused).\n# 图像 banner 的宽度（字符数）\nspring.banner.image.width = 76\n# 图像 banner 的高度（字符数）\nspring.banner.image.height =\n# 图像 banner 的左边界（字符数）\nspring.banner.image.margin = 2\n# 是否将图像转为黑色控制台主题\nspring.banner.image.invert = false\n\n\n当然，你也可以在 YAML 文件中配置，例如：\n\nspring:\n  main:\n    banner-mode: off\n\n\n\n# 编程\n\n默认，Spring Boot 会注册一个 SpringBootBanner 的单例 Bean，用来负责打印 Banner。\n\n如果想完全个人定制 Banner，可以这么做：先实现 org.springframework.boot.Banner#printBanner 接口来自己定制 Banner。在将这个 Banner 通过 SpringApplication.setBanner(…) 方法注入 Spring Boot。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-banner\n\n\n# 参考资料\n\n * Spring Boot 官方文档之 Customizing the Banner",normalizedContent:"# springboot 之 banner 定制\n\n\n# 简介\n\nspring boot 启动时默认会显示以下 logo：\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: spring boot ::        (v2.1.1.release)\n\n\n实际上，spring boot 支持自定义 logo 的功能。\n\n让我们来看看如何实现的。\n\n只要你在 resources 目录下放置名为 banner.txt、banner.gif 、banner.jpg 或 banner.png 的文件，spring boot 会自动加载，将其作为启动时打印的 logo。\n\n * 对于文本文件，spring boot 会将其直接输出。\n * 对于图像文件（ banner.gif 、banner.jpg 或 banner.png ），spring boot 会将图像转为 ascii 字符，然后输出。\n\n\n# 变量\n\nbanner.txt 文件中还可以使用变量来设置字体、颜色、版本号。\n\n变量                                                            描述\n${application.version}                                        manifest.mf 中定义的版本。如：1.0\n${application.formatted-version}                              manifest.mf 中定义的版本，并添加一个 v 前缀。如：v1.0\n${spring-boot.version}                                        spring boot 版本。如：2.1.1.release.\n${spring-boot.formatted-version}                              spring boot 版本，并添加一个 v 前缀。如：v2.1.1.release\n${ansi.name} (or ${ansicolor.name}, ${ansibackground.name},   ansi 颜色、字体。更多细节，参考：ansipropertysource。\n${ansistyle.name})\n${application.title}                                          manifest.mf 中定义的应用名。\n\n示例：\n\n在 spring boot 项目中的 resources 目录下添加一个名为 banner.txt 的文件，内容如下：\n\n${ansicolor.bright_yellow}${ansistyle.bold}\n ________  ___  ___  ________   ___       __   ___  ___\n|\\   ___ \\|\\  \\|\\  \\|\\   ___  \\|\\  \\     |\\  \\|\\  \\|\\  \\\n\\ \\  \\_|\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\    \\ \\  \\ \\  \\\\\\  \\\n \\ \\  \\ \\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\  __\\ \\  \\ \\  \\\\\\  \\\n  \\ \\  \\_\\\\ \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\|\\__\\_\\  \\ \\  \\\\\\  \\\n   \\ \\_______\\ \\_______\\ \\__\\\\ \\__\\ \\____________\\ \\_______\\\n    \\|_______|\\|_______|\\|__| \\|__|\\|____________|\\|_______|\n${ansibackground.white}${ansicolor.red}${ansistyle.underline}\n:: spring boot ::             (v${spring-boot.version})\n:: spring boot tutorial ::    (v1.0.0)\n\n\n> 注：${} 设置字体颜色的变量之间不能换行或空格分隔，否则会导致除最后一个变量外，都不生效。\n\n启动应用后，控制台将打印如下 logo：\n\n推荐两个生成字符画的网站，可以将生成的字符串放入这个banner.txt 文件：\n\n * http://www.network-science.de/ascii/\n * http://patorjk.com/software/taag/\n\n\n# 配置\n\napplication.properties 中与 banner 相关的配置：\n\n# banner 模式。有三种模式：console/log/off\n# console 打印到控制台（通过 system.out）\n# log - 打印到日志中\n# off - 关闭打印\nspring.main.banner-mode = off\n# banner 文件编码\nspring.banner.charset = utf-8\n# banner 文本文件路径\nspring.banner.location = classpath:banner.txt\n# banner 图像文件路径（可以选择 png,jpg,gif 文件）\nspring.banner.image.location = classpath:banner.gif\nused).\n# 图像 banner 的宽度（字符数）\nspring.banner.image.width = 76\n# 图像 banner 的高度（字符数）\nspring.banner.image.height =\n# 图像 banner 的左边界（字符数）\nspring.banner.image.margin = 2\n# 是否将图像转为黑色控制台主题\nspring.banner.image.invert = false\n\n\n当然，你也可以在 yaml 文件中配置，例如：\n\nspring:\n  main:\n    banner-mode: off\n\n\n\n# 编程\n\n默认，spring boot 会注册一个 springbootbanner 的单例 bean，用来负责打印 banner。\n\n如果想完全个人定制 banner，可以这么做：先实现 org.springframework.boot.banner#printbanner 接口来自己定制 banner。在将这个 banner 通过 springapplication.setbanner(…) 方法注入 spring boot。\n\n\n# 示例源码\n\n> 示例源码：spring-boot-banner\n\n\n# 参考资料\n\n * spring boot 官方文档之 customizing the banner",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Spring 其他",frontmatter:{title:"Spring 其他",date:"2020-02-26T23:48:06.000Z",categories:["Java","框架","Spring","Spring其他"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/6bb8c1/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/99.Spring%E5%85%B6%E4%BB%96/",relativePath:"01.Java/13.框架/01.Spring/99.Spring其他/README.md",key:"v-1a8a1886",path:"/pages/6bb8c1/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:16},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:89},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:268}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# Spring 其他\n\n\n# 📖 内容\n\n * Spring4 升级\n * SpringBoot 之 banner\n * SpringBoot 之 Actuator\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Framework 官方文档\n   * Spring Github\n * 书籍\n   * 《Spring In Action》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 我的博客 ◾",normalizedContent:"# spring 其他\n\n\n# 📖 内容\n\n * spring4 升级\n * springboot 之 banner\n * springboot 之 actuator\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring framework 官方文档\n   * spring github\n * 书籍\n   * 《spring in action》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"SPRING-TUTORIAL",frontmatter:{title:"SPRING-TUTORIAL",date:"2022-06-14T09:37:30.000Z",categories:["Java","框架","Spring"],tags:["Java","框架","Spring","SpringBoot"],permalink:"/pages/a1a3d3/",hidden:!0,index:!1},regularPath:"/01.Java/13.%E6%A1%86%E6%9E%B6/01.Spring/",relativePath:"01.Java/13.框架/01.Spring/README.md",key:"v-07a8e71a",path:"/pages/a1a3d3/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:149},{level:3,title:"综合",slug:"综合",normalizedTitle:"综合",charIndex:159},{level:3,title:"核心",slug:"核心",normalizedTitle:"核心",charIndex:231},{level:3,title:"数据",slug:"数据",normalizedTitle:"数据",charIndex:365},{level:3,title:"Web",slug:"web",normalizedTitle:"web",charIndex:765},{level:3,title:"IO",slug:"io",normalizedTitle:"io",charIndex:816},{level:3,title:"集成",slug:"集成",normalizedTitle:"集成",charIndex:683},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:948},{level:2,title:"💻 示例",slug:"💻-示例",normalizedTitle:"💻 示例",charIndex:1018},{level:3,title:"核心篇示例",slug:"核心篇示例",normalizedTitle:"核心篇示例",charIndex:1028},{level:3,title:"数据篇示例",slug:"数据篇示例",normalizedTitle:"数据篇示例",charIndex:1650},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:3026},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:3228}],headersStr:"📖 内容 综合 核心 数据 Web IO 集成 其他 💻 示例 核心篇示例 数据篇示例 📚 资料 🚪 传送",content:"# SPRING-TUTORIAL\n\n\n\n> 🍃 spring-tutorial 是一个 Spring & Spring Boot 教程。\n> \n>  * 🔁 项目同步维护：Github | Gitee\n>  * 📖 电子书阅读：Github Pages | Gitee Pages\n\n\n# 📖 内容\n\n\n# 综合\n\n * Spring 概述\n * SpringBoot 知识图谱\n * SpringBoot 基本原理\n * Spring 面试\n\n\n# 核心\n\n * Spring Bean\n * Spring IoC\n * Spring 依赖查找\n * Spring 依赖注入\n * Spring IoC 依赖来源\n * Spring Bean 作用域\n * Spring Bean 生命周期\n * Spring 配置元数据\n * Spring AOP\n * Spring 资源管理\n * Spring 校验\n * Spring 数据绑定\n * Spring 类型转换\n * Spring EL 表达式\n * Spring 事件\n * Spring 国际化\n * Spring 泛型处理\n * Spring 注解\n * Spring Environment 抽象\n * SpringBoot 教程之快速入门\n * SpringBoot 之属性加载\n * SpringBoot 之 Profile\n\n\n# 数据\n\n * Spring 之数据源\n * Spring 之 JDBC\n * Spring 之事务\n * Spring 之 JPA\n * Spring 集成 Mybatis\n * Spring 访问 Redis\n * Spring 访问 MongoDB\n * Spring 访问 Elasticsearch\n\n\n# Web\n\n * Spring WebMvc\n * SpringBoot 之应用 EasyUI\n\n\n# IO\n\n * SpringBoot 之异步请求\n * SpringBoot 之 Json\n * SpringBoot 之邮件\n\n\n# 集成\n\n * Spring 集成缓存中间件\n * Spring 集成定时任务中间件\n * Spring 集成 Dubbo\n\n\n# 其他\n\n * Spring4 升级\n * SpringBoot 之 banner\n * SpringBoot 之 Actuator\n\n\n# 💻 示例\n\n\n# 核心篇示例\n\n * spring-core-actuator - Spring 应用监控示例。\n * spring-core-aop - Spring AOP 编程示例。\n * spring-core-async - Spring 使用异步接口示例。\n * spring-core-banner - Spring 定制启动时的输出 Logo。\n * spring-core-bean - Spring 管理 JavaBean 生命周期示例。\n * spring-core-conversion - Spring 数据转换示例。\n * spring-core-data-binding - Spring 数据绑定示例。\n * spring-core-ioc - Spring IOC 示例。\n * spring-core-profile - 在 Spring 中根据 profile 在不同的环境下执行不同的行为。\n * spring-core-property - 全方位的演示 Spring 加载属性的方式：记载 properties 和 yaml 两种文件；通过 @Value、@ConfigurationProperties、Environment 读取属性。\n * spring-core-resource - Spring 资源加载示例。\n * spring-core-validation - Spring 数据校验示例。\n\n\n# 数据篇示例\n\n * JDBC\n   * spring-data-jdbc-basics - Spring Boot 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n   * spring-data-jdbc-druid - SpringBoot 使用 Druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - SpringBoot 连接多数据源示例。\n   * spring-data-jdbc-xml - Spring 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n * ORM\n   * spring-data-orm-jpa - SpringBoot 使用 JPA 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis - Spring 使用 MyBatis 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - SpringBoot 使用 MyBatis + Mapper + PageHelper 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - SpringBoot 连接多数据源，并使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - SpringBoot 使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n * Nosql\n   * spring-data-nosql-basics - Spring 访问各种 NoSQL 的示例。\n   * spring-data-nosql-mongodb - SpringBoot 访问 MongoDB 的示例。\n   * spring-data-nosql-redis - SpringBoot 访问 Redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - SpringBoot 访问 Elasticsearch 的示例。\n   * spring-data-nosql-hdfs - SpringBoot 访问 HDFS 的示例。\n * Cache\n   * spring-data-cache-basics - SpringBoot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - SpringBoot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - SpringBoot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - Spring 使用版本管理中间件 Flyway 示例。\n   * spring-data-middleware-sharding - Spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Github\n   * Spring Framework 官方文档\n   * Spring Boot 官方文档\n * 书籍\n   * 《 Spring 实战（第 5 版）》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾",normalizedContent:"# spring-tutorial\n\n\n\n> 🍃 spring-tutorial 是一个 spring & spring boot 教程。\n> \n>  * 🔁 项目同步维护：github | gitee\n>  * 📖 电子书阅读：github pages | gitee pages\n\n\n# 📖 内容\n\n\n# 综合\n\n * spring 概述\n * springboot 知识图谱\n * springboot 基本原理\n * spring 面试\n\n\n# 核心\n\n * spring bean\n * spring ioc\n * spring 依赖查找\n * spring 依赖注入\n * spring ioc 依赖来源\n * spring bean 作用域\n * spring bean 生命周期\n * spring 配置元数据\n * spring aop\n * spring 资源管理\n * spring 校验\n * spring 数据绑定\n * spring 类型转换\n * spring el 表达式\n * spring 事件\n * spring 国际化\n * spring 泛型处理\n * spring 注解\n * spring environment 抽象\n * springboot 教程之快速入门\n * springboot 之属性加载\n * springboot 之 profile\n\n\n# 数据\n\n * spring 之数据源\n * spring 之 jdbc\n * spring 之事务\n * spring 之 jpa\n * spring 集成 mybatis\n * spring 访问 redis\n * spring 访问 mongodb\n * spring 访问 elasticsearch\n\n\n# web\n\n * spring webmvc\n * springboot 之应用 easyui\n\n\n# io\n\n * springboot 之异步请求\n * springboot 之 json\n * springboot 之邮件\n\n\n# 集成\n\n * spring 集成缓存中间件\n * spring 集成定时任务中间件\n * spring 集成 dubbo\n\n\n# 其他\n\n * spring4 升级\n * springboot 之 banner\n * springboot 之 actuator\n\n\n# 💻 示例\n\n\n# 核心篇示例\n\n * spring-core-actuator - spring 应用监控示例。\n * spring-core-aop - spring aop 编程示例。\n * spring-core-async - spring 使用异步接口示例。\n * spring-core-banner - spring 定制启动时的输出 logo。\n * spring-core-bean - spring 管理 javabean 生命周期示例。\n * spring-core-conversion - spring 数据转换示例。\n * spring-core-data-binding - spring 数据绑定示例。\n * spring-core-ioc - spring ioc 示例。\n * spring-core-profile - 在 spring 中根据 profile 在不同的环境下执行不同的行为。\n * spring-core-property - 全方位的演示 spring 加载属性的方式：记载 properties 和 yaml 两种文件；通过 @value、@configurationproperties、environment 读取属性。\n * spring-core-resource - spring 资源加载示例。\n * spring-core-validation - spring 数据校验示例。\n\n\n# 数据篇示例\n\n * jdbc\n   * spring-data-jdbc-basics - spring boot 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n   * spring-data-jdbc-druid - springboot 使用 druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - springboot 连接多数据源示例。\n   * spring-data-jdbc-xml - spring 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n * orm\n   * spring-data-orm-jpa - springboot 使用 jpa 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis - spring 使用 mybatis 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - springboot 使用 mybatis + mapper + pagehelper 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - springboot 连接多数据源，并使用 mybatis plus 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - springboot 使用 mybatis plus 作为 orm 框架访问数据库示例。\n * nosql\n   * spring-data-nosql-basics - spring 访问各种 nosql 的示例。\n   * spring-data-nosql-mongodb - springboot 访问 mongodb 的示例。\n   * spring-data-nosql-redis - springboot 访问 redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - springboot 访问 elasticsearch 的示例。\n   * spring-data-nosql-hdfs - springboot 访问 hdfs 的示例。\n * cache\n   * spring-data-cache-basics - springboot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - springboot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - springboot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - spring 使用版本管理中间件 flyway 示例。\n   * spring-data-middleware-sharding - spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring github\n   * spring framework 官方文档\n   * spring boot 官方文档\n * 书籍\n   * 《 spring 实战（第 5 版）》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-7765fe32",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-3d0b52f2",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-3b93de07",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3},{title:"Home",frontmatter:{home:!0,heroImage:"img/bg.gif",heroText:"SPRING-TUTORIAL",tagline:"🍃 spring-tutorial 是一个 Spring & Spring Boot 教程。",bannerBg:"none",postList:"none",footer:"CC-BY-SA-4.0 Licensed | Copyright © 2018-Now Dunwu"},regularPath:"/",relativePath:"README.md",key:"v-fe19e418",path:"/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:128},{level:3,title:"综合",slug:"综合",normalizedTitle:"综合",charIndex:138},{level:3,title:"核心",slug:"核心",normalizedTitle:"核心",charIndex:210},{level:3,title:"数据",slug:"数据",normalizedTitle:"数据",charIndex:344},{level:3,title:"Web",slug:"web",normalizedTitle:"web",charIndex:744},{level:3,title:"IO",slug:"io",normalizedTitle:"io",charIndex:871},{level:3,title:"集成",slug:"集成",normalizedTitle:"集成",charIndex:662},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1003},{level:2,title:"💻 示例",slug:"💻-示例",normalizedTitle:"💻 示例",charIndex:1073},{level:3,title:"核心篇示例",slug:"核心篇示例",normalizedTitle:"核心篇示例",charIndex:1083},{level:3,title:"数据篇示例",slug:"数据篇示例",normalizedTitle:"数据篇示例",charIndex:1705},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:3081},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:3283}],headersStr:"📖 内容 综合 核心 数据 Web IO 集成 其他 💻 示例 核心篇示例 数据篇示例 📚 资料 🚪 传送",content:"> 🍃 spring-tutorial 是一个 Spring & Spring Boot 教程。\n> \n>  * 🔁 项目同步维护：Github | Gitee\n>  * 📖 电子书阅读：Github Pages | Gitee Pages\n\n\n# 📖 内容\n\n\n# 综合\n\n * Spring 概述\n * SpringBoot 知识图谱\n * SpringBoot 基本原理\n * Spring 面试\n\n\n# 核心\n\n * Spring Bean\n * Spring IoC\n * Spring 依赖查找\n * Spring 依赖注入\n * Spring IoC 依赖来源\n * Spring Bean 作用域\n * Spring Bean 生命周期\n * Spring 配置元数据\n * Spring AOP\n * Spring 资源管理\n * Spring 校验\n * Spring 数据绑定\n * Spring 类型转换\n * Spring EL 表达式\n * Spring 事件\n * Spring 国际化\n * Spring 泛型处理\n * Spring 注解\n * Spring Environment 抽象\n * SpringBoot 教程之快速入门\n * SpringBoot 之属性加载\n * SpringBoot 之 Profile\n\n\n# 数据\n\n * Spring 之数据源\n * Spring 之 JDBC\n * Spring 之事务\n * Spring 之 JPA\n * Spring 集成 Mybatis\n * Spring 访问 Redis\n * Spring 访问 MongoDB\n * Spring 访问 Elasticsearch\n\n\n# Web\n\n * SpringWeb 综述\n * SpringWeb 应用\n * DispatcherServlet\n * Spring 过滤器\n * Spring 跨域\n * Spring 视图\n * SpringBoot 之应用 EasyUI\n\n\n# IO\n\n * SpringBoot 之异步请求\n * SpringBoot 之 Json\n * SpringBoot 之邮件\n\n\n# 集成\n\n * Spring 集成缓存中间件\n * Spring 集成定时任务中间件\n * Spring 集成 Dubbo\n\n\n# 其他\n\n * Spring4 升级\n * SpringBoot 之 banner\n * SpringBoot 之 Actuator\n\n\n# 💻 示例\n\n\n# 核心篇示例\n\n * spring-core-actuator - Spring 应用监控示例。\n * spring-core-aop - Spring AOP 编程示例。\n * spring-core-async - Spring 使用异步接口示例。\n * spring-core-banner - Spring 定制启动时的输出 Logo。\n * spring-core-bean - Spring 管理 JavaBean 生命周期示例。\n * spring-core-conversion - Spring 数据转换示例。\n * spring-core-data-binding - Spring 数据绑定示例。\n * spring-core-ioc - Spring IOC 示例。\n * spring-core-profile - 在 Spring 中根据 profile 在不同的环境下执行不同的行为。\n * spring-core-property - 全方位的演示 Spring 加载属性的方式：记载 properties 和 yaml 两种文件；通过 @Value、@ConfigurationProperties、Environment 读取属性。\n * spring-core-resource - Spring 资源加载示例。\n * spring-core-validation - Spring 数据校验示例。\n\n\n# 数据篇示例\n\n * JDBC\n   * spring-data-jdbc-basics - Spring Boot 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n   * spring-data-jdbc-druid - SpringBoot 使用 Druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - SpringBoot 连接多数据源示例。\n   * spring-data-jdbc-xml - Spring 以 JDBC 方式访问关系型数据库，通过 JdbcTemplate 执行基本的 CRUD 操作。\n * ORM\n   * spring-data-orm-jpa - SpringBoot 使用 JPA 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis - Spring 使用 MyBatis 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - SpringBoot 使用 MyBatis + Mapper + PageHelper 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - SpringBoot 连接多数据源，并使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - SpringBoot 使用 MyBatis Plus 作为 ORM 框架访问数据库示例。\n * Nosql\n   * spring-data-nosql-basics - Spring 访问各种 NoSQL 的示例。\n   * spring-data-nosql-mongodb - SpringBoot 访问 MongoDB 的示例。\n   * spring-data-nosql-redis - SpringBoot 访问 Redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - SpringBoot 访问 Elasticsearch 的示例。\n   * spring-data-nosql-hdfs - SpringBoot 访问 HDFS 的示例。\n * Cache\n   * spring-data-cache-basics - SpringBoot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - SpringBoot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - SpringBoot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - Spring 使用版本管理中间件 Flyway 示例。\n   * spring-data-middleware-sharding - Spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * Spring 官网\n   * Spring Github\n   * Spring Framework 官方文档\n   * Spring Boot 官方文档\n * 书籍\n   * 《 Spring 实战（第 5 版）》\n * 教程\n   * 《小马哥讲 Spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 Spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 IT 知识图谱 ◾ 🎯 钝悟的博客 ◾",normalizedContent:"> 🍃 spring-tutorial 是一个 spring & spring boot 教程。\n> \n>  * 🔁 项目同步维护：github | gitee\n>  * 📖 电子书阅读：github pages | gitee pages\n\n\n# 📖 内容\n\n\n# 综合\n\n * spring 概述\n * springboot 知识图谱\n * springboot 基本原理\n * spring 面试\n\n\n# 核心\n\n * spring bean\n * spring ioc\n * spring 依赖查找\n * spring 依赖注入\n * spring ioc 依赖来源\n * spring bean 作用域\n * spring bean 生命周期\n * spring 配置元数据\n * spring aop\n * spring 资源管理\n * spring 校验\n * spring 数据绑定\n * spring 类型转换\n * spring el 表达式\n * spring 事件\n * spring 国际化\n * spring 泛型处理\n * spring 注解\n * spring environment 抽象\n * springboot 教程之快速入门\n * springboot 之属性加载\n * springboot 之 profile\n\n\n# 数据\n\n * spring 之数据源\n * spring 之 jdbc\n * spring 之事务\n * spring 之 jpa\n * spring 集成 mybatis\n * spring 访问 redis\n * spring 访问 mongodb\n * spring 访问 elasticsearch\n\n\n# web\n\n * springweb 综述\n * springweb 应用\n * dispatcherservlet\n * spring 过滤器\n * spring 跨域\n * spring 视图\n * springboot 之应用 easyui\n\n\n# io\n\n * springboot 之异步请求\n * springboot 之 json\n * springboot 之邮件\n\n\n# 集成\n\n * spring 集成缓存中间件\n * spring 集成定时任务中间件\n * spring 集成 dubbo\n\n\n# 其他\n\n * spring4 升级\n * springboot 之 banner\n * springboot 之 actuator\n\n\n# 💻 示例\n\n\n# 核心篇示例\n\n * spring-core-actuator - spring 应用监控示例。\n * spring-core-aop - spring aop 编程示例。\n * spring-core-async - spring 使用异步接口示例。\n * spring-core-banner - spring 定制启动时的输出 logo。\n * spring-core-bean - spring 管理 javabean 生命周期示例。\n * spring-core-conversion - spring 数据转换示例。\n * spring-core-data-binding - spring 数据绑定示例。\n * spring-core-ioc - spring ioc 示例。\n * spring-core-profile - 在 spring 中根据 profile 在不同的环境下执行不同的行为。\n * spring-core-property - 全方位的演示 spring 加载属性的方式：记载 properties 和 yaml 两种文件；通过 @value、@configurationproperties、environment 读取属性。\n * spring-core-resource - spring 资源加载示例。\n * spring-core-validation - spring 数据校验示例。\n\n\n# 数据篇示例\n\n * jdbc\n   * spring-data-jdbc-basics - spring boot 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n   * spring-data-jdbc-druid - springboot 使用 druid 作为数据库连接池。\n   * spring-data-jdbc-multi-datasource - springboot 连接多数据源示例。\n   * spring-data-jdbc-xml - spring 以 jdbc 方式访问关系型数据库，通过 jdbctemplate 执行基本的 crud 操作。\n * orm\n   * spring-data-orm-jpa - springboot 使用 jpa 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis - spring 使用 mybatis 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-mapper - springboot 使用 mybatis + mapper + pagehelper 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-multi-datasource - springboot 连接多数据源，并使用 mybatis plus 作为 orm 框架访问数据库示例。\n   * spring-data-orm-mybatis-plus - springboot 使用 mybatis plus 作为 orm 框架访问数据库示例。\n * nosql\n   * spring-data-nosql-basics - spring 访问各种 nosql 的示例。\n   * spring-data-nosql-mongodb - springboot 访问 mongodb 的示例。\n   * spring-data-nosql-redis - springboot 访问 redis 单节点、集群的示例。\n   * spring-data-nosql-elasticsearch - springboot 访问 elasticsearch 的示例。\n   * spring-data-nosql-hdfs - springboot 访问 hdfs 的示例。\n * cache\n   * spring-data-cache-basics - springboot 默认缓存框架的示例。\n   * spring-data-cache-j2cache - springboot 使用 j2cache 作为缓存框架的示例。\n   * spring-data-cache-jetcache - springboot 使用 jetcache 作为缓存框架的示例。\n * 中间件\n   * spring-data-middleware-flyway - spring 使用版本管理中间件 flyway 示例。\n   * spring-data-middleware-sharding - spring 使用分库分表中间件示例。\n\n\n# 📚 资料\n\n * 官方\n   * spring 官网\n   * spring github\n   * spring framework 官方文档\n   * spring boot 官方文档\n * 书籍\n   * 《 spring 实战（第 5 版）》\n * 教程\n   * 《小马哥讲 spring 核心编程思想》\n   * geekbang-lessons\n   * 跟我学 spring3\n\n\n# 🚪 传送\n\n◾ 💧 钝悟的 it 知识图谱 ◾ 🎯 钝悟的博客 ◾",charsets:{cjk:!0},lastUpdated:"2024/04/24, 07:33:33",lastUpdatedTimestamp:1713915213e3}],themeConfig:{nav:[{text:"综合篇",link:"/01.Java/13.框架/01.Spring/00.Spring综合/"},{text:"核心篇",link:"/01.Java/13.框架/01.Spring/01.Spring核心/"},{text:"数据篇",link:"/01.Java/13.框架/01.Spring/02.Spring数据/"},{text:"Web篇",link:"/01.Java/13.框架/01.Spring/03.SpringWeb/"},{text:"IO篇",link:"/01.Java/13.框架/01.Spring/04.SpringIO/"},{text:"集成篇",link:"/01.Java/13.框架/01.Spring/05.Spring集成/"},{text:"其他",link:"/01.Java/13.框架/01.Spring/99.Spring其他/"}],sidebarDepth:2,logo:"https://raw.githubusercontent.com/dunwu/images/master/common/dunwu-logo.png",repo:"dunwu/spring-tutorial",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"📝 帮助改善此页面！",sidebar:{"/01.Java/":[{title:"框架",collapsable:!0,children:[{title:"Spring",collapsable:!0,children:[{title:"Spring综合",collapsable:!0,children:[["13.框架/01.Spring/00.Spring综合/01.Spring概述.md","Spring Framework 综述","/pages/9d3091/"],["13.框架/01.Spring/00.Spring综合/21.SpringBoot知识图谱.md","SpringBoot 知识图谱","/pages/430f53/"],["13.框架/01.Spring/00.Spring综合/22.SpringBoot基本原理.md","SpringBoot 基本原理","/pages/dbf521/"],["13.框架/01.Spring/00.Spring综合/99.Spring面试.md","Spring 面试","/pages/db33b0/"]]},{title:"Spring核心",collapsable:!0,children:[["13.框架/01.Spring/01.Spring核心/01.SpringBean.md","Spring Bean","/pages/68097d/"],["13.框架/01.Spring/01.Spring核心/02.SpringIoC.md","Spring IoC","/pages/915530/"],["13.框架/01.Spring/01.Spring核心/03.Spring依赖查找.md","Spring 依赖查找","/pages/9a6f6b/"],["13.框架/01.Spring/01.Spring核心/04.Spring依赖注入.md","Spring 依赖注入","/pages/f61a1c/"],["13.框架/01.Spring/01.Spring核心/05.SpringIoC依赖来源.md","Spring IoC 依赖来源","/pages/a5f257/"],["13.框架/01.Spring/01.Spring核心/06.SpringBean作用域.md","Spring Bean 作用域","/pages/8289f5/"],["13.框架/01.Spring/01.Spring核心/07.SpringBean生命周期.md","Spring Bean 生命周期","/pages/4ab176/"],["13.框架/01.Spring/01.Spring核心/08.Spring配置元数据.md","Spring 配置元数据","/pages/55f315/"],["13.框架/01.Spring/01.Spring核心/09.Spring应用上下文生命周期.md","Spring 应用上下文生命周期","/pages/ad472e/"],["13.框架/01.Spring/01.Spring核心/10.SpringAop.md","Spring AOP","/pages/53aedb/"],["13.框架/01.Spring/01.Spring核心/20.Spring资源管理.md","Spring 资源管理","/pages/a1549f/"],["13.框架/01.Spring/01.Spring核心/21.Spring校验.md","Spring 校验","/pages/fe6aad/"],["13.框架/01.Spring/01.Spring核心/22.Spring数据绑定.md","Spring 数据绑定","/pages/267b4c/"],["13.框架/01.Spring/01.Spring核心/23.Spring类型转换.md","Spring 类型转换","/pages/6662dc/"],["13.框架/01.Spring/01.Spring核心/24.SpringEL.md","Spring EL 表达式","/pages/1f743f/"],["13.框架/01.Spring/01.Spring核心/25.Spring事件.md","Spring 事件","/pages/cca414/"],["13.框架/01.Spring/01.Spring核心/26.Spring国际化.md","Spring 国际化","/pages/b5b8ad/"],["13.框架/01.Spring/01.Spring核心/27.Spring泛型处理.md","Spring 泛型处理","/pages/175cbd/"],["13.框架/01.Spring/01.Spring核心/28.Spring注解.md","Spring 注解","/pages/b6556f/"],["13.框架/01.Spring/01.Spring核心/29.SpringEnvironment抽象.md","Spring Environment 抽象","/pages/03d838/"],["13.框架/01.Spring/01.Spring核心/31.SpringBoot之快速入门.md","SpringBoot 之快速入门","/pages/950e4d/"],["13.框架/01.Spring/01.Spring核心/32.SpringBoot之属性加载.md","SpringBoot 之属性加载详解","/pages/0fb992/"],["13.框架/01.Spring/01.Spring核心/33.SpringBoot之Profile.md","SpringBoot 之 Profile","/pages/cb598e/"]]},{title:"Spring数据",collapsable:!0,children:[["13.框架/01.Spring/02.Spring数据/01.Spring之数据源.md","Spring 之数据源","/pages/1b774c/"],["13.框架/01.Spring/02.Spring数据/02.Spring之JDBC.md","Spring 之 JDBC","/pages/cf19fd/"],["13.框架/01.Spring/02.Spring数据/03.Spring之事务.md","Spring 之事务","/pages/128c54/"],["13.框架/01.Spring/02.Spring数据/04.Spring之JPA.md","Spring 之 JPA","/pages/a03d7b/"],["13.框架/01.Spring/02.Spring数据/10.Spring集成Mybatis.md","Spring 集成 Mybatis","/pages/88219e/"],["13.框架/01.Spring/02.Spring数据/20.SpringData综合.md","Spring Data 综合","/pages/191cdb/"],["13.框架/01.Spring/02.Spring数据/21.Spring访问Redis.md","Spring 访问 Redis","/pages/65e4a2/"],["13.框架/01.Spring/02.Spring数据/22.Spring访问MongoDB.md","Spring 访问 MongoDB","/pages/db2a41/"],["13.框架/01.Spring/02.Spring数据/23.Spring访问Elasticsearch.md","Spring 访问 Elasticsearch","/pages/fac14c/"]]},{title:"SpringWeb",collapsable:!0,children:[["13.框架/01.Spring/03.SpringWeb/01.SpringWeb综述.md","Spring Web 综述","/pages/65351b/"],["13.框架/01.Spring/03.SpringWeb/02.SpringWeb应用.md","Spring Web 应用","/pages/5d002f/"],["13.框架/01.Spring/03.SpringWeb/03.DispatcherServlet.md","Spring MVC 之 DispatcherServlet","/pages/20287b/"],["13.框架/01.Spring/03.SpringWeb/04.Spring过滤器.md","Spring MVC 之过滤器","/pages/4a164d/"],["13.框架/01.Spring/03.SpringWeb/05.Spring跨域.md","Spring MVC 之跨域","/pages/1d2954/"],["13.框架/01.Spring/03.SpringWeb/06.Spring视图.md","Spring MVC 之视图技术","/pages/251e31/"],["13.框架/01.Spring/03.SpringWeb/21.SpringBoot之应用EasyUI.md","SpringBoot 之应用 EasyUI","/pages/ad0516/"]]},{title:"SpringIO",collapsable:!0,children:[["13.框架/01.Spring/04.SpringIO/01.SpringBoot之异步请求.md","spring-boot-async","/pages/92add2/"],["13.框架/01.Spring/04.SpringIO/02.SpringBoot之Json.md","SpringBoot 之集成 Json","/pages/676725/"],["13.框架/01.Spring/04.SpringIO/03.SpringBoot之邮件.md","SpringBoot 之发送邮件","/pages/2586f1/"]]},{title:"Spring集成",collapsable:!0,children:[["13.框架/01.Spring/05.Spring集成/01.Spring集成缓存.md","Spring集成缓存","/pages/a311cb/"],["13.框架/01.Spring/05.Spring集成/02.Spring集成调度器.md","Spring 集成调度器","/pages/a187f0/"],["13.框架/01.Spring/05.Spring集成/03.Spring集成Dubbo.md","Spring集成Dubbo","/pages/274fd7/"]]},{title:"Spring安全",collapsable:!0,children:[["13.框架/01.Spring/10.Spring安全/01.SpringBoot之安全快速入门.md","SpringBoot 之安全快速入门","/pages/568352/"]]},{title:"Spring其他",collapsable:!0,children:[["13.框架/01.Spring/99.Spring其他/01.Spring4升级.md","Spring 4 升级踩雷指南","/pages/752c6a/"],["13.框架/01.Spring/99.Spring其他/21.SpringBoot之banner.md","SpringBoot 之 banner 定制","/pages/bac2ce/"],["13.框架/01.Spring/99.Spring其他/22.SpringBoot之Actuator.md","SpringBoot Actuator 快速入门","/pages/c013cc/"]]}]}]}],catalogue:{}},sidebarOpen:!0,updateBar:{showToArticle:!0},category:!0,tag:!0,archive:!0,author:{name:"dunwu",href:"https://github.com/dunwu"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:forbreak@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/dunwu"}]},footer:{createYear:2019,copyrightInfo:"钝悟（dunwu） | CC-BY-SA-4.0"},htmlModules:{windowRB:'\n    <div class="wwads-cn wwads-vertical windowRB" data-id="261" style="max-width:160px;\n    min-width: auto;min-height:auto;"></div>\n    <style>\n      .windowRB{ padding: 0;}\n      .windowRB .wwads-img{margin-top: 10px;}\n      .windowRB .wwads-content{margin: 0 10px 40px 10px;}\n      .custom-html-window-rb .close-but{\n        display: none;\n      }\n    </style>\n  '}}};var Sl=t(95),kl=t(96),jl=t(11);var Cl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(jl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(jl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(jl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,a=n.length;r<a;r++){const{frontmatter:{categories:a,tags:i}}=n[r];"array"===Object(jl.n)(a)&&a.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(jl.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Wt.component(Sl.default),Wt.component(kl.default);function Tl(n){return n.toString().padStart(2,"0")}t(245);Wt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,408))),Wt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,95))),Wt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,96)));t(246);var Al=t(94),Bl=t.n(Al),Il=t(25);let El,Pl;var _l;"valine"===(_l="gitalk")?t.e(72).then(t.t.bind(null,338,7)).then(n=>Pl=n.default):"gitalk"===_l&&Promise.all([t.e(0),t.e(71)]).then(t.t.bind(null,339,7)).then(()=>t.e(70).then(t.t.bind(null,340,7))).then(n=>El=n.default);function Ml(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=Bl.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${Il.name}@v${Il.version}:`,Il.homepage);const Rl={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new El(Ml({clientID:"01d530004cf00567e0ee",clientSecret:"7dd472f49b47521f80838d810b568c8084b7f1fa",repo:"spring-tutorial",owner:"dunwu",admin:["dunwu"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Pl({...Ml({clientID:"01d530004cf00567e0ee",clientSecret:"7dd472f49b47521f80838d810b568c8084b7f1fa",repo:"spring-tutorial",owner:"dunwu",admin:["dunwu"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Dl="vuepress-plugin-comment";let zl=null;function Ol(n){return Rl.gitalk.clear(Dl)}function Ll(n){return!1!==n.comment&&!1!==n.comments}function Jl(n){clearTimeout(zl);if(document.querySelector("main.page"))return Rl.gitalk.render(n,Dl);zl=setTimeout(()=>Jl(n),200)}var ql={mounted(){zl=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Ol()&&Ll(n)&&Jl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Ol()&&Ll(t)&&Jl(t)})}},Fl=Object(vl.a)(ql,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Ul=[({Vue:n,options:e,router:t,siteData:r,isServer:a})=>{a||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://fastly.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".page-wwads");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Tl(n.getUTCMonth()+1)}-${Tl(n.getUTCDate())} ${Tl(n.getUTCHours())}:${Tl(n.getUTCMinutes())}:${Tl(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(Cl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},()=>{"undefined"!=typeof window&&function(n,e,t){function r(n){var t=e.createElement("div");t.className="heart",a.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var a=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){let t=!0;n.path&&n.path.forEach(n=>{1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)}),t&&(e&&e(),r(n))}}(),function n(){for(var t=0;t<a.length;t++)a[t].alpha<=0?(e.body.removeChild(a[t].el),a.splice(t,1)):(a[t].y--,a[t].scale+=.004,a[t].alpha-=.013,a[t].el.style.cssText="left:"+a[t].x+"px;top:"+a[t].y+"px;opacity:"+a[t].alpha+";transform:scale("+a[t].scale+","+a[t].scale+") rotate(45deg);background:"+a[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)},({Vue:n})=>{n.component("Comment",Fl)}],Nl=["Comment"];class Hl extends class{constructor(){this.store=new Wt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Wt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Hl.prototype,{getPageAsyncComponent:ss,getLayoutAsyncComponent:ls,getAsyncComponent:ps,getVueComponent:cs});var Vl={install(n){const e=new Hl;n.$vuepress=e,n.prototype.$vuepress=e}};function $l(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Wl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return gs("pageKey",e),Wt.component(e)||Wt.component(e,ss(e)),Wt.component(e)?n(e):n("")}},Xl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Gl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ql=(t(251),t(252),Object(vl.a)(Gl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Yl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Wt.config.productionTip=!1,Wt.use(Vo),Wt.use(Vl),Wt.mixin(function(n,e,t=Wt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),i={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},wl)),Wt.component("Content",Wl),Wt.component("ContentSlotsDistributor",Xl),Wt.component("OutboundLink",Ql),Wt.component("ClientOnly",Yl),Wt.component("Layout",ls("Layout")),Wt.component("NotFound",ls("NotFound")),Wt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.9",hash:"060d197"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:wl.routerBase||wl.base,t=new Vo({base:e,mode:"history",fallback:!1,routes:xl,scrollBehavior:(n,e,t)=>t||(n.hash?!Wt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if($l(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";$l(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";$l(n,a)?r(a):$l(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Ul.filter(n=>"function"==typeof n).map(e=>e({Vue:Wt,options:r,router:t,siteData:wl,isServer:n})))}catch(n){console.error(n)}return{app:new Wt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Nl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);